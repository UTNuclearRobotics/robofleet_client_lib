// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TF2MSGS_FB_TF2_MSGS_H_
#define FLATBUFFERS_GENERATED_TF2MSGS_FB_TF2_MSGS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 21,
             "Non-compatible flatbuffers version included");

#include "actionlib_msgs_generated.h"
#include "base_schema_generated.h"
#include "geometry_msgs_generated.h"
#include "std_msgs_generated.h"

namespace fb {
namespace tf2_msgs {

struct LookupTransformActionFeedback;
struct LookupTransformActionFeedbackBuilder;
struct LookupTransformActionFeedbackT;

struct LookupTransformActionResult;
struct LookupTransformActionResultBuilder;
struct LookupTransformActionResultT;

struct TF2Error;
struct TF2ErrorBuilder;
struct TF2ErrorT;

struct TFMessage;
struct TFMessageBuilder;
struct TFMessageT;

struct FrameGraphRequest;
struct FrameGraphRequestBuilder;
struct FrameGraphRequestT;

struct FrameGraphResponse;
struct FrameGraphResponseBuilder;
struct FrameGraphResponseT;

struct LookupTransformResult;
struct LookupTransformResultBuilder;
struct LookupTransformResultT;

struct LookupTransformActionGoal;
struct LookupTransformActionGoalBuilder;
struct LookupTransformActionGoalT;

struct LookupTransformFeedback;
struct LookupTransformFeedbackBuilder;
struct LookupTransformFeedbackT;

struct LookupTransformAction;
struct LookupTransformActionBuilder;
struct LookupTransformActionT;

struct LookupTransformGoal;
struct LookupTransformGoalBuilder;
struct LookupTransformGoalT;

struct LookupTransformActionFeedbackT : public ::flatbuffers::NativeTable {
  typedef LookupTransformActionFeedback TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::actionlib_msgs::GoalStatusT> status{};
  std::unique_ptr<fb::tf2_msgs::LookupTransformFeedbackT> feedback{};
  LookupTransformActionFeedbackT() = default;
  LookupTransformActionFeedbackT(const LookupTransformActionFeedbackT &o);
  LookupTransformActionFeedbackT(LookupTransformActionFeedbackT&&) FLATBUFFERS_NOEXCEPT = default;
  LookupTransformActionFeedbackT &operator=(LookupTransformActionFeedbackT o) FLATBUFFERS_NOEXCEPT;
};

struct LookupTransformActionFeedback FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LookupTransformActionFeedbackT NativeTableType;
  typedef LookupTransformActionFeedbackBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_STATUS = 8,
    VT_FEEDBACK = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::actionlib_msgs::GoalStatus *status() const {
    return GetPointer<const fb::actionlib_msgs::GoalStatus *>(VT_STATUS);
  }
  const fb::tf2_msgs::LookupTransformFeedback *feedback() const {
    return GetPointer<const fb::tf2_msgs::LookupTransformFeedback *>(VT_FEEDBACK);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_STATUS) &&
           verifier.VerifyTable(status()) &&
           VerifyOffsetRequired(verifier, VT_FEEDBACK) &&
           verifier.VerifyTable(feedback()) &&
           verifier.EndTable();
  }
  LookupTransformActionFeedbackT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LookupTransformActionFeedbackT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<LookupTransformActionFeedback> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LookupTransformActionFeedbackT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LookupTransformActionFeedbackBuilder {
  typedef LookupTransformActionFeedback Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(LookupTransformActionFeedback::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(LookupTransformActionFeedback::VT_HEADER, header);
  }
  void add_status(::flatbuffers::Offset<fb::actionlib_msgs::GoalStatus> status) {
    fbb_.AddOffset(LookupTransformActionFeedback::VT_STATUS, status);
  }
  void add_feedback(::flatbuffers::Offset<fb::tf2_msgs::LookupTransformFeedback> feedback) {
    fbb_.AddOffset(LookupTransformActionFeedback::VT_FEEDBACK, feedback);
  }
  explicit LookupTransformActionFeedbackBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LookupTransformActionFeedback> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LookupTransformActionFeedback>(end);
    fbb_.Required(o, LookupTransformActionFeedback::VT_HEADER);
    fbb_.Required(o, LookupTransformActionFeedback::VT_STATUS);
    fbb_.Required(o, LookupTransformActionFeedback::VT_FEEDBACK);
    return o;
  }
};

inline ::flatbuffers::Offset<LookupTransformActionFeedback> CreateLookupTransformActionFeedback(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::actionlib_msgs::GoalStatus> status = 0,
    ::flatbuffers::Offset<fb::tf2_msgs::LookupTransformFeedback> feedback = 0) {
  LookupTransformActionFeedbackBuilder builder_(_fbb);
  builder_.add_feedback(feedback);
  builder_.add_status(status);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<LookupTransformActionFeedback> CreateLookupTransformActionFeedback(::flatbuffers::FlatBufferBuilder &_fbb, const LookupTransformActionFeedbackT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LookupTransformActionResultT : public ::flatbuffers::NativeTable {
  typedef LookupTransformActionResult TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::actionlib_msgs::GoalStatusT> status{};
  std::unique_ptr<fb::tf2_msgs::LookupTransformResultT> result{};
  LookupTransformActionResultT() = default;
  LookupTransformActionResultT(const LookupTransformActionResultT &o);
  LookupTransformActionResultT(LookupTransformActionResultT&&) FLATBUFFERS_NOEXCEPT = default;
  LookupTransformActionResultT &operator=(LookupTransformActionResultT o) FLATBUFFERS_NOEXCEPT;
};

struct LookupTransformActionResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LookupTransformActionResultT NativeTableType;
  typedef LookupTransformActionResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_STATUS = 8,
    VT_RESULT = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::actionlib_msgs::GoalStatus *status() const {
    return GetPointer<const fb::actionlib_msgs::GoalStatus *>(VT_STATUS);
  }
  const fb::tf2_msgs::LookupTransformResult *result() const {
    return GetPointer<const fb::tf2_msgs::LookupTransformResult *>(VT_RESULT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_STATUS) &&
           verifier.VerifyTable(status()) &&
           VerifyOffsetRequired(verifier, VT_RESULT) &&
           verifier.VerifyTable(result()) &&
           verifier.EndTable();
  }
  LookupTransformActionResultT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LookupTransformActionResultT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<LookupTransformActionResult> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LookupTransformActionResultT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LookupTransformActionResultBuilder {
  typedef LookupTransformActionResult Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(LookupTransformActionResult::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(LookupTransformActionResult::VT_HEADER, header);
  }
  void add_status(::flatbuffers::Offset<fb::actionlib_msgs::GoalStatus> status) {
    fbb_.AddOffset(LookupTransformActionResult::VT_STATUS, status);
  }
  void add_result(::flatbuffers::Offset<fb::tf2_msgs::LookupTransformResult> result) {
    fbb_.AddOffset(LookupTransformActionResult::VT_RESULT, result);
  }
  explicit LookupTransformActionResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LookupTransformActionResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LookupTransformActionResult>(end);
    fbb_.Required(o, LookupTransformActionResult::VT_HEADER);
    fbb_.Required(o, LookupTransformActionResult::VT_STATUS);
    fbb_.Required(o, LookupTransformActionResult::VT_RESULT);
    return o;
  }
};

inline ::flatbuffers::Offset<LookupTransformActionResult> CreateLookupTransformActionResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::actionlib_msgs::GoalStatus> status = 0,
    ::flatbuffers::Offset<fb::tf2_msgs::LookupTransformResult> result = 0) {
  LookupTransformActionResultBuilder builder_(_fbb);
  builder_.add_result(result);
  builder_.add_status(status);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<LookupTransformActionResult> CreateLookupTransformActionResult(::flatbuffers::FlatBufferBuilder &_fbb, const LookupTransformActionResultT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TF2ErrorT : public ::flatbuffers::NativeTable {
  typedef TF2Error TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  uint8_t error = 0;
  std::string error_string{};
  TF2ErrorT() = default;
  TF2ErrorT(const TF2ErrorT &o);
  TF2ErrorT(TF2ErrorT&&) FLATBUFFERS_NOEXCEPT = default;
  TF2ErrorT &operator=(TF2ErrorT o) FLATBUFFERS_NOEXCEPT;
};

struct TF2Error FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TF2ErrorT NativeTableType;
  typedef TF2ErrorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_ERROR = 6,
    VT_ERROR_STRING = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  uint8_t error() const {
    return GetField<uint8_t>(VT_ERROR, 0);
  }
  const ::flatbuffers::String *error_string() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR_STRING);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint8_t>(verifier, VT_ERROR, 1) &&
           VerifyOffsetRequired(verifier, VT_ERROR_STRING) &&
           verifier.VerifyString(error_string()) &&
           verifier.EndTable();
  }
  TF2ErrorT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TF2ErrorT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TF2Error> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TF2ErrorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TF2ErrorBuilder {
  typedef TF2Error Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(TF2Error::VT___METADATA, __metadata);
  }
  void add_error(uint8_t error) {
    fbb_.AddElement<uint8_t>(TF2Error::VT_ERROR, error, 0);
  }
  void add_error_string(::flatbuffers::Offset<::flatbuffers::String> error_string) {
    fbb_.AddOffset(TF2Error::VT_ERROR_STRING, error_string);
  }
  explicit TF2ErrorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TF2Error> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TF2Error>(end);
    fbb_.Required(o, TF2Error::VT_ERROR_STRING);
    return o;
  }
};

inline ::flatbuffers::Offset<TF2Error> CreateTF2Error(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint8_t error = 0,
    ::flatbuffers::Offset<::flatbuffers::String> error_string = 0) {
  TF2ErrorBuilder builder_(_fbb);
  builder_.add_error_string(error_string);
  builder_.add___metadata(__metadata);
  builder_.add_error(error);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TF2Error> CreateTF2ErrorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint8_t error = 0,
    const char *error_string = nullptr) {
  auto error_string__ = error_string ? _fbb.CreateString(error_string) : 0;
  return fb::tf2_msgs::CreateTF2Error(
      _fbb,
      __metadata,
      error,
      error_string__);
}

::flatbuffers::Offset<TF2Error> CreateTF2Error(::flatbuffers::FlatBufferBuilder &_fbb, const TF2ErrorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TFMessageT : public ::flatbuffers::NativeTable {
  typedef TFMessage TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::vector<std::unique_ptr<fb::geometry_msgs::TransformStampedT>> transforms{};
  TFMessageT() = default;
  TFMessageT(const TFMessageT &o);
  TFMessageT(TFMessageT&&) FLATBUFFERS_NOEXCEPT = default;
  TFMessageT &operator=(TFMessageT o) FLATBUFFERS_NOEXCEPT;
};

struct TFMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TFMessageT NativeTableType;
  typedef TFMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_TRANSFORMS = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::TransformStamped>> *transforms() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::TransformStamped>> *>(VT_TRANSFORMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_TRANSFORMS) &&
           verifier.VerifyVector(transforms()) &&
           verifier.VerifyVectorOfTables(transforms()) &&
           verifier.EndTable();
  }
  TFMessageT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TFMessageT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TFMessage> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TFMessageT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TFMessageBuilder {
  typedef TFMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(TFMessage::VT___METADATA, __metadata);
  }
  void add_transforms(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::TransformStamped>>> transforms) {
    fbb_.AddOffset(TFMessage::VT_TRANSFORMS, transforms);
  }
  explicit TFMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TFMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TFMessage>(end);
    fbb_.Required(o, TFMessage::VT_TRANSFORMS);
    return o;
  }
};

inline ::flatbuffers::Offset<TFMessage> CreateTFMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::TransformStamped>>> transforms = 0) {
  TFMessageBuilder builder_(_fbb);
  builder_.add_transforms(transforms);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TFMessage> CreateTFMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const std::vector<::flatbuffers::Offset<fb::geometry_msgs::TransformStamped>> *transforms = nullptr) {
  auto transforms__ = transforms ? _fbb.CreateVector<::flatbuffers::Offset<fb::geometry_msgs::TransformStamped>>(*transforms) : 0;
  return fb::tf2_msgs::CreateTFMessage(
      _fbb,
      __metadata,
      transforms__);
}

::flatbuffers::Offset<TFMessage> CreateTFMessage(::flatbuffers::FlatBufferBuilder &_fbb, const TFMessageT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FrameGraphRequestT : public ::flatbuffers::NativeTable {
  typedef FrameGraphRequest TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  FrameGraphRequestT() = default;
  FrameGraphRequestT(const FrameGraphRequestT &o);
  FrameGraphRequestT(FrameGraphRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  FrameGraphRequestT &operator=(FrameGraphRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct FrameGraphRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FrameGraphRequestT NativeTableType;
  typedef FrameGraphRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           verifier.EndTable();
  }
  FrameGraphRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FrameGraphRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FrameGraphRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FrameGraphRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FrameGraphRequestBuilder {
  typedef FrameGraphRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(FrameGraphRequest::VT___METADATA, __metadata);
  }
  explicit FrameGraphRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FrameGraphRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FrameGraphRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FrameGraphRequest> CreateFrameGraphRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0) {
  FrameGraphRequestBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<FrameGraphRequest> CreateFrameGraphRequest(::flatbuffers::FlatBufferBuilder &_fbb, const FrameGraphRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FrameGraphResponseT : public ::flatbuffers::NativeTable {
  typedef FrameGraphResponse TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string frame_yaml{};
  FrameGraphResponseT() = default;
  FrameGraphResponseT(const FrameGraphResponseT &o);
  FrameGraphResponseT(FrameGraphResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  FrameGraphResponseT &operator=(FrameGraphResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct FrameGraphResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FrameGraphResponseT NativeTableType;
  typedef FrameGraphResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_FRAME_YAML = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *frame_yaml() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FRAME_YAML);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_FRAME_YAML) &&
           verifier.VerifyString(frame_yaml()) &&
           verifier.EndTable();
  }
  FrameGraphResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FrameGraphResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FrameGraphResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FrameGraphResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FrameGraphResponseBuilder {
  typedef FrameGraphResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(FrameGraphResponse::VT___METADATA, __metadata);
  }
  void add_frame_yaml(::flatbuffers::Offset<::flatbuffers::String> frame_yaml) {
    fbb_.AddOffset(FrameGraphResponse::VT_FRAME_YAML, frame_yaml);
  }
  explicit FrameGraphResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FrameGraphResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FrameGraphResponse>(end);
    fbb_.Required(o, FrameGraphResponse::VT_FRAME_YAML);
    return o;
  }
};

inline ::flatbuffers::Offset<FrameGraphResponse> CreateFrameGraphResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> frame_yaml = 0) {
  FrameGraphResponseBuilder builder_(_fbb);
  builder_.add_frame_yaml(frame_yaml);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FrameGraphResponse> CreateFrameGraphResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *frame_yaml = nullptr) {
  auto frame_yaml__ = frame_yaml ? _fbb.CreateString(frame_yaml) : 0;
  return fb::tf2_msgs::CreateFrameGraphResponse(
      _fbb,
      __metadata,
      frame_yaml__);
}

::flatbuffers::Offset<FrameGraphResponse> CreateFrameGraphResponse(::flatbuffers::FlatBufferBuilder &_fbb, const FrameGraphResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LookupTransformResultT : public ::flatbuffers::NativeTable {
  typedef LookupTransformResult TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::geometry_msgs::TransformStampedT> transform{};
  std::unique_ptr<fb::tf2_msgs::TF2ErrorT> error{};
  LookupTransformResultT() = default;
  LookupTransformResultT(const LookupTransformResultT &o);
  LookupTransformResultT(LookupTransformResultT&&) FLATBUFFERS_NOEXCEPT = default;
  LookupTransformResultT &operator=(LookupTransformResultT o) FLATBUFFERS_NOEXCEPT;
};

struct LookupTransformResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LookupTransformResultT NativeTableType;
  typedef LookupTransformResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_TRANSFORM = 6,
    VT_ERROR = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::TransformStamped *transform() const {
    return GetPointer<const fb::geometry_msgs::TransformStamped *>(VT_TRANSFORM);
  }
  const fb::tf2_msgs::TF2Error *error() const {
    return GetPointer<const fb::tf2_msgs::TF2Error *>(VT_ERROR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_TRANSFORM) &&
           verifier.VerifyTable(transform()) &&
           VerifyOffsetRequired(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  LookupTransformResultT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LookupTransformResultT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<LookupTransformResult> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LookupTransformResultT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LookupTransformResultBuilder {
  typedef LookupTransformResult Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(LookupTransformResult::VT___METADATA, __metadata);
  }
  void add_transform(::flatbuffers::Offset<fb::geometry_msgs::TransformStamped> transform) {
    fbb_.AddOffset(LookupTransformResult::VT_TRANSFORM, transform);
  }
  void add_error(::flatbuffers::Offset<fb::tf2_msgs::TF2Error> error) {
    fbb_.AddOffset(LookupTransformResult::VT_ERROR, error);
  }
  explicit LookupTransformResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LookupTransformResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LookupTransformResult>(end);
    fbb_.Required(o, LookupTransformResult::VT_TRANSFORM);
    fbb_.Required(o, LookupTransformResult::VT_ERROR);
    return o;
  }
};

inline ::flatbuffers::Offset<LookupTransformResult> CreateLookupTransformResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::TransformStamped> transform = 0,
    ::flatbuffers::Offset<fb::tf2_msgs::TF2Error> error = 0) {
  LookupTransformResultBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_transform(transform);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<LookupTransformResult> CreateLookupTransformResult(::flatbuffers::FlatBufferBuilder &_fbb, const LookupTransformResultT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LookupTransformActionGoalT : public ::flatbuffers::NativeTable {
  typedef LookupTransformActionGoal TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::actionlib_msgs::GoalIDT> goal_id{};
  std::unique_ptr<fb::tf2_msgs::LookupTransformGoalT> goal{};
  LookupTransformActionGoalT() = default;
  LookupTransformActionGoalT(const LookupTransformActionGoalT &o);
  LookupTransformActionGoalT(LookupTransformActionGoalT&&) FLATBUFFERS_NOEXCEPT = default;
  LookupTransformActionGoalT &operator=(LookupTransformActionGoalT o) FLATBUFFERS_NOEXCEPT;
};

struct LookupTransformActionGoal FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LookupTransformActionGoalT NativeTableType;
  typedef LookupTransformActionGoalBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_GOAL_ID = 8,
    VT_GOAL = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::actionlib_msgs::GoalID *goal_id() const {
    return GetPointer<const fb::actionlib_msgs::GoalID *>(VT_GOAL_ID);
  }
  const fb::tf2_msgs::LookupTransformGoal *goal() const {
    return GetPointer<const fb::tf2_msgs::LookupTransformGoal *>(VT_GOAL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_GOAL_ID) &&
           verifier.VerifyTable(goal_id()) &&
           VerifyOffsetRequired(verifier, VT_GOAL) &&
           verifier.VerifyTable(goal()) &&
           verifier.EndTable();
  }
  LookupTransformActionGoalT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LookupTransformActionGoalT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<LookupTransformActionGoal> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LookupTransformActionGoalT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LookupTransformActionGoalBuilder {
  typedef LookupTransformActionGoal Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(LookupTransformActionGoal::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(LookupTransformActionGoal::VT_HEADER, header);
  }
  void add_goal_id(::flatbuffers::Offset<fb::actionlib_msgs::GoalID> goal_id) {
    fbb_.AddOffset(LookupTransformActionGoal::VT_GOAL_ID, goal_id);
  }
  void add_goal(::flatbuffers::Offset<fb::tf2_msgs::LookupTransformGoal> goal) {
    fbb_.AddOffset(LookupTransformActionGoal::VT_GOAL, goal);
  }
  explicit LookupTransformActionGoalBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LookupTransformActionGoal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LookupTransformActionGoal>(end);
    fbb_.Required(o, LookupTransformActionGoal::VT_HEADER);
    fbb_.Required(o, LookupTransformActionGoal::VT_GOAL_ID);
    fbb_.Required(o, LookupTransformActionGoal::VT_GOAL);
    return o;
  }
};

inline ::flatbuffers::Offset<LookupTransformActionGoal> CreateLookupTransformActionGoal(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::actionlib_msgs::GoalID> goal_id = 0,
    ::flatbuffers::Offset<fb::tf2_msgs::LookupTransformGoal> goal = 0) {
  LookupTransformActionGoalBuilder builder_(_fbb);
  builder_.add_goal(goal);
  builder_.add_goal_id(goal_id);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<LookupTransformActionGoal> CreateLookupTransformActionGoal(::flatbuffers::FlatBufferBuilder &_fbb, const LookupTransformActionGoalT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LookupTransformFeedbackT : public ::flatbuffers::NativeTable {
  typedef LookupTransformFeedback TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  LookupTransformFeedbackT() = default;
  LookupTransformFeedbackT(const LookupTransformFeedbackT &o);
  LookupTransformFeedbackT(LookupTransformFeedbackT&&) FLATBUFFERS_NOEXCEPT = default;
  LookupTransformFeedbackT &operator=(LookupTransformFeedbackT o) FLATBUFFERS_NOEXCEPT;
};

struct LookupTransformFeedback FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LookupTransformFeedbackT NativeTableType;
  typedef LookupTransformFeedbackBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           verifier.EndTable();
  }
  LookupTransformFeedbackT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LookupTransformFeedbackT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<LookupTransformFeedback> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LookupTransformFeedbackT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LookupTransformFeedbackBuilder {
  typedef LookupTransformFeedback Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(LookupTransformFeedback::VT___METADATA, __metadata);
  }
  explicit LookupTransformFeedbackBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LookupTransformFeedback> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LookupTransformFeedback>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LookupTransformFeedback> CreateLookupTransformFeedback(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0) {
  LookupTransformFeedbackBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<LookupTransformFeedback> CreateLookupTransformFeedback(::flatbuffers::FlatBufferBuilder &_fbb, const LookupTransformFeedbackT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LookupTransformActionT : public ::flatbuffers::NativeTable {
  typedef LookupTransformAction TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::tf2_msgs::LookupTransformActionGoalT> action_goal{};
  std::unique_ptr<fb::tf2_msgs::LookupTransformActionResultT> action_result{};
  std::unique_ptr<fb::tf2_msgs::LookupTransformActionFeedbackT> action_feedback{};
  LookupTransformActionT() = default;
  LookupTransformActionT(const LookupTransformActionT &o);
  LookupTransformActionT(LookupTransformActionT&&) FLATBUFFERS_NOEXCEPT = default;
  LookupTransformActionT &operator=(LookupTransformActionT o) FLATBUFFERS_NOEXCEPT;
};

struct LookupTransformAction FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LookupTransformActionT NativeTableType;
  typedef LookupTransformActionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_ACTION_GOAL = 6,
    VT_ACTION_RESULT = 8,
    VT_ACTION_FEEDBACK = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::tf2_msgs::LookupTransformActionGoal *action_goal() const {
    return GetPointer<const fb::tf2_msgs::LookupTransformActionGoal *>(VT_ACTION_GOAL);
  }
  const fb::tf2_msgs::LookupTransformActionResult *action_result() const {
    return GetPointer<const fb::tf2_msgs::LookupTransformActionResult *>(VT_ACTION_RESULT);
  }
  const fb::tf2_msgs::LookupTransformActionFeedback *action_feedback() const {
    return GetPointer<const fb::tf2_msgs::LookupTransformActionFeedback *>(VT_ACTION_FEEDBACK);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_ACTION_GOAL) &&
           verifier.VerifyTable(action_goal()) &&
           VerifyOffsetRequired(verifier, VT_ACTION_RESULT) &&
           verifier.VerifyTable(action_result()) &&
           VerifyOffsetRequired(verifier, VT_ACTION_FEEDBACK) &&
           verifier.VerifyTable(action_feedback()) &&
           verifier.EndTable();
  }
  LookupTransformActionT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LookupTransformActionT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<LookupTransformAction> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LookupTransformActionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LookupTransformActionBuilder {
  typedef LookupTransformAction Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(LookupTransformAction::VT___METADATA, __metadata);
  }
  void add_action_goal(::flatbuffers::Offset<fb::tf2_msgs::LookupTransformActionGoal> action_goal) {
    fbb_.AddOffset(LookupTransformAction::VT_ACTION_GOAL, action_goal);
  }
  void add_action_result(::flatbuffers::Offset<fb::tf2_msgs::LookupTransformActionResult> action_result) {
    fbb_.AddOffset(LookupTransformAction::VT_ACTION_RESULT, action_result);
  }
  void add_action_feedback(::flatbuffers::Offset<fb::tf2_msgs::LookupTransformActionFeedback> action_feedback) {
    fbb_.AddOffset(LookupTransformAction::VT_ACTION_FEEDBACK, action_feedback);
  }
  explicit LookupTransformActionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LookupTransformAction> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LookupTransformAction>(end);
    fbb_.Required(o, LookupTransformAction::VT_ACTION_GOAL);
    fbb_.Required(o, LookupTransformAction::VT_ACTION_RESULT);
    fbb_.Required(o, LookupTransformAction::VT_ACTION_FEEDBACK);
    return o;
  }
};

inline ::flatbuffers::Offset<LookupTransformAction> CreateLookupTransformAction(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::tf2_msgs::LookupTransformActionGoal> action_goal = 0,
    ::flatbuffers::Offset<fb::tf2_msgs::LookupTransformActionResult> action_result = 0,
    ::flatbuffers::Offset<fb::tf2_msgs::LookupTransformActionFeedback> action_feedback = 0) {
  LookupTransformActionBuilder builder_(_fbb);
  builder_.add_action_feedback(action_feedback);
  builder_.add_action_result(action_result);
  builder_.add_action_goal(action_goal);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<LookupTransformAction> CreateLookupTransformAction(::flatbuffers::FlatBufferBuilder &_fbb, const LookupTransformActionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LookupTransformGoalT : public ::flatbuffers::NativeTable {
  typedef LookupTransformGoal TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string target_frame{};
  std::string source_frame{};
  std::unique_ptr<fb::RosTime> source_time{};
  std::unique_ptr<fb::RosDuration> timeout{};
  std::unique_ptr<fb::RosTime> target_time{};
  std::string fixed_frame{};
  bool advanced = false;
  LookupTransformGoalT() = default;
  LookupTransformGoalT(const LookupTransformGoalT &o);
  LookupTransformGoalT(LookupTransformGoalT&&) FLATBUFFERS_NOEXCEPT = default;
  LookupTransformGoalT &operator=(LookupTransformGoalT o) FLATBUFFERS_NOEXCEPT;
};

struct LookupTransformGoal FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LookupTransformGoalT NativeTableType;
  typedef LookupTransformGoalBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_TARGET_FRAME = 6,
    VT_SOURCE_FRAME = 8,
    VT_SOURCE_TIME = 10,
    VT_TIMEOUT = 12,
    VT_TARGET_TIME = 14,
    VT_FIXED_FRAME = 16,
    VT_ADVANCED = 18
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *target_frame() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TARGET_FRAME);
  }
  const ::flatbuffers::String *source_frame() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE_FRAME);
  }
  const fb::RosTime *source_time() const {
    return GetStruct<const fb::RosTime *>(VT_SOURCE_TIME);
  }
  const fb::RosDuration *timeout() const {
    return GetStruct<const fb::RosDuration *>(VT_TIMEOUT);
  }
  const fb::RosTime *target_time() const {
    return GetStruct<const fb::RosTime *>(VT_TARGET_TIME);
  }
  const ::flatbuffers::String *fixed_frame() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FIXED_FRAME);
  }
  bool advanced() const {
    return GetField<uint8_t>(VT_ADVANCED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_TARGET_FRAME) &&
           verifier.VerifyString(target_frame()) &&
           VerifyOffsetRequired(verifier, VT_SOURCE_FRAME) &&
           verifier.VerifyString(source_frame()) &&
           VerifyFieldRequired<fb::RosTime>(verifier, VT_SOURCE_TIME, 4) &&
           VerifyFieldRequired<fb::RosDuration>(verifier, VT_TIMEOUT, 4) &&
           VerifyFieldRequired<fb::RosTime>(verifier, VT_TARGET_TIME, 4) &&
           VerifyOffsetRequired(verifier, VT_FIXED_FRAME) &&
           verifier.VerifyString(fixed_frame()) &&
           VerifyField<uint8_t>(verifier, VT_ADVANCED, 1) &&
           verifier.EndTable();
  }
  LookupTransformGoalT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LookupTransformGoalT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<LookupTransformGoal> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LookupTransformGoalT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LookupTransformGoalBuilder {
  typedef LookupTransformGoal Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(LookupTransformGoal::VT___METADATA, __metadata);
  }
  void add_target_frame(::flatbuffers::Offset<::flatbuffers::String> target_frame) {
    fbb_.AddOffset(LookupTransformGoal::VT_TARGET_FRAME, target_frame);
  }
  void add_source_frame(::flatbuffers::Offset<::flatbuffers::String> source_frame) {
    fbb_.AddOffset(LookupTransformGoal::VT_SOURCE_FRAME, source_frame);
  }
  void add_source_time(const fb::RosTime *source_time) {
    fbb_.AddStruct(LookupTransformGoal::VT_SOURCE_TIME, source_time);
  }
  void add_timeout(const fb::RosDuration *timeout) {
    fbb_.AddStruct(LookupTransformGoal::VT_TIMEOUT, timeout);
  }
  void add_target_time(const fb::RosTime *target_time) {
    fbb_.AddStruct(LookupTransformGoal::VT_TARGET_TIME, target_time);
  }
  void add_fixed_frame(::flatbuffers::Offset<::flatbuffers::String> fixed_frame) {
    fbb_.AddOffset(LookupTransformGoal::VT_FIXED_FRAME, fixed_frame);
  }
  void add_advanced(bool advanced) {
    fbb_.AddElement<uint8_t>(LookupTransformGoal::VT_ADVANCED, static_cast<uint8_t>(advanced), 0);
  }
  explicit LookupTransformGoalBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LookupTransformGoal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LookupTransformGoal>(end);
    fbb_.Required(o, LookupTransformGoal::VT_TARGET_FRAME);
    fbb_.Required(o, LookupTransformGoal::VT_SOURCE_FRAME);
    fbb_.Required(o, LookupTransformGoal::VT_SOURCE_TIME);
    fbb_.Required(o, LookupTransformGoal::VT_TIMEOUT);
    fbb_.Required(o, LookupTransformGoal::VT_TARGET_TIME);
    fbb_.Required(o, LookupTransformGoal::VT_FIXED_FRAME);
    return o;
  }
};

inline ::flatbuffers::Offset<LookupTransformGoal> CreateLookupTransformGoal(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> target_frame = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source_frame = 0,
    const fb::RosTime *source_time = nullptr,
    const fb::RosDuration *timeout = nullptr,
    const fb::RosTime *target_time = nullptr,
    ::flatbuffers::Offset<::flatbuffers::String> fixed_frame = 0,
    bool advanced = false) {
  LookupTransformGoalBuilder builder_(_fbb);
  builder_.add_fixed_frame(fixed_frame);
  builder_.add_target_time(target_time);
  builder_.add_timeout(timeout);
  builder_.add_source_time(source_time);
  builder_.add_source_frame(source_frame);
  builder_.add_target_frame(target_frame);
  builder_.add___metadata(__metadata);
  builder_.add_advanced(advanced);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LookupTransformGoal> CreateLookupTransformGoalDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *target_frame = nullptr,
    const char *source_frame = nullptr,
    const fb::RosTime *source_time = nullptr,
    const fb::RosDuration *timeout = nullptr,
    const fb::RosTime *target_time = nullptr,
    const char *fixed_frame = nullptr,
    bool advanced = false) {
  auto target_frame__ = target_frame ? _fbb.CreateString(target_frame) : 0;
  auto source_frame__ = source_frame ? _fbb.CreateString(source_frame) : 0;
  auto fixed_frame__ = fixed_frame ? _fbb.CreateString(fixed_frame) : 0;
  return fb::tf2_msgs::CreateLookupTransformGoal(
      _fbb,
      __metadata,
      target_frame__,
      source_frame__,
      source_time,
      timeout,
      target_time,
      fixed_frame__,
      advanced);
}

::flatbuffers::Offset<LookupTransformGoal> CreateLookupTransformGoal(::flatbuffers::FlatBufferBuilder &_fbb, const LookupTransformGoalT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline LookupTransformActionFeedbackT::LookupTransformActionFeedbackT(const LookupTransformActionFeedbackT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        status((o.status) ? new fb::actionlib_msgs::GoalStatusT(*o.status) : nullptr),
        feedback((o.feedback) ? new fb::tf2_msgs::LookupTransformFeedbackT(*o.feedback) : nullptr) {
}

inline LookupTransformActionFeedbackT &LookupTransformActionFeedbackT::operator=(LookupTransformActionFeedbackT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(status, o.status);
  std::swap(feedback, o.feedback);
  return *this;
}

inline LookupTransformActionFeedbackT *LookupTransformActionFeedback::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LookupTransformActionFeedbackT>(new LookupTransformActionFeedbackT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LookupTransformActionFeedback::UnPackTo(LookupTransformActionFeedbackT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = status(); if (_e) { if(_o->status) { _e->UnPackTo(_o->status.get(), _resolver); } else { _o->status = std::unique_ptr<fb::actionlib_msgs::GoalStatusT>(_e->UnPack(_resolver)); } } else if (_o->status) { _o->status.reset(); } }
  { auto _e = feedback(); if (_e) { if(_o->feedback) { _e->UnPackTo(_o->feedback.get(), _resolver); } else { _o->feedback = std::unique_ptr<fb::tf2_msgs::LookupTransformFeedbackT>(_e->UnPack(_resolver)); } } else if (_o->feedback) { _o->feedback.reset(); } }
}

inline ::flatbuffers::Offset<LookupTransformActionFeedback> LookupTransformActionFeedback::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LookupTransformActionFeedbackT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLookupTransformActionFeedback(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<LookupTransformActionFeedback> CreateLookupTransformActionFeedback(::flatbuffers::FlatBufferBuilder &_fbb, const LookupTransformActionFeedbackT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LookupTransformActionFeedbackT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _status = _o->status ? CreateGoalStatus(_fbb, _o->status.get(), _rehasher) : 0;
  auto _feedback = _o->feedback ? CreateLookupTransformFeedback(_fbb, _o->feedback.get(), _rehasher) : 0;
  return fb::tf2_msgs::CreateLookupTransformActionFeedback(
      _fbb,
      ___metadata,
      _header,
      _status,
      _feedback);
}

inline LookupTransformActionResultT::LookupTransformActionResultT(const LookupTransformActionResultT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        status((o.status) ? new fb::actionlib_msgs::GoalStatusT(*o.status) : nullptr),
        result((o.result) ? new fb::tf2_msgs::LookupTransformResultT(*o.result) : nullptr) {
}

inline LookupTransformActionResultT &LookupTransformActionResultT::operator=(LookupTransformActionResultT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(status, o.status);
  std::swap(result, o.result);
  return *this;
}

inline LookupTransformActionResultT *LookupTransformActionResult::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LookupTransformActionResultT>(new LookupTransformActionResultT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LookupTransformActionResult::UnPackTo(LookupTransformActionResultT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = status(); if (_e) { if(_o->status) { _e->UnPackTo(_o->status.get(), _resolver); } else { _o->status = std::unique_ptr<fb::actionlib_msgs::GoalStatusT>(_e->UnPack(_resolver)); } } else if (_o->status) { _o->status.reset(); } }
  { auto _e = result(); if (_e) { if(_o->result) { _e->UnPackTo(_o->result.get(), _resolver); } else { _o->result = std::unique_ptr<fb::tf2_msgs::LookupTransformResultT>(_e->UnPack(_resolver)); } } else if (_o->result) { _o->result.reset(); } }
}

inline ::flatbuffers::Offset<LookupTransformActionResult> LookupTransformActionResult::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LookupTransformActionResultT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLookupTransformActionResult(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<LookupTransformActionResult> CreateLookupTransformActionResult(::flatbuffers::FlatBufferBuilder &_fbb, const LookupTransformActionResultT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LookupTransformActionResultT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _status = _o->status ? CreateGoalStatus(_fbb, _o->status.get(), _rehasher) : 0;
  auto _result = _o->result ? CreateLookupTransformResult(_fbb, _o->result.get(), _rehasher) : 0;
  return fb::tf2_msgs::CreateLookupTransformActionResult(
      _fbb,
      ___metadata,
      _header,
      _status,
      _result);
}

inline TF2ErrorT::TF2ErrorT(const TF2ErrorT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        error(o.error),
        error_string(o.error_string) {
}

inline TF2ErrorT &TF2ErrorT::operator=(TF2ErrorT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(error, o.error);
  std::swap(error_string, o.error_string);
  return *this;
}

inline TF2ErrorT *TF2Error::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TF2ErrorT>(new TF2ErrorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TF2Error::UnPackTo(TF2ErrorT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = error(); _o->error = _e; }
  { auto _e = error_string(); if (_e) _o->error_string = _e->str(); }
}

inline ::flatbuffers::Offset<TF2Error> TF2Error::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TF2ErrorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTF2Error(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TF2Error> CreateTF2Error(::flatbuffers::FlatBufferBuilder &_fbb, const TF2ErrorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TF2ErrorT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _error = _o->error;
  auto _error_string = _fbb.CreateString(_o->error_string);
  return fb::tf2_msgs::CreateTF2Error(
      _fbb,
      ___metadata,
      _error,
      _error_string);
}

inline TFMessageT::TFMessageT(const TFMessageT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr) {
  transforms.reserve(o.transforms.size());
  for (const auto &transforms_ : o.transforms) { transforms.emplace_back((transforms_) ? new fb::geometry_msgs::TransformStampedT(*transforms_) : nullptr); }
}

inline TFMessageT &TFMessageT::operator=(TFMessageT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(transforms, o.transforms);
  return *this;
}

inline TFMessageT *TFMessage::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TFMessageT>(new TFMessageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TFMessage::UnPackTo(TFMessageT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = transforms(); if (_e) { _o->transforms.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->transforms[_i]) { _e->Get(_i)->UnPackTo(_o->transforms[_i].get(), _resolver); } else { _o->transforms[_i] = std::unique_ptr<fb::geometry_msgs::TransformStampedT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->transforms.resize(0); } }
}

inline ::flatbuffers::Offset<TFMessage> TFMessage::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TFMessageT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTFMessage(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TFMessage> CreateTFMessage(::flatbuffers::FlatBufferBuilder &_fbb, const TFMessageT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TFMessageT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _transforms = _fbb.CreateVector<::flatbuffers::Offset<fb::geometry_msgs::TransformStamped>> (_o->transforms.size(), [](size_t i, _VectorArgs *__va) { return CreateTransformStamped(*__va->__fbb, __va->__o->transforms[i].get(), __va->__rehasher); }, &_va );
  return fb::tf2_msgs::CreateTFMessage(
      _fbb,
      ___metadata,
      _transforms);
}

inline FrameGraphRequestT::FrameGraphRequestT(const FrameGraphRequestT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr) {
}

inline FrameGraphRequestT &FrameGraphRequestT::operator=(FrameGraphRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  return *this;
}

inline FrameGraphRequestT *FrameGraphRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FrameGraphRequestT>(new FrameGraphRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FrameGraphRequest::UnPackTo(FrameGraphRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
}

inline ::flatbuffers::Offset<FrameGraphRequest> FrameGraphRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FrameGraphRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFrameGraphRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FrameGraphRequest> CreateFrameGraphRequest(::flatbuffers::FlatBufferBuilder &_fbb, const FrameGraphRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FrameGraphRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  return fb::tf2_msgs::CreateFrameGraphRequest(
      _fbb,
      ___metadata);
}

inline FrameGraphResponseT::FrameGraphResponseT(const FrameGraphResponseT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        frame_yaml(o.frame_yaml) {
}

inline FrameGraphResponseT &FrameGraphResponseT::operator=(FrameGraphResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(frame_yaml, o.frame_yaml);
  return *this;
}

inline FrameGraphResponseT *FrameGraphResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FrameGraphResponseT>(new FrameGraphResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FrameGraphResponse::UnPackTo(FrameGraphResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = frame_yaml(); if (_e) _o->frame_yaml = _e->str(); }
}

inline ::flatbuffers::Offset<FrameGraphResponse> FrameGraphResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FrameGraphResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFrameGraphResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FrameGraphResponse> CreateFrameGraphResponse(::flatbuffers::FlatBufferBuilder &_fbb, const FrameGraphResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FrameGraphResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _frame_yaml = _fbb.CreateString(_o->frame_yaml);
  return fb::tf2_msgs::CreateFrameGraphResponse(
      _fbb,
      ___metadata,
      _frame_yaml);
}

inline LookupTransformResultT::LookupTransformResultT(const LookupTransformResultT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        transform((o.transform) ? new fb::geometry_msgs::TransformStampedT(*o.transform) : nullptr),
        error((o.error) ? new fb::tf2_msgs::TF2ErrorT(*o.error) : nullptr) {
}

inline LookupTransformResultT &LookupTransformResultT::operator=(LookupTransformResultT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(transform, o.transform);
  std::swap(error, o.error);
  return *this;
}

inline LookupTransformResultT *LookupTransformResult::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LookupTransformResultT>(new LookupTransformResultT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LookupTransformResult::UnPackTo(LookupTransformResultT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = transform(); if (_e) { if(_o->transform) { _e->UnPackTo(_o->transform.get(), _resolver); } else { _o->transform = std::unique_ptr<fb::geometry_msgs::TransformStampedT>(_e->UnPack(_resolver)); } } else if (_o->transform) { _o->transform.reset(); } }
  { auto _e = error(); if (_e) { if(_o->error) { _e->UnPackTo(_o->error.get(), _resolver); } else { _o->error = std::unique_ptr<fb::tf2_msgs::TF2ErrorT>(_e->UnPack(_resolver)); } } else if (_o->error) { _o->error.reset(); } }
}

inline ::flatbuffers::Offset<LookupTransformResult> LookupTransformResult::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LookupTransformResultT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLookupTransformResult(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<LookupTransformResult> CreateLookupTransformResult(::flatbuffers::FlatBufferBuilder &_fbb, const LookupTransformResultT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LookupTransformResultT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _transform = _o->transform ? CreateTransformStamped(_fbb, _o->transform.get(), _rehasher) : 0;
  auto _error = _o->error ? CreateTF2Error(_fbb, _o->error.get(), _rehasher) : 0;
  return fb::tf2_msgs::CreateLookupTransformResult(
      _fbb,
      ___metadata,
      _transform,
      _error);
}

inline LookupTransformActionGoalT::LookupTransformActionGoalT(const LookupTransformActionGoalT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        goal_id((o.goal_id) ? new fb::actionlib_msgs::GoalIDT(*o.goal_id) : nullptr),
        goal((o.goal) ? new fb::tf2_msgs::LookupTransformGoalT(*o.goal) : nullptr) {
}

inline LookupTransformActionGoalT &LookupTransformActionGoalT::operator=(LookupTransformActionGoalT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(goal_id, o.goal_id);
  std::swap(goal, o.goal);
  return *this;
}

inline LookupTransformActionGoalT *LookupTransformActionGoal::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LookupTransformActionGoalT>(new LookupTransformActionGoalT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LookupTransformActionGoal::UnPackTo(LookupTransformActionGoalT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = goal_id(); if (_e) { if(_o->goal_id) { _e->UnPackTo(_o->goal_id.get(), _resolver); } else { _o->goal_id = std::unique_ptr<fb::actionlib_msgs::GoalIDT>(_e->UnPack(_resolver)); } } else if (_o->goal_id) { _o->goal_id.reset(); } }
  { auto _e = goal(); if (_e) { if(_o->goal) { _e->UnPackTo(_o->goal.get(), _resolver); } else { _o->goal = std::unique_ptr<fb::tf2_msgs::LookupTransformGoalT>(_e->UnPack(_resolver)); } } else if (_o->goal) { _o->goal.reset(); } }
}

inline ::flatbuffers::Offset<LookupTransformActionGoal> LookupTransformActionGoal::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LookupTransformActionGoalT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLookupTransformActionGoal(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<LookupTransformActionGoal> CreateLookupTransformActionGoal(::flatbuffers::FlatBufferBuilder &_fbb, const LookupTransformActionGoalT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LookupTransformActionGoalT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _goal_id = _o->goal_id ? CreateGoalID(_fbb, _o->goal_id.get(), _rehasher) : 0;
  auto _goal = _o->goal ? CreateLookupTransformGoal(_fbb, _o->goal.get(), _rehasher) : 0;
  return fb::tf2_msgs::CreateLookupTransformActionGoal(
      _fbb,
      ___metadata,
      _header,
      _goal_id,
      _goal);
}

inline LookupTransformFeedbackT::LookupTransformFeedbackT(const LookupTransformFeedbackT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr) {
}

inline LookupTransformFeedbackT &LookupTransformFeedbackT::operator=(LookupTransformFeedbackT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  return *this;
}

inline LookupTransformFeedbackT *LookupTransformFeedback::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LookupTransformFeedbackT>(new LookupTransformFeedbackT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LookupTransformFeedback::UnPackTo(LookupTransformFeedbackT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
}

inline ::flatbuffers::Offset<LookupTransformFeedback> LookupTransformFeedback::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LookupTransformFeedbackT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLookupTransformFeedback(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<LookupTransformFeedback> CreateLookupTransformFeedback(::flatbuffers::FlatBufferBuilder &_fbb, const LookupTransformFeedbackT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LookupTransformFeedbackT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  return fb::tf2_msgs::CreateLookupTransformFeedback(
      _fbb,
      ___metadata);
}

inline LookupTransformActionT::LookupTransformActionT(const LookupTransformActionT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        action_goal((o.action_goal) ? new fb::tf2_msgs::LookupTransformActionGoalT(*o.action_goal) : nullptr),
        action_result((o.action_result) ? new fb::tf2_msgs::LookupTransformActionResultT(*o.action_result) : nullptr),
        action_feedback((o.action_feedback) ? new fb::tf2_msgs::LookupTransformActionFeedbackT(*o.action_feedback) : nullptr) {
}

inline LookupTransformActionT &LookupTransformActionT::operator=(LookupTransformActionT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(action_goal, o.action_goal);
  std::swap(action_result, o.action_result);
  std::swap(action_feedback, o.action_feedback);
  return *this;
}

inline LookupTransformActionT *LookupTransformAction::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LookupTransformActionT>(new LookupTransformActionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LookupTransformAction::UnPackTo(LookupTransformActionT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = action_goal(); if (_e) { if(_o->action_goal) { _e->UnPackTo(_o->action_goal.get(), _resolver); } else { _o->action_goal = std::unique_ptr<fb::tf2_msgs::LookupTransformActionGoalT>(_e->UnPack(_resolver)); } } else if (_o->action_goal) { _o->action_goal.reset(); } }
  { auto _e = action_result(); if (_e) { if(_o->action_result) { _e->UnPackTo(_o->action_result.get(), _resolver); } else { _o->action_result = std::unique_ptr<fb::tf2_msgs::LookupTransformActionResultT>(_e->UnPack(_resolver)); } } else if (_o->action_result) { _o->action_result.reset(); } }
  { auto _e = action_feedback(); if (_e) { if(_o->action_feedback) { _e->UnPackTo(_o->action_feedback.get(), _resolver); } else { _o->action_feedback = std::unique_ptr<fb::tf2_msgs::LookupTransformActionFeedbackT>(_e->UnPack(_resolver)); } } else if (_o->action_feedback) { _o->action_feedback.reset(); } }
}

inline ::flatbuffers::Offset<LookupTransformAction> LookupTransformAction::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LookupTransformActionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLookupTransformAction(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<LookupTransformAction> CreateLookupTransformAction(::flatbuffers::FlatBufferBuilder &_fbb, const LookupTransformActionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LookupTransformActionT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _action_goal = _o->action_goal ? CreateLookupTransformActionGoal(_fbb, _o->action_goal.get(), _rehasher) : 0;
  auto _action_result = _o->action_result ? CreateLookupTransformActionResult(_fbb, _o->action_result.get(), _rehasher) : 0;
  auto _action_feedback = _o->action_feedback ? CreateLookupTransformActionFeedback(_fbb, _o->action_feedback.get(), _rehasher) : 0;
  return fb::tf2_msgs::CreateLookupTransformAction(
      _fbb,
      ___metadata,
      _action_goal,
      _action_result,
      _action_feedback);
}

inline LookupTransformGoalT::LookupTransformGoalT(const LookupTransformGoalT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        target_frame(o.target_frame),
        source_frame(o.source_frame),
        source_time((o.source_time) ? new fb::RosTime(*o.source_time) : nullptr),
        timeout((o.timeout) ? new fb::RosDuration(*o.timeout) : nullptr),
        target_time((o.target_time) ? new fb::RosTime(*o.target_time) : nullptr),
        fixed_frame(o.fixed_frame),
        advanced(o.advanced) {
}

inline LookupTransformGoalT &LookupTransformGoalT::operator=(LookupTransformGoalT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(target_frame, o.target_frame);
  std::swap(source_frame, o.source_frame);
  std::swap(source_time, o.source_time);
  std::swap(timeout, o.timeout);
  std::swap(target_time, o.target_time);
  std::swap(fixed_frame, o.fixed_frame);
  std::swap(advanced, o.advanced);
  return *this;
}

inline LookupTransformGoalT *LookupTransformGoal::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LookupTransformGoalT>(new LookupTransformGoalT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LookupTransformGoal::UnPackTo(LookupTransformGoalT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = target_frame(); if (_e) _o->target_frame = _e->str(); }
  { auto _e = source_frame(); if (_e) _o->source_frame = _e->str(); }
  { auto _e = source_time(); if (_e) _o->source_time = std::unique_ptr<fb::RosTime>(new fb::RosTime(*_e)); }
  { auto _e = timeout(); if (_e) _o->timeout = std::unique_ptr<fb::RosDuration>(new fb::RosDuration(*_e)); }
  { auto _e = target_time(); if (_e) _o->target_time = std::unique_ptr<fb::RosTime>(new fb::RosTime(*_e)); }
  { auto _e = fixed_frame(); if (_e) _o->fixed_frame = _e->str(); }
  { auto _e = advanced(); _o->advanced = _e; }
}

inline ::flatbuffers::Offset<LookupTransformGoal> LookupTransformGoal::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LookupTransformGoalT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLookupTransformGoal(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<LookupTransformGoal> CreateLookupTransformGoal(::flatbuffers::FlatBufferBuilder &_fbb, const LookupTransformGoalT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LookupTransformGoalT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _target_frame = _fbb.CreateString(_o->target_frame);
  auto _source_frame = _fbb.CreateString(_o->source_frame);
  auto _source_time = _o->source_time ? _o->source_time.get() : nullptr;
  auto _timeout = _o->timeout ? _o->timeout.get() : nullptr;
  auto _target_time = _o->target_time ? _o->target_time.get() : nullptr;
  auto _fixed_frame = _fbb.CreateString(_o->fixed_frame);
  auto _advanced = _o->advanced;
  return fb::tf2_msgs::CreateLookupTransformGoal(
      _fbb,
      ___metadata,
      _target_frame,
      _source_frame,
      _source_time,
      _timeout,
      _target_time,
      _fixed_frame,
      _advanced);
}

}  // namespace tf2_msgs
}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_TF2MSGS_FB_TF2_MSGS_H_
