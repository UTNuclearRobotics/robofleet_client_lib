// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NAVMSGS_FB_NAV_MSGS_H_
#define FLATBUFFERS_GENERATED_NAVMSGS_FB_NAV_MSGS_H_

#include "./flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 21,
             "Non-compatible flatbuffers version included");

#include "actionlib_msgs_generated.h"
#include "base_schema_generated.h"
#include "geometry_msgs_generated.h"
#include "std_msgs_generated.h"

namespace fb {
namespace nav_msgs {

struct Path;
struct PathBuilder;
struct PathT;

struct GetMapResult;
struct GetMapResultBuilder;
struct GetMapResultT;

struct Odometry;
struct OdometryBuilder;
struct OdometryT;

struct GetMapActionResult;
struct GetMapActionResultBuilder;
struct GetMapActionResultT;

struct GetMapAction;
struct GetMapActionBuilder;
struct GetMapActionT;

struct GridCells;
struct GridCellsBuilder;
struct GridCellsT;

struct GetMapActionGoal;
struct GetMapActionGoalBuilder;
struct GetMapActionGoalT;

struct SetMapRequest;
struct SetMapRequestBuilder;
struct SetMapRequestT;

struct SetMapResponse;
struct SetMapResponseBuilder;
struct SetMapResponseT;

struct GetMapActionFeedback;
struct GetMapActionFeedbackBuilder;
struct GetMapActionFeedbackT;

struct GetMapRequest;
struct GetMapRequestBuilder;
struct GetMapRequestT;

struct GetMapResponse;
struct GetMapResponseBuilder;
struct GetMapResponseT;

struct GetMapFeedback;
struct GetMapFeedbackBuilder;
struct GetMapFeedbackT;

struct GetPlanRequest;
struct GetPlanRequestBuilder;
struct GetPlanRequestT;

struct GetPlanResponse;
struct GetPlanResponseBuilder;
struct GetPlanResponseT;

struct OccupancyGrid;
struct OccupancyGridBuilder;
struct OccupancyGridT;

struct MapMetaData;
struct MapMetaDataBuilder;
struct MapMetaDataT;

struct LoadMapRequest;
struct LoadMapRequestBuilder;
struct LoadMapRequestT;

struct LoadMapResponse;
struct LoadMapResponseBuilder;
struct LoadMapResponseT;

struct GetMapGoal;
struct GetMapGoalBuilder;
struct GetMapGoalT;

struct PathT : public ::flatbuffers::NativeTable {
  typedef Path TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::vector<std::unique_ptr<fb::geometry_msgs::PoseStampedT>> poses{};
  PathT() = default;
  PathT(const PathT &o);
  PathT(PathT&&) FLATBUFFERS_NOEXCEPT = default;
  PathT &operator=(PathT o) FLATBUFFERS_NOEXCEPT;
};

struct Path FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PathT NativeTableType;
  typedef PathBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_POSES = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::PoseStamped>> *poses() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::PoseStamped>> *>(VT_POSES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_POSES) &&
           verifier.VerifyVector(poses()) &&
           verifier.VerifyVectorOfTables(poses()) &&
           verifier.EndTable();
  }
  PathT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PathT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Path> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PathT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PathBuilder {
  typedef Path Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Path::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(Path::VT_HEADER, header);
  }
  void add_poses(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::PoseStamped>>> poses) {
    fbb_.AddOffset(Path::VT_POSES, poses);
  }
  explicit PathBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Path> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Path>(end);
    fbb_.Required(o, Path::VT_HEADER);
    fbb_.Required(o, Path::VT_POSES);
    return o;
  }
};

inline ::flatbuffers::Offset<Path> CreatePath(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::PoseStamped>>> poses = 0) {
  PathBuilder builder_(_fbb);
  builder_.add_poses(poses);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Path> CreatePathDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const std::vector<::flatbuffers::Offset<fb::geometry_msgs::PoseStamped>> *poses = nullptr) {
  auto poses__ = poses ? _fbb.CreateVector<::flatbuffers::Offset<fb::geometry_msgs::PoseStamped>>(*poses) : 0;
  return fb::nav_msgs::CreatePath(
      _fbb,
      __metadata,
      header,
      poses__);
}

::flatbuffers::Offset<Path> CreatePath(::flatbuffers::FlatBufferBuilder &_fbb, const PathT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetMapResultT : public ::flatbuffers::NativeTable {
  typedef GetMapResult TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::nav_msgs::OccupancyGridT> map{};
  GetMapResultT() = default;
  GetMapResultT(const GetMapResultT &o);
  GetMapResultT(GetMapResultT&&) FLATBUFFERS_NOEXCEPT = default;
  GetMapResultT &operator=(GetMapResultT o) FLATBUFFERS_NOEXCEPT;
};

struct GetMapResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetMapResultT NativeTableType;
  typedef GetMapResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_MAP = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::nav_msgs::OccupancyGrid *map() const {
    return GetPointer<const fb::nav_msgs::OccupancyGrid *>(VT_MAP);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_MAP) &&
           verifier.VerifyTable(map()) &&
           verifier.EndTable();
  }
  GetMapResultT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetMapResultT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GetMapResult> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapResultT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetMapResultBuilder {
  typedef GetMapResult Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GetMapResult::VT___METADATA, __metadata);
  }
  void add_map(::flatbuffers::Offset<fb::nav_msgs::OccupancyGrid> map) {
    fbb_.AddOffset(GetMapResult::VT_MAP, map);
  }
  explicit GetMapResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetMapResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetMapResult>(end);
    fbb_.Required(o, GetMapResult::VT_MAP);
    return o;
  }
};

inline ::flatbuffers::Offset<GetMapResult> CreateGetMapResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::nav_msgs::OccupancyGrid> map = 0) {
  GetMapResultBuilder builder_(_fbb);
  builder_.add_map(map);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<GetMapResult> CreateGetMapResult(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapResultT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OdometryT : public ::flatbuffers::NativeTable {
  typedef Odometry TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::string child_frame_id{};
  std::unique_ptr<fb::geometry_msgs::PoseWithCovarianceT> pose{};
  std::unique_ptr<fb::geometry_msgs::TwistWithCovarianceT> twist{};
  OdometryT() = default;
  OdometryT(const OdometryT &o);
  OdometryT(OdometryT&&) FLATBUFFERS_NOEXCEPT = default;
  OdometryT &operator=(OdometryT o) FLATBUFFERS_NOEXCEPT;
};

struct Odometry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OdometryT NativeTableType;
  typedef OdometryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_CHILD_FRAME_ID = 8,
    VT_POSE = 10,
    VT_TWIST = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const ::flatbuffers::String *child_frame_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHILD_FRAME_ID);
  }
  const fb::geometry_msgs::PoseWithCovariance *pose() const {
    return GetPointer<const fb::geometry_msgs::PoseWithCovariance *>(VT_POSE);
  }
  const fb::geometry_msgs::TwistWithCovariance *twist() const {
    return GetPointer<const fb::geometry_msgs::TwistWithCovariance *>(VT_TWIST);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_CHILD_FRAME_ID) &&
           verifier.VerifyString(child_frame_id()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           VerifyOffsetRequired(verifier, VT_TWIST) &&
           verifier.VerifyTable(twist()) &&
           verifier.EndTable();
  }
  OdometryT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OdometryT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Odometry> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OdometryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OdometryBuilder {
  typedef Odometry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Odometry::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(Odometry::VT_HEADER, header);
  }
  void add_child_frame_id(::flatbuffers::Offset<::flatbuffers::String> child_frame_id) {
    fbb_.AddOffset(Odometry::VT_CHILD_FRAME_ID, child_frame_id);
  }
  void add_pose(::flatbuffers::Offset<fb::geometry_msgs::PoseWithCovariance> pose) {
    fbb_.AddOffset(Odometry::VT_POSE, pose);
  }
  void add_twist(::flatbuffers::Offset<fb::geometry_msgs::TwistWithCovariance> twist) {
    fbb_.AddOffset(Odometry::VT_TWIST, twist);
  }
  explicit OdometryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Odometry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Odometry>(end);
    fbb_.Required(o, Odometry::VT_HEADER);
    fbb_.Required(o, Odometry::VT_CHILD_FRAME_ID);
    fbb_.Required(o, Odometry::VT_POSE);
    fbb_.Required(o, Odometry::VT_TWIST);
    return o;
  }
};

inline ::flatbuffers::Offset<Odometry> CreateOdometry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<::flatbuffers::String> child_frame_id = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::PoseWithCovariance> pose = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::TwistWithCovariance> twist = 0) {
  OdometryBuilder builder_(_fbb);
  builder_.add_twist(twist);
  builder_.add_pose(pose);
  builder_.add_child_frame_id(child_frame_id);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Odometry> CreateOdometryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const char *child_frame_id = nullptr,
    ::flatbuffers::Offset<fb::geometry_msgs::PoseWithCovariance> pose = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::TwistWithCovariance> twist = 0) {
  auto child_frame_id__ = child_frame_id ? _fbb.CreateString(child_frame_id) : 0;
  return fb::nav_msgs::CreateOdometry(
      _fbb,
      __metadata,
      header,
      child_frame_id__,
      pose,
      twist);
}

::flatbuffers::Offset<Odometry> CreateOdometry(::flatbuffers::FlatBufferBuilder &_fbb, const OdometryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetMapActionResultT : public ::flatbuffers::NativeTable {
  typedef GetMapActionResult TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::actionlib_msgs::GoalStatusT> status{};
  std::unique_ptr<fb::nav_msgs::GetMapResultT> result{};
  GetMapActionResultT() = default;
  GetMapActionResultT(const GetMapActionResultT &o);
  GetMapActionResultT(GetMapActionResultT&&) FLATBUFFERS_NOEXCEPT = default;
  GetMapActionResultT &operator=(GetMapActionResultT o) FLATBUFFERS_NOEXCEPT;
};

struct GetMapActionResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetMapActionResultT NativeTableType;
  typedef GetMapActionResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_STATUS = 8,
    VT_RESULT = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::actionlib_msgs::GoalStatus *status() const {
    return GetPointer<const fb::actionlib_msgs::GoalStatus *>(VT_STATUS);
  }
  const fb::nav_msgs::GetMapResult *result() const {
    return GetPointer<const fb::nav_msgs::GetMapResult *>(VT_RESULT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_STATUS) &&
           verifier.VerifyTable(status()) &&
           VerifyOffsetRequired(verifier, VT_RESULT) &&
           verifier.VerifyTable(result()) &&
           verifier.EndTable();
  }
  GetMapActionResultT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetMapActionResultT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GetMapActionResult> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapActionResultT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetMapActionResultBuilder {
  typedef GetMapActionResult Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GetMapActionResult::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(GetMapActionResult::VT_HEADER, header);
  }
  void add_status(::flatbuffers::Offset<fb::actionlib_msgs::GoalStatus> status) {
    fbb_.AddOffset(GetMapActionResult::VT_STATUS, status);
  }
  void add_result(::flatbuffers::Offset<fb::nav_msgs::GetMapResult> result) {
    fbb_.AddOffset(GetMapActionResult::VT_RESULT, result);
  }
  explicit GetMapActionResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetMapActionResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetMapActionResult>(end);
    fbb_.Required(o, GetMapActionResult::VT_HEADER);
    fbb_.Required(o, GetMapActionResult::VT_STATUS);
    fbb_.Required(o, GetMapActionResult::VT_RESULT);
    return o;
  }
};

inline ::flatbuffers::Offset<GetMapActionResult> CreateGetMapActionResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::actionlib_msgs::GoalStatus> status = 0,
    ::flatbuffers::Offset<fb::nav_msgs::GetMapResult> result = 0) {
  GetMapActionResultBuilder builder_(_fbb);
  builder_.add_result(result);
  builder_.add_status(status);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<GetMapActionResult> CreateGetMapActionResult(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapActionResultT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetMapActionT : public ::flatbuffers::NativeTable {
  typedef GetMapAction TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::nav_msgs::GetMapActionGoalT> action_goal{};
  std::unique_ptr<fb::nav_msgs::GetMapActionResultT> action_result{};
  std::unique_ptr<fb::nav_msgs::GetMapActionFeedbackT> action_feedback{};
  GetMapActionT() = default;
  GetMapActionT(const GetMapActionT &o);
  GetMapActionT(GetMapActionT&&) FLATBUFFERS_NOEXCEPT = default;
  GetMapActionT &operator=(GetMapActionT o) FLATBUFFERS_NOEXCEPT;
};

struct GetMapAction FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetMapActionT NativeTableType;
  typedef GetMapActionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_ACTION_GOAL = 6,
    VT_ACTION_RESULT = 8,
    VT_ACTION_FEEDBACK = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::nav_msgs::GetMapActionGoal *action_goal() const {
    return GetPointer<const fb::nav_msgs::GetMapActionGoal *>(VT_ACTION_GOAL);
  }
  const fb::nav_msgs::GetMapActionResult *action_result() const {
    return GetPointer<const fb::nav_msgs::GetMapActionResult *>(VT_ACTION_RESULT);
  }
  const fb::nav_msgs::GetMapActionFeedback *action_feedback() const {
    return GetPointer<const fb::nav_msgs::GetMapActionFeedback *>(VT_ACTION_FEEDBACK);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_ACTION_GOAL) &&
           verifier.VerifyTable(action_goal()) &&
           VerifyOffsetRequired(verifier, VT_ACTION_RESULT) &&
           verifier.VerifyTable(action_result()) &&
           VerifyOffsetRequired(verifier, VT_ACTION_FEEDBACK) &&
           verifier.VerifyTable(action_feedback()) &&
           verifier.EndTable();
  }
  GetMapActionT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetMapActionT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GetMapAction> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapActionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetMapActionBuilder {
  typedef GetMapAction Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GetMapAction::VT___METADATA, __metadata);
  }
  void add_action_goal(::flatbuffers::Offset<fb::nav_msgs::GetMapActionGoal> action_goal) {
    fbb_.AddOffset(GetMapAction::VT_ACTION_GOAL, action_goal);
  }
  void add_action_result(::flatbuffers::Offset<fb::nav_msgs::GetMapActionResult> action_result) {
    fbb_.AddOffset(GetMapAction::VT_ACTION_RESULT, action_result);
  }
  void add_action_feedback(::flatbuffers::Offset<fb::nav_msgs::GetMapActionFeedback> action_feedback) {
    fbb_.AddOffset(GetMapAction::VT_ACTION_FEEDBACK, action_feedback);
  }
  explicit GetMapActionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetMapAction> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetMapAction>(end);
    fbb_.Required(o, GetMapAction::VT_ACTION_GOAL);
    fbb_.Required(o, GetMapAction::VT_ACTION_RESULT);
    fbb_.Required(o, GetMapAction::VT_ACTION_FEEDBACK);
    return o;
  }
};

inline ::flatbuffers::Offset<GetMapAction> CreateGetMapAction(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::nav_msgs::GetMapActionGoal> action_goal = 0,
    ::flatbuffers::Offset<fb::nav_msgs::GetMapActionResult> action_result = 0,
    ::flatbuffers::Offset<fb::nav_msgs::GetMapActionFeedback> action_feedback = 0) {
  GetMapActionBuilder builder_(_fbb);
  builder_.add_action_feedback(action_feedback);
  builder_.add_action_result(action_result);
  builder_.add_action_goal(action_goal);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<GetMapAction> CreateGetMapAction(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapActionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GridCellsT : public ::flatbuffers::NativeTable {
  typedef GridCells TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  float cell_width = 0.0f;
  float cell_height = 0.0f;
  std::vector<std::unique_ptr<fb::geometry_msgs::PointT>> cells{};
  GridCellsT() = default;
  GridCellsT(const GridCellsT &o);
  GridCellsT(GridCellsT&&) FLATBUFFERS_NOEXCEPT = default;
  GridCellsT &operator=(GridCellsT o) FLATBUFFERS_NOEXCEPT;
};

struct GridCells FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GridCellsT NativeTableType;
  typedef GridCellsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_CELL_WIDTH = 8,
    VT_CELL_HEIGHT = 10,
    VT_CELLS = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  float cell_width() const {
    return GetField<float>(VT_CELL_WIDTH, 0.0f);
  }
  float cell_height() const {
    return GetField<float>(VT_CELL_HEIGHT, 0.0f);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::Point>> *cells() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::Point>> *>(VT_CELLS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<float>(verifier, VT_CELL_WIDTH, 4) &&
           VerifyField<float>(verifier, VT_CELL_HEIGHT, 4) &&
           VerifyOffsetRequired(verifier, VT_CELLS) &&
           verifier.VerifyVector(cells()) &&
           verifier.VerifyVectorOfTables(cells()) &&
           verifier.EndTable();
  }
  GridCellsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GridCellsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GridCells> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GridCellsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GridCellsBuilder {
  typedef GridCells Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GridCells::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(GridCells::VT_HEADER, header);
  }
  void add_cell_width(float cell_width) {
    fbb_.AddElement<float>(GridCells::VT_CELL_WIDTH, cell_width, 0.0f);
  }
  void add_cell_height(float cell_height) {
    fbb_.AddElement<float>(GridCells::VT_CELL_HEIGHT, cell_height, 0.0f);
  }
  void add_cells(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::Point>>> cells) {
    fbb_.AddOffset(GridCells::VT_CELLS, cells);
  }
  explicit GridCellsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GridCells> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GridCells>(end);
    fbb_.Required(o, GridCells::VT_HEADER);
    fbb_.Required(o, GridCells::VT_CELLS);
    return o;
  }
};

inline ::flatbuffers::Offset<GridCells> CreateGridCells(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    float cell_width = 0.0f,
    float cell_height = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::Point>>> cells = 0) {
  GridCellsBuilder builder_(_fbb);
  builder_.add_cells(cells);
  builder_.add_cell_height(cell_height);
  builder_.add_cell_width(cell_width);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GridCells> CreateGridCellsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    float cell_width = 0.0f,
    float cell_height = 0.0f,
    const std::vector<::flatbuffers::Offset<fb::geometry_msgs::Point>> *cells = nullptr) {
  auto cells__ = cells ? _fbb.CreateVector<::flatbuffers::Offset<fb::geometry_msgs::Point>>(*cells) : 0;
  return fb::nav_msgs::CreateGridCells(
      _fbb,
      __metadata,
      header,
      cell_width,
      cell_height,
      cells__);
}

::flatbuffers::Offset<GridCells> CreateGridCells(::flatbuffers::FlatBufferBuilder &_fbb, const GridCellsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetMapActionGoalT : public ::flatbuffers::NativeTable {
  typedef GetMapActionGoal TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::actionlib_msgs::GoalIDT> goal_id{};
  std::unique_ptr<fb::nav_msgs::GetMapGoalT> goal{};
  GetMapActionGoalT() = default;
  GetMapActionGoalT(const GetMapActionGoalT &o);
  GetMapActionGoalT(GetMapActionGoalT&&) FLATBUFFERS_NOEXCEPT = default;
  GetMapActionGoalT &operator=(GetMapActionGoalT o) FLATBUFFERS_NOEXCEPT;
};

struct GetMapActionGoal FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetMapActionGoalT NativeTableType;
  typedef GetMapActionGoalBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_GOAL_ID = 8,
    VT_GOAL = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::actionlib_msgs::GoalID *goal_id() const {
    return GetPointer<const fb::actionlib_msgs::GoalID *>(VT_GOAL_ID);
  }
  const fb::nav_msgs::GetMapGoal *goal() const {
    return GetPointer<const fb::nav_msgs::GetMapGoal *>(VT_GOAL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_GOAL_ID) &&
           verifier.VerifyTable(goal_id()) &&
           VerifyOffsetRequired(verifier, VT_GOAL) &&
           verifier.VerifyTable(goal()) &&
           verifier.EndTable();
  }
  GetMapActionGoalT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetMapActionGoalT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GetMapActionGoal> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapActionGoalT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetMapActionGoalBuilder {
  typedef GetMapActionGoal Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GetMapActionGoal::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(GetMapActionGoal::VT_HEADER, header);
  }
  void add_goal_id(::flatbuffers::Offset<fb::actionlib_msgs::GoalID> goal_id) {
    fbb_.AddOffset(GetMapActionGoal::VT_GOAL_ID, goal_id);
  }
  void add_goal(::flatbuffers::Offset<fb::nav_msgs::GetMapGoal> goal) {
    fbb_.AddOffset(GetMapActionGoal::VT_GOAL, goal);
  }
  explicit GetMapActionGoalBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetMapActionGoal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetMapActionGoal>(end);
    fbb_.Required(o, GetMapActionGoal::VT_HEADER);
    fbb_.Required(o, GetMapActionGoal::VT_GOAL_ID);
    fbb_.Required(o, GetMapActionGoal::VT_GOAL);
    return o;
  }
};

inline ::flatbuffers::Offset<GetMapActionGoal> CreateGetMapActionGoal(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::actionlib_msgs::GoalID> goal_id = 0,
    ::flatbuffers::Offset<fb::nav_msgs::GetMapGoal> goal = 0) {
  GetMapActionGoalBuilder builder_(_fbb);
  builder_.add_goal(goal);
  builder_.add_goal_id(goal_id);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<GetMapActionGoal> CreateGetMapActionGoal(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapActionGoalT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SetMapRequestT : public ::flatbuffers::NativeTable {
  typedef SetMapRequest TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::nav_msgs::OccupancyGridT> map{};
  std::unique_ptr<fb::geometry_msgs::PoseWithCovarianceStampedT> initial_pose{};
  SetMapRequestT() = default;
  SetMapRequestT(const SetMapRequestT &o);
  SetMapRequestT(SetMapRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  SetMapRequestT &operator=(SetMapRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct SetMapRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetMapRequestT NativeTableType;
  typedef SetMapRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_MAP = 6,
    VT_INITIAL_POSE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::nav_msgs::OccupancyGrid *map() const {
    return GetPointer<const fb::nav_msgs::OccupancyGrid *>(VT_MAP);
  }
  const fb::geometry_msgs::PoseWithCovarianceStamped *initial_pose() const {
    return GetPointer<const fb::geometry_msgs::PoseWithCovarianceStamped *>(VT_INITIAL_POSE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_MAP) &&
           verifier.VerifyTable(map()) &&
           VerifyOffsetRequired(verifier, VT_INITIAL_POSE) &&
           verifier.VerifyTable(initial_pose()) &&
           verifier.EndTable();
  }
  SetMapRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SetMapRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SetMapRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetMapRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SetMapRequestBuilder {
  typedef SetMapRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(SetMapRequest::VT___METADATA, __metadata);
  }
  void add_map(::flatbuffers::Offset<fb::nav_msgs::OccupancyGrid> map) {
    fbb_.AddOffset(SetMapRequest::VT_MAP, map);
  }
  void add_initial_pose(::flatbuffers::Offset<fb::geometry_msgs::PoseWithCovarianceStamped> initial_pose) {
    fbb_.AddOffset(SetMapRequest::VT_INITIAL_POSE, initial_pose);
  }
  explicit SetMapRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetMapRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetMapRequest>(end);
    fbb_.Required(o, SetMapRequest::VT_MAP);
    fbb_.Required(o, SetMapRequest::VT_INITIAL_POSE);
    return o;
  }
};

inline ::flatbuffers::Offset<SetMapRequest> CreateSetMapRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::nav_msgs::OccupancyGrid> map = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::PoseWithCovarianceStamped> initial_pose = 0) {
  SetMapRequestBuilder builder_(_fbb);
  builder_.add_initial_pose(initial_pose);
  builder_.add_map(map);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<SetMapRequest> CreateSetMapRequest(::flatbuffers::FlatBufferBuilder &_fbb, const SetMapRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SetMapResponseT : public ::flatbuffers::NativeTable {
  typedef SetMapResponse TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  bool success = false;
  SetMapResponseT() = default;
  SetMapResponseT(const SetMapResponseT &o);
  SetMapResponseT(SetMapResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  SetMapResponseT &operator=(SetMapResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct SetMapResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetMapResponseT NativeTableType;
  typedef SetMapResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_SUCCESS = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           verifier.EndTable();
  }
  SetMapResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SetMapResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SetMapResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetMapResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SetMapResponseBuilder {
  typedef SetMapResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(SetMapResponse::VT___METADATA, __metadata);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(SetMapResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit SetMapResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetMapResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetMapResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetMapResponse> CreateSetMapResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    bool success = false) {
  SetMapResponseBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  builder_.add_success(success);
  return builder_.Finish();
}

::flatbuffers::Offset<SetMapResponse> CreateSetMapResponse(::flatbuffers::FlatBufferBuilder &_fbb, const SetMapResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetMapActionFeedbackT : public ::flatbuffers::NativeTable {
  typedef GetMapActionFeedback TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::actionlib_msgs::GoalStatusT> status{};
  std::unique_ptr<fb::nav_msgs::GetMapFeedbackT> feedback{};
  GetMapActionFeedbackT() = default;
  GetMapActionFeedbackT(const GetMapActionFeedbackT &o);
  GetMapActionFeedbackT(GetMapActionFeedbackT&&) FLATBUFFERS_NOEXCEPT = default;
  GetMapActionFeedbackT &operator=(GetMapActionFeedbackT o) FLATBUFFERS_NOEXCEPT;
};

struct GetMapActionFeedback FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetMapActionFeedbackT NativeTableType;
  typedef GetMapActionFeedbackBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_STATUS = 8,
    VT_FEEDBACK = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::actionlib_msgs::GoalStatus *status() const {
    return GetPointer<const fb::actionlib_msgs::GoalStatus *>(VT_STATUS);
  }
  const fb::nav_msgs::GetMapFeedback *feedback() const {
    return GetPointer<const fb::nav_msgs::GetMapFeedback *>(VT_FEEDBACK);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_STATUS) &&
           verifier.VerifyTable(status()) &&
           VerifyOffsetRequired(verifier, VT_FEEDBACK) &&
           verifier.VerifyTable(feedback()) &&
           verifier.EndTable();
  }
  GetMapActionFeedbackT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetMapActionFeedbackT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GetMapActionFeedback> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapActionFeedbackT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetMapActionFeedbackBuilder {
  typedef GetMapActionFeedback Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GetMapActionFeedback::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(GetMapActionFeedback::VT_HEADER, header);
  }
  void add_status(::flatbuffers::Offset<fb::actionlib_msgs::GoalStatus> status) {
    fbb_.AddOffset(GetMapActionFeedback::VT_STATUS, status);
  }
  void add_feedback(::flatbuffers::Offset<fb::nav_msgs::GetMapFeedback> feedback) {
    fbb_.AddOffset(GetMapActionFeedback::VT_FEEDBACK, feedback);
  }
  explicit GetMapActionFeedbackBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetMapActionFeedback> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetMapActionFeedback>(end);
    fbb_.Required(o, GetMapActionFeedback::VT_HEADER);
    fbb_.Required(o, GetMapActionFeedback::VT_STATUS);
    fbb_.Required(o, GetMapActionFeedback::VT_FEEDBACK);
    return o;
  }
};

inline ::flatbuffers::Offset<GetMapActionFeedback> CreateGetMapActionFeedback(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::actionlib_msgs::GoalStatus> status = 0,
    ::flatbuffers::Offset<fb::nav_msgs::GetMapFeedback> feedback = 0) {
  GetMapActionFeedbackBuilder builder_(_fbb);
  builder_.add_feedback(feedback);
  builder_.add_status(status);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<GetMapActionFeedback> CreateGetMapActionFeedback(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapActionFeedbackT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetMapRequestT : public ::flatbuffers::NativeTable {
  typedef GetMapRequest TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  GetMapRequestT() = default;
  GetMapRequestT(const GetMapRequestT &o);
  GetMapRequestT(GetMapRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  GetMapRequestT &operator=(GetMapRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct GetMapRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetMapRequestT NativeTableType;
  typedef GetMapRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           verifier.EndTable();
  }
  GetMapRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetMapRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GetMapRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetMapRequestBuilder {
  typedef GetMapRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GetMapRequest::VT___METADATA, __metadata);
  }
  explicit GetMapRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetMapRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetMapRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetMapRequest> CreateGetMapRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0) {
  GetMapRequestBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<GetMapRequest> CreateGetMapRequest(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetMapResponseT : public ::flatbuffers::NativeTable {
  typedef GetMapResponse TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::nav_msgs::OccupancyGridT> map{};
  GetMapResponseT() = default;
  GetMapResponseT(const GetMapResponseT &o);
  GetMapResponseT(GetMapResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  GetMapResponseT &operator=(GetMapResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct GetMapResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetMapResponseT NativeTableType;
  typedef GetMapResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_MAP = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::nav_msgs::OccupancyGrid *map() const {
    return GetPointer<const fb::nav_msgs::OccupancyGrid *>(VT_MAP);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_MAP) &&
           verifier.VerifyTable(map()) &&
           verifier.EndTable();
  }
  GetMapResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetMapResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GetMapResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetMapResponseBuilder {
  typedef GetMapResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GetMapResponse::VT___METADATA, __metadata);
  }
  void add_map(::flatbuffers::Offset<fb::nav_msgs::OccupancyGrid> map) {
    fbb_.AddOffset(GetMapResponse::VT_MAP, map);
  }
  explicit GetMapResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetMapResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetMapResponse>(end);
    fbb_.Required(o, GetMapResponse::VT_MAP);
    return o;
  }
};

inline ::flatbuffers::Offset<GetMapResponse> CreateGetMapResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::nav_msgs::OccupancyGrid> map = 0) {
  GetMapResponseBuilder builder_(_fbb);
  builder_.add_map(map);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<GetMapResponse> CreateGetMapResponse(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetMapFeedbackT : public ::flatbuffers::NativeTable {
  typedef GetMapFeedback TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  GetMapFeedbackT() = default;
  GetMapFeedbackT(const GetMapFeedbackT &o);
  GetMapFeedbackT(GetMapFeedbackT&&) FLATBUFFERS_NOEXCEPT = default;
  GetMapFeedbackT &operator=(GetMapFeedbackT o) FLATBUFFERS_NOEXCEPT;
};

struct GetMapFeedback FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetMapFeedbackT NativeTableType;
  typedef GetMapFeedbackBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           verifier.EndTable();
  }
  GetMapFeedbackT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetMapFeedbackT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GetMapFeedback> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapFeedbackT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetMapFeedbackBuilder {
  typedef GetMapFeedback Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GetMapFeedback::VT___METADATA, __metadata);
  }
  explicit GetMapFeedbackBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetMapFeedback> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetMapFeedback>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetMapFeedback> CreateGetMapFeedback(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0) {
  GetMapFeedbackBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<GetMapFeedback> CreateGetMapFeedback(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapFeedbackT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetPlanRequestT : public ::flatbuffers::NativeTable {
  typedef GetPlanRequest TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::geometry_msgs::PoseStampedT> start{};
  std::unique_ptr<fb::geometry_msgs::PoseStampedT> goal{};
  float tolerance = 0.0f;
  GetPlanRequestT() = default;
  GetPlanRequestT(const GetPlanRequestT &o);
  GetPlanRequestT(GetPlanRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  GetPlanRequestT &operator=(GetPlanRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct GetPlanRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetPlanRequestT NativeTableType;
  typedef GetPlanRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_START = 6,
    VT_GOAL = 8,
    VT_TOLERANCE = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::PoseStamped *start() const {
    return GetPointer<const fb::geometry_msgs::PoseStamped *>(VT_START);
  }
  const fb::geometry_msgs::PoseStamped *goal() const {
    return GetPointer<const fb::geometry_msgs::PoseStamped *>(VT_GOAL);
  }
  float tolerance() const {
    return GetField<float>(VT_TOLERANCE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_START) &&
           verifier.VerifyTable(start()) &&
           VerifyOffsetRequired(verifier, VT_GOAL) &&
           verifier.VerifyTable(goal()) &&
           VerifyField<float>(verifier, VT_TOLERANCE, 4) &&
           verifier.EndTable();
  }
  GetPlanRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetPlanRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GetPlanRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetPlanRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetPlanRequestBuilder {
  typedef GetPlanRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GetPlanRequest::VT___METADATA, __metadata);
  }
  void add_start(::flatbuffers::Offset<fb::geometry_msgs::PoseStamped> start) {
    fbb_.AddOffset(GetPlanRequest::VT_START, start);
  }
  void add_goal(::flatbuffers::Offset<fb::geometry_msgs::PoseStamped> goal) {
    fbb_.AddOffset(GetPlanRequest::VT_GOAL, goal);
  }
  void add_tolerance(float tolerance) {
    fbb_.AddElement<float>(GetPlanRequest::VT_TOLERANCE, tolerance, 0.0f);
  }
  explicit GetPlanRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetPlanRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetPlanRequest>(end);
    fbb_.Required(o, GetPlanRequest::VT_START);
    fbb_.Required(o, GetPlanRequest::VT_GOAL);
    return o;
  }
};

inline ::flatbuffers::Offset<GetPlanRequest> CreateGetPlanRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::PoseStamped> start = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::PoseStamped> goal = 0,
    float tolerance = 0.0f) {
  GetPlanRequestBuilder builder_(_fbb);
  builder_.add_tolerance(tolerance);
  builder_.add_goal(goal);
  builder_.add_start(start);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<GetPlanRequest> CreateGetPlanRequest(::flatbuffers::FlatBufferBuilder &_fbb, const GetPlanRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetPlanResponseT : public ::flatbuffers::NativeTable {
  typedef GetPlanResponse TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::nav_msgs::PathT> plan{};
  GetPlanResponseT() = default;
  GetPlanResponseT(const GetPlanResponseT &o);
  GetPlanResponseT(GetPlanResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  GetPlanResponseT &operator=(GetPlanResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct GetPlanResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetPlanResponseT NativeTableType;
  typedef GetPlanResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_PLAN = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::nav_msgs::Path *plan() const {
    return GetPointer<const fb::nav_msgs::Path *>(VT_PLAN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_PLAN) &&
           verifier.VerifyTable(plan()) &&
           verifier.EndTable();
  }
  GetPlanResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetPlanResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GetPlanResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetPlanResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetPlanResponseBuilder {
  typedef GetPlanResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GetPlanResponse::VT___METADATA, __metadata);
  }
  void add_plan(::flatbuffers::Offset<fb::nav_msgs::Path> plan) {
    fbb_.AddOffset(GetPlanResponse::VT_PLAN, plan);
  }
  explicit GetPlanResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetPlanResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetPlanResponse>(end);
    fbb_.Required(o, GetPlanResponse::VT_PLAN);
    return o;
  }
};

inline ::flatbuffers::Offset<GetPlanResponse> CreateGetPlanResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::nav_msgs::Path> plan = 0) {
  GetPlanResponseBuilder builder_(_fbb);
  builder_.add_plan(plan);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<GetPlanResponse> CreateGetPlanResponse(::flatbuffers::FlatBufferBuilder &_fbb, const GetPlanResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OccupancyGridT : public ::flatbuffers::NativeTable {
  typedef OccupancyGrid TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::nav_msgs::MapMetaDataT> info{};
  std::vector<int8_t> data{};
  OccupancyGridT() = default;
  OccupancyGridT(const OccupancyGridT &o);
  OccupancyGridT(OccupancyGridT&&) FLATBUFFERS_NOEXCEPT = default;
  OccupancyGridT &operator=(OccupancyGridT o) FLATBUFFERS_NOEXCEPT;
};

struct OccupancyGrid FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OccupancyGridT NativeTableType;
  typedef OccupancyGridBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_INFO = 8,
    VT_DATA = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::nav_msgs::MapMetaData *info() const {
    return GetPointer<const fb::nav_msgs::MapMetaData *>(VT_INFO);
  }
  const ::flatbuffers::Vector<int8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  OccupancyGridT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OccupancyGridT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<OccupancyGrid> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OccupancyGridT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OccupancyGridBuilder {
  typedef OccupancyGrid Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(OccupancyGrid::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(OccupancyGrid::VT_HEADER, header);
  }
  void add_info(::flatbuffers::Offset<fb::nav_msgs::MapMetaData> info) {
    fbb_.AddOffset(OccupancyGrid::VT_INFO, info);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> data) {
    fbb_.AddOffset(OccupancyGrid::VT_DATA, data);
  }
  explicit OccupancyGridBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OccupancyGrid> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OccupancyGrid>(end);
    fbb_.Required(o, OccupancyGrid::VT_HEADER);
    fbb_.Required(o, OccupancyGrid::VT_INFO);
    fbb_.Required(o, OccupancyGrid::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<OccupancyGrid> CreateOccupancyGrid(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::nav_msgs::MapMetaData> info = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> data = 0) {
  OccupancyGridBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_info(info);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OccupancyGrid> CreateOccupancyGridDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::nav_msgs::MapMetaData> info = 0,
    const std::vector<int8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<int8_t>(*data) : 0;
  return fb::nav_msgs::CreateOccupancyGrid(
      _fbb,
      __metadata,
      header,
      info,
      data__);
}

::flatbuffers::Offset<OccupancyGrid> CreateOccupancyGrid(::flatbuffers::FlatBufferBuilder &_fbb, const OccupancyGridT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MapMetaDataT : public ::flatbuffers::NativeTable {
  typedef MapMetaData TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::RosTime> map_load_time{};
  float resolution = 0.0f;
  uint32_t width = 0;
  uint32_t height = 0;
  std::unique_ptr<fb::geometry_msgs::PoseT> origin{};
  MapMetaDataT() = default;
  MapMetaDataT(const MapMetaDataT &o);
  MapMetaDataT(MapMetaDataT&&) FLATBUFFERS_NOEXCEPT = default;
  MapMetaDataT &operator=(MapMetaDataT o) FLATBUFFERS_NOEXCEPT;
};

struct MapMetaData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MapMetaDataT NativeTableType;
  typedef MapMetaDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_MAP_LOAD_TIME = 6,
    VT_RESOLUTION = 8,
    VT_WIDTH = 10,
    VT_HEIGHT = 12,
    VT_ORIGIN = 14
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::RosTime *map_load_time() const {
    return GetStruct<const fb::RosTime *>(VT_MAP_LOAD_TIME);
  }
  float resolution() const {
    return GetField<float>(VT_RESOLUTION, 0.0f);
  }
  uint32_t width() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  const fb::geometry_msgs::Pose *origin() const {
    return GetPointer<const fb::geometry_msgs::Pose *>(VT_ORIGIN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyFieldRequired<fb::RosTime>(verifier, VT_MAP_LOAD_TIME, 4) &&
           VerifyField<float>(verifier, VT_RESOLUTION, 4) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH, 4) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT, 4) &&
           VerifyOffsetRequired(verifier, VT_ORIGIN) &&
           verifier.VerifyTable(origin()) &&
           verifier.EndTable();
  }
  MapMetaDataT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MapMetaDataT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<MapMetaData> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MapMetaDataT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MapMetaDataBuilder {
  typedef MapMetaData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(MapMetaData::VT___METADATA, __metadata);
  }
  void add_map_load_time(const fb::RosTime *map_load_time) {
    fbb_.AddStruct(MapMetaData::VT_MAP_LOAD_TIME, map_load_time);
  }
  void add_resolution(float resolution) {
    fbb_.AddElement<float>(MapMetaData::VT_RESOLUTION, resolution, 0.0f);
  }
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(MapMetaData::VT_WIDTH, width, 0);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(MapMetaData::VT_HEIGHT, height, 0);
  }
  void add_origin(::flatbuffers::Offset<fb::geometry_msgs::Pose> origin) {
    fbb_.AddOffset(MapMetaData::VT_ORIGIN, origin);
  }
  explicit MapMetaDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MapMetaData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MapMetaData>(end);
    fbb_.Required(o, MapMetaData::VT_MAP_LOAD_TIME);
    fbb_.Required(o, MapMetaData::VT_ORIGIN);
    return o;
  }
};

inline ::flatbuffers::Offset<MapMetaData> CreateMapMetaData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const fb::RosTime *map_load_time = nullptr,
    float resolution = 0.0f,
    uint32_t width = 0,
    uint32_t height = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Pose> origin = 0) {
  MapMetaDataBuilder builder_(_fbb);
  builder_.add_origin(origin);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_resolution(resolution);
  builder_.add_map_load_time(map_load_time);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<MapMetaData> CreateMapMetaData(::flatbuffers::FlatBufferBuilder &_fbb, const MapMetaDataT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LoadMapRequestT : public ::flatbuffers::NativeTable {
  typedef LoadMapRequest TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string map_url{};
  LoadMapRequestT() = default;
  LoadMapRequestT(const LoadMapRequestT &o);
  LoadMapRequestT(LoadMapRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  LoadMapRequestT &operator=(LoadMapRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct LoadMapRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LoadMapRequestT NativeTableType;
  typedef LoadMapRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_MAP_URL = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *map_url() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MAP_URL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_MAP_URL) &&
           verifier.VerifyString(map_url()) &&
           verifier.EndTable();
  }
  LoadMapRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LoadMapRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<LoadMapRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LoadMapRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LoadMapRequestBuilder {
  typedef LoadMapRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(LoadMapRequest::VT___METADATA, __metadata);
  }
  void add_map_url(::flatbuffers::Offset<::flatbuffers::String> map_url) {
    fbb_.AddOffset(LoadMapRequest::VT_MAP_URL, map_url);
  }
  explicit LoadMapRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LoadMapRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LoadMapRequest>(end);
    fbb_.Required(o, LoadMapRequest::VT_MAP_URL);
    return o;
  }
};

inline ::flatbuffers::Offset<LoadMapRequest> CreateLoadMapRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> map_url = 0) {
  LoadMapRequestBuilder builder_(_fbb);
  builder_.add_map_url(map_url);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LoadMapRequest> CreateLoadMapRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *map_url = nullptr) {
  auto map_url__ = map_url ? _fbb.CreateString(map_url) : 0;
  return fb::nav_msgs::CreateLoadMapRequest(
      _fbb,
      __metadata,
      map_url__);
}

::flatbuffers::Offset<LoadMapRequest> CreateLoadMapRequest(::flatbuffers::FlatBufferBuilder &_fbb, const LoadMapRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LoadMapResponseT : public ::flatbuffers::NativeTable {
  typedef LoadMapResponse TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::nav_msgs::OccupancyGridT> map{};
  uint8_t result = 0;
  LoadMapResponseT() = default;
  LoadMapResponseT(const LoadMapResponseT &o);
  LoadMapResponseT(LoadMapResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  LoadMapResponseT &operator=(LoadMapResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct LoadMapResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LoadMapResponseT NativeTableType;
  typedef LoadMapResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_MAP = 6,
    VT_RESULT = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::nav_msgs::OccupancyGrid *map() const {
    return GetPointer<const fb::nav_msgs::OccupancyGrid *>(VT_MAP);
  }
  uint8_t result() const {
    return GetField<uint8_t>(VT_RESULT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_MAP) &&
           verifier.VerifyTable(map()) &&
           VerifyField<uint8_t>(verifier, VT_RESULT, 1) &&
           verifier.EndTable();
  }
  LoadMapResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LoadMapResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<LoadMapResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LoadMapResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LoadMapResponseBuilder {
  typedef LoadMapResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(LoadMapResponse::VT___METADATA, __metadata);
  }
  void add_map(::flatbuffers::Offset<fb::nav_msgs::OccupancyGrid> map) {
    fbb_.AddOffset(LoadMapResponse::VT_MAP, map);
  }
  void add_result(uint8_t result) {
    fbb_.AddElement<uint8_t>(LoadMapResponse::VT_RESULT, result, 0);
  }
  explicit LoadMapResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LoadMapResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LoadMapResponse>(end);
    fbb_.Required(o, LoadMapResponse::VT_MAP);
    return o;
  }
};

inline ::flatbuffers::Offset<LoadMapResponse> CreateLoadMapResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::nav_msgs::OccupancyGrid> map = 0,
    uint8_t result = 0) {
  LoadMapResponseBuilder builder_(_fbb);
  builder_.add_map(map);
  builder_.add___metadata(__metadata);
  builder_.add_result(result);
  return builder_.Finish();
}

::flatbuffers::Offset<LoadMapResponse> CreateLoadMapResponse(::flatbuffers::FlatBufferBuilder &_fbb, const LoadMapResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetMapGoalT : public ::flatbuffers::NativeTable {
  typedef GetMapGoal TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  GetMapGoalT() = default;
  GetMapGoalT(const GetMapGoalT &o);
  GetMapGoalT(GetMapGoalT&&) FLATBUFFERS_NOEXCEPT = default;
  GetMapGoalT &operator=(GetMapGoalT o) FLATBUFFERS_NOEXCEPT;
};

struct GetMapGoal FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetMapGoalT NativeTableType;
  typedef GetMapGoalBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           verifier.EndTable();
  }
  GetMapGoalT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetMapGoalT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GetMapGoal> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapGoalT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetMapGoalBuilder {
  typedef GetMapGoal Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GetMapGoal::VT___METADATA, __metadata);
  }
  explicit GetMapGoalBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetMapGoal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetMapGoal>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetMapGoal> CreateGetMapGoal(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0) {
  GetMapGoalBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<GetMapGoal> CreateGetMapGoal(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapGoalT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline PathT::PathT(const PathT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr) {
  poses.reserve(o.poses.size());
  for (const auto &poses_ : o.poses) { poses.emplace_back((poses_) ? new fb::geometry_msgs::PoseStampedT(*poses_) : nullptr); }
}

inline PathT &PathT::operator=(PathT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(poses, o.poses);
  return *this;
}

inline PathT *Path::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PathT>(new PathT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Path::UnPackTo(PathT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = poses(); if (_e) { _o->poses.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->poses[_i]) { _e->Get(_i)->UnPackTo(_o->poses[_i].get(), _resolver); } else { _o->poses[_i] = std::unique_ptr<fb::geometry_msgs::PoseStampedT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->poses.resize(0); } }
}

inline ::flatbuffers::Offset<Path> Path::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PathT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePath(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Path> CreatePath(::flatbuffers::FlatBufferBuilder &_fbb, const PathT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PathT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _poses = _fbb.CreateVector<::flatbuffers::Offset<fb::geometry_msgs::PoseStamped>> (_o->poses.size(), [](size_t i, _VectorArgs *__va) { return CreatePoseStamped(*__va->__fbb, __va->__o->poses[i].get(), __va->__rehasher); }, &_va );
  return fb::nav_msgs::CreatePath(
      _fbb,
      ___metadata,
      _header,
      _poses);
}

inline GetMapResultT::GetMapResultT(const GetMapResultT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        map((o.map) ? new fb::nav_msgs::OccupancyGridT(*o.map) : nullptr) {
}

inline GetMapResultT &GetMapResultT::operator=(GetMapResultT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(map, o.map);
  return *this;
}

inline GetMapResultT *GetMapResult::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetMapResultT>(new GetMapResultT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetMapResult::UnPackTo(GetMapResultT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = map(); if (_e) { if(_o->map) { _e->UnPackTo(_o->map.get(), _resolver); } else { _o->map = std::unique_ptr<fb::nav_msgs::OccupancyGridT>(_e->UnPack(_resolver)); } } else if (_o->map) { _o->map.reset(); } }
}

inline ::flatbuffers::Offset<GetMapResult> GetMapResult::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapResultT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetMapResult(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GetMapResult> CreateGetMapResult(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapResultT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GetMapResultT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _map = _o->map ? CreateOccupancyGrid(_fbb, _o->map.get(), _rehasher) : 0;
  return fb::nav_msgs::CreateGetMapResult(
      _fbb,
      ___metadata,
      _map);
}

inline OdometryT::OdometryT(const OdometryT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        child_frame_id(o.child_frame_id),
        pose((o.pose) ? new fb::geometry_msgs::PoseWithCovarianceT(*o.pose) : nullptr),
        twist((o.twist) ? new fb::geometry_msgs::TwistWithCovarianceT(*o.twist) : nullptr) {
}

inline OdometryT &OdometryT::operator=(OdometryT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(child_frame_id, o.child_frame_id);
  std::swap(pose, o.pose);
  std::swap(twist, o.twist);
  return *this;
}

inline OdometryT *Odometry::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<OdometryT>(new OdometryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Odometry::UnPackTo(OdometryT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = child_frame_id(); if (_e) _o->child_frame_id = _e->str(); }
  { auto _e = pose(); if (_e) { if(_o->pose) { _e->UnPackTo(_o->pose.get(), _resolver); } else { _o->pose = std::unique_ptr<fb::geometry_msgs::PoseWithCovarianceT>(_e->UnPack(_resolver)); } } else if (_o->pose) { _o->pose.reset(); } }
  { auto _e = twist(); if (_e) { if(_o->twist) { _e->UnPackTo(_o->twist.get(), _resolver); } else { _o->twist = std::unique_ptr<fb::geometry_msgs::TwistWithCovarianceT>(_e->UnPack(_resolver)); } } else if (_o->twist) { _o->twist.reset(); } }
}

inline ::flatbuffers::Offset<Odometry> Odometry::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OdometryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOdometry(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Odometry> CreateOdometry(::flatbuffers::FlatBufferBuilder &_fbb, const OdometryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const OdometryT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _child_frame_id = _fbb.CreateString(_o->child_frame_id);
  auto _pose = _o->pose ? CreatePoseWithCovariance(_fbb, _o->pose.get(), _rehasher) : 0;
  auto _twist = _o->twist ? CreateTwistWithCovariance(_fbb, _o->twist.get(), _rehasher) : 0;
  return fb::nav_msgs::CreateOdometry(
      _fbb,
      ___metadata,
      _header,
      _child_frame_id,
      _pose,
      _twist);
}

inline GetMapActionResultT::GetMapActionResultT(const GetMapActionResultT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        status((o.status) ? new fb::actionlib_msgs::GoalStatusT(*o.status) : nullptr),
        result((o.result) ? new fb::nav_msgs::GetMapResultT(*o.result) : nullptr) {
}

inline GetMapActionResultT &GetMapActionResultT::operator=(GetMapActionResultT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(status, o.status);
  std::swap(result, o.result);
  return *this;
}

inline GetMapActionResultT *GetMapActionResult::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetMapActionResultT>(new GetMapActionResultT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetMapActionResult::UnPackTo(GetMapActionResultT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = status(); if (_e) { if(_o->status) { _e->UnPackTo(_o->status.get(), _resolver); } else { _o->status = std::unique_ptr<fb::actionlib_msgs::GoalStatusT>(_e->UnPack(_resolver)); } } else if (_o->status) { _o->status.reset(); } }
  { auto _e = result(); if (_e) { if(_o->result) { _e->UnPackTo(_o->result.get(), _resolver); } else { _o->result = std::unique_ptr<fb::nav_msgs::GetMapResultT>(_e->UnPack(_resolver)); } } else if (_o->result) { _o->result.reset(); } }
}

inline ::flatbuffers::Offset<GetMapActionResult> GetMapActionResult::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapActionResultT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetMapActionResult(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GetMapActionResult> CreateGetMapActionResult(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapActionResultT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GetMapActionResultT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _status = _o->status ? CreateGoalStatus(_fbb, _o->status.get(), _rehasher) : 0;
  auto _result = _o->result ? CreateGetMapResult(_fbb, _o->result.get(), _rehasher) : 0;
  return fb::nav_msgs::CreateGetMapActionResult(
      _fbb,
      ___metadata,
      _header,
      _status,
      _result);
}

inline GetMapActionT::GetMapActionT(const GetMapActionT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        action_goal((o.action_goal) ? new fb::nav_msgs::GetMapActionGoalT(*o.action_goal) : nullptr),
        action_result((o.action_result) ? new fb::nav_msgs::GetMapActionResultT(*o.action_result) : nullptr),
        action_feedback((o.action_feedback) ? new fb::nav_msgs::GetMapActionFeedbackT(*o.action_feedback) : nullptr) {
}

inline GetMapActionT &GetMapActionT::operator=(GetMapActionT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(action_goal, o.action_goal);
  std::swap(action_result, o.action_result);
  std::swap(action_feedback, o.action_feedback);
  return *this;
}

inline GetMapActionT *GetMapAction::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetMapActionT>(new GetMapActionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetMapAction::UnPackTo(GetMapActionT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = action_goal(); if (_e) { if(_o->action_goal) { _e->UnPackTo(_o->action_goal.get(), _resolver); } else { _o->action_goal = std::unique_ptr<fb::nav_msgs::GetMapActionGoalT>(_e->UnPack(_resolver)); } } else if (_o->action_goal) { _o->action_goal.reset(); } }
  { auto _e = action_result(); if (_e) { if(_o->action_result) { _e->UnPackTo(_o->action_result.get(), _resolver); } else { _o->action_result = std::unique_ptr<fb::nav_msgs::GetMapActionResultT>(_e->UnPack(_resolver)); } } else if (_o->action_result) { _o->action_result.reset(); } }
  { auto _e = action_feedback(); if (_e) { if(_o->action_feedback) { _e->UnPackTo(_o->action_feedback.get(), _resolver); } else { _o->action_feedback = std::unique_ptr<fb::nav_msgs::GetMapActionFeedbackT>(_e->UnPack(_resolver)); } } else if (_o->action_feedback) { _o->action_feedback.reset(); } }
}

inline ::flatbuffers::Offset<GetMapAction> GetMapAction::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapActionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetMapAction(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GetMapAction> CreateGetMapAction(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapActionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GetMapActionT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _action_goal = _o->action_goal ? CreateGetMapActionGoal(_fbb, _o->action_goal.get(), _rehasher) : 0;
  auto _action_result = _o->action_result ? CreateGetMapActionResult(_fbb, _o->action_result.get(), _rehasher) : 0;
  auto _action_feedback = _o->action_feedback ? CreateGetMapActionFeedback(_fbb, _o->action_feedback.get(), _rehasher) : 0;
  return fb::nav_msgs::CreateGetMapAction(
      _fbb,
      ___metadata,
      _action_goal,
      _action_result,
      _action_feedback);
}

inline GridCellsT::GridCellsT(const GridCellsT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        cell_width(o.cell_width),
        cell_height(o.cell_height) {
  cells.reserve(o.cells.size());
  for (const auto &cells_ : o.cells) { cells.emplace_back((cells_) ? new fb::geometry_msgs::PointT(*cells_) : nullptr); }
}

inline GridCellsT &GridCellsT::operator=(GridCellsT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(cell_width, o.cell_width);
  std::swap(cell_height, o.cell_height);
  std::swap(cells, o.cells);
  return *this;
}

inline GridCellsT *GridCells::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GridCellsT>(new GridCellsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GridCells::UnPackTo(GridCellsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = cell_width(); _o->cell_width = _e; }
  { auto _e = cell_height(); _o->cell_height = _e; }
  { auto _e = cells(); if (_e) { _o->cells.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->cells[_i]) { _e->Get(_i)->UnPackTo(_o->cells[_i].get(), _resolver); } else { _o->cells[_i] = std::unique_ptr<fb::geometry_msgs::PointT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->cells.resize(0); } }
}

inline ::flatbuffers::Offset<GridCells> GridCells::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GridCellsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGridCells(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GridCells> CreateGridCells(::flatbuffers::FlatBufferBuilder &_fbb, const GridCellsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GridCellsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _cell_width = _o->cell_width;
  auto _cell_height = _o->cell_height;
  auto _cells = _fbb.CreateVector<::flatbuffers::Offset<fb::geometry_msgs::Point>> (_o->cells.size(), [](size_t i, _VectorArgs *__va) { return CreatePoint(*__va->__fbb, __va->__o->cells[i].get(), __va->__rehasher); }, &_va );
  return fb::nav_msgs::CreateGridCells(
      _fbb,
      ___metadata,
      _header,
      _cell_width,
      _cell_height,
      _cells);
}

inline GetMapActionGoalT::GetMapActionGoalT(const GetMapActionGoalT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        goal_id((o.goal_id) ? new fb::actionlib_msgs::GoalIDT(*o.goal_id) : nullptr),
        goal((o.goal) ? new fb::nav_msgs::GetMapGoalT(*o.goal) : nullptr) {
}

inline GetMapActionGoalT &GetMapActionGoalT::operator=(GetMapActionGoalT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(goal_id, o.goal_id);
  std::swap(goal, o.goal);
  return *this;
}

inline GetMapActionGoalT *GetMapActionGoal::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetMapActionGoalT>(new GetMapActionGoalT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetMapActionGoal::UnPackTo(GetMapActionGoalT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = goal_id(); if (_e) { if(_o->goal_id) { _e->UnPackTo(_o->goal_id.get(), _resolver); } else { _o->goal_id = std::unique_ptr<fb::actionlib_msgs::GoalIDT>(_e->UnPack(_resolver)); } } else if (_o->goal_id) { _o->goal_id.reset(); } }
  { auto _e = goal(); if (_e) { if(_o->goal) { _e->UnPackTo(_o->goal.get(), _resolver); } else { _o->goal = std::unique_ptr<fb::nav_msgs::GetMapGoalT>(_e->UnPack(_resolver)); } } else if (_o->goal) { _o->goal.reset(); } }
}

inline ::flatbuffers::Offset<GetMapActionGoal> GetMapActionGoal::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapActionGoalT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetMapActionGoal(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GetMapActionGoal> CreateGetMapActionGoal(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapActionGoalT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GetMapActionGoalT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _goal_id = _o->goal_id ? CreateGoalID(_fbb, _o->goal_id.get(), _rehasher) : 0;
  auto _goal = _o->goal ? CreateGetMapGoal(_fbb, _o->goal.get(), _rehasher) : 0;
  return fb::nav_msgs::CreateGetMapActionGoal(
      _fbb,
      ___metadata,
      _header,
      _goal_id,
      _goal);
}

inline SetMapRequestT::SetMapRequestT(const SetMapRequestT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        map((o.map) ? new fb::nav_msgs::OccupancyGridT(*o.map) : nullptr),
        initial_pose((o.initial_pose) ? new fb::geometry_msgs::PoseWithCovarianceStampedT(*o.initial_pose) : nullptr) {
}

inline SetMapRequestT &SetMapRequestT::operator=(SetMapRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(map, o.map);
  std::swap(initial_pose, o.initial_pose);
  return *this;
}

inline SetMapRequestT *SetMapRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SetMapRequestT>(new SetMapRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SetMapRequest::UnPackTo(SetMapRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = map(); if (_e) { if(_o->map) { _e->UnPackTo(_o->map.get(), _resolver); } else { _o->map = std::unique_ptr<fb::nav_msgs::OccupancyGridT>(_e->UnPack(_resolver)); } } else if (_o->map) { _o->map.reset(); } }
  { auto _e = initial_pose(); if (_e) { if(_o->initial_pose) { _e->UnPackTo(_o->initial_pose.get(), _resolver); } else { _o->initial_pose = std::unique_ptr<fb::geometry_msgs::PoseWithCovarianceStampedT>(_e->UnPack(_resolver)); } } else if (_o->initial_pose) { _o->initial_pose.reset(); } }
}

inline ::flatbuffers::Offset<SetMapRequest> SetMapRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetMapRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSetMapRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SetMapRequest> CreateSetMapRequest(::flatbuffers::FlatBufferBuilder &_fbb, const SetMapRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SetMapRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _map = _o->map ? CreateOccupancyGrid(_fbb, _o->map.get(), _rehasher) : 0;
  auto _initial_pose = _o->initial_pose ? CreatePoseWithCovarianceStamped(_fbb, _o->initial_pose.get(), _rehasher) : 0;
  return fb::nav_msgs::CreateSetMapRequest(
      _fbb,
      ___metadata,
      _map,
      _initial_pose);
}

inline SetMapResponseT::SetMapResponseT(const SetMapResponseT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        success(o.success) {
}

inline SetMapResponseT &SetMapResponseT::operator=(SetMapResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(success, o.success);
  return *this;
}

inline SetMapResponseT *SetMapResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SetMapResponseT>(new SetMapResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SetMapResponse::UnPackTo(SetMapResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = success(); _o->success = _e; }
}

inline ::flatbuffers::Offset<SetMapResponse> SetMapResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetMapResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSetMapResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SetMapResponse> CreateSetMapResponse(::flatbuffers::FlatBufferBuilder &_fbb, const SetMapResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SetMapResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _success = _o->success;
  return fb::nav_msgs::CreateSetMapResponse(
      _fbb,
      ___metadata,
      _success);
}

inline GetMapActionFeedbackT::GetMapActionFeedbackT(const GetMapActionFeedbackT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        status((o.status) ? new fb::actionlib_msgs::GoalStatusT(*o.status) : nullptr),
        feedback((o.feedback) ? new fb::nav_msgs::GetMapFeedbackT(*o.feedback) : nullptr) {
}

inline GetMapActionFeedbackT &GetMapActionFeedbackT::operator=(GetMapActionFeedbackT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(status, o.status);
  std::swap(feedback, o.feedback);
  return *this;
}

inline GetMapActionFeedbackT *GetMapActionFeedback::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetMapActionFeedbackT>(new GetMapActionFeedbackT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetMapActionFeedback::UnPackTo(GetMapActionFeedbackT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = status(); if (_e) { if(_o->status) { _e->UnPackTo(_o->status.get(), _resolver); } else { _o->status = std::unique_ptr<fb::actionlib_msgs::GoalStatusT>(_e->UnPack(_resolver)); } } else if (_o->status) { _o->status.reset(); } }
  { auto _e = feedback(); if (_e) { if(_o->feedback) { _e->UnPackTo(_o->feedback.get(), _resolver); } else { _o->feedback = std::unique_ptr<fb::nav_msgs::GetMapFeedbackT>(_e->UnPack(_resolver)); } } else if (_o->feedback) { _o->feedback.reset(); } }
}

inline ::flatbuffers::Offset<GetMapActionFeedback> GetMapActionFeedback::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapActionFeedbackT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetMapActionFeedback(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GetMapActionFeedback> CreateGetMapActionFeedback(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapActionFeedbackT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GetMapActionFeedbackT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _status = _o->status ? CreateGoalStatus(_fbb, _o->status.get(), _rehasher) : 0;
  auto _feedback = _o->feedback ? CreateGetMapFeedback(_fbb, _o->feedback.get(), _rehasher) : 0;
  return fb::nav_msgs::CreateGetMapActionFeedback(
      _fbb,
      ___metadata,
      _header,
      _status,
      _feedback);
}

inline GetMapRequestT::GetMapRequestT(const GetMapRequestT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr) {
}

inline GetMapRequestT &GetMapRequestT::operator=(GetMapRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  return *this;
}

inline GetMapRequestT *GetMapRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetMapRequestT>(new GetMapRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetMapRequest::UnPackTo(GetMapRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
}

inline ::flatbuffers::Offset<GetMapRequest> GetMapRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetMapRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GetMapRequest> CreateGetMapRequest(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GetMapRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  return fb::nav_msgs::CreateGetMapRequest(
      _fbb,
      ___metadata);
}

inline GetMapResponseT::GetMapResponseT(const GetMapResponseT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        map((o.map) ? new fb::nav_msgs::OccupancyGridT(*o.map) : nullptr) {
}

inline GetMapResponseT &GetMapResponseT::operator=(GetMapResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(map, o.map);
  return *this;
}

inline GetMapResponseT *GetMapResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetMapResponseT>(new GetMapResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetMapResponse::UnPackTo(GetMapResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = map(); if (_e) { if(_o->map) { _e->UnPackTo(_o->map.get(), _resolver); } else { _o->map = std::unique_ptr<fb::nav_msgs::OccupancyGridT>(_e->UnPack(_resolver)); } } else if (_o->map) { _o->map.reset(); } }
}

inline ::flatbuffers::Offset<GetMapResponse> GetMapResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetMapResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GetMapResponse> CreateGetMapResponse(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GetMapResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _map = _o->map ? CreateOccupancyGrid(_fbb, _o->map.get(), _rehasher) : 0;
  return fb::nav_msgs::CreateGetMapResponse(
      _fbb,
      ___metadata,
      _map);
}

inline GetMapFeedbackT::GetMapFeedbackT(const GetMapFeedbackT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr) {
}

inline GetMapFeedbackT &GetMapFeedbackT::operator=(GetMapFeedbackT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  return *this;
}

inline GetMapFeedbackT *GetMapFeedback::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetMapFeedbackT>(new GetMapFeedbackT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetMapFeedback::UnPackTo(GetMapFeedbackT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
}

inline ::flatbuffers::Offset<GetMapFeedback> GetMapFeedback::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapFeedbackT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetMapFeedback(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GetMapFeedback> CreateGetMapFeedback(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapFeedbackT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GetMapFeedbackT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  return fb::nav_msgs::CreateGetMapFeedback(
      _fbb,
      ___metadata);
}

inline GetPlanRequestT::GetPlanRequestT(const GetPlanRequestT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        start((o.start) ? new fb::geometry_msgs::PoseStampedT(*o.start) : nullptr),
        goal((o.goal) ? new fb::geometry_msgs::PoseStampedT(*o.goal) : nullptr),
        tolerance(o.tolerance) {
}

inline GetPlanRequestT &GetPlanRequestT::operator=(GetPlanRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(start, o.start);
  std::swap(goal, o.goal);
  std::swap(tolerance, o.tolerance);
  return *this;
}

inline GetPlanRequestT *GetPlanRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetPlanRequestT>(new GetPlanRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetPlanRequest::UnPackTo(GetPlanRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = start(); if (_e) { if(_o->start) { _e->UnPackTo(_o->start.get(), _resolver); } else { _o->start = std::unique_ptr<fb::geometry_msgs::PoseStampedT>(_e->UnPack(_resolver)); } } else if (_o->start) { _o->start.reset(); } }
  { auto _e = goal(); if (_e) { if(_o->goal) { _e->UnPackTo(_o->goal.get(), _resolver); } else { _o->goal = std::unique_ptr<fb::geometry_msgs::PoseStampedT>(_e->UnPack(_resolver)); } } else if (_o->goal) { _o->goal.reset(); } }
  { auto _e = tolerance(); _o->tolerance = _e; }
}

inline ::flatbuffers::Offset<GetPlanRequest> GetPlanRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetPlanRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetPlanRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GetPlanRequest> CreateGetPlanRequest(::flatbuffers::FlatBufferBuilder &_fbb, const GetPlanRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GetPlanRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _start = _o->start ? CreatePoseStamped(_fbb, _o->start.get(), _rehasher) : 0;
  auto _goal = _o->goal ? CreatePoseStamped(_fbb, _o->goal.get(), _rehasher) : 0;
  auto _tolerance = _o->tolerance;
  return fb::nav_msgs::CreateGetPlanRequest(
      _fbb,
      ___metadata,
      _start,
      _goal,
      _tolerance);
}

inline GetPlanResponseT::GetPlanResponseT(const GetPlanResponseT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        plan((o.plan) ? new fb::nav_msgs::PathT(*o.plan) : nullptr) {
}

inline GetPlanResponseT &GetPlanResponseT::operator=(GetPlanResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(plan, o.plan);
  return *this;
}

inline GetPlanResponseT *GetPlanResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetPlanResponseT>(new GetPlanResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetPlanResponse::UnPackTo(GetPlanResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = plan(); if (_e) { if(_o->plan) { _e->UnPackTo(_o->plan.get(), _resolver); } else { _o->plan = std::unique_ptr<fb::nav_msgs::PathT>(_e->UnPack(_resolver)); } } else if (_o->plan) { _o->plan.reset(); } }
}

inline ::flatbuffers::Offset<GetPlanResponse> GetPlanResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetPlanResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetPlanResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GetPlanResponse> CreateGetPlanResponse(::flatbuffers::FlatBufferBuilder &_fbb, const GetPlanResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GetPlanResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _plan = _o->plan ? CreatePath(_fbb, _o->plan.get(), _rehasher) : 0;
  return fb::nav_msgs::CreateGetPlanResponse(
      _fbb,
      ___metadata,
      _plan);
}

inline OccupancyGridT::OccupancyGridT(const OccupancyGridT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        info((o.info) ? new fb::nav_msgs::MapMetaDataT(*o.info) : nullptr),
        data(o.data) {
}

inline OccupancyGridT &OccupancyGridT::operator=(OccupancyGridT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(info, o.info);
  std::swap(data, o.data);
  return *this;
}

inline OccupancyGridT *OccupancyGrid::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<OccupancyGridT>(new OccupancyGridT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OccupancyGrid::UnPackTo(OccupancyGridT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = info(); if (_e) { if(_o->info) { _e->UnPackTo(_o->info.get(), _resolver); } else { _o->info = std::unique_ptr<fb::nav_msgs::MapMetaDataT>(_e->UnPack(_resolver)); } } else if (_o->info) { _o->info.reset(); } }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
}

inline ::flatbuffers::Offset<OccupancyGrid> OccupancyGrid::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OccupancyGridT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOccupancyGrid(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<OccupancyGrid> CreateOccupancyGrid(::flatbuffers::FlatBufferBuilder &_fbb, const OccupancyGridT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const OccupancyGridT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _info = _o->info ? CreateMapMetaData(_fbb, _o->info.get(), _rehasher) : 0;
  auto _data = _fbb.CreateVector(_o->data);
  return fb::nav_msgs::CreateOccupancyGrid(
      _fbb,
      ___metadata,
      _header,
      _info,
      _data);
}

inline MapMetaDataT::MapMetaDataT(const MapMetaDataT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        map_load_time((o.map_load_time) ? new fb::RosTime(*o.map_load_time) : nullptr),
        resolution(o.resolution),
        width(o.width),
        height(o.height),
        origin((o.origin) ? new fb::geometry_msgs::PoseT(*o.origin) : nullptr) {
}

inline MapMetaDataT &MapMetaDataT::operator=(MapMetaDataT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(map_load_time, o.map_load_time);
  std::swap(resolution, o.resolution);
  std::swap(width, o.width);
  std::swap(height, o.height);
  std::swap(origin, o.origin);
  return *this;
}

inline MapMetaDataT *MapMetaData::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MapMetaDataT>(new MapMetaDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MapMetaData::UnPackTo(MapMetaDataT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = map_load_time(); if (_e) _o->map_load_time = std::unique_ptr<fb::RosTime>(new fb::RosTime(*_e)); }
  { auto _e = resolution(); _o->resolution = _e; }
  { auto _e = width(); _o->width = _e; }
  { auto _e = height(); _o->height = _e; }
  { auto _e = origin(); if (_e) { if(_o->origin) { _e->UnPackTo(_o->origin.get(), _resolver); } else { _o->origin = std::unique_ptr<fb::geometry_msgs::PoseT>(_e->UnPack(_resolver)); } } else if (_o->origin) { _o->origin.reset(); } }
}

inline ::flatbuffers::Offset<MapMetaData> MapMetaData::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MapMetaDataT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMapMetaData(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<MapMetaData> CreateMapMetaData(::flatbuffers::FlatBufferBuilder &_fbb, const MapMetaDataT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MapMetaDataT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _map_load_time = _o->map_load_time ? _o->map_load_time.get() : nullptr;
  auto _resolution = _o->resolution;
  auto _width = _o->width;
  auto _height = _o->height;
  auto _origin = _o->origin ? CreatePose(_fbb, _o->origin.get(), _rehasher) : 0;
  return fb::nav_msgs::CreateMapMetaData(
      _fbb,
      ___metadata,
      _map_load_time,
      _resolution,
      _width,
      _height,
      _origin);
}

inline LoadMapRequestT::LoadMapRequestT(const LoadMapRequestT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        map_url(o.map_url) {
}

inline LoadMapRequestT &LoadMapRequestT::operator=(LoadMapRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(map_url, o.map_url);
  return *this;
}

inline LoadMapRequestT *LoadMapRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LoadMapRequestT>(new LoadMapRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LoadMapRequest::UnPackTo(LoadMapRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = map_url(); if (_e) _o->map_url = _e->str(); }
}

inline ::flatbuffers::Offset<LoadMapRequest> LoadMapRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LoadMapRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLoadMapRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<LoadMapRequest> CreateLoadMapRequest(::flatbuffers::FlatBufferBuilder &_fbb, const LoadMapRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LoadMapRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _map_url = _fbb.CreateString(_o->map_url);
  return fb::nav_msgs::CreateLoadMapRequest(
      _fbb,
      ___metadata,
      _map_url);
}

inline LoadMapResponseT::LoadMapResponseT(const LoadMapResponseT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        map((o.map) ? new fb::nav_msgs::OccupancyGridT(*o.map) : nullptr),
        result(o.result) {
}

inline LoadMapResponseT &LoadMapResponseT::operator=(LoadMapResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(map, o.map);
  std::swap(result, o.result);
  return *this;
}

inline LoadMapResponseT *LoadMapResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LoadMapResponseT>(new LoadMapResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LoadMapResponse::UnPackTo(LoadMapResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = map(); if (_e) { if(_o->map) { _e->UnPackTo(_o->map.get(), _resolver); } else { _o->map = std::unique_ptr<fb::nav_msgs::OccupancyGridT>(_e->UnPack(_resolver)); } } else if (_o->map) { _o->map.reset(); } }
  { auto _e = result(); _o->result = _e; }
}

inline ::flatbuffers::Offset<LoadMapResponse> LoadMapResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LoadMapResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLoadMapResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<LoadMapResponse> CreateLoadMapResponse(::flatbuffers::FlatBufferBuilder &_fbb, const LoadMapResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LoadMapResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _map = _o->map ? CreateOccupancyGrid(_fbb, _o->map.get(), _rehasher) : 0;
  auto _result = _o->result;
  return fb::nav_msgs::CreateLoadMapResponse(
      _fbb,
      ___metadata,
      _map,
      _result);
}

inline GetMapGoalT::GetMapGoalT(const GetMapGoalT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr) {
}

inline GetMapGoalT &GetMapGoalT::operator=(GetMapGoalT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  return *this;
}

inline GetMapGoalT *GetMapGoal::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetMapGoalT>(new GetMapGoalT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetMapGoal::UnPackTo(GetMapGoalT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
}

inline ::flatbuffers::Offset<GetMapGoal> GetMapGoal::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapGoalT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetMapGoal(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GetMapGoal> CreateGetMapGoal(::flatbuffers::FlatBufferBuilder &_fbb, const GetMapGoalT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GetMapGoalT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  return fb::nav_msgs::CreateGetMapGoal(
      _fbb,
      ___metadata);
}

}  // namespace nav_msgs
}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_NAVMSGS_FB_NAV_MSGS_H_
