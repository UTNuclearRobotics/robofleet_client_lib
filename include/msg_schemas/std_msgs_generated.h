// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_STDMSGS_FB_STD_MSGS_H_
#define FLATBUFFERS_GENERATED_STDMSGS_FB_STD_MSGS_H_

#include "./flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 21,
             "Non-compatible flatbuffers version included");

namespace fb {
namespace std_msgs {

struct MultiArrayDimension;
struct MultiArrayDimensionBuilder;
struct MultiArrayDimensionT;

struct Bool;
struct BoolBuilder;
struct BoolT;

struct Int32MultiArray;
struct Int32MultiArrayBuilder;
struct Int32MultiArrayT;

struct UInt16;
struct UInt16Builder;
struct UInt16T;

struct UInt16MultiArray;
struct UInt16MultiArrayBuilder;
struct UInt16MultiArrayT;

struct UInt64;
struct UInt64Builder;
struct UInt64T;

struct Float32;
struct Float32Builder;
struct Float32T;

struct Empty;
struct EmptyBuilder;
struct EmptyT;

struct Byte;
struct ByteBuilder;
struct ByteT;

struct ByteMultiArray;
struct ByteMultiArrayBuilder;
struct ByteMultiArrayT;

struct Float64MultiArray;
struct Float64MultiArrayBuilder;
struct Float64MultiArrayT;

struct Int16;
struct Int16Builder;
struct Int16T;

struct Int8MultiArray;
struct Int8MultiArrayBuilder;
struct Int8MultiArrayT;

struct UInt8MultiArray;
struct UInt8MultiArrayBuilder;
struct UInt8MultiArrayT;

struct UInt64MultiArray;
struct UInt64MultiArrayBuilder;
struct UInt64MultiArrayT;

struct Int16MultiArray;
struct Int16MultiArrayBuilder;
struct Int16MultiArrayT;

struct Duration;
struct DurationBuilder;
struct DurationT;

struct Float64;
struct Float64Builder;
struct Float64T;

struct Time;
struct TimeBuilder;
struct TimeT;

struct Float32MultiArray;
struct Float32MultiArrayBuilder;
struct Float32MultiArrayT;

struct Int8;
struct Int8Builder;
struct Int8T;

struct String;
struct StringBuilder;
struct StringT;

struct UInt32;
struct UInt32Builder;
struct UInt32T;

struct UInt32MultiArray;
struct UInt32MultiArrayBuilder;
struct UInt32MultiArrayT;

struct ColorRGBA;
struct ColorRGBABuilder;
struct ColorRGBAT;

struct Int64MultiArray;
struct Int64MultiArrayBuilder;
struct Int64MultiArrayT;

struct Header;
struct HeaderBuilder;
struct HeaderT;

struct Int64;
struct Int64Builder;
struct Int64T;

struct UInt8;
struct UInt8Builder;
struct UInt8T;

struct Char;
struct CharBuilder;
struct CharT;

struct MultiArrayLayout;
struct MultiArrayLayoutBuilder;
struct MultiArrayLayoutT;

struct Int32;
struct Int32Builder;
struct Int32T;

struct MultiArrayDimensionT : public ::flatbuffers::NativeTable {
  typedef MultiArrayDimension TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string label{};
  uint32_t size = 0;
  uint32_t stride = 0;
  MultiArrayDimensionT() = default;
  MultiArrayDimensionT(const MultiArrayDimensionT &o);
  MultiArrayDimensionT(MultiArrayDimensionT&&) FLATBUFFERS_NOEXCEPT = default;
  MultiArrayDimensionT &operator=(MultiArrayDimensionT o) FLATBUFFERS_NOEXCEPT;
};

struct MultiArrayDimension FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MultiArrayDimensionT NativeTableType;
  typedef MultiArrayDimensionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_LABEL = 6,
    VT_SIZE = 8,
    VT_STRIDE = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *label() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LABEL);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  uint32_t stride() const {
    return GetField<uint32_t>(VT_STRIDE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_LABEL) &&
           verifier.VerifyString(label()) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_STRIDE, 4) &&
           verifier.EndTable();
  }
  MultiArrayDimensionT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MultiArrayDimensionT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<MultiArrayDimension> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MultiArrayDimensionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MultiArrayDimensionBuilder {
  typedef MultiArrayDimension Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(MultiArrayDimension::VT___METADATA, __metadata);
  }
  void add_label(::flatbuffers::Offset<::flatbuffers::String> label) {
    fbb_.AddOffset(MultiArrayDimension::VT_LABEL, label);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(MultiArrayDimension::VT_SIZE, size, 0);
  }
  void add_stride(uint32_t stride) {
    fbb_.AddElement<uint32_t>(MultiArrayDimension::VT_STRIDE, stride, 0);
  }
  explicit MultiArrayDimensionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MultiArrayDimension> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MultiArrayDimension>(end);
    fbb_.Required(o, MultiArrayDimension::VT_LABEL);
    return o;
  }
};

inline ::flatbuffers::Offset<MultiArrayDimension> CreateMultiArrayDimension(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> label = 0,
    uint32_t size = 0,
    uint32_t stride = 0) {
  MultiArrayDimensionBuilder builder_(_fbb);
  builder_.add_stride(stride);
  builder_.add_size(size);
  builder_.add_label(label);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MultiArrayDimension> CreateMultiArrayDimensionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *label = nullptr,
    uint32_t size = 0,
    uint32_t stride = 0) {
  auto label__ = label ? _fbb.CreateString(label) : 0;
  return fb::std_msgs::CreateMultiArrayDimension(
      _fbb,
      __metadata,
      label__,
      size,
      stride);
}

::flatbuffers::Offset<MultiArrayDimension> CreateMultiArrayDimension(::flatbuffers::FlatBufferBuilder &_fbb, const MultiArrayDimensionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BoolT : public ::flatbuffers::NativeTable {
  typedef Bool TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  bool data = false;
  BoolT() = default;
  BoolT(const BoolT &o);
  BoolT(BoolT&&) FLATBUFFERS_NOEXCEPT = default;
  BoolT &operator=(BoolT o) FLATBUFFERS_NOEXCEPT;
};

struct Bool FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BoolT NativeTableType;
  typedef BoolBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_DATA = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool data() const {
    return GetField<uint8_t>(VT_DATA, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint8_t>(verifier, VT_DATA, 1) &&
           verifier.EndTable();
  }
  BoolT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BoolT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Bool> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BoolT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BoolBuilder {
  typedef Bool Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Bool::VT___METADATA, __metadata);
  }
  void add_data(bool data) {
    fbb_.AddElement<uint8_t>(Bool::VT_DATA, static_cast<uint8_t>(data), 0);
  }
  explicit BoolBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Bool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Bool>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Bool> CreateBool(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    bool data = false) {
  BoolBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  builder_.add_data(data);
  return builder_.Finish();
}

::flatbuffers::Offset<Bool> CreateBool(::flatbuffers::FlatBufferBuilder &_fbb, const BoolT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Int32MultiArrayT : public ::flatbuffers::NativeTable {
  typedef Int32MultiArray TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::MultiArrayLayoutT> layout{};
  std::vector<int32_t> data{};
  Int32MultiArrayT() = default;
  Int32MultiArrayT(const Int32MultiArrayT &o);
  Int32MultiArrayT(Int32MultiArrayT&&) FLATBUFFERS_NOEXCEPT = default;
  Int32MultiArrayT &operator=(Int32MultiArrayT o) FLATBUFFERS_NOEXCEPT;
};

struct Int32MultiArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Int32MultiArrayT NativeTableType;
  typedef Int32MultiArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_LAYOUT = 6,
    VT_DATA = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::MultiArrayLayout *layout() const {
    return GetPointer<const fb::std_msgs::MultiArrayLayout *>(VT_LAYOUT);
  }
  const ::flatbuffers::Vector<int32_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_LAYOUT) &&
           verifier.VerifyTable(layout()) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  Int32MultiArrayT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Int32MultiArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Int32MultiArray> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Int32MultiArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Int32MultiArrayBuilder {
  typedef Int32MultiArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Int32MultiArray::VT___METADATA, __metadata);
  }
  void add_layout(::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout) {
    fbb_.AddOffset(Int32MultiArray::VT_LAYOUT, layout);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> data) {
    fbb_.AddOffset(Int32MultiArray::VT_DATA, data);
  }
  explicit Int32MultiArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Int32MultiArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Int32MultiArray>(end);
    fbb_.Required(o, Int32MultiArray::VT_LAYOUT);
    fbb_.Required(o, Int32MultiArray::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<Int32MultiArray> CreateInt32MultiArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> data = 0) {
  Int32MultiArrayBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_layout(layout);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Int32MultiArray> CreateInt32MultiArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout = 0,
    const std::vector<int32_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<int32_t>(*data) : 0;
  return fb::std_msgs::CreateInt32MultiArray(
      _fbb,
      __metadata,
      layout,
      data__);
}

::flatbuffers::Offset<Int32MultiArray> CreateInt32MultiArray(::flatbuffers::FlatBufferBuilder &_fbb, const Int32MultiArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UInt16T : public ::flatbuffers::NativeTable {
  typedef UInt16 TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  uint16_t data = 0;
  UInt16T() = default;
  UInt16T(const UInt16T &o);
  UInt16T(UInt16T&&) FLATBUFFERS_NOEXCEPT = default;
  UInt16T &operator=(UInt16T o) FLATBUFFERS_NOEXCEPT;
};

struct UInt16 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UInt16T NativeTableType;
  typedef UInt16Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_DATA = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  uint16_t data() const {
    return GetField<uint16_t>(VT_DATA, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint16_t>(verifier, VT_DATA, 2) &&
           verifier.EndTable();
  }
  UInt16T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UInt16T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UInt16> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UInt16T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UInt16Builder {
  typedef UInt16 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(UInt16::VT___METADATA, __metadata);
  }
  void add_data(uint16_t data) {
    fbb_.AddElement<uint16_t>(UInt16::VT_DATA, data, 0);
  }
  explicit UInt16Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UInt16> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UInt16>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UInt16> CreateUInt16(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint16_t data = 0) {
  UInt16Builder builder_(_fbb);
  builder_.add___metadata(__metadata);
  builder_.add_data(data);
  return builder_.Finish();
}

::flatbuffers::Offset<UInt16> CreateUInt16(::flatbuffers::FlatBufferBuilder &_fbb, const UInt16T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UInt16MultiArrayT : public ::flatbuffers::NativeTable {
  typedef UInt16MultiArray TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::MultiArrayLayoutT> layout{};
  std::vector<uint16_t> data{};
  UInt16MultiArrayT() = default;
  UInt16MultiArrayT(const UInt16MultiArrayT &o);
  UInt16MultiArrayT(UInt16MultiArrayT&&) FLATBUFFERS_NOEXCEPT = default;
  UInt16MultiArrayT &operator=(UInt16MultiArrayT o) FLATBUFFERS_NOEXCEPT;
};

struct UInt16MultiArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UInt16MultiArrayT NativeTableType;
  typedef UInt16MultiArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_LAYOUT = 6,
    VT_DATA = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::MultiArrayLayout *layout() const {
    return GetPointer<const fb::std_msgs::MultiArrayLayout *>(VT_LAYOUT);
  }
  const ::flatbuffers::Vector<uint16_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint16_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_LAYOUT) &&
           verifier.VerifyTable(layout()) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  UInt16MultiArrayT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UInt16MultiArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UInt16MultiArray> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UInt16MultiArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UInt16MultiArrayBuilder {
  typedef UInt16MultiArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(UInt16MultiArray::VT___METADATA, __metadata);
  }
  void add_layout(::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout) {
    fbb_.AddOffset(UInt16MultiArray::VT_LAYOUT, layout);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> data) {
    fbb_.AddOffset(UInt16MultiArray::VT_DATA, data);
  }
  explicit UInt16MultiArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UInt16MultiArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UInt16MultiArray>(end);
    fbb_.Required(o, UInt16MultiArray::VT_LAYOUT);
    fbb_.Required(o, UInt16MultiArray::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<UInt16MultiArray> CreateUInt16MultiArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> data = 0) {
  UInt16MultiArrayBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_layout(layout);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UInt16MultiArray> CreateUInt16MultiArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout = 0,
    const std::vector<uint16_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint16_t>(*data) : 0;
  return fb::std_msgs::CreateUInt16MultiArray(
      _fbb,
      __metadata,
      layout,
      data__);
}

::flatbuffers::Offset<UInt16MultiArray> CreateUInt16MultiArray(::flatbuffers::FlatBufferBuilder &_fbb, const UInt16MultiArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UInt64T : public ::flatbuffers::NativeTable {
  typedef UInt64 TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  uint64_t data = 0;
  UInt64T() = default;
  UInt64T(const UInt64T &o);
  UInt64T(UInt64T&&) FLATBUFFERS_NOEXCEPT = default;
  UInt64T &operator=(UInt64T o) FLATBUFFERS_NOEXCEPT;
};

struct UInt64 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UInt64T NativeTableType;
  typedef UInt64Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_DATA = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  uint64_t data() const {
    return GetField<uint64_t>(VT_DATA, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint64_t>(verifier, VT_DATA, 8) &&
           verifier.EndTable();
  }
  UInt64T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UInt64T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UInt64> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UInt64T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UInt64Builder {
  typedef UInt64 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(UInt64::VT___METADATA, __metadata);
  }
  void add_data(uint64_t data) {
    fbb_.AddElement<uint64_t>(UInt64::VT_DATA, data, 0);
  }
  explicit UInt64Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UInt64> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UInt64>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UInt64> CreateUInt64(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint64_t data = 0) {
  UInt64Builder builder_(_fbb);
  builder_.add_data(data);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<UInt64> CreateUInt64(::flatbuffers::FlatBufferBuilder &_fbb, const UInt64T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Float32T : public ::flatbuffers::NativeTable {
  typedef Float32 TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  float data = 0.0f;
  Float32T() = default;
  Float32T(const Float32T &o);
  Float32T(Float32T&&) FLATBUFFERS_NOEXCEPT = default;
  Float32T &operator=(Float32T o) FLATBUFFERS_NOEXCEPT;
};

struct Float32 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Float32T NativeTableType;
  typedef Float32Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_DATA = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  float data() const {
    return GetField<float>(VT_DATA, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<float>(verifier, VT_DATA, 4) &&
           verifier.EndTable();
  }
  Float32T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Float32T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Float32> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Float32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Float32Builder {
  typedef Float32 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Float32::VT___METADATA, __metadata);
  }
  void add_data(float data) {
    fbb_.AddElement<float>(Float32::VT_DATA, data, 0.0f);
  }
  explicit Float32Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Float32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Float32>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Float32> CreateFloat32(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    float data = 0.0f) {
  Float32Builder builder_(_fbb);
  builder_.add_data(data);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<Float32> CreateFloat32(::flatbuffers::FlatBufferBuilder &_fbb, const Float32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EmptyT : public ::flatbuffers::NativeTable {
  typedef Empty TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  EmptyT() = default;
  EmptyT(const EmptyT &o);
  EmptyT(EmptyT&&) FLATBUFFERS_NOEXCEPT = default;
  EmptyT &operator=(EmptyT o) FLATBUFFERS_NOEXCEPT;
};

struct Empty FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EmptyT NativeTableType;
  typedef EmptyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           verifier.EndTable();
  }
  EmptyT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EmptyT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Empty> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EmptyT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EmptyBuilder {
  typedef Empty Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Empty::VT___METADATA, __metadata);
  }
  explicit EmptyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Empty> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Empty>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Empty> CreateEmpty(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0) {
  EmptyBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<Empty> CreateEmpty(::flatbuffers::FlatBufferBuilder &_fbb, const EmptyT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ByteT : public ::flatbuffers::NativeTable {
  typedef Byte TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  int8_t data = 0;
  ByteT() = default;
  ByteT(const ByteT &o);
  ByteT(ByteT&&) FLATBUFFERS_NOEXCEPT = default;
  ByteT &operator=(ByteT o) FLATBUFFERS_NOEXCEPT;
};

struct Byte FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ByteT NativeTableType;
  typedef ByteBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_DATA = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  int8_t data() const {
    return GetField<int8_t>(VT_DATA, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<int8_t>(verifier, VT_DATA, 1) &&
           verifier.EndTable();
  }
  ByteT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ByteT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Byte> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ByteT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ByteBuilder {
  typedef Byte Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Byte::VT___METADATA, __metadata);
  }
  void add_data(int8_t data) {
    fbb_.AddElement<int8_t>(Byte::VT_DATA, data, 0);
  }
  explicit ByteBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Byte> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Byte>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Byte> CreateByte(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    int8_t data = 0) {
  ByteBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  builder_.add_data(data);
  return builder_.Finish();
}

::flatbuffers::Offset<Byte> CreateByte(::flatbuffers::FlatBufferBuilder &_fbb, const ByteT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ByteMultiArrayT : public ::flatbuffers::NativeTable {
  typedef ByteMultiArray TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::MultiArrayLayoutT> layout{};
  std::vector<int8_t> data{};
  ByteMultiArrayT() = default;
  ByteMultiArrayT(const ByteMultiArrayT &o);
  ByteMultiArrayT(ByteMultiArrayT&&) FLATBUFFERS_NOEXCEPT = default;
  ByteMultiArrayT &operator=(ByteMultiArrayT o) FLATBUFFERS_NOEXCEPT;
};

struct ByteMultiArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ByteMultiArrayT NativeTableType;
  typedef ByteMultiArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_LAYOUT = 6,
    VT_DATA = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::MultiArrayLayout *layout() const {
    return GetPointer<const fb::std_msgs::MultiArrayLayout *>(VT_LAYOUT);
  }
  const ::flatbuffers::Vector<int8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_LAYOUT) &&
           verifier.VerifyTable(layout()) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  ByteMultiArrayT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ByteMultiArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ByteMultiArray> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ByteMultiArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ByteMultiArrayBuilder {
  typedef ByteMultiArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ByteMultiArray::VT___METADATA, __metadata);
  }
  void add_layout(::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout) {
    fbb_.AddOffset(ByteMultiArray::VT_LAYOUT, layout);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> data) {
    fbb_.AddOffset(ByteMultiArray::VT_DATA, data);
  }
  explicit ByteMultiArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ByteMultiArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ByteMultiArray>(end);
    fbb_.Required(o, ByteMultiArray::VT_LAYOUT);
    fbb_.Required(o, ByteMultiArray::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<ByteMultiArray> CreateByteMultiArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> data = 0) {
  ByteMultiArrayBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_layout(layout);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ByteMultiArray> CreateByteMultiArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout = 0,
    const std::vector<int8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<int8_t>(*data) : 0;
  return fb::std_msgs::CreateByteMultiArray(
      _fbb,
      __metadata,
      layout,
      data__);
}

::flatbuffers::Offset<ByteMultiArray> CreateByteMultiArray(::flatbuffers::FlatBufferBuilder &_fbb, const ByteMultiArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Float64MultiArrayT : public ::flatbuffers::NativeTable {
  typedef Float64MultiArray TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::MultiArrayLayoutT> layout{};
  std::vector<double> data{};
  Float64MultiArrayT() = default;
  Float64MultiArrayT(const Float64MultiArrayT &o);
  Float64MultiArrayT(Float64MultiArrayT&&) FLATBUFFERS_NOEXCEPT = default;
  Float64MultiArrayT &operator=(Float64MultiArrayT o) FLATBUFFERS_NOEXCEPT;
};

struct Float64MultiArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Float64MultiArrayT NativeTableType;
  typedef Float64MultiArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_LAYOUT = 6,
    VT_DATA = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::MultiArrayLayout *layout() const {
    return GetPointer<const fb::std_msgs::MultiArrayLayout *>(VT_LAYOUT);
  }
  const ::flatbuffers::Vector<double> *data() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_LAYOUT) &&
           verifier.VerifyTable(layout()) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  Float64MultiArrayT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Float64MultiArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Float64MultiArray> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Float64MultiArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Float64MultiArrayBuilder {
  typedef Float64MultiArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Float64MultiArray::VT___METADATA, __metadata);
  }
  void add_layout(::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout) {
    fbb_.AddOffset(Float64MultiArray::VT_LAYOUT, layout);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<double>> data) {
    fbb_.AddOffset(Float64MultiArray::VT_DATA, data);
  }
  explicit Float64MultiArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Float64MultiArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Float64MultiArray>(end);
    fbb_.Required(o, Float64MultiArray::VT_LAYOUT);
    fbb_.Required(o, Float64MultiArray::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<Float64MultiArray> CreateFloat64MultiArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> data = 0) {
  Float64MultiArrayBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_layout(layout);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Float64MultiArray> CreateFloat64MultiArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout = 0,
    const std::vector<double> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<double>(*data) : 0;
  return fb::std_msgs::CreateFloat64MultiArray(
      _fbb,
      __metadata,
      layout,
      data__);
}

::flatbuffers::Offset<Float64MultiArray> CreateFloat64MultiArray(::flatbuffers::FlatBufferBuilder &_fbb, const Float64MultiArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Int16T : public ::flatbuffers::NativeTable {
  typedef Int16 TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  int16_t data = 0;
  Int16T() = default;
  Int16T(const Int16T &o);
  Int16T(Int16T&&) FLATBUFFERS_NOEXCEPT = default;
  Int16T &operator=(Int16T o) FLATBUFFERS_NOEXCEPT;
};

struct Int16 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Int16T NativeTableType;
  typedef Int16Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_DATA = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  int16_t data() const {
    return GetField<int16_t>(VT_DATA, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<int16_t>(verifier, VT_DATA, 2) &&
           verifier.EndTable();
  }
  Int16T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Int16T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Int16> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Int16T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Int16Builder {
  typedef Int16 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Int16::VT___METADATA, __metadata);
  }
  void add_data(int16_t data) {
    fbb_.AddElement<int16_t>(Int16::VT_DATA, data, 0);
  }
  explicit Int16Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Int16> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Int16>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Int16> CreateInt16(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    int16_t data = 0) {
  Int16Builder builder_(_fbb);
  builder_.add___metadata(__metadata);
  builder_.add_data(data);
  return builder_.Finish();
}

::flatbuffers::Offset<Int16> CreateInt16(::flatbuffers::FlatBufferBuilder &_fbb, const Int16T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Int8MultiArrayT : public ::flatbuffers::NativeTable {
  typedef Int8MultiArray TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::MultiArrayLayoutT> layout{};
  std::vector<int8_t> data{};
  Int8MultiArrayT() = default;
  Int8MultiArrayT(const Int8MultiArrayT &o);
  Int8MultiArrayT(Int8MultiArrayT&&) FLATBUFFERS_NOEXCEPT = default;
  Int8MultiArrayT &operator=(Int8MultiArrayT o) FLATBUFFERS_NOEXCEPT;
};

struct Int8MultiArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Int8MultiArrayT NativeTableType;
  typedef Int8MultiArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_LAYOUT = 6,
    VT_DATA = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::MultiArrayLayout *layout() const {
    return GetPointer<const fb::std_msgs::MultiArrayLayout *>(VT_LAYOUT);
  }
  const ::flatbuffers::Vector<int8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_LAYOUT) &&
           verifier.VerifyTable(layout()) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  Int8MultiArrayT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Int8MultiArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Int8MultiArray> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Int8MultiArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Int8MultiArrayBuilder {
  typedef Int8MultiArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Int8MultiArray::VT___METADATA, __metadata);
  }
  void add_layout(::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout) {
    fbb_.AddOffset(Int8MultiArray::VT_LAYOUT, layout);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> data) {
    fbb_.AddOffset(Int8MultiArray::VT_DATA, data);
  }
  explicit Int8MultiArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Int8MultiArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Int8MultiArray>(end);
    fbb_.Required(o, Int8MultiArray::VT_LAYOUT);
    fbb_.Required(o, Int8MultiArray::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<Int8MultiArray> CreateInt8MultiArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> data = 0) {
  Int8MultiArrayBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_layout(layout);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Int8MultiArray> CreateInt8MultiArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout = 0,
    const std::vector<int8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<int8_t>(*data) : 0;
  return fb::std_msgs::CreateInt8MultiArray(
      _fbb,
      __metadata,
      layout,
      data__);
}

::flatbuffers::Offset<Int8MultiArray> CreateInt8MultiArray(::flatbuffers::FlatBufferBuilder &_fbb, const Int8MultiArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UInt8MultiArrayT : public ::flatbuffers::NativeTable {
  typedef UInt8MultiArray TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::MultiArrayLayoutT> layout{};
  std::vector<uint8_t> data{};
  UInt8MultiArrayT() = default;
  UInt8MultiArrayT(const UInt8MultiArrayT &o);
  UInt8MultiArrayT(UInt8MultiArrayT&&) FLATBUFFERS_NOEXCEPT = default;
  UInt8MultiArrayT &operator=(UInt8MultiArrayT o) FLATBUFFERS_NOEXCEPT;
};

struct UInt8MultiArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UInt8MultiArrayT NativeTableType;
  typedef UInt8MultiArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_LAYOUT = 6,
    VT_DATA = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::MultiArrayLayout *layout() const {
    return GetPointer<const fb::std_msgs::MultiArrayLayout *>(VT_LAYOUT);
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_LAYOUT) &&
           verifier.VerifyTable(layout()) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  UInt8MultiArrayT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UInt8MultiArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UInt8MultiArray> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UInt8MultiArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UInt8MultiArrayBuilder {
  typedef UInt8MultiArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(UInt8MultiArray::VT___METADATA, __metadata);
  }
  void add_layout(::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout) {
    fbb_.AddOffset(UInt8MultiArray::VT_LAYOUT, layout);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(UInt8MultiArray::VT_DATA, data);
  }
  explicit UInt8MultiArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UInt8MultiArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UInt8MultiArray>(end);
    fbb_.Required(o, UInt8MultiArray::VT_LAYOUT);
    fbb_.Required(o, UInt8MultiArray::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<UInt8MultiArray> CreateUInt8MultiArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  UInt8MultiArrayBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_layout(layout);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UInt8MultiArray> CreateUInt8MultiArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return fb::std_msgs::CreateUInt8MultiArray(
      _fbb,
      __metadata,
      layout,
      data__);
}

::flatbuffers::Offset<UInt8MultiArray> CreateUInt8MultiArray(::flatbuffers::FlatBufferBuilder &_fbb, const UInt8MultiArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UInt64MultiArrayT : public ::flatbuffers::NativeTable {
  typedef UInt64MultiArray TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::MultiArrayLayoutT> layout{};
  std::vector<uint64_t> data{};
  UInt64MultiArrayT() = default;
  UInt64MultiArrayT(const UInt64MultiArrayT &o);
  UInt64MultiArrayT(UInt64MultiArrayT&&) FLATBUFFERS_NOEXCEPT = default;
  UInt64MultiArrayT &operator=(UInt64MultiArrayT o) FLATBUFFERS_NOEXCEPT;
};

struct UInt64MultiArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UInt64MultiArrayT NativeTableType;
  typedef UInt64MultiArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_LAYOUT = 6,
    VT_DATA = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::MultiArrayLayout *layout() const {
    return GetPointer<const fb::std_msgs::MultiArrayLayout *>(VT_LAYOUT);
  }
  const ::flatbuffers::Vector<uint64_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_LAYOUT) &&
           verifier.VerifyTable(layout()) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  UInt64MultiArrayT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UInt64MultiArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UInt64MultiArray> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UInt64MultiArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UInt64MultiArrayBuilder {
  typedef UInt64MultiArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(UInt64MultiArray::VT___METADATA, __metadata);
  }
  void add_layout(::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout) {
    fbb_.AddOffset(UInt64MultiArray::VT_LAYOUT, layout);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> data) {
    fbb_.AddOffset(UInt64MultiArray::VT_DATA, data);
  }
  explicit UInt64MultiArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UInt64MultiArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UInt64MultiArray>(end);
    fbb_.Required(o, UInt64MultiArray::VT_LAYOUT);
    fbb_.Required(o, UInt64MultiArray::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<UInt64MultiArray> CreateUInt64MultiArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> data = 0) {
  UInt64MultiArrayBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_layout(layout);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UInt64MultiArray> CreateUInt64MultiArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout = 0,
    const std::vector<uint64_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint64_t>(*data) : 0;
  return fb::std_msgs::CreateUInt64MultiArray(
      _fbb,
      __metadata,
      layout,
      data__);
}

::flatbuffers::Offset<UInt64MultiArray> CreateUInt64MultiArray(::flatbuffers::FlatBufferBuilder &_fbb, const UInt64MultiArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Int16MultiArrayT : public ::flatbuffers::NativeTable {
  typedef Int16MultiArray TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::MultiArrayLayoutT> layout{};
  std::vector<int16_t> data{};
  Int16MultiArrayT() = default;
  Int16MultiArrayT(const Int16MultiArrayT &o);
  Int16MultiArrayT(Int16MultiArrayT&&) FLATBUFFERS_NOEXCEPT = default;
  Int16MultiArrayT &operator=(Int16MultiArrayT o) FLATBUFFERS_NOEXCEPT;
};

struct Int16MultiArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Int16MultiArrayT NativeTableType;
  typedef Int16MultiArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_LAYOUT = 6,
    VT_DATA = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::MultiArrayLayout *layout() const {
    return GetPointer<const fb::std_msgs::MultiArrayLayout *>(VT_LAYOUT);
  }
  const ::flatbuffers::Vector<int16_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<int16_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_LAYOUT) &&
           verifier.VerifyTable(layout()) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  Int16MultiArrayT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Int16MultiArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Int16MultiArray> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Int16MultiArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Int16MultiArrayBuilder {
  typedef Int16MultiArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Int16MultiArray::VT___METADATA, __metadata);
  }
  void add_layout(::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout) {
    fbb_.AddOffset(Int16MultiArray::VT_LAYOUT, layout);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<int16_t>> data) {
    fbb_.AddOffset(Int16MultiArray::VT_DATA, data);
  }
  explicit Int16MultiArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Int16MultiArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Int16MultiArray>(end);
    fbb_.Required(o, Int16MultiArray::VT_LAYOUT);
    fbb_.Required(o, Int16MultiArray::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<Int16MultiArray> CreateInt16MultiArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int16_t>> data = 0) {
  Int16MultiArrayBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_layout(layout);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Int16MultiArray> CreateInt16MultiArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout = 0,
    const std::vector<int16_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<int16_t>(*data) : 0;
  return fb::std_msgs::CreateInt16MultiArray(
      _fbb,
      __metadata,
      layout,
      data__);
}

::flatbuffers::Offset<Int16MultiArray> CreateInt16MultiArray(::flatbuffers::FlatBufferBuilder &_fbb, const Int16MultiArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DurationT : public ::flatbuffers::NativeTable {
  typedef Duration TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::RosDuration> data{};
  DurationT() = default;
  DurationT(const DurationT &o);
  DurationT(DurationT&&) FLATBUFFERS_NOEXCEPT = default;
  DurationT &operator=(DurationT o) FLATBUFFERS_NOEXCEPT;
};

struct Duration FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DurationT NativeTableType;
  typedef DurationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_DATA = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::RosDuration *data() const {
    return GetStruct<const fb::RosDuration *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyFieldRequired<fb::RosDuration>(verifier, VT_DATA, 4) &&
           verifier.EndTable();
  }
  DurationT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DurationT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Duration> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DurationT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DurationBuilder {
  typedef Duration Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Duration::VT___METADATA, __metadata);
  }
  void add_data(const fb::RosDuration *data) {
    fbb_.AddStruct(Duration::VT_DATA, data);
  }
  explicit DurationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Duration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Duration>(end);
    fbb_.Required(o, Duration::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<Duration> CreateDuration(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const fb::RosDuration *data = nullptr) {
  DurationBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<Duration> CreateDuration(::flatbuffers::FlatBufferBuilder &_fbb, const DurationT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Float64T : public ::flatbuffers::NativeTable {
  typedef Float64 TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  double data = 0.0;
  Float64T() = default;
  Float64T(const Float64T &o);
  Float64T(Float64T&&) FLATBUFFERS_NOEXCEPT = default;
  Float64T &operator=(Float64T o) FLATBUFFERS_NOEXCEPT;
};

struct Float64 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Float64T NativeTableType;
  typedef Float64Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_DATA = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  double data() const {
    return GetField<double>(VT_DATA, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<double>(verifier, VT_DATA, 8) &&
           verifier.EndTable();
  }
  Float64T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Float64T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Float64> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Float64T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Float64Builder {
  typedef Float64 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Float64::VT___METADATA, __metadata);
  }
  void add_data(double data) {
    fbb_.AddElement<double>(Float64::VT_DATA, data, 0.0);
  }
  explicit Float64Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Float64> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Float64>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Float64> CreateFloat64(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    double data = 0.0) {
  Float64Builder builder_(_fbb);
  builder_.add_data(data);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<Float64> CreateFloat64(::flatbuffers::FlatBufferBuilder &_fbb, const Float64T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TimeT : public ::flatbuffers::NativeTable {
  typedef Time TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::RosTime> data{};
  TimeT() = default;
  TimeT(const TimeT &o);
  TimeT(TimeT&&) FLATBUFFERS_NOEXCEPT = default;
  TimeT &operator=(TimeT o) FLATBUFFERS_NOEXCEPT;
};

struct Time FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TimeT NativeTableType;
  typedef TimeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_DATA = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::RosTime *data() const {
    return GetStruct<const fb::RosTime *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyFieldRequired<fb::RosTime>(verifier, VT_DATA, 4) &&
           verifier.EndTable();
  }
  TimeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TimeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Time> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TimeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TimeBuilder {
  typedef Time Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Time::VT___METADATA, __metadata);
  }
  void add_data(const fb::RosTime *data) {
    fbb_.AddStruct(Time::VT_DATA, data);
  }
  explicit TimeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Time> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Time>(end);
    fbb_.Required(o, Time::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<Time> CreateTime(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const fb::RosTime *data = nullptr) {
  TimeBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<Time> CreateTime(::flatbuffers::FlatBufferBuilder &_fbb, const TimeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Float32MultiArrayT : public ::flatbuffers::NativeTable {
  typedef Float32MultiArray TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::MultiArrayLayoutT> layout{};
  std::vector<float> data{};
  Float32MultiArrayT() = default;
  Float32MultiArrayT(const Float32MultiArrayT &o);
  Float32MultiArrayT(Float32MultiArrayT&&) FLATBUFFERS_NOEXCEPT = default;
  Float32MultiArrayT &operator=(Float32MultiArrayT o) FLATBUFFERS_NOEXCEPT;
};

struct Float32MultiArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Float32MultiArrayT NativeTableType;
  typedef Float32MultiArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_LAYOUT = 6,
    VT_DATA = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::MultiArrayLayout *layout() const {
    return GetPointer<const fb::std_msgs::MultiArrayLayout *>(VT_LAYOUT);
  }
  const ::flatbuffers::Vector<float> *data() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_LAYOUT) &&
           verifier.VerifyTable(layout()) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  Float32MultiArrayT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Float32MultiArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Float32MultiArray> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Float32MultiArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Float32MultiArrayBuilder {
  typedef Float32MultiArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Float32MultiArray::VT___METADATA, __metadata);
  }
  void add_layout(::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout) {
    fbb_.AddOffset(Float32MultiArray::VT_LAYOUT, layout);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<float>> data) {
    fbb_.AddOffset(Float32MultiArray::VT_DATA, data);
  }
  explicit Float32MultiArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Float32MultiArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Float32MultiArray>(end);
    fbb_.Required(o, Float32MultiArray::VT_LAYOUT);
    fbb_.Required(o, Float32MultiArray::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<Float32MultiArray> CreateFloat32MultiArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> data = 0) {
  Float32MultiArrayBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_layout(layout);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Float32MultiArray> CreateFloat32MultiArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout = 0,
    const std::vector<float> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<float>(*data) : 0;
  return fb::std_msgs::CreateFloat32MultiArray(
      _fbb,
      __metadata,
      layout,
      data__);
}

::flatbuffers::Offset<Float32MultiArray> CreateFloat32MultiArray(::flatbuffers::FlatBufferBuilder &_fbb, const Float32MultiArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Int8T : public ::flatbuffers::NativeTable {
  typedef Int8 TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  int8_t data = 0;
  Int8T() = default;
  Int8T(const Int8T &o);
  Int8T(Int8T&&) FLATBUFFERS_NOEXCEPT = default;
  Int8T &operator=(Int8T o) FLATBUFFERS_NOEXCEPT;
};

struct Int8 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Int8T NativeTableType;
  typedef Int8Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_DATA = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  int8_t data() const {
    return GetField<int8_t>(VT_DATA, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<int8_t>(verifier, VT_DATA, 1) &&
           verifier.EndTable();
  }
  Int8T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Int8T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Int8> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Int8T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Int8Builder {
  typedef Int8 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Int8::VT___METADATA, __metadata);
  }
  void add_data(int8_t data) {
    fbb_.AddElement<int8_t>(Int8::VT_DATA, data, 0);
  }
  explicit Int8Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Int8> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Int8>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Int8> CreateInt8(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    int8_t data = 0) {
  Int8Builder builder_(_fbb);
  builder_.add___metadata(__metadata);
  builder_.add_data(data);
  return builder_.Finish();
}

::flatbuffers::Offset<Int8> CreateInt8(::flatbuffers::FlatBufferBuilder &_fbb, const Int8T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StringT : public ::flatbuffers::NativeTable {
  typedef String TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string data{};
  StringT() = default;
  StringT(const StringT &o);
  StringT(StringT&&) FLATBUFFERS_NOEXCEPT = default;
  StringT &operator=(StringT o) FLATBUFFERS_NOEXCEPT;
};

struct String FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StringT NativeTableType;
  typedef StringBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_DATA = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *data() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyString(data()) &&
           verifier.EndTable();
  }
  StringT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StringT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<String> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StringT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StringBuilder {
  typedef String Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(String::VT___METADATA, __metadata);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::String> data) {
    fbb_.AddOffset(String::VT_DATA, data);
  }
  explicit StringBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<String> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<String>(end);
    fbb_.Required(o, String::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<String> CreateString(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> data = 0) {
  StringBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<String> CreateStringDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *data = nullptr) {
  auto data__ = data ? _fbb.CreateString(data) : 0;
  return fb::std_msgs::CreateString(
      _fbb,
      __metadata,
      data__);
}

::flatbuffers::Offset<String> CreateString(::flatbuffers::FlatBufferBuilder &_fbb, const StringT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UInt32T : public ::flatbuffers::NativeTable {
  typedef UInt32 TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  uint32_t data = 0;
  UInt32T() = default;
  UInt32T(const UInt32T &o);
  UInt32T(UInt32T&&) FLATBUFFERS_NOEXCEPT = default;
  UInt32T &operator=(UInt32T o) FLATBUFFERS_NOEXCEPT;
};

struct UInt32 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UInt32T NativeTableType;
  typedef UInt32Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_DATA = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  uint32_t data() const {
    return GetField<uint32_t>(VT_DATA, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint32_t>(verifier, VT_DATA, 4) &&
           verifier.EndTable();
  }
  UInt32T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UInt32T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UInt32> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UInt32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UInt32Builder {
  typedef UInt32 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(UInt32::VT___METADATA, __metadata);
  }
  void add_data(uint32_t data) {
    fbb_.AddElement<uint32_t>(UInt32::VT_DATA, data, 0);
  }
  explicit UInt32Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UInt32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UInt32>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UInt32> CreateUInt32(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint32_t data = 0) {
  UInt32Builder builder_(_fbb);
  builder_.add_data(data);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<UInt32> CreateUInt32(::flatbuffers::FlatBufferBuilder &_fbb, const UInt32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UInt32MultiArrayT : public ::flatbuffers::NativeTable {
  typedef UInt32MultiArray TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::MultiArrayLayoutT> layout{};
  std::vector<uint32_t> data{};
  UInt32MultiArrayT() = default;
  UInt32MultiArrayT(const UInt32MultiArrayT &o);
  UInt32MultiArrayT(UInt32MultiArrayT&&) FLATBUFFERS_NOEXCEPT = default;
  UInt32MultiArrayT &operator=(UInt32MultiArrayT o) FLATBUFFERS_NOEXCEPT;
};

struct UInt32MultiArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UInt32MultiArrayT NativeTableType;
  typedef UInt32MultiArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_LAYOUT = 6,
    VT_DATA = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::MultiArrayLayout *layout() const {
    return GetPointer<const fb::std_msgs::MultiArrayLayout *>(VT_LAYOUT);
  }
  const ::flatbuffers::Vector<uint32_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_LAYOUT) &&
           verifier.VerifyTable(layout()) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  UInt32MultiArrayT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UInt32MultiArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UInt32MultiArray> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UInt32MultiArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UInt32MultiArrayBuilder {
  typedef UInt32MultiArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(UInt32MultiArray::VT___METADATA, __metadata);
  }
  void add_layout(::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout) {
    fbb_.AddOffset(UInt32MultiArray::VT_LAYOUT, layout);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> data) {
    fbb_.AddOffset(UInt32MultiArray::VT_DATA, data);
  }
  explicit UInt32MultiArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UInt32MultiArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UInt32MultiArray>(end);
    fbb_.Required(o, UInt32MultiArray::VT_LAYOUT);
    fbb_.Required(o, UInt32MultiArray::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<UInt32MultiArray> CreateUInt32MultiArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> data = 0) {
  UInt32MultiArrayBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_layout(layout);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UInt32MultiArray> CreateUInt32MultiArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout = 0,
    const std::vector<uint32_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint32_t>(*data) : 0;
  return fb::std_msgs::CreateUInt32MultiArray(
      _fbb,
      __metadata,
      layout,
      data__);
}

::flatbuffers::Offset<UInt32MultiArray> CreateUInt32MultiArray(::flatbuffers::FlatBufferBuilder &_fbb, const UInt32MultiArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ColorRGBAT : public ::flatbuffers::NativeTable {
  typedef ColorRGBA TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  float r = 0.0f;
  float g = 0.0f;
  float b = 0.0f;
  float a = 0.0f;
  ColorRGBAT() = default;
  ColorRGBAT(const ColorRGBAT &o);
  ColorRGBAT(ColorRGBAT&&) FLATBUFFERS_NOEXCEPT = default;
  ColorRGBAT &operator=(ColorRGBAT o) FLATBUFFERS_NOEXCEPT;
};

struct ColorRGBA FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ColorRGBAT NativeTableType;
  typedef ColorRGBABuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_R = 6,
    VT_G = 8,
    VT_B = 10,
    VT_A = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  float r() const {
    return GetField<float>(VT_R, 0.0f);
  }
  float g() const {
    return GetField<float>(VT_G, 0.0f);
  }
  float b() const {
    return GetField<float>(VT_B, 0.0f);
  }
  float a() const {
    return GetField<float>(VT_A, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<float>(verifier, VT_R, 4) &&
           VerifyField<float>(verifier, VT_G, 4) &&
           VerifyField<float>(verifier, VT_B, 4) &&
           VerifyField<float>(verifier, VT_A, 4) &&
           verifier.EndTable();
  }
  ColorRGBAT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ColorRGBAT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ColorRGBA> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ColorRGBAT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ColorRGBABuilder {
  typedef ColorRGBA Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ColorRGBA::VT___METADATA, __metadata);
  }
  void add_r(float r) {
    fbb_.AddElement<float>(ColorRGBA::VT_R, r, 0.0f);
  }
  void add_g(float g) {
    fbb_.AddElement<float>(ColorRGBA::VT_G, g, 0.0f);
  }
  void add_b(float b) {
    fbb_.AddElement<float>(ColorRGBA::VT_B, b, 0.0f);
  }
  void add_a(float a) {
    fbb_.AddElement<float>(ColorRGBA::VT_A, a, 0.0f);
  }
  explicit ColorRGBABuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ColorRGBA> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ColorRGBA>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ColorRGBA> CreateColorRGBA(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    float r = 0.0f,
    float g = 0.0f,
    float b = 0.0f,
    float a = 0.0f) {
  ColorRGBABuilder builder_(_fbb);
  builder_.add_a(a);
  builder_.add_b(b);
  builder_.add_g(g);
  builder_.add_r(r);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<ColorRGBA> CreateColorRGBA(::flatbuffers::FlatBufferBuilder &_fbb, const ColorRGBAT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Int64MultiArrayT : public ::flatbuffers::NativeTable {
  typedef Int64MultiArray TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::MultiArrayLayoutT> layout{};
  std::vector<int64_t> data{};
  Int64MultiArrayT() = default;
  Int64MultiArrayT(const Int64MultiArrayT &o);
  Int64MultiArrayT(Int64MultiArrayT&&) FLATBUFFERS_NOEXCEPT = default;
  Int64MultiArrayT &operator=(Int64MultiArrayT o) FLATBUFFERS_NOEXCEPT;
};

struct Int64MultiArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Int64MultiArrayT NativeTableType;
  typedef Int64MultiArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_LAYOUT = 6,
    VT_DATA = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::MultiArrayLayout *layout() const {
    return GetPointer<const fb::std_msgs::MultiArrayLayout *>(VT_LAYOUT);
  }
  const ::flatbuffers::Vector<int64_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_LAYOUT) &&
           verifier.VerifyTable(layout()) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  Int64MultiArrayT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Int64MultiArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Int64MultiArray> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Int64MultiArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Int64MultiArrayBuilder {
  typedef Int64MultiArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Int64MultiArray::VT___METADATA, __metadata);
  }
  void add_layout(::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout) {
    fbb_.AddOffset(Int64MultiArray::VT_LAYOUT, layout);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> data) {
    fbb_.AddOffset(Int64MultiArray::VT_DATA, data);
  }
  explicit Int64MultiArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Int64MultiArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Int64MultiArray>(end);
    fbb_.Required(o, Int64MultiArray::VT_LAYOUT);
    fbb_.Required(o, Int64MultiArray::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<Int64MultiArray> CreateInt64MultiArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> data = 0) {
  Int64MultiArrayBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_layout(layout);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Int64MultiArray> CreateInt64MultiArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::MultiArrayLayout> layout = 0,
    const std::vector<int64_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<int64_t>(*data) : 0;
  return fb::std_msgs::CreateInt64MultiArray(
      _fbb,
      __metadata,
      layout,
      data__);
}

::flatbuffers::Offset<Int64MultiArray> CreateInt64MultiArray(::flatbuffers::FlatBufferBuilder &_fbb, const Int64MultiArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HeaderT : public ::flatbuffers::NativeTable {
  typedef Header TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  uint32_t seq = 0;
  std::unique_ptr<fb::RosTime> stamp{};
  std::string frame_id{};
  HeaderT() = default;
  HeaderT(const HeaderT &o);
  HeaderT(HeaderT&&) FLATBUFFERS_NOEXCEPT = default;
  HeaderT &operator=(HeaderT o) FLATBUFFERS_NOEXCEPT;
};

struct Header FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HeaderT NativeTableType;
  typedef HeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_SEQ = 6,
    VT_STAMP = 8,
    VT_FRAME_ID = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  uint32_t seq() const {
    return GetField<uint32_t>(VT_SEQ, 0);
  }
  const fb::RosTime *stamp() const {
    return GetStruct<const fb::RosTime *>(VT_STAMP);
  }
  const ::flatbuffers::String *frame_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FRAME_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint32_t>(verifier, VT_SEQ, 4) &&
           VerifyFieldRequired<fb::RosTime>(verifier, VT_STAMP, 4) &&
           VerifyOffsetRequired(verifier, VT_FRAME_ID) &&
           verifier.VerifyString(frame_id()) &&
           verifier.EndTable();
  }
  HeaderT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HeaderT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Header> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HeaderT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HeaderBuilder {
  typedef Header Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Header::VT___METADATA, __metadata);
  }
  void add_seq(uint32_t seq) {
    fbb_.AddElement<uint32_t>(Header::VT_SEQ, seq, 0);
  }
  void add_stamp(const fb::RosTime *stamp) {
    fbb_.AddStruct(Header::VT_STAMP, stamp);
  }
  void add_frame_id(::flatbuffers::Offset<::flatbuffers::String> frame_id) {
    fbb_.AddOffset(Header::VT_FRAME_ID, frame_id);
  }
  explicit HeaderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Header> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Header>(end);
    fbb_.Required(o, Header::VT_STAMP);
    fbb_.Required(o, Header::VT_FRAME_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<Header> CreateHeader(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint32_t seq = 0,
    const fb::RosTime *stamp = nullptr,
    ::flatbuffers::Offset<::flatbuffers::String> frame_id = 0) {
  HeaderBuilder builder_(_fbb);
  builder_.add_frame_id(frame_id);
  builder_.add_stamp(stamp);
  builder_.add_seq(seq);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Header> CreateHeaderDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint32_t seq = 0,
    const fb::RosTime *stamp = nullptr,
    const char *frame_id = nullptr) {
  auto frame_id__ = frame_id ? _fbb.CreateString(frame_id) : 0;
  return fb::std_msgs::CreateHeader(
      _fbb,
      __metadata,
      seq,
      stamp,
      frame_id__);
}

::flatbuffers::Offset<Header> CreateHeader(::flatbuffers::FlatBufferBuilder &_fbb, const HeaderT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Int64T : public ::flatbuffers::NativeTable {
  typedef Int64 TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  int64_t data = 0;
  Int64T() = default;
  Int64T(const Int64T &o);
  Int64T(Int64T&&) FLATBUFFERS_NOEXCEPT = default;
  Int64T &operator=(Int64T o) FLATBUFFERS_NOEXCEPT;
};

struct Int64 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Int64T NativeTableType;
  typedef Int64Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_DATA = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  int64_t data() const {
    return GetField<int64_t>(VT_DATA, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<int64_t>(verifier, VT_DATA, 8) &&
           verifier.EndTable();
  }
  Int64T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Int64T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Int64> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Int64T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Int64Builder {
  typedef Int64 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Int64::VT___METADATA, __metadata);
  }
  void add_data(int64_t data) {
    fbb_.AddElement<int64_t>(Int64::VT_DATA, data, 0);
  }
  explicit Int64Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Int64> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Int64>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Int64> CreateInt64(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    int64_t data = 0) {
  Int64Builder builder_(_fbb);
  builder_.add_data(data);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<Int64> CreateInt64(::flatbuffers::FlatBufferBuilder &_fbb, const Int64T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UInt8T : public ::flatbuffers::NativeTable {
  typedef UInt8 TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  uint8_t data = 0;
  UInt8T() = default;
  UInt8T(const UInt8T &o);
  UInt8T(UInt8T&&) FLATBUFFERS_NOEXCEPT = default;
  UInt8T &operator=(UInt8T o) FLATBUFFERS_NOEXCEPT;
};

struct UInt8 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UInt8T NativeTableType;
  typedef UInt8Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_DATA = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  uint8_t data() const {
    return GetField<uint8_t>(VT_DATA, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint8_t>(verifier, VT_DATA, 1) &&
           verifier.EndTable();
  }
  UInt8T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UInt8T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UInt8> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UInt8T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UInt8Builder {
  typedef UInt8 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(UInt8::VT___METADATA, __metadata);
  }
  void add_data(uint8_t data) {
    fbb_.AddElement<uint8_t>(UInt8::VT_DATA, data, 0);
  }
  explicit UInt8Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UInt8> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UInt8>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UInt8> CreateUInt8(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint8_t data = 0) {
  UInt8Builder builder_(_fbb);
  builder_.add___metadata(__metadata);
  builder_.add_data(data);
  return builder_.Finish();
}

::flatbuffers::Offset<UInt8> CreateUInt8(::flatbuffers::FlatBufferBuilder &_fbb, const UInt8T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CharT : public ::flatbuffers::NativeTable {
  typedef Char TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  uint8_t data = 0;
  CharT() = default;
  CharT(const CharT &o);
  CharT(CharT&&) FLATBUFFERS_NOEXCEPT = default;
  CharT &operator=(CharT o) FLATBUFFERS_NOEXCEPT;
};

struct Char FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CharT NativeTableType;
  typedef CharBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_DATA = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  uint8_t data() const {
    return GetField<uint8_t>(VT_DATA, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint8_t>(verifier, VT_DATA, 1) &&
           verifier.EndTable();
  }
  CharT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CharT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Char> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CharT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CharBuilder {
  typedef Char Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Char::VT___METADATA, __metadata);
  }
  void add_data(uint8_t data) {
    fbb_.AddElement<uint8_t>(Char::VT_DATA, data, 0);
  }
  explicit CharBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Char> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Char>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Char> CreateChar(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint8_t data = 0) {
  CharBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  builder_.add_data(data);
  return builder_.Finish();
}

::flatbuffers::Offset<Char> CreateChar(::flatbuffers::FlatBufferBuilder &_fbb, const CharT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MultiArrayLayoutT : public ::flatbuffers::NativeTable {
  typedef MultiArrayLayout TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::vector<std::unique_ptr<fb::std_msgs::MultiArrayDimensionT>> dim{};
  uint32_t data_offset = 0;
  MultiArrayLayoutT() = default;
  MultiArrayLayoutT(const MultiArrayLayoutT &o);
  MultiArrayLayoutT(MultiArrayLayoutT&&) FLATBUFFERS_NOEXCEPT = default;
  MultiArrayLayoutT &operator=(MultiArrayLayoutT o) FLATBUFFERS_NOEXCEPT;
};

struct MultiArrayLayout FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MultiArrayLayoutT NativeTableType;
  typedef MultiArrayLayoutBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_DIM = 6,
    VT_DATA_OFFSET = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::std_msgs::MultiArrayDimension>> *dim() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::std_msgs::MultiArrayDimension>> *>(VT_DIM);
  }
  uint32_t data_offset() const {
    return GetField<uint32_t>(VT_DATA_OFFSET, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_DIM) &&
           verifier.VerifyVector(dim()) &&
           verifier.VerifyVectorOfTables(dim()) &&
           VerifyField<uint32_t>(verifier, VT_DATA_OFFSET, 4) &&
           verifier.EndTable();
  }
  MultiArrayLayoutT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MultiArrayLayoutT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<MultiArrayLayout> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MultiArrayLayoutT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MultiArrayLayoutBuilder {
  typedef MultiArrayLayout Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(MultiArrayLayout::VT___METADATA, __metadata);
  }
  void add_dim(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::std_msgs::MultiArrayDimension>>> dim) {
    fbb_.AddOffset(MultiArrayLayout::VT_DIM, dim);
  }
  void add_data_offset(uint32_t data_offset) {
    fbb_.AddElement<uint32_t>(MultiArrayLayout::VT_DATA_OFFSET, data_offset, 0);
  }
  explicit MultiArrayLayoutBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MultiArrayLayout> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MultiArrayLayout>(end);
    fbb_.Required(o, MultiArrayLayout::VT_DIM);
    return o;
  }
};

inline ::flatbuffers::Offset<MultiArrayLayout> CreateMultiArrayLayout(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::std_msgs::MultiArrayDimension>>> dim = 0,
    uint32_t data_offset = 0) {
  MultiArrayLayoutBuilder builder_(_fbb);
  builder_.add_data_offset(data_offset);
  builder_.add_dim(dim);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MultiArrayLayout> CreateMultiArrayLayoutDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const std::vector<::flatbuffers::Offset<fb::std_msgs::MultiArrayDimension>> *dim = nullptr,
    uint32_t data_offset = 0) {
  auto dim__ = dim ? _fbb.CreateVector<::flatbuffers::Offset<fb::std_msgs::MultiArrayDimension>>(*dim) : 0;
  return fb::std_msgs::CreateMultiArrayLayout(
      _fbb,
      __metadata,
      dim__,
      data_offset);
}

::flatbuffers::Offset<MultiArrayLayout> CreateMultiArrayLayout(::flatbuffers::FlatBufferBuilder &_fbb, const MultiArrayLayoutT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Int32T : public ::flatbuffers::NativeTable {
  typedef Int32 TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  int32_t data = 0;
  Int32T() = default;
  Int32T(const Int32T &o);
  Int32T(Int32T&&) FLATBUFFERS_NOEXCEPT = default;
  Int32T &operator=(Int32T o) FLATBUFFERS_NOEXCEPT;
};

struct Int32 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Int32T NativeTableType;
  typedef Int32Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_DATA = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  int32_t data() const {
    return GetField<int32_t>(VT_DATA, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<int32_t>(verifier, VT_DATA, 4) &&
           verifier.EndTable();
  }
  Int32T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Int32T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Int32> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Int32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Int32Builder {
  typedef Int32 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Int32::VT___METADATA, __metadata);
  }
  void add_data(int32_t data) {
    fbb_.AddElement<int32_t>(Int32::VT_DATA, data, 0);
  }
  explicit Int32Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Int32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Int32>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Int32> CreateInt32(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    int32_t data = 0) {
  Int32Builder builder_(_fbb);
  builder_.add_data(data);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<Int32> CreateInt32(::flatbuffers::FlatBufferBuilder &_fbb, const Int32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline MultiArrayDimensionT::MultiArrayDimensionT(const MultiArrayDimensionT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        label(o.label),
        size(o.size),
        stride(o.stride) {
}

inline MultiArrayDimensionT &MultiArrayDimensionT::operator=(MultiArrayDimensionT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(label, o.label);
  std::swap(size, o.size);
  std::swap(stride, o.stride);
  return *this;
}

inline MultiArrayDimensionT *MultiArrayDimension::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MultiArrayDimensionT>(new MultiArrayDimensionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MultiArrayDimension::UnPackTo(MultiArrayDimensionT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = label(); if (_e) _o->label = _e->str(); }
  { auto _e = size(); _o->size = _e; }
  { auto _e = stride(); _o->stride = _e; }
}

inline ::flatbuffers::Offset<MultiArrayDimension> MultiArrayDimension::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MultiArrayDimensionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMultiArrayDimension(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<MultiArrayDimension> CreateMultiArrayDimension(::flatbuffers::FlatBufferBuilder &_fbb, const MultiArrayDimensionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MultiArrayDimensionT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _label = _fbb.CreateString(_o->label);
  auto _size = _o->size;
  auto _stride = _o->stride;
  return fb::std_msgs::CreateMultiArrayDimension(
      _fbb,
      ___metadata,
      _label,
      _size,
      _stride);
}

inline BoolT::BoolT(const BoolT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        data(o.data) {
}

inline BoolT &BoolT::operator=(BoolT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(data, o.data);
  return *this;
}

inline BoolT *Bool::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BoolT>(new BoolT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Bool::UnPackTo(BoolT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = data(); _o->data = _e; }
}

inline ::flatbuffers::Offset<Bool> Bool::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BoolT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBool(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Bool> CreateBool(::flatbuffers::FlatBufferBuilder &_fbb, const BoolT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BoolT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _data = _o->data;
  return fb::std_msgs::CreateBool(
      _fbb,
      ___metadata,
      _data);
}

inline Int32MultiArrayT::Int32MultiArrayT(const Int32MultiArrayT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        layout((o.layout) ? new fb::std_msgs::MultiArrayLayoutT(*o.layout) : nullptr),
        data(o.data) {
}

inline Int32MultiArrayT &Int32MultiArrayT::operator=(Int32MultiArrayT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(layout, o.layout);
  std::swap(data, o.data);
  return *this;
}

inline Int32MultiArrayT *Int32MultiArray::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Int32MultiArrayT>(new Int32MultiArrayT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Int32MultiArray::UnPackTo(Int32MultiArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = layout(); if (_e) { if(_o->layout) { _e->UnPackTo(_o->layout.get(), _resolver); } else { _o->layout = std::unique_ptr<fb::std_msgs::MultiArrayLayoutT>(_e->UnPack(_resolver)); } } else if (_o->layout) { _o->layout.reset(); } }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } else { _o->data.resize(0); } }
}

inline ::flatbuffers::Offset<Int32MultiArray> Int32MultiArray::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Int32MultiArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInt32MultiArray(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Int32MultiArray> CreateInt32MultiArray(::flatbuffers::FlatBufferBuilder &_fbb, const Int32MultiArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Int32MultiArrayT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _layout = _o->layout ? CreateMultiArrayLayout(_fbb, _o->layout.get(), _rehasher) : 0;
  auto _data = _fbb.CreateVector(_o->data);
  return fb::std_msgs::CreateInt32MultiArray(
      _fbb,
      ___metadata,
      _layout,
      _data);
}

inline UInt16T::UInt16T(const UInt16T &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        data(o.data) {
}

inline UInt16T &UInt16T::operator=(UInt16T o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(data, o.data);
  return *this;
}

inline UInt16T *UInt16::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UInt16T>(new UInt16T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UInt16::UnPackTo(UInt16T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = data(); _o->data = _e; }
}

inline ::flatbuffers::Offset<UInt16> UInt16::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UInt16T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUInt16(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UInt16> CreateUInt16(::flatbuffers::FlatBufferBuilder &_fbb, const UInt16T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UInt16T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _data = _o->data;
  return fb::std_msgs::CreateUInt16(
      _fbb,
      ___metadata,
      _data);
}

inline UInt16MultiArrayT::UInt16MultiArrayT(const UInt16MultiArrayT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        layout((o.layout) ? new fb::std_msgs::MultiArrayLayoutT(*o.layout) : nullptr),
        data(o.data) {
}

inline UInt16MultiArrayT &UInt16MultiArrayT::operator=(UInt16MultiArrayT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(layout, o.layout);
  std::swap(data, o.data);
  return *this;
}

inline UInt16MultiArrayT *UInt16MultiArray::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UInt16MultiArrayT>(new UInt16MultiArrayT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UInt16MultiArray::UnPackTo(UInt16MultiArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = layout(); if (_e) { if(_o->layout) { _e->UnPackTo(_o->layout.get(), _resolver); } else { _o->layout = std::unique_ptr<fb::std_msgs::MultiArrayLayoutT>(_e->UnPack(_resolver)); } } else if (_o->layout) { _o->layout.reset(); } }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } else { _o->data.resize(0); } }
}

inline ::flatbuffers::Offset<UInt16MultiArray> UInt16MultiArray::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UInt16MultiArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUInt16MultiArray(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UInt16MultiArray> CreateUInt16MultiArray(::flatbuffers::FlatBufferBuilder &_fbb, const UInt16MultiArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UInt16MultiArrayT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _layout = _o->layout ? CreateMultiArrayLayout(_fbb, _o->layout.get(), _rehasher) : 0;
  auto _data = _fbb.CreateVector(_o->data);
  return fb::std_msgs::CreateUInt16MultiArray(
      _fbb,
      ___metadata,
      _layout,
      _data);
}

inline UInt64T::UInt64T(const UInt64T &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        data(o.data) {
}

inline UInt64T &UInt64T::operator=(UInt64T o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(data, o.data);
  return *this;
}

inline UInt64T *UInt64::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UInt64T>(new UInt64T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UInt64::UnPackTo(UInt64T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = data(); _o->data = _e; }
}

inline ::flatbuffers::Offset<UInt64> UInt64::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UInt64T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUInt64(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UInt64> CreateUInt64(::flatbuffers::FlatBufferBuilder &_fbb, const UInt64T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UInt64T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _data = _o->data;
  return fb::std_msgs::CreateUInt64(
      _fbb,
      ___metadata,
      _data);
}

inline Float32T::Float32T(const Float32T &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        data(o.data) {
}

inline Float32T &Float32T::operator=(Float32T o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(data, o.data);
  return *this;
}

inline Float32T *Float32::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Float32T>(new Float32T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Float32::UnPackTo(Float32T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = data(); _o->data = _e; }
}

inline ::flatbuffers::Offset<Float32> Float32::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Float32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFloat32(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Float32> CreateFloat32(::flatbuffers::FlatBufferBuilder &_fbb, const Float32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Float32T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _data = _o->data;
  return fb::std_msgs::CreateFloat32(
      _fbb,
      ___metadata,
      _data);
}

inline EmptyT::EmptyT(const EmptyT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr) {
}

inline EmptyT &EmptyT::operator=(EmptyT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  return *this;
}

inline EmptyT *Empty::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EmptyT>(new EmptyT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Empty::UnPackTo(EmptyT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
}

inline ::flatbuffers::Offset<Empty> Empty::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EmptyT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEmpty(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Empty> CreateEmpty(::flatbuffers::FlatBufferBuilder &_fbb, const EmptyT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const EmptyT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  return fb::std_msgs::CreateEmpty(
      _fbb,
      ___metadata);
}

inline ByteT::ByteT(const ByteT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        data(o.data) {
}

inline ByteT &ByteT::operator=(ByteT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(data, o.data);
  return *this;
}

inline ByteT *Byte::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ByteT>(new ByteT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Byte::UnPackTo(ByteT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = data(); _o->data = _e; }
}

inline ::flatbuffers::Offset<Byte> Byte::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ByteT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateByte(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Byte> CreateByte(::flatbuffers::FlatBufferBuilder &_fbb, const ByteT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ByteT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _data = _o->data;
  return fb::std_msgs::CreateByte(
      _fbb,
      ___metadata,
      _data);
}

inline ByteMultiArrayT::ByteMultiArrayT(const ByteMultiArrayT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        layout((o.layout) ? new fb::std_msgs::MultiArrayLayoutT(*o.layout) : nullptr),
        data(o.data) {
}

inline ByteMultiArrayT &ByteMultiArrayT::operator=(ByteMultiArrayT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(layout, o.layout);
  std::swap(data, o.data);
  return *this;
}

inline ByteMultiArrayT *ByteMultiArray::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ByteMultiArrayT>(new ByteMultiArrayT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ByteMultiArray::UnPackTo(ByteMultiArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = layout(); if (_e) { if(_o->layout) { _e->UnPackTo(_o->layout.get(), _resolver); } else { _o->layout = std::unique_ptr<fb::std_msgs::MultiArrayLayoutT>(_e->UnPack(_resolver)); } } else if (_o->layout) { _o->layout.reset(); } }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
}

inline ::flatbuffers::Offset<ByteMultiArray> ByteMultiArray::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ByteMultiArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateByteMultiArray(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ByteMultiArray> CreateByteMultiArray(::flatbuffers::FlatBufferBuilder &_fbb, const ByteMultiArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ByteMultiArrayT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _layout = _o->layout ? CreateMultiArrayLayout(_fbb, _o->layout.get(), _rehasher) : 0;
  auto _data = _fbb.CreateVector(_o->data);
  return fb::std_msgs::CreateByteMultiArray(
      _fbb,
      ___metadata,
      _layout,
      _data);
}

inline Float64MultiArrayT::Float64MultiArrayT(const Float64MultiArrayT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        layout((o.layout) ? new fb::std_msgs::MultiArrayLayoutT(*o.layout) : nullptr),
        data(o.data) {
}

inline Float64MultiArrayT &Float64MultiArrayT::operator=(Float64MultiArrayT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(layout, o.layout);
  std::swap(data, o.data);
  return *this;
}

inline Float64MultiArrayT *Float64MultiArray::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Float64MultiArrayT>(new Float64MultiArrayT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Float64MultiArray::UnPackTo(Float64MultiArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = layout(); if (_e) { if(_o->layout) { _e->UnPackTo(_o->layout.get(), _resolver); } else { _o->layout = std::unique_ptr<fb::std_msgs::MultiArrayLayoutT>(_e->UnPack(_resolver)); } } else if (_o->layout) { _o->layout.reset(); } }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } else { _o->data.resize(0); } }
}

inline ::flatbuffers::Offset<Float64MultiArray> Float64MultiArray::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Float64MultiArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFloat64MultiArray(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Float64MultiArray> CreateFloat64MultiArray(::flatbuffers::FlatBufferBuilder &_fbb, const Float64MultiArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Float64MultiArrayT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _layout = _o->layout ? CreateMultiArrayLayout(_fbb, _o->layout.get(), _rehasher) : 0;
  auto _data = _fbb.CreateVector(_o->data);
  return fb::std_msgs::CreateFloat64MultiArray(
      _fbb,
      ___metadata,
      _layout,
      _data);
}

inline Int16T::Int16T(const Int16T &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        data(o.data) {
}

inline Int16T &Int16T::operator=(Int16T o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(data, o.data);
  return *this;
}

inline Int16T *Int16::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Int16T>(new Int16T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Int16::UnPackTo(Int16T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = data(); _o->data = _e; }
}

inline ::flatbuffers::Offset<Int16> Int16::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Int16T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInt16(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Int16> CreateInt16(::flatbuffers::FlatBufferBuilder &_fbb, const Int16T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Int16T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _data = _o->data;
  return fb::std_msgs::CreateInt16(
      _fbb,
      ___metadata,
      _data);
}

inline Int8MultiArrayT::Int8MultiArrayT(const Int8MultiArrayT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        layout((o.layout) ? new fb::std_msgs::MultiArrayLayoutT(*o.layout) : nullptr),
        data(o.data) {
}

inline Int8MultiArrayT &Int8MultiArrayT::operator=(Int8MultiArrayT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(layout, o.layout);
  std::swap(data, o.data);
  return *this;
}

inline Int8MultiArrayT *Int8MultiArray::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Int8MultiArrayT>(new Int8MultiArrayT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Int8MultiArray::UnPackTo(Int8MultiArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = layout(); if (_e) { if(_o->layout) { _e->UnPackTo(_o->layout.get(), _resolver); } else { _o->layout = std::unique_ptr<fb::std_msgs::MultiArrayLayoutT>(_e->UnPack(_resolver)); } } else if (_o->layout) { _o->layout.reset(); } }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
}

inline ::flatbuffers::Offset<Int8MultiArray> Int8MultiArray::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Int8MultiArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInt8MultiArray(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Int8MultiArray> CreateInt8MultiArray(::flatbuffers::FlatBufferBuilder &_fbb, const Int8MultiArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Int8MultiArrayT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _layout = _o->layout ? CreateMultiArrayLayout(_fbb, _o->layout.get(), _rehasher) : 0;
  auto _data = _fbb.CreateVector(_o->data);
  return fb::std_msgs::CreateInt8MultiArray(
      _fbb,
      ___metadata,
      _layout,
      _data);
}

inline UInt8MultiArrayT::UInt8MultiArrayT(const UInt8MultiArrayT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        layout((o.layout) ? new fb::std_msgs::MultiArrayLayoutT(*o.layout) : nullptr),
        data(o.data) {
}

inline UInt8MultiArrayT &UInt8MultiArrayT::operator=(UInt8MultiArrayT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(layout, o.layout);
  std::swap(data, o.data);
  return *this;
}

inline UInt8MultiArrayT *UInt8MultiArray::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UInt8MultiArrayT>(new UInt8MultiArrayT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UInt8MultiArray::UnPackTo(UInt8MultiArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = layout(); if (_e) { if(_o->layout) { _e->UnPackTo(_o->layout.get(), _resolver); } else { _o->layout = std::unique_ptr<fb::std_msgs::MultiArrayLayoutT>(_e->UnPack(_resolver)); } } else if (_o->layout) { _o->layout.reset(); } }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
}

inline ::flatbuffers::Offset<UInt8MultiArray> UInt8MultiArray::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UInt8MultiArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUInt8MultiArray(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UInt8MultiArray> CreateUInt8MultiArray(::flatbuffers::FlatBufferBuilder &_fbb, const UInt8MultiArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UInt8MultiArrayT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _layout = _o->layout ? CreateMultiArrayLayout(_fbb, _o->layout.get(), _rehasher) : 0;
  auto _data = _fbb.CreateVector(_o->data);
  return fb::std_msgs::CreateUInt8MultiArray(
      _fbb,
      ___metadata,
      _layout,
      _data);
}

inline UInt64MultiArrayT::UInt64MultiArrayT(const UInt64MultiArrayT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        layout((o.layout) ? new fb::std_msgs::MultiArrayLayoutT(*o.layout) : nullptr),
        data(o.data) {
}

inline UInt64MultiArrayT &UInt64MultiArrayT::operator=(UInt64MultiArrayT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(layout, o.layout);
  std::swap(data, o.data);
  return *this;
}

inline UInt64MultiArrayT *UInt64MultiArray::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UInt64MultiArrayT>(new UInt64MultiArrayT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UInt64MultiArray::UnPackTo(UInt64MultiArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = layout(); if (_e) { if(_o->layout) { _e->UnPackTo(_o->layout.get(), _resolver); } else { _o->layout = std::unique_ptr<fb::std_msgs::MultiArrayLayoutT>(_e->UnPack(_resolver)); } } else if (_o->layout) { _o->layout.reset(); } }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } else { _o->data.resize(0); } }
}

inline ::flatbuffers::Offset<UInt64MultiArray> UInt64MultiArray::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UInt64MultiArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUInt64MultiArray(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UInt64MultiArray> CreateUInt64MultiArray(::flatbuffers::FlatBufferBuilder &_fbb, const UInt64MultiArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UInt64MultiArrayT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _layout = _o->layout ? CreateMultiArrayLayout(_fbb, _o->layout.get(), _rehasher) : 0;
  auto _data = _fbb.CreateVector(_o->data);
  return fb::std_msgs::CreateUInt64MultiArray(
      _fbb,
      ___metadata,
      _layout,
      _data);
}

inline Int16MultiArrayT::Int16MultiArrayT(const Int16MultiArrayT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        layout((o.layout) ? new fb::std_msgs::MultiArrayLayoutT(*o.layout) : nullptr),
        data(o.data) {
}

inline Int16MultiArrayT &Int16MultiArrayT::operator=(Int16MultiArrayT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(layout, o.layout);
  std::swap(data, o.data);
  return *this;
}

inline Int16MultiArrayT *Int16MultiArray::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Int16MultiArrayT>(new Int16MultiArrayT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Int16MultiArray::UnPackTo(Int16MultiArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = layout(); if (_e) { if(_o->layout) { _e->UnPackTo(_o->layout.get(), _resolver); } else { _o->layout = std::unique_ptr<fb::std_msgs::MultiArrayLayoutT>(_e->UnPack(_resolver)); } } else if (_o->layout) { _o->layout.reset(); } }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } else { _o->data.resize(0); } }
}

inline ::flatbuffers::Offset<Int16MultiArray> Int16MultiArray::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Int16MultiArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInt16MultiArray(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Int16MultiArray> CreateInt16MultiArray(::flatbuffers::FlatBufferBuilder &_fbb, const Int16MultiArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Int16MultiArrayT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _layout = _o->layout ? CreateMultiArrayLayout(_fbb, _o->layout.get(), _rehasher) : 0;
  auto _data = _fbb.CreateVector(_o->data);
  return fb::std_msgs::CreateInt16MultiArray(
      _fbb,
      ___metadata,
      _layout,
      _data);
}

inline DurationT::DurationT(const DurationT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        data((o.data) ? new fb::RosDuration(*o.data) : nullptr) {
}

inline DurationT &DurationT::operator=(DurationT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(data, o.data);
  return *this;
}

inline DurationT *Duration::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DurationT>(new DurationT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Duration::UnPackTo(DurationT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = data(); if (_e) _o->data = std::unique_ptr<fb::RosDuration>(new fb::RosDuration(*_e)); }
}

inline ::flatbuffers::Offset<Duration> Duration::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DurationT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDuration(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Duration> CreateDuration(::flatbuffers::FlatBufferBuilder &_fbb, const DurationT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DurationT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _data = _o->data ? _o->data.get() : nullptr;
  return fb::std_msgs::CreateDuration(
      _fbb,
      ___metadata,
      _data);
}

inline Float64T::Float64T(const Float64T &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        data(o.data) {
}

inline Float64T &Float64T::operator=(Float64T o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(data, o.data);
  return *this;
}

inline Float64T *Float64::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Float64T>(new Float64T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Float64::UnPackTo(Float64T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = data(); _o->data = _e; }
}

inline ::flatbuffers::Offset<Float64> Float64::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Float64T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFloat64(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Float64> CreateFloat64(::flatbuffers::FlatBufferBuilder &_fbb, const Float64T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Float64T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _data = _o->data;
  return fb::std_msgs::CreateFloat64(
      _fbb,
      ___metadata,
      _data);
}

inline TimeT::TimeT(const TimeT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        data((o.data) ? new fb::RosTime(*o.data) : nullptr) {
}

inline TimeT &TimeT::operator=(TimeT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(data, o.data);
  return *this;
}

inline TimeT *Time::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TimeT>(new TimeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Time::UnPackTo(TimeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = data(); if (_e) _o->data = std::unique_ptr<fb::RosTime>(new fb::RosTime(*_e)); }
}

inline ::flatbuffers::Offset<Time> Time::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TimeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTime(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Time> CreateTime(::flatbuffers::FlatBufferBuilder &_fbb, const TimeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TimeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _data = _o->data ? _o->data.get() : nullptr;
  return fb::std_msgs::CreateTime(
      _fbb,
      ___metadata,
      _data);
}

inline Float32MultiArrayT::Float32MultiArrayT(const Float32MultiArrayT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        layout((o.layout) ? new fb::std_msgs::MultiArrayLayoutT(*o.layout) : nullptr),
        data(o.data) {
}

inline Float32MultiArrayT &Float32MultiArrayT::operator=(Float32MultiArrayT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(layout, o.layout);
  std::swap(data, o.data);
  return *this;
}

inline Float32MultiArrayT *Float32MultiArray::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Float32MultiArrayT>(new Float32MultiArrayT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Float32MultiArray::UnPackTo(Float32MultiArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = layout(); if (_e) { if(_o->layout) { _e->UnPackTo(_o->layout.get(), _resolver); } else { _o->layout = std::unique_ptr<fb::std_msgs::MultiArrayLayoutT>(_e->UnPack(_resolver)); } } else if (_o->layout) { _o->layout.reset(); } }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } else { _o->data.resize(0); } }
}

inline ::flatbuffers::Offset<Float32MultiArray> Float32MultiArray::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Float32MultiArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFloat32MultiArray(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Float32MultiArray> CreateFloat32MultiArray(::flatbuffers::FlatBufferBuilder &_fbb, const Float32MultiArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Float32MultiArrayT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _layout = _o->layout ? CreateMultiArrayLayout(_fbb, _o->layout.get(), _rehasher) : 0;
  auto _data = _fbb.CreateVector(_o->data);
  return fb::std_msgs::CreateFloat32MultiArray(
      _fbb,
      ___metadata,
      _layout,
      _data);
}

inline Int8T::Int8T(const Int8T &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        data(o.data) {
}

inline Int8T &Int8T::operator=(Int8T o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(data, o.data);
  return *this;
}

inline Int8T *Int8::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Int8T>(new Int8T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Int8::UnPackTo(Int8T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = data(); _o->data = _e; }
}

inline ::flatbuffers::Offset<Int8> Int8::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Int8T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInt8(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Int8> CreateInt8(::flatbuffers::FlatBufferBuilder &_fbb, const Int8T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Int8T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _data = _o->data;
  return fb::std_msgs::CreateInt8(
      _fbb,
      ___metadata,
      _data);
}

inline StringT::StringT(const StringT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        data(o.data) {
}

inline StringT &StringT::operator=(StringT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(data, o.data);
  return *this;
}

inline StringT *String::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StringT>(new StringT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void String::UnPackTo(StringT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = data(); if (_e) _o->data = _e->str(); }
}

inline ::flatbuffers::Offset<String> String::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StringT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateString(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<String> CreateString(::flatbuffers::FlatBufferBuilder &_fbb, const StringT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StringT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _data = _fbb.CreateString(_o->data);
  return fb::std_msgs::CreateString(
      _fbb,
      ___metadata,
      _data);
}

inline UInt32T::UInt32T(const UInt32T &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        data(o.data) {
}

inline UInt32T &UInt32T::operator=(UInt32T o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(data, o.data);
  return *this;
}

inline UInt32T *UInt32::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UInt32T>(new UInt32T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UInt32::UnPackTo(UInt32T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = data(); _o->data = _e; }
}

inline ::flatbuffers::Offset<UInt32> UInt32::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UInt32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUInt32(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UInt32> CreateUInt32(::flatbuffers::FlatBufferBuilder &_fbb, const UInt32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UInt32T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _data = _o->data;
  return fb::std_msgs::CreateUInt32(
      _fbb,
      ___metadata,
      _data);
}

inline UInt32MultiArrayT::UInt32MultiArrayT(const UInt32MultiArrayT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        layout((o.layout) ? new fb::std_msgs::MultiArrayLayoutT(*o.layout) : nullptr),
        data(o.data) {
}

inline UInt32MultiArrayT &UInt32MultiArrayT::operator=(UInt32MultiArrayT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(layout, o.layout);
  std::swap(data, o.data);
  return *this;
}

inline UInt32MultiArrayT *UInt32MultiArray::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UInt32MultiArrayT>(new UInt32MultiArrayT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UInt32MultiArray::UnPackTo(UInt32MultiArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = layout(); if (_e) { if(_o->layout) { _e->UnPackTo(_o->layout.get(), _resolver); } else { _o->layout = std::unique_ptr<fb::std_msgs::MultiArrayLayoutT>(_e->UnPack(_resolver)); } } else if (_o->layout) { _o->layout.reset(); } }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } else { _o->data.resize(0); } }
}

inline ::flatbuffers::Offset<UInt32MultiArray> UInt32MultiArray::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UInt32MultiArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUInt32MultiArray(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UInt32MultiArray> CreateUInt32MultiArray(::flatbuffers::FlatBufferBuilder &_fbb, const UInt32MultiArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UInt32MultiArrayT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _layout = _o->layout ? CreateMultiArrayLayout(_fbb, _o->layout.get(), _rehasher) : 0;
  auto _data = _fbb.CreateVector(_o->data);
  return fb::std_msgs::CreateUInt32MultiArray(
      _fbb,
      ___metadata,
      _layout,
      _data);
}

inline ColorRGBAT::ColorRGBAT(const ColorRGBAT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        r(o.r),
        g(o.g),
        b(o.b),
        a(o.a) {
}

inline ColorRGBAT &ColorRGBAT::operator=(ColorRGBAT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(r, o.r);
  std::swap(g, o.g);
  std::swap(b, o.b);
  std::swap(a, o.a);
  return *this;
}

inline ColorRGBAT *ColorRGBA::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ColorRGBAT>(new ColorRGBAT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ColorRGBA::UnPackTo(ColorRGBAT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = r(); _o->r = _e; }
  { auto _e = g(); _o->g = _e; }
  { auto _e = b(); _o->b = _e; }
  { auto _e = a(); _o->a = _e; }
}

inline ::flatbuffers::Offset<ColorRGBA> ColorRGBA::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ColorRGBAT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateColorRGBA(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ColorRGBA> CreateColorRGBA(::flatbuffers::FlatBufferBuilder &_fbb, const ColorRGBAT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ColorRGBAT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _r = _o->r;
  auto _g = _o->g;
  auto _b = _o->b;
  auto _a = _o->a;
  return fb::std_msgs::CreateColorRGBA(
      _fbb,
      ___metadata,
      _r,
      _g,
      _b,
      _a);
}

inline Int64MultiArrayT::Int64MultiArrayT(const Int64MultiArrayT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        layout((o.layout) ? new fb::std_msgs::MultiArrayLayoutT(*o.layout) : nullptr),
        data(o.data) {
}

inline Int64MultiArrayT &Int64MultiArrayT::operator=(Int64MultiArrayT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(layout, o.layout);
  std::swap(data, o.data);
  return *this;
}

inline Int64MultiArrayT *Int64MultiArray::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Int64MultiArrayT>(new Int64MultiArrayT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Int64MultiArray::UnPackTo(Int64MultiArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = layout(); if (_e) { if(_o->layout) { _e->UnPackTo(_o->layout.get(), _resolver); } else { _o->layout = std::unique_ptr<fb::std_msgs::MultiArrayLayoutT>(_e->UnPack(_resolver)); } } else if (_o->layout) { _o->layout.reset(); } }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } else { _o->data.resize(0); } }
}

inline ::flatbuffers::Offset<Int64MultiArray> Int64MultiArray::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Int64MultiArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInt64MultiArray(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Int64MultiArray> CreateInt64MultiArray(::flatbuffers::FlatBufferBuilder &_fbb, const Int64MultiArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Int64MultiArrayT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _layout = _o->layout ? CreateMultiArrayLayout(_fbb, _o->layout.get(), _rehasher) : 0;
  auto _data = _fbb.CreateVector(_o->data);
  return fb::std_msgs::CreateInt64MultiArray(
      _fbb,
      ___metadata,
      _layout,
      _data);
}

inline HeaderT::HeaderT(const HeaderT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        seq(o.seq),
        stamp((o.stamp) ? new fb::RosTime(*o.stamp) : nullptr),
        frame_id(o.frame_id) {
}

inline HeaderT &HeaderT::operator=(HeaderT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(seq, o.seq);
  std::swap(stamp, o.stamp);
  std::swap(frame_id, o.frame_id);
  return *this;
}

inline HeaderT *Header::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<HeaderT>(new HeaderT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Header::UnPackTo(HeaderT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = seq(); _o->seq = _e; }
  { auto _e = stamp(); if (_e) _o->stamp = std::unique_ptr<fb::RosTime>(new fb::RosTime(*_e)); }
  { auto _e = frame_id(); if (_e) _o->frame_id = _e->str(); }
}

inline ::flatbuffers::Offset<Header> Header::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HeaderT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHeader(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Header> CreateHeader(::flatbuffers::FlatBufferBuilder &_fbb, const HeaderT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const HeaderT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _seq = _o->seq;
  auto _stamp = _o->stamp ? _o->stamp.get() : nullptr;
  auto _frame_id = _fbb.CreateString(_o->frame_id);
  return fb::std_msgs::CreateHeader(
      _fbb,
      ___metadata,
      _seq,
      _stamp,
      _frame_id);
}

inline Int64T::Int64T(const Int64T &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        data(o.data) {
}

inline Int64T &Int64T::operator=(Int64T o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(data, o.data);
  return *this;
}

inline Int64T *Int64::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Int64T>(new Int64T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Int64::UnPackTo(Int64T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = data(); _o->data = _e; }
}

inline ::flatbuffers::Offset<Int64> Int64::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Int64T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInt64(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Int64> CreateInt64(::flatbuffers::FlatBufferBuilder &_fbb, const Int64T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Int64T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _data = _o->data;
  return fb::std_msgs::CreateInt64(
      _fbb,
      ___metadata,
      _data);
}

inline UInt8T::UInt8T(const UInt8T &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        data(o.data) {
}

inline UInt8T &UInt8T::operator=(UInt8T o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(data, o.data);
  return *this;
}

inline UInt8T *UInt8::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UInt8T>(new UInt8T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UInt8::UnPackTo(UInt8T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = data(); _o->data = _e; }
}

inline ::flatbuffers::Offset<UInt8> UInt8::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UInt8T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUInt8(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UInt8> CreateUInt8(::flatbuffers::FlatBufferBuilder &_fbb, const UInt8T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UInt8T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _data = _o->data;
  return fb::std_msgs::CreateUInt8(
      _fbb,
      ___metadata,
      _data);
}

inline CharT::CharT(const CharT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        data(o.data) {
}

inline CharT &CharT::operator=(CharT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(data, o.data);
  return *this;
}

inline CharT *Char::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CharT>(new CharT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Char::UnPackTo(CharT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = data(); _o->data = _e; }
}

inline ::flatbuffers::Offset<Char> Char::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CharT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateChar(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Char> CreateChar(::flatbuffers::FlatBufferBuilder &_fbb, const CharT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CharT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _data = _o->data;
  return fb::std_msgs::CreateChar(
      _fbb,
      ___metadata,
      _data);
}

inline MultiArrayLayoutT::MultiArrayLayoutT(const MultiArrayLayoutT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        data_offset(o.data_offset) {
  dim.reserve(o.dim.size());
  for (const auto &dim_ : o.dim) { dim.emplace_back((dim_) ? new fb::std_msgs::MultiArrayDimensionT(*dim_) : nullptr); }
}

inline MultiArrayLayoutT &MultiArrayLayoutT::operator=(MultiArrayLayoutT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(dim, o.dim);
  std::swap(data_offset, o.data_offset);
  return *this;
}

inline MultiArrayLayoutT *MultiArrayLayout::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MultiArrayLayoutT>(new MultiArrayLayoutT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MultiArrayLayout::UnPackTo(MultiArrayLayoutT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = dim(); if (_e) { _o->dim.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->dim[_i]) { _e->Get(_i)->UnPackTo(_o->dim[_i].get(), _resolver); } else { _o->dim[_i] = std::unique_ptr<fb::std_msgs::MultiArrayDimensionT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->dim.resize(0); } }
  { auto _e = data_offset(); _o->data_offset = _e; }
}

inline ::flatbuffers::Offset<MultiArrayLayout> MultiArrayLayout::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MultiArrayLayoutT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMultiArrayLayout(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<MultiArrayLayout> CreateMultiArrayLayout(::flatbuffers::FlatBufferBuilder &_fbb, const MultiArrayLayoutT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MultiArrayLayoutT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _dim = _fbb.CreateVector<::flatbuffers::Offset<fb::std_msgs::MultiArrayDimension>> (_o->dim.size(), [](size_t i, _VectorArgs *__va) { return CreateMultiArrayDimension(*__va->__fbb, __va->__o->dim[i].get(), __va->__rehasher); }, &_va );
  auto _data_offset = _o->data_offset;
  return fb::std_msgs::CreateMultiArrayLayout(
      _fbb,
      ___metadata,
      _dim,
      _data_offset);
}

inline Int32T::Int32T(const Int32T &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        data(o.data) {
}

inline Int32T &Int32T::operator=(Int32T o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(data, o.data);
  return *this;
}

inline Int32T *Int32::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Int32T>(new Int32T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Int32::UnPackTo(Int32T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = data(); _o->data = _e; }
}

inline ::flatbuffers::Offset<Int32> Int32::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Int32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInt32(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Int32> CreateInt32(::flatbuffers::FlatBufferBuilder &_fbb, const Int32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Int32T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _data = _o->data;
  return fb::std_msgs::CreateInt32(
      _fbb,
      ___metadata,
      _data);
}

}  // namespace std_msgs
}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_STDMSGS_FB_STD_MSGS_H_
