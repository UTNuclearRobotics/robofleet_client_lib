// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_LEGTRACKER_FB_LEG_TRACKER_H_
#define FLATBUFFERS_GENERATED_LEGTRACKER_FB_LEG_TRACKER_H_

#include "./flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 21,
             "Non-compatible flatbuffers version included");

#include "base_schema_generated.h"
#include "geometry_msgs_generated.h"
#include "std_msgs_generated.h"

namespace fb {
namespace leg_tracker {

struct SaveBagRequest;
struct SaveBagRequestBuilder;
struct SaveBagRequestT;

struct SaveBagResponse;
struct SaveBagResponseBuilder;
struct SaveBagResponseT;

struct DetectionArray;
struct DetectionArrayBuilder;
struct DetectionArrayT;

struct Detection;
struct DetectionBuilder;
struct DetectionT;

struct ArcLabelAndBagRequest;
struct ArcLabelAndBagRequestBuilder;
struct ArcLabelAndBagRequestT;

struct ArcLabelAndBagResponse;
struct ArcLabelAndBagResponseBuilder;
struct ArcLabelAndBagResponseT;

struct CircLabelAndBagRequest;
struct CircLabelAndBagRequestBuilder;
struct CircLabelAndBagRequestT;

struct CircLabelAndBagResponse;
struct CircLabelAndBagResponseBuilder;
struct CircLabelAndBagResponseT;

struct LegArray;
struct LegArrayBuilder;
struct LegArrayT;

struct Person;
struct PersonBuilder;
struct PersonT;

struct ArcLabelRequest;
struct ArcLabelRequestBuilder;
struct ArcLabelRequestT;

struct ArcLabelResponse;
struct ArcLabelResponseBuilder;
struct ArcLabelResponseT;

struct CartesianLabelAndBagRequest;
struct CartesianLabelAndBagRequestBuilder;
struct CartesianLabelAndBagRequestT;

struct CartesianLabelAndBagResponse;
struct CartesianLabelAndBagResponseBuilder;
struct CartesianLabelAndBagResponseT;

struct CircLabelRequest;
struct CircLabelRequestBuilder;
struct CircLabelRequestT;

struct CircLabelResponse;
struct CircLabelResponseBuilder;
struct CircLabelResponseT;

struct CartesianLabelRequest;
struct CartesianLabelRequestBuilder;
struct CartesianLabelRequestT;

struct CartesianLabelResponse;
struct CartesianLabelResponseBuilder;
struct CartesianLabelResponseT;

struct Leg;
struct LegBuilder;
struct LegT;

struct PersonArray;
struct PersonArrayBuilder;
struct PersonArrayT;

struct SaveBagRequestT : public ::flatbuffers::NativeTable {
  typedef SaveBagRequest TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::vector<std::string> topics{};
  std::string filename{};
  uint8_t duration_sec = 0;
  SaveBagRequestT() = default;
  SaveBagRequestT(const SaveBagRequestT &o);
  SaveBagRequestT(SaveBagRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  SaveBagRequestT &operator=(SaveBagRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct SaveBagRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SaveBagRequestT NativeTableType;
  typedef SaveBagRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_TOPICS = 6,
    VT_FILENAME = 8,
    VT_DURATION_SEC = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *topics() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_TOPICS);
  }
  const ::flatbuffers::String *filename() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILENAME);
  }
  uint8_t duration_sec() const {
    return GetField<uint8_t>(VT_DURATION_SEC, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_TOPICS) &&
           verifier.VerifyVector(topics()) &&
           verifier.VerifyVectorOfStrings(topics()) &&
           VerifyOffsetRequired(verifier, VT_FILENAME) &&
           verifier.VerifyString(filename()) &&
           VerifyField<uint8_t>(verifier, VT_DURATION_SEC, 1) &&
           verifier.EndTable();
  }
  SaveBagRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SaveBagRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SaveBagRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SaveBagRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SaveBagRequestBuilder {
  typedef SaveBagRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(SaveBagRequest::VT___METADATA, __metadata);
  }
  void add_topics(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> topics) {
    fbb_.AddOffset(SaveBagRequest::VT_TOPICS, topics);
  }
  void add_filename(::flatbuffers::Offset<::flatbuffers::String> filename) {
    fbb_.AddOffset(SaveBagRequest::VT_FILENAME, filename);
  }
  void add_duration_sec(uint8_t duration_sec) {
    fbb_.AddElement<uint8_t>(SaveBagRequest::VT_DURATION_SEC, duration_sec, 0);
  }
  explicit SaveBagRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SaveBagRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SaveBagRequest>(end);
    fbb_.Required(o, SaveBagRequest::VT_TOPICS);
    fbb_.Required(o, SaveBagRequest::VT_FILENAME);
    return o;
  }
};

inline ::flatbuffers::Offset<SaveBagRequest> CreateSaveBagRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> topics = 0,
    ::flatbuffers::Offset<::flatbuffers::String> filename = 0,
    uint8_t duration_sec = 0) {
  SaveBagRequestBuilder builder_(_fbb);
  builder_.add_filename(filename);
  builder_.add_topics(topics);
  builder_.add___metadata(__metadata);
  builder_.add_duration_sec(duration_sec);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SaveBagRequest> CreateSaveBagRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *topics = nullptr,
    const char *filename = nullptr,
    uint8_t duration_sec = 0) {
  auto topics__ = topics ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*topics) : 0;
  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
  return fb::leg_tracker::CreateSaveBagRequest(
      _fbb,
      __metadata,
      topics__,
      filename__,
      duration_sec);
}

::flatbuffers::Offset<SaveBagRequest> CreateSaveBagRequest(::flatbuffers::FlatBufferBuilder &_fbb, const SaveBagRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SaveBagResponseT : public ::flatbuffers::NativeTable {
  typedef SaveBagResponse TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  SaveBagResponseT() = default;
  SaveBagResponseT(const SaveBagResponseT &o);
  SaveBagResponseT(SaveBagResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  SaveBagResponseT &operator=(SaveBagResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct SaveBagResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SaveBagResponseT NativeTableType;
  typedef SaveBagResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           verifier.EndTable();
  }
  SaveBagResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SaveBagResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SaveBagResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SaveBagResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SaveBagResponseBuilder {
  typedef SaveBagResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(SaveBagResponse::VT___METADATA, __metadata);
  }
  explicit SaveBagResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SaveBagResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SaveBagResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SaveBagResponse> CreateSaveBagResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0) {
  SaveBagResponseBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<SaveBagResponse> CreateSaveBagResponse(::flatbuffers::FlatBufferBuilder &_fbb, const SaveBagResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DetectionArrayT : public ::flatbuffers::NativeTable {
  typedef DetectionArray TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::vector<std::unique_ptr<fb::leg_tracker::DetectionT>> detections{};
  DetectionArrayT() = default;
  DetectionArrayT(const DetectionArrayT &o);
  DetectionArrayT(DetectionArrayT&&) FLATBUFFERS_NOEXCEPT = default;
  DetectionArrayT &operator=(DetectionArrayT o) FLATBUFFERS_NOEXCEPT;
};

struct DetectionArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DetectionArrayT NativeTableType;
  typedef DetectionArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_DETECTIONS = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::leg_tracker::Detection>> *detections() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::leg_tracker::Detection>> *>(VT_DETECTIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_DETECTIONS) &&
           verifier.VerifyVector(detections()) &&
           verifier.VerifyVectorOfTables(detections()) &&
           verifier.EndTable();
  }
  DetectionArrayT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DetectionArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DetectionArray> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DetectionArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DetectionArrayBuilder {
  typedef DetectionArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(DetectionArray::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(DetectionArray::VT_HEADER, header);
  }
  void add_detections(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::leg_tracker::Detection>>> detections) {
    fbb_.AddOffset(DetectionArray::VT_DETECTIONS, detections);
  }
  explicit DetectionArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DetectionArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DetectionArray>(end);
    fbb_.Required(o, DetectionArray::VT_HEADER);
    fbb_.Required(o, DetectionArray::VT_DETECTIONS);
    return o;
  }
};

inline ::flatbuffers::Offset<DetectionArray> CreateDetectionArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::leg_tracker::Detection>>> detections = 0) {
  DetectionArrayBuilder builder_(_fbb);
  builder_.add_detections(detections);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DetectionArray> CreateDetectionArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const std::vector<::flatbuffers::Offset<fb::leg_tracker::Detection>> *detections = nullptr) {
  auto detections__ = detections ? _fbb.CreateVector<::flatbuffers::Offset<fb::leg_tracker::Detection>>(*detections) : 0;
  return fb::leg_tracker::CreateDetectionArray(
      _fbb,
      __metadata,
      header,
      detections__);
}

::flatbuffers::Offset<DetectionArray> CreateDetectionArray(::flatbuffers::FlatBufferBuilder &_fbb, const DetectionArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DetectionT : public ::flatbuffers::NativeTable {
  typedef Detection TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::geometry_msgs::PointT> position{};
  float confidence = 0.0f;
  int32_t label = 0;
  DetectionT() = default;
  DetectionT(const DetectionT &o);
  DetectionT(DetectionT&&) FLATBUFFERS_NOEXCEPT = default;
  DetectionT &operator=(DetectionT o) FLATBUFFERS_NOEXCEPT;
};

struct Detection FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DetectionT NativeTableType;
  typedef DetectionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_POSITION = 6,
    VT_CONFIDENCE = 8,
    VT_LABEL = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Point *position() const {
    return GetPointer<const fb::geometry_msgs::Point *>(VT_POSITION);
  }
  float confidence() const {
    return GetField<float>(VT_CONFIDENCE, 0.0f);
  }
  int32_t label() const {
    return GetField<int32_t>(VT_LABEL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_POSITION) &&
           verifier.VerifyTable(position()) &&
           VerifyField<float>(verifier, VT_CONFIDENCE, 4) &&
           VerifyField<int32_t>(verifier, VT_LABEL, 4) &&
           verifier.EndTable();
  }
  DetectionT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DetectionT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Detection> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DetectionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DetectionBuilder {
  typedef Detection Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Detection::VT___METADATA, __metadata);
  }
  void add_position(::flatbuffers::Offset<fb::geometry_msgs::Point> position) {
    fbb_.AddOffset(Detection::VT_POSITION, position);
  }
  void add_confidence(float confidence) {
    fbb_.AddElement<float>(Detection::VT_CONFIDENCE, confidence, 0.0f);
  }
  void add_label(int32_t label) {
    fbb_.AddElement<int32_t>(Detection::VT_LABEL, label, 0);
  }
  explicit DetectionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Detection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Detection>(end);
    fbb_.Required(o, Detection::VT_POSITION);
    return o;
  }
};

inline ::flatbuffers::Offset<Detection> CreateDetection(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Point> position = 0,
    float confidence = 0.0f,
    int32_t label = 0) {
  DetectionBuilder builder_(_fbb);
  builder_.add_label(label);
  builder_.add_confidence(confidence);
  builder_.add_position(position);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<Detection> CreateDetection(::flatbuffers::FlatBufferBuilder &_fbb, const DetectionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArcLabelAndBagRequestT : public ::flatbuffers::NativeTable {
  typedef ArcLabelAndBagRequest TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string scan_topic{};
  std::string laser_frame{};
  std::string label_frame{};
  uint8_t class_label = 0;
  std::string filename{};
  float min_angle = 0.0f;
  float max_angle = 0.0f;
  float max_radius = 0.0f;
  uint8_t duration_sec = 0;
  ArcLabelAndBagRequestT() = default;
  ArcLabelAndBagRequestT(const ArcLabelAndBagRequestT &o);
  ArcLabelAndBagRequestT(ArcLabelAndBagRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  ArcLabelAndBagRequestT &operator=(ArcLabelAndBagRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct ArcLabelAndBagRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArcLabelAndBagRequestT NativeTableType;
  typedef ArcLabelAndBagRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_SCAN_TOPIC = 6,
    VT_LASER_FRAME = 8,
    VT_LABEL_FRAME = 10,
    VT_CLASS_LABEL = 12,
    VT_FILENAME = 14,
    VT_MIN_ANGLE = 16,
    VT_MAX_ANGLE = 18,
    VT_MAX_RADIUS = 20,
    VT_DURATION_SEC = 22
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *scan_topic() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SCAN_TOPIC);
  }
  const ::flatbuffers::String *laser_frame() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LASER_FRAME);
  }
  const ::flatbuffers::String *label_frame() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LABEL_FRAME);
  }
  uint8_t class_label() const {
    return GetField<uint8_t>(VT_CLASS_LABEL, 0);
  }
  const ::flatbuffers::String *filename() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILENAME);
  }
  float min_angle() const {
    return GetField<float>(VT_MIN_ANGLE, 0.0f);
  }
  float max_angle() const {
    return GetField<float>(VT_MAX_ANGLE, 0.0f);
  }
  float max_radius() const {
    return GetField<float>(VT_MAX_RADIUS, 0.0f);
  }
  uint8_t duration_sec() const {
    return GetField<uint8_t>(VT_DURATION_SEC, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_SCAN_TOPIC) &&
           verifier.VerifyString(scan_topic()) &&
           VerifyOffsetRequired(verifier, VT_LASER_FRAME) &&
           verifier.VerifyString(laser_frame()) &&
           VerifyOffsetRequired(verifier, VT_LABEL_FRAME) &&
           verifier.VerifyString(label_frame()) &&
           VerifyField<uint8_t>(verifier, VT_CLASS_LABEL, 1) &&
           VerifyOffsetRequired(verifier, VT_FILENAME) &&
           verifier.VerifyString(filename()) &&
           VerifyField<float>(verifier, VT_MIN_ANGLE, 4) &&
           VerifyField<float>(verifier, VT_MAX_ANGLE, 4) &&
           VerifyField<float>(verifier, VT_MAX_RADIUS, 4) &&
           VerifyField<uint8_t>(verifier, VT_DURATION_SEC, 1) &&
           verifier.EndTable();
  }
  ArcLabelAndBagRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArcLabelAndBagRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ArcLabelAndBagRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ArcLabelAndBagRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArcLabelAndBagRequestBuilder {
  typedef ArcLabelAndBagRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ArcLabelAndBagRequest::VT___METADATA, __metadata);
  }
  void add_scan_topic(::flatbuffers::Offset<::flatbuffers::String> scan_topic) {
    fbb_.AddOffset(ArcLabelAndBagRequest::VT_SCAN_TOPIC, scan_topic);
  }
  void add_laser_frame(::flatbuffers::Offset<::flatbuffers::String> laser_frame) {
    fbb_.AddOffset(ArcLabelAndBagRequest::VT_LASER_FRAME, laser_frame);
  }
  void add_label_frame(::flatbuffers::Offset<::flatbuffers::String> label_frame) {
    fbb_.AddOffset(ArcLabelAndBagRequest::VT_LABEL_FRAME, label_frame);
  }
  void add_class_label(uint8_t class_label) {
    fbb_.AddElement<uint8_t>(ArcLabelAndBagRequest::VT_CLASS_LABEL, class_label, 0);
  }
  void add_filename(::flatbuffers::Offset<::flatbuffers::String> filename) {
    fbb_.AddOffset(ArcLabelAndBagRequest::VT_FILENAME, filename);
  }
  void add_min_angle(float min_angle) {
    fbb_.AddElement<float>(ArcLabelAndBagRequest::VT_MIN_ANGLE, min_angle, 0.0f);
  }
  void add_max_angle(float max_angle) {
    fbb_.AddElement<float>(ArcLabelAndBagRequest::VT_MAX_ANGLE, max_angle, 0.0f);
  }
  void add_max_radius(float max_radius) {
    fbb_.AddElement<float>(ArcLabelAndBagRequest::VT_MAX_RADIUS, max_radius, 0.0f);
  }
  void add_duration_sec(uint8_t duration_sec) {
    fbb_.AddElement<uint8_t>(ArcLabelAndBagRequest::VT_DURATION_SEC, duration_sec, 0);
  }
  explicit ArcLabelAndBagRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArcLabelAndBagRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArcLabelAndBagRequest>(end);
    fbb_.Required(o, ArcLabelAndBagRequest::VT_SCAN_TOPIC);
    fbb_.Required(o, ArcLabelAndBagRequest::VT_LASER_FRAME);
    fbb_.Required(o, ArcLabelAndBagRequest::VT_LABEL_FRAME);
    fbb_.Required(o, ArcLabelAndBagRequest::VT_FILENAME);
    return o;
  }
};

inline ::flatbuffers::Offset<ArcLabelAndBagRequest> CreateArcLabelAndBagRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> scan_topic = 0,
    ::flatbuffers::Offset<::flatbuffers::String> laser_frame = 0,
    ::flatbuffers::Offset<::flatbuffers::String> label_frame = 0,
    uint8_t class_label = 0,
    ::flatbuffers::Offset<::flatbuffers::String> filename = 0,
    float min_angle = 0.0f,
    float max_angle = 0.0f,
    float max_radius = 0.0f,
    uint8_t duration_sec = 0) {
  ArcLabelAndBagRequestBuilder builder_(_fbb);
  builder_.add_max_radius(max_radius);
  builder_.add_max_angle(max_angle);
  builder_.add_min_angle(min_angle);
  builder_.add_filename(filename);
  builder_.add_label_frame(label_frame);
  builder_.add_laser_frame(laser_frame);
  builder_.add_scan_topic(scan_topic);
  builder_.add___metadata(__metadata);
  builder_.add_duration_sec(duration_sec);
  builder_.add_class_label(class_label);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArcLabelAndBagRequest> CreateArcLabelAndBagRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *scan_topic = nullptr,
    const char *laser_frame = nullptr,
    const char *label_frame = nullptr,
    uint8_t class_label = 0,
    const char *filename = nullptr,
    float min_angle = 0.0f,
    float max_angle = 0.0f,
    float max_radius = 0.0f,
    uint8_t duration_sec = 0) {
  auto scan_topic__ = scan_topic ? _fbb.CreateString(scan_topic) : 0;
  auto laser_frame__ = laser_frame ? _fbb.CreateString(laser_frame) : 0;
  auto label_frame__ = label_frame ? _fbb.CreateString(label_frame) : 0;
  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
  return fb::leg_tracker::CreateArcLabelAndBagRequest(
      _fbb,
      __metadata,
      scan_topic__,
      laser_frame__,
      label_frame__,
      class_label,
      filename__,
      min_angle,
      max_angle,
      max_radius,
      duration_sec);
}

::flatbuffers::Offset<ArcLabelAndBagRequest> CreateArcLabelAndBagRequest(::flatbuffers::FlatBufferBuilder &_fbb, const ArcLabelAndBagRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArcLabelAndBagResponseT : public ::flatbuffers::NativeTable {
  typedef ArcLabelAndBagResponse TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  ArcLabelAndBagResponseT() = default;
  ArcLabelAndBagResponseT(const ArcLabelAndBagResponseT &o);
  ArcLabelAndBagResponseT(ArcLabelAndBagResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  ArcLabelAndBagResponseT &operator=(ArcLabelAndBagResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct ArcLabelAndBagResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArcLabelAndBagResponseT NativeTableType;
  typedef ArcLabelAndBagResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           verifier.EndTable();
  }
  ArcLabelAndBagResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArcLabelAndBagResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ArcLabelAndBagResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ArcLabelAndBagResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArcLabelAndBagResponseBuilder {
  typedef ArcLabelAndBagResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ArcLabelAndBagResponse::VT___METADATA, __metadata);
  }
  explicit ArcLabelAndBagResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArcLabelAndBagResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArcLabelAndBagResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArcLabelAndBagResponse> CreateArcLabelAndBagResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0) {
  ArcLabelAndBagResponseBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<ArcLabelAndBagResponse> CreateArcLabelAndBagResponse(::flatbuffers::FlatBufferBuilder &_fbb, const ArcLabelAndBagResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CircLabelAndBagRequestT : public ::flatbuffers::NativeTable {
  typedef CircLabelAndBagRequest TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string scan_topic{};
  std::string laser_frame{};
  std::string label_frame{};
  uint8_t class_label = 0;
  std::string filename{};
  float x_center = 0.0f;
  float y_center = 0.0f;
  float radius = 0.0f;
  uint8_t duration_sec = 0;
  CircLabelAndBagRequestT() = default;
  CircLabelAndBagRequestT(const CircLabelAndBagRequestT &o);
  CircLabelAndBagRequestT(CircLabelAndBagRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  CircLabelAndBagRequestT &operator=(CircLabelAndBagRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct CircLabelAndBagRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CircLabelAndBagRequestT NativeTableType;
  typedef CircLabelAndBagRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_SCAN_TOPIC = 6,
    VT_LASER_FRAME = 8,
    VT_LABEL_FRAME = 10,
    VT_CLASS_LABEL = 12,
    VT_FILENAME = 14,
    VT_X_CENTER = 16,
    VT_Y_CENTER = 18,
    VT_RADIUS = 20,
    VT_DURATION_SEC = 22
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *scan_topic() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SCAN_TOPIC);
  }
  const ::flatbuffers::String *laser_frame() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LASER_FRAME);
  }
  const ::flatbuffers::String *label_frame() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LABEL_FRAME);
  }
  uint8_t class_label() const {
    return GetField<uint8_t>(VT_CLASS_LABEL, 0);
  }
  const ::flatbuffers::String *filename() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILENAME);
  }
  float x_center() const {
    return GetField<float>(VT_X_CENTER, 0.0f);
  }
  float y_center() const {
    return GetField<float>(VT_Y_CENTER, 0.0f);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  uint8_t duration_sec() const {
    return GetField<uint8_t>(VT_DURATION_SEC, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_SCAN_TOPIC) &&
           verifier.VerifyString(scan_topic()) &&
           VerifyOffsetRequired(verifier, VT_LASER_FRAME) &&
           verifier.VerifyString(laser_frame()) &&
           VerifyOffsetRequired(verifier, VT_LABEL_FRAME) &&
           verifier.VerifyString(label_frame()) &&
           VerifyField<uint8_t>(verifier, VT_CLASS_LABEL, 1) &&
           VerifyOffsetRequired(verifier, VT_FILENAME) &&
           verifier.VerifyString(filename()) &&
           VerifyField<float>(verifier, VT_X_CENTER, 4) &&
           VerifyField<float>(verifier, VT_Y_CENTER, 4) &&
           VerifyField<float>(verifier, VT_RADIUS, 4) &&
           VerifyField<uint8_t>(verifier, VT_DURATION_SEC, 1) &&
           verifier.EndTable();
  }
  CircLabelAndBagRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CircLabelAndBagRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CircLabelAndBagRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CircLabelAndBagRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CircLabelAndBagRequestBuilder {
  typedef CircLabelAndBagRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(CircLabelAndBagRequest::VT___METADATA, __metadata);
  }
  void add_scan_topic(::flatbuffers::Offset<::flatbuffers::String> scan_topic) {
    fbb_.AddOffset(CircLabelAndBagRequest::VT_SCAN_TOPIC, scan_topic);
  }
  void add_laser_frame(::flatbuffers::Offset<::flatbuffers::String> laser_frame) {
    fbb_.AddOffset(CircLabelAndBagRequest::VT_LASER_FRAME, laser_frame);
  }
  void add_label_frame(::flatbuffers::Offset<::flatbuffers::String> label_frame) {
    fbb_.AddOffset(CircLabelAndBagRequest::VT_LABEL_FRAME, label_frame);
  }
  void add_class_label(uint8_t class_label) {
    fbb_.AddElement<uint8_t>(CircLabelAndBagRequest::VT_CLASS_LABEL, class_label, 0);
  }
  void add_filename(::flatbuffers::Offset<::flatbuffers::String> filename) {
    fbb_.AddOffset(CircLabelAndBagRequest::VT_FILENAME, filename);
  }
  void add_x_center(float x_center) {
    fbb_.AddElement<float>(CircLabelAndBagRequest::VT_X_CENTER, x_center, 0.0f);
  }
  void add_y_center(float y_center) {
    fbb_.AddElement<float>(CircLabelAndBagRequest::VT_Y_CENTER, y_center, 0.0f);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(CircLabelAndBagRequest::VT_RADIUS, radius, 0.0f);
  }
  void add_duration_sec(uint8_t duration_sec) {
    fbb_.AddElement<uint8_t>(CircLabelAndBagRequest::VT_DURATION_SEC, duration_sec, 0);
  }
  explicit CircLabelAndBagRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CircLabelAndBagRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CircLabelAndBagRequest>(end);
    fbb_.Required(o, CircLabelAndBagRequest::VT_SCAN_TOPIC);
    fbb_.Required(o, CircLabelAndBagRequest::VT_LASER_FRAME);
    fbb_.Required(o, CircLabelAndBagRequest::VT_LABEL_FRAME);
    fbb_.Required(o, CircLabelAndBagRequest::VT_FILENAME);
    return o;
  }
};

inline ::flatbuffers::Offset<CircLabelAndBagRequest> CreateCircLabelAndBagRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> scan_topic = 0,
    ::flatbuffers::Offset<::flatbuffers::String> laser_frame = 0,
    ::flatbuffers::Offset<::flatbuffers::String> label_frame = 0,
    uint8_t class_label = 0,
    ::flatbuffers::Offset<::flatbuffers::String> filename = 0,
    float x_center = 0.0f,
    float y_center = 0.0f,
    float radius = 0.0f,
    uint8_t duration_sec = 0) {
  CircLabelAndBagRequestBuilder builder_(_fbb);
  builder_.add_radius(radius);
  builder_.add_y_center(y_center);
  builder_.add_x_center(x_center);
  builder_.add_filename(filename);
  builder_.add_label_frame(label_frame);
  builder_.add_laser_frame(laser_frame);
  builder_.add_scan_topic(scan_topic);
  builder_.add___metadata(__metadata);
  builder_.add_duration_sec(duration_sec);
  builder_.add_class_label(class_label);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CircLabelAndBagRequest> CreateCircLabelAndBagRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *scan_topic = nullptr,
    const char *laser_frame = nullptr,
    const char *label_frame = nullptr,
    uint8_t class_label = 0,
    const char *filename = nullptr,
    float x_center = 0.0f,
    float y_center = 0.0f,
    float radius = 0.0f,
    uint8_t duration_sec = 0) {
  auto scan_topic__ = scan_topic ? _fbb.CreateString(scan_topic) : 0;
  auto laser_frame__ = laser_frame ? _fbb.CreateString(laser_frame) : 0;
  auto label_frame__ = label_frame ? _fbb.CreateString(label_frame) : 0;
  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
  return fb::leg_tracker::CreateCircLabelAndBagRequest(
      _fbb,
      __metadata,
      scan_topic__,
      laser_frame__,
      label_frame__,
      class_label,
      filename__,
      x_center,
      y_center,
      radius,
      duration_sec);
}

::flatbuffers::Offset<CircLabelAndBagRequest> CreateCircLabelAndBagRequest(::flatbuffers::FlatBufferBuilder &_fbb, const CircLabelAndBagRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CircLabelAndBagResponseT : public ::flatbuffers::NativeTable {
  typedef CircLabelAndBagResponse TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  CircLabelAndBagResponseT() = default;
  CircLabelAndBagResponseT(const CircLabelAndBagResponseT &o);
  CircLabelAndBagResponseT(CircLabelAndBagResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  CircLabelAndBagResponseT &operator=(CircLabelAndBagResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct CircLabelAndBagResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CircLabelAndBagResponseT NativeTableType;
  typedef CircLabelAndBagResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           verifier.EndTable();
  }
  CircLabelAndBagResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CircLabelAndBagResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CircLabelAndBagResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CircLabelAndBagResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CircLabelAndBagResponseBuilder {
  typedef CircLabelAndBagResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(CircLabelAndBagResponse::VT___METADATA, __metadata);
  }
  explicit CircLabelAndBagResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CircLabelAndBagResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CircLabelAndBagResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CircLabelAndBagResponse> CreateCircLabelAndBagResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0) {
  CircLabelAndBagResponseBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<CircLabelAndBagResponse> CreateCircLabelAndBagResponse(::flatbuffers::FlatBufferBuilder &_fbb, const CircLabelAndBagResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LegArrayT : public ::flatbuffers::NativeTable {
  typedef LegArray TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::vector<std::unique_ptr<fb::leg_tracker::LegT>> legs{};
  LegArrayT() = default;
  LegArrayT(const LegArrayT &o);
  LegArrayT(LegArrayT&&) FLATBUFFERS_NOEXCEPT = default;
  LegArrayT &operator=(LegArrayT o) FLATBUFFERS_NOEXCEPT;
};

struct LegArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LegArrayT NativeTableType;
  typedef LegArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_LEGS = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::leg_tracker::Leg>> *legs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::leg_tracker::Leg>> *>(VT_LEGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_LEGS) &&
           verifier.VerifyVector(legs()) &&
           verifier.VerifyVectorOfTables(legs()) &&
           verifier.EndTable();
  }
  LegArrayT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LegArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<LegArray> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LegArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LegArrayBuilder {
  typedef LegArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(LegArray::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(LegArray::VT_HEADER, header);
  }
  void add_legs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::leg_tracker::Leg>>> legs) {
    fbb_.AddOffset(LegArray::VT_LEGS, legs);
  }
  explicit LegArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LegArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LegArray>(end);
    fbb_.Required(o, LegArray::VT_HEADER);
    fbb_.Required(o, LegArray::VT_LEGS);
    return o;
  }
};

inline ::flatbuffers::Offset<LegArray> CreateLegArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::leg_tracker::Leg>>> legs = 0) {
  LegArrayBuilder builder_(_fbb);
  builder_.add_legs(legs);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LegArray> CreateLegArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const std::vector<::flatbuffers::Offset<fb::leg_tracker::Leg>> *legs = nullptr) {
  auto legs__ = legs ? _fbb.CreateVector<::flatbuffers::Offset<fb::leg_tracker::Leg>>(*legs) : 0;
  return fb::leg_tracker::CreateLegArray(
      _fbb,
      __metadata,
      header,
      legs__);
}

::flatbuffers::Offset<LegArray> CreateLegArray(::flatbuffers::FlatBufferBuilder &_fbb, const LegArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PersonT : public ::flatbuffers::NativeTable {
  typedef Person TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::geometry_msgs::PoseT> pose{};
  uint32_t id = 0;
  PersonT() = default;
  PersonT(const PersonT &o);
  PersonT(PersonT&&) FLATBUFFERS_NOEXCEPT = default;
  PersonT &operator=(PersonT o) FLATBUFFERS_NOEXCEPT;
};

struct Person FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PersonT NativeTableType;
  typedef PersonBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_POSE = 6,
    VT_ID = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Pose *pose() const {
    return GetPointer<const fb::geometry_msgs::Pose *>(VT_POSE);
  }
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           verifier.EndTable();
  }
  PersonT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PersonT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Person> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PersonT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PersonBuilder {
  typedef Person Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Person::VT___METADATA, __metadata);
  }
  void add_pose(::flatbuffers::Offset<fb::geometry_msgs::Pose> pose) {
    fbb_.AddOffset(Person::VT_POSE, pose);
  }
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(Person::VT_ID, id, 0);
  }
  explicit PersonBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Person> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Person>(end);
    fbb_.Required(o, Person::VT_POSE);
    return o;
  }
};

inline ::flatbuffers::Offset<Person> CreatePerson(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Pose> pose = 0,
    uint32_t id = 0) {
  PersonBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_pose(pose);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<Person> CreatePerson(::flatbuffers::FlatBufferBuilder &_fbb, const PersonT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArcLabelRequestT : public ::flatbuffers::NativeTable {
  typedef ArcLabelRequest TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string scan_topic{};
  std::string laser_frame{};
  std::string label_frame{};
  uint8_t class_label = 0;
  std::string filename{};
  float min_angle = 0.0f;
  float max_angle = 0.0f;
  float max_radius = 0.0f;
  ArcLabelRequestT() = default;
  ArcLabelRequestT(const ArcLabelRequestT &o);
  ArcLabelRequestT(ArcLabelRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  ArcLabelRequestT &operator=(ArcLabelRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct ArcLabelRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArcLabelRequestT NativeTableType;
  typedef ArcLabelRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_SCAN_TOPIC = 6,
    VT_LASER_FRAME = 8,
    VT_LABEL_FRAME = 10,
    VT_CLASS_LABEL = 12,
    VT_FILENAME = 14,
    VT_MIN_ANGLE = 16,
    VT_MAX_ANGLE = 18,
    VT_MAX_RADIUS = 20
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *scan_topic() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SCAN_TOPIC);
  }
  const ::flatbuffers::String *laser_frame() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LASER_FRAME);
  }
  const ::flatbuffers::String *label_frame() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LABEL_FRAME);
  }
  uint8_t class_label() const {
    return GetField<uint8_t>(VT_CLASS_LABEL, 0);
  }
  const ::flatbuffers::String *filename() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILENAME);
  }
  float min_angle() const {
    return GetField<float>(VT_MIN_ANGLE, 0.0f);
  }
  float max_angle() const {
    return GetField<float>(VT_MAX_ANGLE, 0.0f);
  }
  float max_radius() const {
    return GetField<float>(VT_MAX_RADIUS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_SCAN_TOPIC) &&
           verifier.VerifyString(scan_topic()) &&
           VerifyOffsetRequired(verifier, VT_LASER_FRAME) &&
           verifier.VerifyString(laser_frame()) &&
           VerifyOffsetRequired(verifier, VT_LABEL_FRAME) &&
           verifier.VerifyString(label_frame()) &&
           VerifyField<uint8_t>(verifier, VT_CLASS_LABEL, 1) &&
           VerifyOffsetRequired(verifier, VT_FILENAME) &&
           verifier.VerifyString(filename()) &&
           VerifyField<float>(verifier, VT_MIN_ANGLE, 4) &&
           VerifyField<float>(verifier, VT_MAX_ANGLE, 4) &&
           VerifyField<float>(verifier, VT_MAX_RADIUS, 4) &&
           verifier.EndTable();
  }
  ArcLabelRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArcLabelRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ArcLabelRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ArcLabelRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArcLabelRequestBuilder {
  typedef ArcLabelRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ArcLabelRequest::VT___METADATA, __metadata);
  }
  void add_scan_topic(::flatbuffers::Offset<::flatbuffers::String> scan_topic) {
    fbb_.AddOffset(ArcLabelRequest::VT_SCAN_TOPIC, scan_topic);
  }
  void add_laser_frame(::flatbuffers::Offset<::flatbuffers::String> laser_frame) {
    fbb_.AddOffset(ArcLabelRequest::VT_LASER_FRAME, laser_frame);
  }
  void add_label_frame(::flatbuffers::Offset<::flatbuffers::String> label_frame) {
    fbb_.AddOffset(ArcLabelRequest::VT_LABEL_FRAME, label_frame);
  }
  void add_class_label(uint8_t class_label) {
    fbb_.AddElement<uint8_t>(ArcLabelRequest::VT_CLASS_LABEL, class_label, 0);
  }
  void add_filename(::flatbuffers::Offset<::flatbuffers::String> filename) {
    fbb_.AddOffset(ArcLabelRequest::VT_FILENAME, filename);
  }
  void add_min_angle(float min_angle) {
    fbb_.AddElement<float>(ArcLabelRequest::VT_MIN_ANGLE, min_angle, 0.0f);
  }
  void add_max_angle(float max_angle) {
    fbb_.AddElement<float>(ArcLabelRequest::VT_MAX_ANGLE, max_angle, 0.0f);
  }
  void add_max_radius(float max_radius) {
    fbb_.AddElement<float>(ArcLabelRequest::VT_MAX_RADIUS, max_radius, 0.0f);
  }
  explicit ArcLabelRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArcLabelRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArcLabelRequest>(end);
    fbb_.Required(o, ArcLabelRequest::VT_SCAN_TOPIC);
    fbb_.Required(o, ArcLabelRequest::VT_LASER_FRAME);
    fbb_.Required(o, ArcLabelRequest::VT_LABEL_FRAME);
    fbb_.Required(o, ArcLabelRequest::VT_FILENAME);
    return o;
  }
};

inline ::flatbuffers::Offset<ArcLabelRequest> CreateArcLabelRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> scan_topic = 0,
    ::flatbuffers::Offset<::flatbuffers::String> laser_frame = 0,
    ::flatbuffers::Offset<::flatbuffers::String> label_frame = 0,
    uint8_t class_label = 0,
    ::flatbuffers::Offset<::flatbuffers::String> filename = 0,
    float min_angle = 0.0f,
    float max_angle = 0.0f,
    float max_radius = 0.0f) {
  ArcLabelRequestBuilder builder_(_fbb);
  builder_.add_max_radius(max_radius);
  builder_.add_max_angle(max_angle);
  builder_.add_min_angle(min_angle);
  builder_.add_filename(filename);
  builder_.add_label_frame(label_frame);
  builder_.add_laser_frame(laser_frame);
  builder_.add_scan_topic(scan_topic);
  builder_.add___metadata(__metadata);
  builder_.add_class_label(class_label);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArcLabelRequest> CreateArcLabelRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *scan_topic = nullptr,
    const char *laser_frame = nullptr,
    const char *label_frame = nullptr,
    uint8_t class_label = 0,
    const char *filename = nullptr,
    float min_angle = 0.0f,
    float max_angle = 0.0f,
    float max_radius = 0.0f) {
  auto scan_topic__ = scan_topic ? _fbb.CreateString(scan_topic) : 0;
  auto laser_frame__ = laser_frame ? _fbb.CreateString(laser_frame) : 0;
  auto label_frame__ = label_frame ? _fbb.CreateString(label_frame) : 0;
  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
  return fb::leg_tracker::CreateArcLabelRequest(
      _fbb,
      __metadata,
      scan_topic__,
      laser_frame__,
      label_frame__,
      class_label,
      filename__,
      min_angle,
      max_angle,
      max_radius);
}

::flatbuffers::Offset<ArcLabelRequest> CreateArcLabelRequest(::flatbuffers::FlatBufferBuilder &_fbb, const ArcLabelRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArcLabelResponseT : public ::flatbuffers::NativeTable {
  typedef ArcLabelResponse TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  ArcLabelResponseT() = default;
  ArcLabelResponseT(const ArcLabelResponseT &o);
  ArcLabelResponseT(ArcLabelResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  ArcLabelResponseT &operator=(ArcLabelResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct ArcLabelResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArcLabelResponseT NativeTableType;
  typedef ArcLabelResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           verifier.EndTable();
  }
  ArcLabelResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArcLabelResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ArcLabelResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ArcLabelResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArcLabelResponseBuilder {
  typedef ArcLabelResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ArcLabelResponse::VT___METADATA, __metadata);
  }
  explicit ArcLabelResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArcLabelResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArcLabelResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArcLabelResponse> CreateArcLabelResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0) {
  ArcLabelResponseBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<ArcLabelResponse> CreateArcLabelResponse(::flatbuffers::FlatBufferBuilder &_fbb, const ArcLabelResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CartesianLabelAndBagRequestT : public ::flatbuffers::NativeTable {
  typedef CartesianLabelAndBagRequest TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string scan_topic{};
  std::string laser_frame{};
  std::string label_frame{};
  uint8_t class_label = 0;
  std::string filename{};
  float x_center = 0.0f;
  float y_center = 0.0f;
  float x_length = 0.0f;
  float y_width = 0.0f;
  float yaw = 0.0f;
  uint8_t duration_sec = 0;
  CartesianLabelAndBagRequestT() = default;
  CartesianLabelAndBagRequestT(const CartesianLabelAndBagRequestT &o);
  CartesianLabelAndBagRequestT(CartesianLabelAndBagRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  CartesianLabelAndBagRequestT &operator=(CartesianLabelAndBagRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct CartesianLabelAndBagRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CartesianLabelAndBagRequestT NativeTableType;
  typedef CartesianLabelAndBagRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_SCAN_TOPIC = 6,
    VT_LASER_FRAME = 8,
    VT_LABEL_FRAME = 10,
    VT_CLASS_LABEL = 12,
    VT_FILENAME = 14,
    VT_X_CENTER = 16,
    VT_Y_CENTER = 18,
    VT_X_LENGTH = 20,
    VT_Y_WIDTH = 22,
    VT_YAW = 24,
    VT_DURATION_SEC = 26
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *scan_topic() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SCAN_TOPIC);
  }
  const ::flatbuffers::String *laser_frame() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LASER_FRAME);
  }
  const ::flatbuffers::String *label_frame() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LABEL_FRAME);
  }
  uint8_t class_label() const {
    return GetField<uint8_t>(VT_CLASS_LABEL, 0);
  }
  const ::flatbuffers::String *filename() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILENAME);
  }
  float x_center() const {
    return GetField<float>(VT_X_CENTER, 0.0f);
  }
  float y_center() const {
    return GetField<float>(VT_Y_CENTER, 0.0f);
  }
  float x_length() const {
    return GetField<float>(VT_X_LENGTH, 0.0f);
  }
  float y_width() const {
    return GetField<float>(VT_Y_WIDTH, 0.0f);
  }
  float yaw() const {
    return GetField<float>(VT_YAW, 0.0f);
  }
  uint8_t duration_sec() const {
    return GetField<uint8_t>(VT_DURATION_SEC, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_SCAN_TOPIC) &&
           verifier.VerifyString(scan_topic()) &&
           VerifyOffsetRequired(verifier, VT_LASER_FRAME) &&
           verifier.VerifyString(laser_frame()) &&
           VerifyOffsetRequired(verifier, VT_LABEL_FRAME) &&
           verifier.VerifyString(label_frame()) &&
           VerifyField<uint8_t>(verifier, VT_CLASS_LABEL, 1) &&
           VerifyOffsetRequired(verifier, VT_FILENAME) &&
           verifier.VerifyString(filename()) &&
           VerifyField<float>(verifier, VT_X_CENTER, 4) &&
           VerifyField<float>(verifier, VT_Y_CENTER, 4) &&
           VerifyField<float>(verifier, VT_X_LENGTH, 4) &&
           VerifyField<float>(verifier, VT_Y_WIDTH, 4) &&
           VerifyField<float>(verifier, VT_YAW, 4) &&
           VerifyField<uint8_t>(verifier, VT_DURATION_SEC, 1) &&
           verifier.EndTable();
  }
  CartesianLabelAndBagRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CartesianLabelAndBagRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CartesianLabelAndBagRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CartesianLabelAndBagRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CartesianLabelAndBagRequestBuilder {
  typedef CartesianLabelAndBagRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(CartesianLabelAndBagRequest::VT___METADATA, __metadata);
  }
  void add_scan_topic(::flatbuffers::Offset<::flatbuffers::String> scan_topic) {
    fbb_.AddOffset(CartesianLabelAndBagRequest::VT_SCAN_TOPIC, scan_topic);
  }
  void add_laser_frame(::flatbuffers::Offset<::flatbuffers::String> laser_frame) {
    fbb_.AddOffset(CartesianLabelAndBagRequest::VT_LASER_FRAME, laser_frame);
  }
  void add_label_frame(::flatbuffers::Offset<::flatbuffers::String> label_frame) {
    fbb_.AddOffset(CartesianLabelAndBagRequest::VT_LABEL_FRAME, label_frame);
  }
  void add_class_label(uint8_t class_label) {
    fbb_.AddElement<uint8_t>(CartesianLabelAndBagRequest::VT_CLASS_LABEL, class_label, 0);
  }
  void add_filename(::flatbuffers::Offset<::flatbuffers::String> filename) {
    fbb_.AddOffset(CartesianLabelAndBagRequest::VT_FILENAME, filename);
  }
  void add_x_center(float x_center) {
    fbb_.AddElement<float>(CartesianLabelAndBagRequest::VT_X_CENTER, x_center, 0.0f);
  }
  void add_y_center(float y_center) {
    fbb_.AddElement<float>(CartesianLabelAndBagRequest::VT_Y_CENTER, y_center, 0.0f);
  }
  void add_x_length(float x_length) {
    fbb_.AddElement<float>(CartesianLabelAndBagRequest::VT_X_LENGTH, x_length, 0.0f);
  }
  void add_y_width(float y_width) {
    fbb_.AddElement<float>(CartesianLabelAndBagRequest::VT_Y_WIDTH, y_width, 0.0f);
  }
  void add_yaw(float yaw) {
    fbb_.AddElement<float>(CartesianLabelAndBagRequest::VT_YAW, yaw, 0.0f);
  }
  void add_duration_sec(uint8_t duration_sec) {
    fbb_.AddElement<uint8_t>(CartesianLabelAndBagRequest::VT_DURATION_SEC, duration_sec, 0);
  }
  explicit CartesianLabelAndBagRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CartesianLabelAndBagRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CartesianLabelAndBagRequest>(end);
    fbb_.Required(o, CartesianLabelAndBagRequest::VT_SCAN_TOPIC);
    fbb_.Required(o, CartesianLabelAndBagRequest::VT_LASER_FRAME);
    fbb_.Required(o, CartesianLabelAndBagRequest::VT_LABEL_FRAME);
    fbb_.Required(o, CartesianLabelAndBagRequest::VT_FILENAME);
    return o;
  }
};

inline ::flatbuffers::Offset<CartesianLabelAndBagRequest> CreateCartesianLabelAndBagRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> scan_topic = 0,
    ::flatbuffers::Offset<::flatbuffers::String> laser_frame = 0,
    ::flatbuffers::Offset<::flatbuffers::String> label_frame = 0,
    uint8_t class_label = 0,
    ::flatbuffers::Offset<::flatbuffers::String> filename = 0,
    float x_center = 0.0f,
    float y_center = 0.0f,
    float x_length = 0.0f,
    float y_width = 0.0f,
    float yaw = 0.0f,
    uint8_t duration_sec = 0) {
  CartesianLabelAndBagRequestBuilder builder_(_fbb);
  builder_.add_yaw(yaw);
  builder_.add_y_width(y_width);
  builder_.add_x_length(x_length);
  builder_.add_y_center(y_center);
  builder_.add_x_center(x_center);
  builder_.add_filename(filename);
  builder_.add_label_frame(label_frame);
  builder_.add_laser_frame(laser_frame);
  builder_.add_scan_topic(scan_topic);
  builder_.add___metadata(__metadata);
  builder_.add_duration_sec(duration_sec);
  builder_.add_class_label(class_label);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CartesianLabelAndBagRequest> CreateCartesianLabelAndBagRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *scan_topic = nullptr,
    const char *laser_frame = nullptr,
    const char *label_frame = nullptr,
    uint8_t class_label = 0,
    const char *filename = nullptr,
    float x_center = 0.0f,
    float y_center = 0.0f,
    float x_length = 0.0f,
    float y_width = 0.0f,
    float yaw = 0.0f,
    uint8_t duration_sec = 0) {
  auto scan_topic__ = scan_topic ? _fbb.CreateString(scan_topic) : 0;
  auto laser_frame__ = laser_frame ? _fbb.CreateString(laser_frame) : 0;
  auto label_frame__ = label_frame ? _fbb.CreateString(label_frame) : 0;
  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
  return fb::leg_tracker::CreateCartesianLabelAndBagRequest(
      _fbb,
      __metadata,
      scan_topic__,
      laser_frame__,
      label_frame__,
      class_label,
      filename__,
      x_center,
      y_center,
      x_length,
      y_width,
      yaw,
      duration_sec);
}

::flatbuffers::Offset<CartesianLabelAndBagRequest> CreateCartesianLabelAndBagRequest(::flatbuffers::FlatBufferBuilder &_fbb, const CartesianLabelAndBagRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CartesianLabelAndBagResponseT : public ::flatbuffers::NativeTable {
  typedef CartesianLabelAndBagResponse TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  CartesianLabelAndBagResponseT() = default;
  CartesianLabelAndBagResponseT(const CartesianLabelAndBagResponseT &o);
  CartesianLabelAndBagResponseT(CartesianLabelAndBagResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  CartesianLabelAndBagResponseT &operator=(CartesianLabelAndBagResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct CartesianLabelAndBagResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CartesianLabelAndBagResponseT NativeTableType;
  typedef CartesianLabelAndBagResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           verifier.EndTable();
  }
  CartesianLabelAndBagResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CartesianLabelAndBagResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CartesianLabelAndBagResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CartesianLabelAndBagResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CartesianLabelAndBagResponseBuilder {
  typedef CartesianLabelAndBagResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(CartesianLabelAndBagResponse::VT___METADATA, __metadata);
  }
  explicit CartesianLabelAndBagResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CartesianLabelAndBagResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CartesianLabelAndBagResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CartesianLabelAndBagResponse> CreateCartesianLabelAndBagResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0) {
  CartesianLabelAndBagResponseBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<CartesianLabelAndBagResponse> CreateCartesianLabelAndBagResponse(::flatbuffers::FlatBufferBuilder &_fbb, const CartesianLabelAndBagResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CircLabelRequestT : public ::flatbuffers::NativeTable {
  typedef CircLabelRequest TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string scan_topic{};
  std::string laser_frame{};
  std::string label_frame{};
  uint8_t class_label = 0;
  std::string filename{};
  float x_center = 0.0f;
  float y_center = 0.0f;
  float radius = 0.0f;
  CircLabelRequestT() = default;
  CircLabelRequestT(const CircLabelRequestT &o);
  CircLabelRequestT(CircLabelRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  CircLabelRequestT &operator=(CircLabelRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct CircLabelRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CircLabelRequestT NativeTableType;
  typedef CircLabelRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_SCAN_TOPIC = 6,
    VT_LASER_FRAME = 8,
    VT_LABEL_FRAME = 10,
    VT_CLASS_LABEL = 12,
    VT_FILENAME = 14,
    VT_X_CENTER = 16,
    VT_Y_CENTER = 18,
    VT_RADIUS = 20
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *scan_topic() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SCAN_TOPIC);
  }
  const ::flatbuffers::String *laser_frame() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LASER_FRAME);
  }
  const ::flatbuffers::String *label_frame() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LABEL_FRAME);
  }
  uint8_t class_label() const {
    return GetField<uint8_t>(VT_CLASS_LABEL, 0);
  }
  const ::flatbuffers::String *filename() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILENAME);
  }
  float x_center() const {
    return GetField<float>(VT_X_CENTER, 0.0f);
  }
  float y_center() const {
    return GetField<float>(VT_Y_CENTER, 0.0f);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_SCAN_TOPIC) &&
           verifier.VerifyString(scan_topic()) &&
           VerifyOffsetRequired(verifier, VT_LASER_FRAME) &&
           verifier.VerifyString(laser_frame()) &&
           VerifyOffsetRequired(verifier, VT_LABEL_FRAME) &&
           verifier.VerifyString(label_frame()) &&
           VerifyField<uint8_t>(verifier, VT_CLASS_LABEL, 1) &&
           VerifyOffsetRequired(verifier, VT_FILENAME) &&
           verifier.VerifyString(filename()) &&
           VerifyField<float>(verifier, VT_X_CENTER, 4) &&
           VerifyField<float>(verifier, VT_Y_CENTER, 4) &&
           VerifyField<float>(verifier, VT_RADIUS, 4) &&
           verifier.EndTable();
  }
  CircLabelRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CircLabelRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CircLabelRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CircLabelRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CircLabelRequestBuilder {
  typedef CircLabelRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(CircLabelRequest::VT___METADATA, __metadata);
  }
  void add_scan_topic(::flatbuffers::Offset<::flatbuffers::String> scan_topic) {
    fbb_.AddOffset(CircLabelRequest::VT_SCAN_TOPIC, scan_topic);
  }
  void add_laser_frame(::flatbuffers::Offset<::flatbuffers::String> laser_frame) {
    fbb_.AddOffset(CircLabelRequest::VT_LASER_FRAME, laser_frame);
  }
  void add_label_frame(::flatbuffers::Offset<::flatbuffers::String> label_frame) {
    fbb_.AddOffset(CircLabelRequest::VT_LABEL_FRAME, label_frame);
  }
  void add_class_label(uint8_t class_label) {
    fbb_.AddElement<uint8_t>(CircLabelRequest::VT_CLASS_LABEL, class_label, 0);
  }
  void add_filename(::flatbuffers::Offset<::flatbuffers::String> filename) {
    fbb_.AddOffset(CircLabelRequest::VT_FILENAME, filename);
  }
  void add_x_center(float x_center) {
    fbb_.AddElement<float>(CircLabelRequest::VT_X_CENTER, x_center, 0.0f);
  }
  void add_y_center(float y_center) {
    fbb_.AddElement<float>(CircLabelRequest::VT_Y_CENTER, y_center, 0.0f);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(CircLabelRequest::VT_RADIUS, radius, 0.0f);
  }
  explicit CircLabelRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CircLabelRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CircLabelRequest>(end);
    fbb_.Required(o, CircLabelRequest::VT_SCAN_TOPIC);
    fbb_.Required(o, CircLabelRequest::VT_LASER_FRAME);
    fbb_.Required(o, CircLabelRequest::VT_LABEL_FRAME);
    fbb_.Required(o, CircLabelRequest::VT_FILENAME);
    return o;
  }
};

inline ::flatbuffers::Offset<CircLabelRequest> CreateCircLabelRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> scan_topic = 0,
    ::flatbuffers::Offset<::flatbuffers::String> laser_frame = 0,
    ::flatbuffers::Offset<::flatbuffers::String> label_frame = 0,
    uint8_t class_label = 0,
    ::flatbuffers::Offset<::flatbuffers::String> filename = 0,
    float x_center = 0.0f,
    float y_center = 0.0f,
    float radius = 0.0f) {
  CircLabelRequestBuilder builder_(_fbb);
  builder_.add_radius(radius);
  builder_.add_y_center(y_center);
  builder_.add_x_center(x_center);
  builder_.add_filename(filename);
  builder_.add_label_frame(label_frame);
  builder_.add_laser_frame(laser_frame);
  builder_.add_scan_topic(scan_topic);
  builder_.add___metadata(__metadata);
  builder_.add_class_label(class_label);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CircLabelRequest> CreateCircLabelRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *scan_topic = nullptr,
    const char *laser_frame = nullptr,
    const char *label_frame = nullptr,
    uint8_t class_label = 0,
    const char *filename = nullptr,
    float x_center = 0.0f,
    float y_center = 0.0f,
    float radius = 0.0f) {
  auto scan_topic__ = scan_topic ? _fbb.CreateString(scan_topic) : 0;
  auto laser_frame__ = laser_frame ? _fbb.CreateString(laser_frame) : 0;
  auto label_frame__ = label_frame ? _fbb.CreateString(label_frame) : 0;
  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
  return fb::leg_tracker::CreateCircLabelRequest(
      _fbb,
      __metadata,
      scan_topic__,
      laser_frame__,
      label_frame__,
      class_label,
      filename__,
      x_center,
      y_center,
      radius);
}

::flatbuffers::Offset<CircLabelRequest> CreateCircLabelRequest(::flatbuffers::FlatBufferBuilder &_fbb, const CircLabelRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CircLabelResponseT : public ::flatbuffers::NativeTable {
  typedef CircLabelResponse TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  CircLabelResponseT() = default;
  CircLabelResponseT(const CircLabelResponseT &o);
  CircLabelResponseT(CircLabelResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  CircLabelResponseT &operator=(CircLabelResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct CircLabelResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CircLabelResponseT NativeTableType;
  typedef CircLabelResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           verifier.EndTable();
  }
  CircLabelResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CircLabelResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CircLabelResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CircLabelResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CircLabelResponseBuilder {
  typedef CircLabelResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(CircLabelResponse::VT___METADATA, __metadata);
  }
  explicit CircLabelResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CircLabelResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CircLabelResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CircLabelResponse> CreateCircLabelResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0) {
  CircLabelResponseBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<CircLabelResponse> CreateCircLabelResponse(::flatbuffers::FlatBufferBuilder &_fbb, const CircLabelResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CartesianLabelRequestT : public ::flatbuffers::NativeTable {
  typedef CartesianLabelRequest TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string scan_topic{};
  std::string laser_frame{};
  std::string label_frame{};
  uint8_t class_label = 0;
  std::string filename{};
  float x_center = 0.0f;
  float y_center = 0.0f;
  float x_length = 0.0f;
  float y_width = 0.0f;
  float yaw = 0.0f;
  CartesianLabelRequestT() = default;
  CartesianLabelRequestT(const CartesianLabelRequestT &o);
  CartesianLabelRequestT(CartesianLabelRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  CartesianLabelRequestT &operator=(CartesianLabelRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct CartesianLabelRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CartesianLabelRequestT NativeTableType;
  typedef CartesianLabelRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_SCAN_TOPIC = 6,
    VT_LASER_FRAME = 8,
    VT_LABEL_FRAME = 10,
    VT_CLASS_LABEL = 12,
    VT_FILENAME = 14,
    VT_X_CENTER = 16,
    VT_Y_CENTER = 18,
    VT_X_LENGTH = 20,
    VT_Y_WIDTH = 22,
    VT_YAW = 24
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *scan_topic() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SCAN_TOPIC);
  }
  const ::flatbuffers::String *laser_frame() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LASER_FRAME);
  }
  const ::flatbuffers::String *label_frame() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LABEL_FRAME);
  }
  uint8_t class_label() const {
    return GetField<uint8_t>(VT_CLASS_LABEL, 0);
  }
  const ::flatbuffers::String *filename() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILENAME);
  }
  float x_center() const {
    return GetField<float>(VT_X_CENTER, 0.0f);
  }
  float y_center() const {
    return GetField<float>(VT_Y_CENTER, 0.0f);
  }
  float x_length() const {
    return GetField<float>(VT_X_LENGTH, 0.0f);
  }
  float y_width() const {
    return GetField<float>(VT_Y_WIDTH, 0.0f);
  }
  float yaw() const {
    return GetField<float>(VT_YAW, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_SCAN_TOPIC) &&
           verifier.VerifyString(scan_topic()) &&
           VerifyOffsetRequired(verifier, VT_LASER_FRAME) &&
           verifier.VerifyString(laser_frame()) &&
           VerifyOffsetRequired(verifier, VT_LABEL_FRAME) &&
           verifier.VerifyString(label_frame()) &&
           VerifyField<uint8_t>(verifier, VT_CLASS_LABEL, 1) &&
           VerifyOffsetRequired(verifier, VT_FILENAME) &&
           verifier.VerifyString(filename()) &&
           VerifyField<float>(verifier, VT_X_CENTER, 4) &&
           VerifyField<float>(verifier, VT_Y_CENTER, 4) &&
           VerifyField<float>(verifier, VT_X_LENGTH, 4) &&
           VerifyField<float>(verifier, VT_Y_WIDTH, 4) &&
           VerifyField<float>(verifier, VT_YAW, 4) &&
           verifier.EndTable();
  }
  CartesianLabelRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CartesianLabelRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CartesianLabelRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CartesianLabelRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CartesianLabelRequestBuilder {
  typedef CartesianLabelRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(CartesianLabelRequest::VT___METADATA, __metadata);
  }
  void add_scan_topic(::flatbuffers::Offset<::flatbuffers::String> scan_topic) {
    fbb_.AddOffset(CartesianLabelRequest::VT_SCAN_TOPIC, scan_topic);
  }
  void add_laser_frame(::flatbuffers::Offset<::flatbuffers::String> laser_frame) {
    fbb_.AddOffset(CartesianLabelRequest::VT_LASER_FRAME, laser_frame);
  }
  void add_label_frame(::flatbuffers::Offset<::flatbuffers::String> label_frame) {
    fbb_.AddOffset(CartesianLabelRequest::VT_LABEL_FRAME, label_frame);
  }
  void add_class_label(uint8_t class_label) {
    fbb_.AddElement<uint8_t>(CartesianLabelRequest::VT_CLASS_LABEL, class_label, 0);
  }
  void add_filename(::flatbuffers::Offset<::flatbuffers::String> filename) {
    fbb_.AddOffset(CartesianLabelRequest::VT_FILENAME, filename);
  }
  void add_x_center(float x_center) {
    fbb_.AddElement<float>(CartesianLabelRequest::VT_X_CENTER, x_center, 0.0f);
  }
  void add_y_center(float y_center) {
    fbb_.AddElement<float>(CartesianLabelRequest::VT_Y_CENTER, y_center, 0.0f);
  }
  void add_x_length(float x_length) {
    fbb_.AddElement<float>(CartesianLabelRequest::VT_X_LENGTH, x_length, 0.0f);
  }
  void add_y_width(float y_width) {
    fbb_.AddElement<float>(CartesianLabelRequest::VT_Y_WIDTH, y_width, 0.0f);
  }
  void add_yaw(float yaw) {
    fbb_.AddElement<float>(CartesianLabelRequest::VT_YAW, yaw, 0.0f);
  }
  explicit CartesianLabelRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CartesianLabelRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CartesianLabelRequest>(end);
    fbb_.Required(o, CartesianLabelRequest::VT_SCAN_TOPIC);
    fbb_.Required(o, CartesianLabelRequest::VT_LASER_FRAME);
    fbb_.Required(o, CartesianLabelRequest::VT_LABEL_FRAME);
    fbb_.Required(o, CartesianLabelRequest::VT_FILENAME);
    return o;
  }
};

inline ::flatbuffers::Offset<CartesianLabelRequest> CreateCartesianLabelRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> scan_topic = 0,
    ::flatbuffers::Offset<::flatbuffers::String> laser_frame = 0,
    ::flatbuffers::Offset<::flatbuffers::String> label_frame = 0,
    uint8_t class_label = 0,
    ::flatbuffers::Offset<::flatbuffers::String> filename = 0,
    float x_center = 0.0f,
    float y_center = 0.0f,
    float x_length = 0.0f,
    float y_width = 0.0f,
    float yaw = 0.0f) {
  CartesianLabelRequestBuilder builder_(_fbb);
  builder_.add_yaw(yaw);
  builder_.add_y_width(y_width);
  builder_.add_x_length(x_length);
  builder_.add_y_center(y_center);
  builder_.add_x_center(x_center);
  builder_.add_filename(filename);
  builder_.add_label_frame(label_frame);
  builder_.add_laser_frame(laser_frame);
  builder_.add_scan_topic(scan_topic);
  builder_.add___metadata(__metadata);
  builder_.add_class_label(class_label);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CartesianLabelRequest> CreateCartesianLabelRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *scan_topic = nullptr,
    const char *laser_frame = nullptr,
    const char *label_frame = nullptr,
    uint8_t class_label = 0,
    const char *filename = nullptr,
    float x_center = 0.0f,
    float y_center = 0.0f,
    float x_length = 0.0f,
    float y_width = 0.0f,
    float yaw = 0.0f) {
  auto scan_topic__ = scan_topic ? _fbb.CreateString(scan_topic) : 0;
  auto laser_frame__ = laser_frame ? _fbb.CreateString(laser_frame) : 0;
  auto label_frame__ = label_frame ? _fbb.CreateString(label_frame) : 0;
  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
  return fb::leg_tracker::CreateCartesianLabelRequest(
      _fbb,
      __metadata,
      scan_topic__,
      laser_frame__,
      label_frame__,
      class_label,
      filename__,
      x_center,
      y_center,
      x_length,
      y_width,
      yaw);
}

::flatbuffers::Offset<CartesianLabelRequest> CreateCartesianLabelRequest(::flatbuffers::FlatBufferBuilder &_fbb, const CartesianLabelRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CartesianLabelResponseT : public ::flatbuffers::NativeTable {
  typedef CartesianLabelResponse TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  CartesianLabelResponseT() = default;
  CartesianLabelResponseT(const CartesianLabelResponseT &o);
  CartesianLabelResponseT(CartesianLabelResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  CartesianLabelResponseT &operator=(CartesianLabelResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct CartesianLabelResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CartesianLabelResponseT NativeTableType;
  typedef CartesianLabelResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           verifier.EndTable();
  }
  CartesianLabelResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CartesianLabelResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CartesianLabelResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CartesianLabelResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CartesianLabelResponseBuilder {
  typedef CartesianLabelResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(CartesianLabelResponse::VT___METADATA, __metadata);
  }
  explicit CartesianLabelResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CartesianLabelResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CartesianLabelResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CartesianLabelResponse> CreateCartesianLabelResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0) {
  CartesianLabelResponseBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<CartesianLabelResponse> CreateCartesianLabelResponse(::flatbuffers::FlatBufferBuilder &_fbb, const CartesianLabelResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LegT : public ::flatbuffers::NativeTable {
  typedef Leg TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::geometry_msgs::PointT> position{};
  float confidence = 0.0f;
  LegT() = default;
  LegT(const LegT &o);
  LegT(LegT&&) FLATBUFFERS_NOEXCEPT = default;
  LegT &operator=(LegT o) FLATBUFFERS_NOEXCEPT;
};

struct Leg FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LegT NativeTableType;
  typedef LegBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_POSITION = 6,
    VT_CONFIDENCE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Point *position() const {
    return GetPointer<const fb::geometry_msgs::Point *>(VT_POSITION);
  }
  float confidence() const {
    return GetField<float>(VT_CONFIDENCE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_POSITION) &&
           verifier.VerifyTable(position()) &&
           VerifyField<float>(verifier, VT_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
  LegT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LegT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Leg> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LegT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LegBuilder {
  typedef Leg Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Leg::VT___METADATA, __metadata);
  }
  void add_position(::flatbuffers::Offset<fb::geometry_msgs::Point> position) {
    fbb_.AddOffset(Leg::VT_POSITION, position);
  }
  void add_confidence(float confidence) {
    fbb_.AddElement<float>(Leg::VT_CONFIDENCE, confidence, 0.0f);
  }
  explicit LegBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Leg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Leg>(end);
    fbb_.Required(o, Leg::VT_POSITION);
    return o;
  }
};

inline ::flatbuffers::Offset<Leg> CreateLeg(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Point> position = 0,
    float confidence = 0.0f) {
  LegBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  builder_.add_position(position);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<Leg> CreateLeg(::flatbuffers::FlatBufferBuilder &_fbb, const LegT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PersonArrayT : public ::flatbuffers::NativeTable {
  typedef PersonArray TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::vector<std::unique_ptr<fb::leg_tracker::PersonT>> people{};
  PersonArrayT() = default;
  PersonArrayT(const PersonArrayT &o);
  PersonArrayT(PersonArrayT&&) FLATBUFFERS_NOEXCEPT = default;
  PersonArrayT &operator=(PersonArrayT o) FLATBUFFERS_NOEXCEPT;
};

struct PersonArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PersonArrayT NativeTableType;
  typedef PersonArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_PEOPLE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::leg_tracker::Person>> *people() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::leg_tracker::Person>> *>(VT_PEOPLE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_PEOPLE) &&
           verifier.VerifyVector(people()) &&
           verifier.VerifyVectorOfTables(people()) &&
           verifier.EndTable();
  }
  PersonArrayT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PersonArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PersonArray> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PersonArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PersonArrayBuilder {
  typedef PersonArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PersonArray::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(PersonArray::VT_HEADER, header);
  }
  void add_people(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::leg_tracker::Person>>> people) {
    fbb_.AddOffset(PersonArray::VT_PEOPLE, people);
  }
  explicit PersonArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PersonArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PersonArray>(end);
    fbb_.Required(o, PersonArray::VT_HEADER);
    fbb_.Required(o, PersonArray::VT_PEOPLE);
    return o;
  }
};

inline ::flatbuffers::Offset<PersonArray> CreatePersonArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::leg_tracker::Person>>> people = 0) {
  PersonArrayBuilder builder_(_fbb);
  builder_.add_people(people);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PersonArray> CreatePersonArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const std::vector<::flatbuffers::Offset<fb::leg_tracker::Person>> *people = nullptr) {
  auto people__ = people ? _fbb.CreateVector<::flatbuffers::Offset<fb::leg_tracker::Person>>(*people) : 0;
  return fb::leg_tracker::CreatePersonArray(
      _fbb,
      __metadata,
      header,
      people__);
}

::flatbuffers::Offset<PersonArray> CreatePersonArray(::flatbuffers::FlatBufferBuilder &_fbb, const PersonArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline SaveBagRequestT::SaveBagRequestT(const SaveBagRequestT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        topics(o.topics),
        filename(o.filename),
        duration_sec(o.duration_sec) {
}

inline SaveBagRequestT &SaveBagRequestT::operator=(SaveBagRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(topics, o.topics);
  std::swap(filename, o.filename);
  std::swap(duration_sec, o.duration_sec);
  return *this;
}

inline SaveBagRequestT *SaveBagRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SaveBagRequestT>(new SaveBagRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SaveBagRequest::UnPackTo(SaveBagRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = topics(); if (_e) { _o->topics.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->topics[_i] = _e->Get(_i)->str(); } } else { _o->topics.resize(0); } }
  { auto _e = filename(); if (_e) _o->filename = _e->str(); }
  { auto _e = duration_sec(); _o->duration_sec = _e; }
}

inline ::flatbuffers::Offset<SaveBagRequest> SaveBagRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SaveBagRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSaveBagRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SaveBagRequest> CreateSaveBagRequest(::flatbuffers::FlatBufferBuilder &_fbb, const SaveBagRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SaveBagRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _topics = _fbb.CreateVectorOfStrings(_o->topics);
  auto _filename = _fbb.CreateString(_o->filename);
  auto _duration_sec = _o->duration_sec;
  return fb::leg_tracker::CreateSaveBagRequest(
      _fbb,
      ___metadata,
      _topics,
      _filename,
      _duration_sec);
}

inline SaveBagResponseT::SaveBagResponseT(const SaveBagResponseT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr) {
}

inline SaveBagResponseT &SaveBagResponseT::operator=(SaveBagResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  return *this;
}

inline SaveBagResponseT *SaveBagResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SaveBagResponseT>(new SaveBagResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SaveBagResponse::UnPackTo(SaveBagResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
}

inline ::flatbuffers::Offset<SaveBagResponse> SaveBagResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SaveBagResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSaveBagResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SaveBagResponse> CreateSaveBagResponse(::flatbuffers::FlatBufferBuilder &_fbb, const SaveBagResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SaveBagResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  return fb::leg_tracker::CreateSaveBagResponse(
      _fbb,
      ___metadata);
}

inline DetectionArrayT::DetectionArrayT(const DetectionArrayT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr) {
  detections.reserve(o.detections.size());
  for (const auto &detections_ : o.detections) { detections.emplace_back((detections_) ? new fb::leg_tracker::DetectionT(*detections_) : nullptr); }
}

inline DetectionArrayT &DetectionArrayT::operator=(DetectionArrayT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(detections, o.detections);
  return *this;
}

inline DetectionArrayT *DetectionArray::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DetectionArrayT>(new DetectionArrayT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DetectionArray::UnPackTo(DetectionArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = detections(); if (_e) { _o->detections.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->detections[_i]) { _e->Get(_i)->UnPackTo(_o->detections[_i].get(), _resolver); } else { _o->detections[_i] = std::unique_ptr<fb::leg_tracker::DetectionT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->detections.resize(0); } }
}

inline ::flatbuffers::Offset<DetectionArray> DetectionArray::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DetectionArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDetectionArray(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DetectionArray> CreateDetectionArray(::flatbuffers::FlatBufferBuilder &_fbb, const DetectionArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DetectionArrayT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _detections = _fbb.CreateVector<::flatbuffers::Offset<fb::leg_tracker::Detection>> (_o->detections.size(), [](size_t i, _VectorArgs *__va) { return CreateDetection(*__va->__fbb, __va->__o->detections[i].get(), __va->__rehasher); }, &_va );
  return fb::leg_tracker::CreateDetectionArray(
      _fbb,
      ___metadata,
      _header,
      _detections);
}

inline DetectionT::DetectionT(const DetectionT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        position((o.position) ? new fb::geometry_msgs::PointT(*o.position) : nullptr),
        confidence(o.confidence),
        label(o.label) {
}

inline DetectionT &DetectionT::operator=(DetectionT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(position, o.position);
  std::swap(confidence, o.confidence);
  std::swap(label, o.label);
  return *this;
}

inline DetectionT *Detection::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DetectionT>(new DetectionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Detection::UnPackTo(DetectionT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = position(); if (_e) { if(_o->position) { _e->UnPackTo(_o->position.get(), _resolver); } else { _o->position = std::unique_ptr<fb::geometry_msgs::PointT>(_e->UnPack(_resolver)); } } else if (_o->position) { _o->position.reset(); } }
  { auto _e = confidence(); _o->confidence = _e; }
  { auto _e = label(); _o->label = _e; }
}

inline ::flatbuffers::Offset<Detection> Detection::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DetectionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDetection(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Detection> CreateDetection(::flatbuffers::FlatBufferBuilder &_fbb, const DetectionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DetectionT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _position = _o->position ? CreatePoint(_fbb, _o->position.get(), _rehasher) : 0;
  auto _confidence = _o->confidence;
  auto _label = _o->label;
  return fb::leg_tracker::CreateDetection(
      _fbb,
      ___metadata,
      _position,
      _confidence,
      _label);
}

inline ArcLabelAndBagRequestT::ArcLabelAndBagRequestT(const ArcLabelAndBagRequestT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        scan_topic(o.scan_topic),
        laser_frame(o.laser_frame),
        label_frame(o.label_frame),
        class_label(o.class_label),
        filename(o.filename),
        min_angle(o.min_angle),
        max_angle(o.max_angle),
        max_radius(o.max_radius),
        duration_sec(o.duration_sec) {
}

inline ArcLabelAndBagRequestT &ArcLabelAndBagRequestT::operator=(ArcLabelAndBagRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(scan_topic, o.scan_topic);
  std::swap(laser_frame, o.laser_frame);
  std::swap(label_frame, o.label_frame);
  std::swap(class_label, o.class_label);
  std::swap(filename, o.filename);
  std::swap(min_angle, o.min_angle);
  std::swap(max_angle, o.max_angle);
  std::swap(max_radius, o.max_radius);
  std::swap(duration_sec, o.duration_sec);
  return *this;
}

inline ArcLabelAndBagRequestT *ArcLabelAndBagRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ArcLabelAndBagRequestT>(new ArcLabelAndBagRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ArcLabelAndBagRequest::UnPackTo(ArcLabelAndBagRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = scan_topic(); if (_e) _o->scan_topic = _e->str(); }
  { auto _e = laser_frame(); if (_e) _o->laser_frame = _e->str(); }
  { auto _e = label_frame(); if (_e) _o->label_frame = _e->str(); }
  { auto _e = class_label(); _o->class_label = _e; }
  { auto _e = filename(); if (_e) _o->filename = _e->str(); }
  { auto _e = min_angle(); _o->min_angle = _e; }
  { auto _e = max_angle(); _o->max_angle = _e; }
  { auto _e = max_radius(); _o->max_radius = _e; }
  { auto _e = duration_sec(); _o->duration_sec = _e; }
}

inline ::flatbuffers::Offset<ArcLabelAndBagRequest> ArcLabelAndBagRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ArcLabelAndBagRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateArcLabelAndBagRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ArcLabelAndBagRequest> CreateArcLabelAndBagRequest(::flatbuffers::FlatBufferBuilder &_fbb, const ArcLabelAndBagRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ArcLabelAndBagRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _scan_topic = _fbb.CreateString(_o->scan_topic);
  auto _laser_frame = _fbb.CreateString(_o->laser_frame);
  auto _label_frame = _fbb.CreateString(_o->label_frame);
  auto _class_label = _o->class_label;
  auto _filename = _fbb.CreateString(_o->filename);
  auto _min_angle = _o->min_angle;
  auto _max_angle = _o->max_angle;
  auto _max_radius = _o->max_radius;
  auto _duration_sec = _o->duration_sec;
  return fb::leg_tracker::CreateArcLabelAndBagRequest(
      _fbb,
      ___metadata,
      _scan_topic,
      _laser_frame,
      _label_frame,
      _class_label,
      _filename,
      _min_angle,
      _max_angle,
      _max_radius,
      _duration_sec);
}

inline ArcLabelAndBagResponseT::ArcLabelAndBagResponseT(const ArcLabelAndBagResponseT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr) {
}

inline ArcLabelAndBagResponseT &ArcLabelAndBagResponseT::operator=(ArcLabelAndBagResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  return *this;
}

inline ArcLabelAndBagResponseT *ArcLabelAndBagResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ArcLabelAndBagResponseT>(new ArcLabelAndBagResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ArcLabelAndBagResponse::UnPackTo(ArcLabelAndBagResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
}

inline ::flatbuffers::Offset<ArcLabelAndBagResponse> ArcLabelAndBagResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ArcLabelAndBagResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateArcLabelAndBagResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ArcLabelAndBagResponse> CreateArcLabelAndBagResponse(::flatbuffers::FlatBufferBuilder &_fbb, const ArcLabelAndBagResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ArcLabelAndBagResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  return fb::leg_tracker::CreateArcLabelAndBagResponse(
      _fbb,
      ___metadata);
}

inline CircLabelAndBagRequestT::CircLabelAndBagRequestT(const CircLabelAndBagRequestT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        scan_topic(o.scan_topic),
        laser_frame(o.laser_frame),
        label_frame(o.label_frame),
        class_label(o.class_label),
        filename(o.filename),
        x_center(o.x_center),
        y_center(o.y_center),
        radius(o.radius),
        duration_sec(o.duration_sec) {
}

inline CircLabelAndBagRequestT &CircLabelAndBagRequestT::operator=(CircLabelAndBagRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(scan_topic, o.scan_topic);
  std::swap(laser_frame, o.laser_frame);
  std::swap(label_frame, o.label_frame);
  std::swap(class_label, o.class_label);
  std::swap(filename, o.filename);
  std::swap(x_center, o.x_center);
  std::swap(y_center, o.y_center);
  std::swap(radius, o.radius);
  std::swap(duration_sec, o.duration_sec);
  return *this;
}

inline CircLabelAndBagRequestT *CircLabelAndBagRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CircLabelAndBagRequestT>(new CircLabelAndBagRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CircLabelAndBagRequest::UnPackTo(CircLabelAndBagRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = scan_topic(); if (_e) _o->scan_topic = _e->str(); }
  { auto _e = laser_frame(); if (_e) _o->laser_frame = _e->str(); }
  { auto _e = label_frame(); if (_e) _o->label_frame = _e->str(); }
  { auto _e = class_label(); _o->class_label = _e; }
  { auto _e = filename(); if (_e) _o->filename = _e->str(); }
  { auto _e = x_center(); _o->x_center = _e; }
  { auto _e = y_center(); _o->y_center = _e; }
  { auto _e = radius(); _o->radius = _e; }
  { auto _e = duration_sec(); _o->duration_sec = _e; }
}

inline ::flatbuffers::Offset<CircLabelAndBagRequest> CircLabelAndBagRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CircLabelAndBagRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCircLabelAndBagRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CircLabelAndBagRequest> CreateCircLabelAndBagRequest(::flatbuffers::FlatBufferBuilder &_fbb, const CircLabelAndBagRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CircLabelAndBagRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _scan_topic = _fbb.CreateString(_o->scan_topic);
  auto _laser_frame = _fbb.CreateString(_o->laser_frame);
  auto _label_frame = _fbb.CreateString(_o->label_frame);
  auto _class_label = _o->class_label;
  auto _filename = _fbb.CreateString(_o->filename);
  auto _x_center = _o->x_center;
  auto _y_center = _o->y_center;
  auto _radius = _o->radius;
  auto _duration_sec = _o->duration_sec;
  return fb::leg_tracker::CreateCircLabelAndBagRequest(
      _fbb,
      ___metadata,
      _scan_topic,
      _laser_frame,
      _label_frame,
      _class_label,
      _filename,
      _x_center,
      _y_center,
      _radius,
      _duration_sec);
}

inline CircLabelAndBagResponseT::CircLabelAndBagResponseT(const CircLabelAndBagResponseT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr) {
}

inline CircLabelAndBagResponseT &CircLabelAndBagResponseT::operator=(CircLabelAndBagResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  return *this;
}

inline CircLabelAndBagResponseT *CircLabelAndBagResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CircLabelAndBagResponseT>(new CircLabelAndBagResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CircLabelAndBagResponse::UnPackTo(CircLabelAndBagResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
}

inline ::flatbuffers::Offset<CircLabelAndBagResponse> CircLabelAndBagResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CircLabelAndBagResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCircLabelAndBagResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CircLabelAndBagResponse> CreateCircLabelAndBagResponse(::flatbuffers::FlatBufferBuilder &_fbb, const CircLabelAndBagResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CircLabelAndBagResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  return fb::leg_tracker::CreateCircLabelAndBagResponse(
      _fbb,
      ___metadata);
}

inline LegArrayT::LegArrayT(const LegArrayT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr) {
  legs.reserve(o.legs.size());
  for (const auto &legs_ : o.legs) { legs.emplace_back((legs_) ? new fb::leg_tracker::LegT(*legs_) : nullptr); }
}

inline LegArrayT &LegArrayT::operator=(LegArrayT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(legs, o.legs);
  return *this;
}

inline LegArrayT *LegArray::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LegArrayT>(new LegArrayT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LegArray::UnPackTo(LegArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = legs(); if (_e) { _o->legs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->legs[_i]) { _e->Get(_i)->UnPackTo(_o->legs[_i].get(), _resolver); } else { _o->legs[_i] = std::unique_ptr<fb::leg_tracker::LegT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->legs.resize(0); } }
}

inline ::flatbuffers::Offset<LegArray> LegArray::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LegArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLegArray(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<LegArray> CreateLegArray(::flatbuffers::FlatBufferBuilder &_fbb, const LegArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LegArrayT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _legs = _fbb.CreateVector<::flatbuffers::Offset<fb::leg_tracker::Leg>> (_o->legs.size(), [](size_t i, _VectorArgs *__va) { return CreateLeg(*__va->__fbb, __va->__o->legs[i].get(), __va->__rehasher); }, &_va );
  return fb::leg_tracker::CreateLegArray(
      _fbb,
      ___metadata,
      _header,
      _legs);
}

inline PersonT::PersonT(const PersonT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        pose((o.pose) ? new fb::geometry_msgs::PoseT(*o.pose) : nullptr),
        id(o.id) {
}

inline PersonT &PersonT::operator=(PersonT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(pose, o.pose);
  std::swap(id, o.id);
  return *this;
}

inline PersonT *Person::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PersonT>(new PersonT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Person::UnPackTo(PersonT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = pose(); if (_e) { if(_o->pose) { _e->UnPackTo(_o->pose.get(), _resolver); } else { _o->pose = std::unique_ptr<fb::geometry_msgs::PoseT>(_e->UnPack(_resolver)); } } else if (_o->pose) { _o->pose.reset(); } }
  { auto _e = id(); _o->id = _e; }
}

inline ::flatbuffers::Offset<Person> Person::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PersonT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePerson(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Person> CreatePerson(::flatbuffers::FlatBufferBuilder &_fbb, const PersonT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PersonT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _pose = _o->pose ? CreatePose(_fbb, _o->pose.get(), _rehasher) : 0;
  auto _id = _o->id;
  return fb::leg_tracker::CreatePerson(
      _fbb,
      ___metadata,
      _pose,
      _id);
}

inline ArcLabelRequestT::ArcLabelRequestT(const ArcLabelRequestT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        scan_topic(o.scan_topic),
        laser_frame(o.laser_frame),
        label_frame(o.label_frame),
        class_label(o.class_label),
        filename(o.filename),
        min_angle(o.min_angle),
        max_angle(o.max_angle),
        max_radius(o.max_radius) {
}

inline ArcLabelRequestT &ArcLabelRequestT::operator=(ArcLabelRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(scan_topic, o.scan_topic);
  std::swap(laser_frame, o.laser_frame);
  std::swap(label_frame, o.label_frame);
  std::swap(class_label, o.class_label);
  std::swap(filename, o.filename);
  std::swap(min_angle, o.min_angle);
  std::swap(max_angle, o.max_angle);
  std::swap(max_radius, o.max_radius);
  return *this;
}

inline ArcLabelRequestT *ArcLabelRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ArcLabelRequestT>(new ArcLabelRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ArcLabelRequest::UnPackTo(ArcLabelRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = scan_topic(); if (_e) _o->scan_topic = _e->str(); }
  { auto _e = laser_frame(); if (_e) _o->laser_frame = _e->str(); }
  { auto _e = label_frame(); if (_e) _o->label_frame = _e->str(); }
  { auto _e = class_label(); _o->class_label = _e; }
  { auto _e = filename(); if (_e) _o->filename = _e->str(); }
  { auto _e = min_angle(); _o->min_angle = _e; }
  { auto _e = max_angle(); _o->max_angle = _e; }
  { auto _e = max_radius(); _o->max_radius = _e; }
}

inline ::flatbuffers::Offset<ArcLabelRequest> ArcLabelRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ArcLabelRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateArcLabelRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ArcLabelRequest> CreateArcLabelRequest(::flatbuffers::FlatBufferBuilder &_fbb, const ArcLabelRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ArcLabelRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _scan_topic = _fbb.CreateString(_o->scan_topic);
  auto _laser_frame = _fbb.CreateString(_o->laser_frame);
  auto _label_frame = _fbb.CreateString(_o->label_frame);
  auto _class_label = _o->class_label;
  auto _filename = _fbb.CreateString(_o->filename);
  auto _min_angle = _o->min_angle;
  auto _max_angle = _o->max_angle;
  auto _max_radius = _o->max_radius;
  return fb::leg_tracker::CreateArcLabelRequest(
      _fbb,
      ___metadata,
      _scan_topic,
      _laser_frame,
      _label_frame,
      _class_label,
      _filename,
      _min_angle,
      _max_angle,
      _max_radius);
}

inline ArcLabelResponseT::ArcLabelResponseT(const ArcLabelResponseT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr) {
}

inline ArcLabelResponseT &ArcLabelResponseT::operator=(ArcLabelResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  return *this;
}

inline ArcLabelResponseT *ArcLabelResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ArcLabelResponseT>(new ArcLabelResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ArcLabelResponse::UnPackTo(ArcLabelResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
}

inline ::flatbuffers::Offset<ArcLabelResponse> ArcLabelResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ArcLabelResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateArcLabelResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ArcLabelResponse> CreateArcLabelResponse(::flatbuffers::FlatBufferBuilder &_fbb, const ArcLabelResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ArcLabelResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  return fb::leg_tracker::CreateArcLabelResponse(
      _fbb,
      ___metadata);
}

inline CartesianLabelAndBagRequestT::CartesianLabelAndBagRequestT(const CartesianLabelAndBagRequestT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        scan_topic(o.scan_topic),
        laser_frame(o.laser_frame),
        label_frame(o.label_frame),
        class_label(o.class_label),
        filename(o.filename),
        x_center(o.x_center),
        y_center(o.y_center),
        x_length(o.x_length),
        y_width(o.y_width),
        yaw(o.yaw),
        duration_sec(o.duration_sec) {
}

inline CartesianLabelAndBagRequestT &CartesianLabelAndBagRequestT::operator=(CartesianLabelAndBagRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(scan_topic, o.scan_topic);
  std::swap(laser_frame, o.laser_frame);
  std::swap(label_frame, o.label_frame);
  std::swap(class_label, o.class_label);
  std::swap(filename, o.filename);
  std::swap(x_center, o.x_center);
  std::swap(y_center, o.y_center);
  std::swap(x_length, o.x_length);
  std::swap(y_width, o.y_width);
  std::swap(yaw, o.yaw);
  std::swap(duration_sec, o.duration_sec);
  return *this;
}

inline CartesianLabelAndBagRequestT *CartesianLabelAndBagRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CartesianLabelAndBagRequestT>(new CartesianLabelAndBagRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CartesianLabelAndBagRequest::UnPackTo(CartesianLabelAndBagRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = scan_topic(); if (_e) _o->scan_topic = _e->str(); }
  { auto _e = laser_frame(); if (_e) _o->laser_frame = _e->str(); }
  { auto _e = label_frame(); if (_e) _o->label_frame = _e->str(); }
  { auto _e = class_label(); _o->class_label = _e; }
  { auto _e = filename(); if (_e) _o->filename = _e->str(); }
  { auto _e = x_center(); _o->x_center = _e; }
  { auto _e = y_center(); _o->y_center = _e; }
  { auto _e = x_length(); _o->x_length = _e; }
  { auto _e = y_width(); _o->y_width = _e; }
  { auto _e = yaw(); _o->yaw = _e; }
  { auto _e = duration_sec(); _o->duration_sec = _e; }
}

inline ::flatbuffers::Offset<CartesianLabelAndBagRequest> CartesianLabelAndBagRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CartesianLabelAndBagRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCartesianLabelAndBagRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CartesianLabelAndBagRequest> CreateCartesianLabelAndBagRequest(::flatbuffers::FlatBufferBuilder &_fbb, const CartesianLabelAndBagRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CartesianLabelAndBagRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _scan_topic = _fbb.CreateString(_o->scan_topic);
  auto _laser_frame = _fbb.CreateString(_o->laser_frame);
  auto _label_frame = _fbb.CreateString(_o->label_frame);
  auto _class_label = _o->class_label;
  auto _filename = _fbb.CreateString(_o->filename);
  auto _x_center = _o->x_center;
  auto _y_center = _o->y_center;
  auto _x_length = _o->x_length;
  auto _y_width = _o->y_width;
  auto _yaw = _o->yaw;
  auto _duration_sec = _o->duration_sec;
  return fb::leg_tracker::CreateCartesianLabelAndBagRequest(
      _fbb,
      ___metadata,
      _scan_topic,
      _laser_frame,
      _label_frame,
      _class_label,
      _filename,
      _x_center,
      _y_center,
      _x_length,
      _y_width,
      _yaw,
      _duration_sec);
}

inline CartesianLabelAndBagResponseT::CartesianLabelAndBagResponseT(const CartesianLabelAndBagResponseT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr) {
}

inline CartesianLabelAndBagResponseT &CartesianLabelAndBagResponseT::operator=(CartesianLabelAndBagResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  return *this;
}

inline CartesianLabelAndBagResponseT *CartesianLabelAndBagResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CartesianLabelAndBagResponseT>(new CartesianLabelAndBagResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CartesianLabelAndBagResponse::UnPackTo(CartesianLabelAndBagResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
}

inline ::flatbuffers::Offset<CartesianLabelAndBagResponse> CartesianLabelAndBagResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CartesianLabelAndBagResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCartesianLabelAndBagResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CartesianLabelAndBagResponse> CreateCartesianLabelAndBagResponse(::flatbuffers::FlatBufferBuilder &_fbb, const CartesianLabelAndBagResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CartesianLabelAndBagResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  return fb::leg_tracker::CreateCartesianLabelAndBagResponse(
      _fbb,
      ___metadata);
}

inline CircLabelRequestT::CircLabelRequestT(const CircLabelRequestT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        scan_topic(o.scan_topic),
        laser_frame(o.laser_frame),
        label_frame(o.label_frame),
        class_label(o.class_label),
        filename(o.filename),
        x_center(o.x_center),
        y_center(o.y_center),
        radius(o.radius) {
}

inline CircLabelRequestT &CircLabelRequestT::operator=(CircLabelRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(scan_topic, o.scan_topic);
  std::swap(laser_frame, o.laser_frame);
  std::swap(label_frame, o.label_frame);
  std::swap(class_label, o.class_label);
  std::swap(filename, o.filename);
  std::swap(x_center, o.x_center);
  std::swap(y_center, o.y_center);
  std::swap(radius, o.radius);
  return *this;
}

inline CircLabelRequestT *CircLabelRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CircLabelRequestT>(new CircLabelRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CircLabelRequest::UnPackTo(CircLabelRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = scan_topic(); if (_e) _o->scan_topic = _e->str(); }
  { auto _e = laser_frame(); if (_e) _o->laser_frame = _e->str(); }
  { auto _e = label_frame(); if (_e) _o->label_frame = _e->str(); }
  { auto _e = class_label(); _o->class_label = _e; }
  { auto _e = filename(); if (_e) _o->filename = _e->str(); }
  { auto _e = x_center(); _o->x_center = _e; }
  { auto _e = y_center(); _o->y_center = _e; }
  { auto _e = radius(); _o->radius = _e; }
}

inline ::flatbuffers::Offset<CircLabelRequest> CircLabelRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CircLabelRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCircLabelRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CircLabelRequest> CreateCircLabelRequest(::flatbuffers::FlatBufferBuilder &_fbb, const CircLabelRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CircLabelRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _scan_topic = _fbb.CreateString(_o->scan_topic);
  auto _laser_frame = _fbb.CreateString(_o->laser_frame);
  auto _label_frame = _fbb.CreateString(_o->label_frame);
  auto _class_label = _o->class_label;
  auto _filename = _fbb.CreateString(_o->filename);
  auto _x_center = _o->x_center;
  auto _y_center = _o->y_center;
  auto _radius = _o->radius;
  return fb::leg_tracker::CreateCircLabelRequest(
      _fbb,
      ___metadata,
      _scan_topic,
      _laser_frame,
      _label_frame,
      _class_label,
      _filename,
      _x_center,
      _y_center,
      _radius);
}

inline CircLabelResponseT::CircLabelResponseT(const CircLabelResponseT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr) {
}

inline CircLabelResponseT &CircLabelResponseT::operator=(CircLabelResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  return *this;
}

inline CircLabelResponseT *CircLabelResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CircLabelResponseT>(new CircLabelResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CircLabelResponse::UnPackTo(CircLabelResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
}

inline ::flatbuffers::Offset<CircLabelResponse> CircLabelResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CircLabelResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCircLabelResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CircLabelResponse> CreateCircLabelResponse(::flatbuffers::FlatBufferBuilder &_fbb, const CircLabelResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CircLabelResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  return fb::leg_tracker::CreateCircLabelResponse(
      _fbb,
      ___metadata);
}

inline CartesianLabelRequestT::CartesianLabelRequestT(const CartesianLabelRequestT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        scan_topic(o.scan_topic),
        laser_frame(o.laser_frame),
        label_frame(o.label_frame),
        class_label(o.class_label),
        filename(o.filename),
        x_center(o.x_center),
        y_center(o.y_center),
        x_length(o.x_length),
        y_width(o.y_width),
        yaw(o.yaw) {
}

inline CartesianLabelRequestT &CartesianLabelRequestT::operator=(CartesianLabelRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(scan_topic, o.scan_topic);
  std::swap(laser_frame, o.laser_frame);
  std::swap(label_frame, o.label_frame);
  std::swap(class_label, o.class_label);
  std::swap(filename, o.filename);
  std::swap(x_center, o.x_center);
  std::swap(y_center, o.y_center);
  std::swap(x_length, o.x_length);
  std::swap(y_width, o.y_width);
  std::swap(yaw, o.yaw);
  return *this;
}

inline CartesianLabelRequestT *CartesianLabelRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CartesianLabelRequestT>(new CartesianLabelRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CartesianLabelRequest::UnPackTo(CartesianLabelRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = scan_topic(); if (_e) _o->scan_topic = _e->str(); }
  { auto _e = laser_frame(); if (_e) _o->laser_frame = _e->str(); }
  { auto _e = label_frame(); if (_e) _o->label_frame = _e->str(); }
  { auto _e = class_label(); _o->class_label = _e; }
  { auto _e = filename(); if (_e) _o->filename = _e->str(); }
  { auto _e = x_center(); _o->x_center = _e; }
  { auto _e = y_center(); _o->y_center = _e; }
  { auto _e = x_length(); _o->x_length = _e; }
  { auto _e = y_width(); _o->y_width = _e; }
  { auto _e = yaw(); _o->yaw = _e; }
}

inline ::flatbuffers::Offset<CartesianLabelRequest> CartesianLabelRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CartesianLabelRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCartesianLabelRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CartesianLabelRequest> CreateCartesianLabelRequest(::flatbuffers::FlatBufferBuilder &_fbb, const CartesianLabelRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CartesianLabelRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _scan_topic = _fbb.CreateString(_o->scan_topic);
  auto _laser_frame = _fbb.CreateString(_o->laser_frame);
  auto _label_frame = _fbb.CreateString(_o->label_frame);
  auto _class_label = _o->class_label;
  auto _filename = _fbb.CreateString(_o->filename);
  auto _x_center = _o->x_center;
  auto _y_center = _o->y_center;
  auto _x_length = _o->x_length;
  auto _y_width = _o->y_width;
  auto _yaw = _o->yaw;
  return fb::leg_tracker::CreateCartesianLabelRequest(
      _fbb,
      ___metadata,
      _scan_topic,
      _laser_frame,
      _label_frame,
      _class_label,
      _filename,
      _x_center,
      _y_center,
      _x_length,
      _y_width,
      _yaw);
}

inline CartesianLabelResponseT::CartesianLabelResponseT(const CartesianLabelResponseT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr) {
}

inline CartesianLabelResponseT &CartesianLabelResponseT::operator=(CartesianLabelResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  return *this;
}

inline CartesianLabelResponseT *CartesianLabelResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CartesianLabelResponseT>(new CartesianLabelResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CartesianLabelResponse::UnPackTo(CartesianLabelResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
}

inline ::flatbuffers::Offset<CartesianLabelResponse> CartesianLabelResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CartesianLabelResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCartesianLabelResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CartesianLabelResponse> CreateCartesianLabelResponse(::flatbuffers::FlatBufferBuilder &_fbb, const CartesianLabelResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CartesianLabelResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  return fb::leg_tracker::CreateCartesianLabelResponse(
      _fbb,
      ___metadata);
}

inline LegT::LegT(const LegT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        position((o.position) ? new fb::geometry_msgs::PointT(*o.position) : nullptr),
        confidence(o.confidence) {
}

inline LegT &LegT::operator=(LegT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(position, o.position);
  std::swap(confidence, o.confidence);
  return *this;
}

inline LegT *Leg::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LegT>(new LegT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Leg::UnPackTo(LegT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = position(); if (_e) { if(_o->position) { _e->UnPackTo(_o->position.get(), _resolver); } else { _o->position = std::unique_ptr<fb::geometry_msgs::PointT>(_e->UnPack(_resolver)); } } else if (_o->position) { _o->position.reset(); } }
  { auto _e = confidence(); _o->confidence = _e; }
}

inline ::flatbuffers::Offset<Leg> Leg::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LegT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLeg(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Leg> CreateLeg(::flatbuffers::FlatBufferBuilder &_fbb, const LegT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LegT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _position = _o->position ? CreatePoint(_fbb, _o->position.get(), _rehasher) : 0;
  auto _confidence = _o->confidence;
  return fb::leg_tracker::CreateLeg(
      _fbb,
      ___metadata,
      _position,
      _confidence);
}

inline PersonArrayT::PersonArrayT(const PersonArrayT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr) {
  people.reserve(o.people.size());
  for (const auto &people_ : o.people) { people.emplace_back((people_) ? new fb::leg_tracker::PersonT(*people_) : nullptr); }
}

inline PersonArrayT &PersonArrayT::operator=(PersonArrayT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(people, o.people);
  return *this;
}

inline PersonArrayT *PersonArray::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PersonArrayT>(new PersonArrayT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PersonArray::UnPackTo(PersonArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = people(); if (_e) { _o->people.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->people[_i]) { _e->Get(_i)->UnPackTo(_o->people[_i].get(), _resolver); } else { _o->people[_i] = std::unique_ptr<fb::leg_tracker::PersonT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->people.resize(0); } }
}

inline ::flatbuffers::Offset<PersonArray> PersonArray::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PersonArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePersonArray(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PersonArray> CreatePersonArray(::flatbuffers::FlatBufferBuilder &_fbb, const PersonArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PersonArrayT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _people = _fbb.CreateVector<::flatbuffers::Offset<fb::leg_tracker::Person>> (_o->people.size(), [](size_t i, _VectorArgs *__va) { return CreatePerson(*__va->__fbb, __va->__o->people[i].get(), __va->__rehasher); }, &_va );
  return fb::leg_tracker::CreatePersonArray(
      _fbb,
      ___metadata,
      _header,
      _people);
}

}  // namespace leg_tracker
}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_LEGTRACKER_FB_LEG_TRACKER_H_
