// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_AUDIOCOMMONMSGS_FB_AUDIO_COMMON_MSGS_H_
#define FLATBUFFERS_GENERATED_AUDIOCOMMONMSGS_FB_AUDIO_COMMON_MSGS_H_

#include "./flatbuffers/flatbuffers.h"

#include "std_msgs_generated.h"
#include "base_schema_generated.h"

namespace fb {
namespace audio_common_msgs {

struct AudioInfo;
struct AudioInfoBuilder;
struct AudioInfoT;

struct AudioData;
struct AudioDataBuilder;
struct AudioDataT;

struct AudioDataStamped;
struct AudioDataStampedBuilder;
struct AudioDataStampedT;

struct AudioInfoT : public flatbuffers::NativeTable {
  typedef AudioInfo TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  uint8_t channels = 0;
  uint32_t sample_rate = 0;
  std::string sample_format{};
  uint32_t bitrate = 0;
  std::string coding_format{};
  AudioInfoT() = default;
  AudioInfoT(const AudioInfoT &o);
  AudioInfoT(AudioInfoT&&) FLATBUFFERS_NOEXCEPT = default;
  AudioInfoT &operator=(AudioInfoT o) FLATBUFFERS_NOEXCEPT;
};

struct AudioInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AudioInfoT NativeTableType;
  typedef AudioInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_CHANNELS = 6,
    VT_SAMPLE_RATE = 8,
    VT_SAMPLE_FORMAT = 10,
    VT_BITRATE = 12,
    VT_CODING_FORMAT = 14
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  uint8_t channels() const {
    return GetField<uint8_t>(VT_CHANNELS, 0);
  }
  uint32_t sample_rate() const {
    return GetField<uint32_t>(VT_SAMPLE_RATE, 0);
  }
  const flatbuffers::String *sample_format() const {
    return GetPointer<const flatbuffers::String *>(VT_SAMPLE_FORMAT);
  }
  uint32_t bitrate() const {
    return GetField<uint32_t>(VT_BITRATE, 0);
  }
  const flatbuffers::String *coding_format() const {
    return GetPointer<const flatbuffers::String *>(VT_CODING_FORMAT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint8_t>(verifier, VT_CHANNELS, 1) &&
           VerifyField<uint32_t>(verifier, VT_SAMPLE_RATE, 4) &&
           VerifyOffsetRequired(verifier, VT_SAMPLE_FORMAT) &&
           verifier.VerifyString(sample_format()) &&
           VerifyField<uint32_t>(verifier, VT_BITRATE, 4) &&
           VerifyOffsetRequired(verifier, VT_CODING_FORMAT) &&
           verifier.VerifyString(coding_format()) &&
           verifier.EndTable();
  }
  AudioInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AudioInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AudioInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AudioInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AudioInfoBuilder {
  typedef AudioInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(AudioInfo::VT___METADATA, __metadata);
  }
  void add_channels(uint8_t channels) {
    fbb_.AddElement<uint8_t>(AudioInfo::VT_CHANNELS, channels, 0);
  }
  void add_sample_rate(uint32_t sample_rate) {
    fbb_.AddElement<uint32_t>(AudioInfo::VT_SAMPLE_RATE, sample_rate, 0);
  }
  void add_sample_format(flatbuffers::Offset<flatbuffers::String> sample_format) {
    fbb_.AddOffset(AudioInfo::VT_SAMPLE_FORMAT, sample_format);
  }
  void add_bitrate(uint32_t bitrate) {
    fbb_.AddElement<uint32_t>(AudioInfo::VT_BITRATE, bitrate, 0);
  }
  void add_coding_format(flatbuffers::Offset<flatbuffers::String> coding_format) {
    fbb_.AddOffset(AudioInfo::VT_CODING_FORMAT, coding_format);
  }
  explicit AudioInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AudioInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AudioInfo>(end);
    fbb_.Required(o, AudioInfo::VT_SAMPLE_FORMAT);
    fbb_.Required(o, AudioInfo::VT_CODING_FORMAT);
    return o;
  }
};

inline flatbuffers::Offset<AudioInfo> CreateAudioInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint8_t channels = 0,
    uint32_t sample_rate = 0,
    flatbuffers::Offset<flatbuffers::String> sample_format = 0,
    uint32_t bitrate = 0,
    flatbuffers::Offset<flatbuffers::String> coding_format = 0) {
  AudioInfoBuilder builder_(_fbb);
  builder_.add_coding_format(coding_format);
  builder_.add_bitrate(bitrate);
  builder_.add_sample_format(sample_format);
  builder_.add_sample_rate(sample_rate);
  builder_.add___metadata(__metadata);
  builder_.add_channels(channels);
  return builder_.Finish();
}

inline flatbuffers::Offset<AudioInfo> CreateAudioInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint8_t channels = 0,
    uint32_t sample_rate = 0,
    const char *sample_format = nullptr,
    uint32_t bitrate = 0,
    const char *coding_format = nullptr) {
  auto sample_format__ = sample_format ? _fbb.CreateString(sample_format) : 0;
  auto coding_format__ = coding_format ? _fbb.CreateString(coding_format) : 0;
  return fb::audio_common_msgs::CreateAudioInfo(
      _fbb,
      __metadata,
      channels,
      sample_rate,
      sample_format__,
      bitrate,
      coding_format__);
}

flatbuffers::Offset<AudioInfo> CreateAudioInfo(flatbuffers::FlatBufferBuilder &_fbb, const AudioInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AudioDataT : public flatbuffers::NativeTable {
  typedef AudioData TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::vector<uint8_t> data{};
  AudioDataT() = default;
  AudioDataT(const AudioDataT &o);
  AudioDataT(AudioDataT&&) FLATBUFFERS_NOEXCEPT = default;
  AudioDataT &operator=(AudioDataT o) FLATBUFFERS_NOEXCEPT;
};

struct AudioData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AudioDataT NativeTableType;
  typedef AudioDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_DATA = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  AudioDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AudioDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AudioData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AudioDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AudioDataBuilder {
  typedef AudioData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(AudioData::VT___METADATA, __metadata);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(AudioData::VT_DATA, data);
  }
  explicit AudioDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AudioData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AudioData>(end);
    fbb_.Required(o, AudioData::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<AudioData> CreateAudioData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  AudioDataBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<AudioData> CreateAudioDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return fb::audio_common_msgs::CreateAudioData(
      _fbb,
      __metadata,
      data__);
}

flatbuffers::Offset<AudioData> CreateAudioData(flatbuffers::FlatBufferBuilder &_fbb, const AudioDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AudioDataStampedT : public flatbuffers::NativeTable {
  typedef AudioDataStamped TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::audio_common_msgs::AudioDataT> audio{};
  AudioDataStampedT() = default;
  AudioDataStampedT(const AudioDataStampedT &o);
  AudioDataStampedT(AudioDataStampedT&&) FLATBUFFERS_NOEXCEPT = default;
  AudioDataStampedT &operator=(AudioDataStampedT o) FLATBUFFERS_NOEXCEPT;
};

struct AudioDataStamped FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AudioDataStampedT NativeTableType;
  typedef AudioDataStampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_AUDIO = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::audio_common_msgs::AudioData *audio() const {
    return GetPointer<const fb::audio_common_msgs::AudioData *>(VT_AUDIO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_AUDIO) &&
           verifier.VerifyTable(audio()) &&
           verifier.EndTable();
  }
  AudioDataStampedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AudioDataStampedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AudioDataStamped> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AudioDataStampedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AudioDataStampedBuilder {
  typedef AudioDataStamped Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(AudioDataStamped::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(AudioDataStamped::VT_HEADER, header);
  }
  void add_audio(flatbuffers::Offset<fb::audio_common_msgs::AudioData> audio) {
    fbb_.AddOffset(AudioDataStamped::VT_AUDIO, audio);
  }
  explicit AudioDataStampedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AudioDataStamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AudioDataStamped>(end);
    fbb_.Required(o, AudioDataStamped::VT_HEADER);
    fbb_.Required(o, AudioDataStamped::VT_AUDIO);
    return o;
  }
};

inline flatbuffers::Offset<AudioDataStamped> CreateAudioDataStamped(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<fb::audio_common_msgs::AudioData> audio = 0) {
  AudioDataStampedBuilder builder_(_fbb);
  builder_.add_audio(audio);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<AudioDataStamped> CreateAudioDataStamped(flatbuffers::FlatBufferBuilder &_fbb, const AudioDataStampedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline AudioInfoT::AudioInfoT(const AudioInfoT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        channels(o.channels),
        sample_rate(o.sample_rate),
        sample_format(o.sample_format),
        bitrate(o.bitrate),
        coding_format(o.coding_format) {
}

inline AudioInfoT &AudioInfoT::operator=(AudioInfoT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(channels, o.channels);
  std::swap(sample_rate, o.sample_rate);
  std::swap(sample_format, o.sample_format);
  std::swap(bitrate, o.bitrate);
  std::swap(coding_format, o.coding_format);
  return *this;
}

inline AudioInfoT *AudioInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AudioInfoT>(new AudioInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AudioInfo::UnPackTo(AudioInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = channels(); _o->channels = _e; }
  { auto _e = sample_rate(); _o->sample_rate = _e; }
  { auto _e = sample_format(); if (_e) _o->sample_format = _e->str(); }
  { auto _e = bitrate(); _o->bitrate = _e; }
  { auto _e = coding_format(); if (_e) _o->coding_format = _e->str(); }
}

inline flatbuffers::Offset<AudioInfo> AudioInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AudioInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAudioInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AudioInfo> CreateAudioInfo(flatbuffers::FlatBufferBuilder &_fbb, const AudioInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AudioInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _channels = _o->channels;
  auto _sample_rate = _o->sample_rate;
  auto _sample_format = _fbb.CreateString(_o->sample_format);
  auto _bitrate = _o->bitrate;
  auto _coding_format = _fbb.CreateString(_o->coding_format);
  return fb::audio_common_msgs::CreateAudioInfo(
      _fbb,
      ___metadata,
      _channels,
      _sample_rate,
      _sample_format,
      _bitrate,
      _coding_format);
}

inline AudioDataT::AudioDataT(const AudioDataT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        data(o.data) {
}

inline AudioDataT &AudioDataT::operator=(AudioDataT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(data, o.data);
  return *this;
}

inline AudioDataT *AudioData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AudioDataT>(new AudioDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AudioData::UnPackTo(AudioDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
}

inline flatbuffers::Offset<AudioData> AudioData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AudioDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAudioData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AudioData> CreateAudioData(flatbuffers::FlatBufferBuilder &_fbb, const AudioDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AudioDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _data = _fbb.CreateVector(_o->data);
  return fb::audio_common_msgs::CreateAudioData(
      _fbb,
      ___metadata,
      _data);
}

inline AudioDataStampedT::AudioDataStampedT(const AudioDataStampedT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        audio((o.audio) ? new fb::audio_common_msgs::AudioDataT(*o.audio) : nullptr) {
}

inline AudioDataStampedT &AudioDataStampedT::operator=(AudioDataStampedT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(audio, o.audio);
  return *this;
}

inline AudioDataStampedT *AudioDataStamped::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AudioDataStampedT>(new AudioDataStampedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AudioDataStamped::UnPackTo(AudioDataStampedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } }
  { auto _e = audio(); if (_e) { if(_o->audio) { _e->UnPackTo(_o->audio.get(), _resolver); } else { _o->audio = std::unique_ptr<fb::audio_common_msgs::AudioDataT>(_e->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<AudioDataStamped> AudioDataStamped::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AudioDataStampedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAudioDataStamped(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AudioDataStamped> CreateAudioDataStamped(flatbuffers::FlatBufferBuilder &_fbb, const AudioDataStampedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AudioDataStampedT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _audio = _o->audio ? CreateAudioData(_fbb, _o->audio.get(), _rehasher) : 0;
  return fb::audio_common_msgs::CreateAudioDataStamped(
      _fbb,
      ___metadata,
      _header,
      _audio);
}

}  // namespace audio_common_msgs
}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_AUDIOCOMMONMSGS_FB_AUDIO_COMMON_MSGS_H_
