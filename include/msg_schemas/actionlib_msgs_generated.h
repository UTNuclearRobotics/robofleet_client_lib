// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ACTIONLIBMSGS_FB_ACTIONLIB_MSGS_H_
#define FLATBUFFERS_GENERATED_ACTIONLIBMSGS_FB_ACTIONLIB_MSGS_H_

#include "./flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 21,
             "Non-compatible flatbuffers version included");

#include "base_schema_generated.h"
#include "std_msgs_generated.h"

namespace fb {
namespace actionlib_msgs {

struct GoalID;
struct GoalIDBuilder;
struct GoalIDT;

struct GoalStatus;
struct GoalStatusBuilder;
struct GoalStatusT;

struct GoalStatusArray;
struct GoalStatusArrayBuilder;
struct GoalStatusArrayT;

struct GoalIDT : public ::flatbuffers::NativeTable {
  typedef GoalID TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::RosTime> stamp{};
  std::string id{};
  GoalIDT() = default;
  GoalIDT(const GoalIDT &o);
  GoalIDT(GoalIDT&&) FLATBUFFERS_NOEXCEPT = default;
  GoalIDT &operator=(GoalIDT o) FLATBUFFERS_NOEXCEPT;
};

struct GoalID FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GoalIDT NativeTableType;
  typedef GoalIDBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_STAMP = 6,
    VT_ID = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::RosTime *stamp() const {
    return GetStruct<const fb::RosTime *>(VT_STAMP);
  }
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyFieldRequired<fb::RosTime>(verifier, VT_STAMP, 4) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           verifier.EndTable();
  }
  GoalIDT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GoalIDT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GoalID> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GoalIDT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GoalIDBuilder {
  typedef GoalID Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GoalID::VT___METADATA, __metadata);
  }
  void add_stamp(const fb::RosTime *stamp) {
    fbb_.AddStruct(GoalID::VT_STAMP, stamp);
  }
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(GoalID::VT_ID, id);
  }
  explicit GoalIDBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GoalID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GoalID>(end);
    fbb_.Required(o, GoalID::VT_STAMP);
    fbb_.Required(o, GoalID::VT_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<GoalID> CreateGoalID(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const fb::RosTime *stamp = nullptr,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0) {
  GoalIDBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_stamp(stamp);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GoalID> CreateGoalIDDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const fb::RosTime *stamp = nullptr,
    const char *id = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return fb::actionlib_msgs::CreateGoalID(
      _fbb,
      __metadata,
      stamp,
      id__);
}

::flatbuffers::Offset<GoalID> CreateGoalID(::flatbuffers::FlatBufferBuilder &_fbb, const GoalIDT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GoalStatusT : public ::flatbuffers::NativeTable {
  typedef GoalStatus TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::actionlib_msgs::GoalIDT> goal_id{};
  uint8_t status = 0;
  std::string text{};
  GoalStatusT() = default;
  GoalStatusT(const GoalStatusT &o);
  GoalStatusT(GoalStatusT&&) FLATBUFFERS_NOEXCEPT = default;
  GoalStatusT &operator=(GoalStatusT o) FLATBUFFERS_NOEXCEPT;
};

struct GoalStatus FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GoalStatusT NativeTableType;
  typedef GoalStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_GOAL_ID = 6,
    VT_STATUS = 8,
    VT_TEXT = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::actionlib_msgs::GoalID *goal_id() const {
    return GetPointer<const fb::actionlib_msgs::GoalID *>(VT_GOAL_ID);
  }
  uint8_t status() const {
    return GetField<uint8_t>(VT_STATUS, 0);
  }
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_GOAL_ID) &&
           verifier.VerifyTable(goal_id()) &&
           VerifyField<uint8_t>(verifier, VT_STATUS, 1) &&
           VerifyOffsetRequired(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           verifier.EndTable();
  }
  GoalStatusT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GoalStatusT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GoalStatus> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GoalStatusT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GoalStatusBuilder {
  typedef GoalStatus Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GoalStatus::VT___METADATA, __metadata);
  }
  void add_goal_id(::flatbuffers::Offset<fb::actionlib_msgs::GoalID> goal_id) {
    fbb_.AddOffset(GoalStatus::VT_GOAL_ID, goal_id);
  }
  void add_status(uint8_t status) {
    fbb_.AddElement<uint8_t>(GoalStatus::VT_STATUS, status, 0);
  }
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(GoalStatus::VT_TEXT, text);
  }
  explicit GoalStatusBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GoalStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GoalStatus>(end);
    fbb_.Required(o, GoalStatus::VT_GOAL_ID);
    fbb_.Required(o, GoalStatus::VT_TEXT);
    return o;
  }
};

inline ::flatbuffers::Offset<GoalStatus> CreateGoalStatus(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::actionlib_msgs::GoalID> goal_id = 0,
    uint8_t status = 0,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0) {
  GoalStatusBuilder builder_(_fbb);
  builder_.add_text(text);
  builder_.add_goal_id(goal_id);
  builder_.add___metadata(__metadata);
  builder_.add_status(status);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GoalStatus> CreateGoalStatusDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::actionlib_msgs::GoalID> goal_id = 0,
    uint8_t status = 0,
    const char *text = nullptr) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return fb::actionlib_msgs::CreateGoalStatus(
      _fbb,
      __metadata,
      goal_id,
      status,
      text__);
}

::flatbuffers::Offset<GoalStatus> CreateGoalStatus(::flatbuffers::FlatBufferBuilder &_fbb, const GoalStatusT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GoalStatusArrayT : public ::flatbuffers::NativeTable {
  typedef GoalStatusArray TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::vector<std::unique_ptr<fb::actionlib_msgs::GoalStatusT>> status_list{};
  GoalStatusArrayT() = default;
  GoalStatusArrayT(const GoalStatusArrayT &o);
  GoalStatusArrayT(GoalStatusArrayT&&) FLATBUFFERS_NOEXCEPT = default;
  GoalStatusArrayT &operator=(GoalStatusArrayT o) FLATBUFFERS_NOEXCEPT;
};

struct GoalStatusArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GoalStatusArrayT NativeTableType;
  typedef GoalStatusArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_STATUS_LIST = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::actionlib_msgs::GoalStatus>> *status_list() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::actionlib_msgs::GoalStatus>> *>(VT_STATUS_LIST);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_STATUS_LIST) &&
           verifier.VerifyVector(status_list()) &&
           verifier.VerifyVectorOfTables(status_list()) &&
           verifier.EndTable();
  }
  GoalStatusArrayT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GoalStatusArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GoalStatusArray> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GoalStatusArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GoalStatusArrayBuilder {
  typedef GoalStatusArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GoalStatusArray::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(GoalStatusArray::VT_HEADER, header);
  }
  void add_status_list(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::actionlib_msgs::GoalStatus>>> status_list) {
    fbb_.AddOffset(GoalStatusArray::VT_STATUS_LIST, status_list);
  }
  explicit GoalStatusArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GoalStatusArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GoalStatusArray>(end);
    fbb_.Required(o, GoalStatusArray::VT_HEADER);
    fbb_.Required(o, GoalStatusArray::VT_STATUS_LIST);
    return o;
  }
};

inline ::flatbuffers::Offset<GoalStatusArray> CreateGoalStatusArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::actionlib_msgs::GoalStatus>>> status_list = 0) {
  GoalStatusArrayBuilder builder_(_fbb);
  builder_.add_status_list(status_list);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GoalStatusArray> CreateGoalStatusArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const std::vector<::flatbuffers::Offset<fb::actionlib_msgs::GoalStatus>> *status_list = nullptr) {
  auto status_list__ = status_list ? _fbb.CreateVector<::flatbuffers::Offset<fb::actionlib_msgs::GoalStatus>>(*status_list) : 0;
  return fb::actionlib_msgs::CreateGoalStatusArray(
      _fbb,
      __metadata,
      header,
      status_list__);
}

::flatbuffers::Offset<GoalStatusArray> CreateGoalStatusArray(::flatbuffers::FlatBufferBuilder &_fbb, const GoalStatusArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline GoalIDT::GoalIDT(const GoalIDT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        stamp((o.stamp) ? new fb::RosTime(*o.stamp) : nullptr),
        id(o.id) {
}

inline GoalIDT &GoalIDT::operator=(GoalIDT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(stamp, o.stamp);
  std::swap(id, o.id);
  return *this;
}

inline GoalIDT *GoalID::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GoalIDT>(new GoalIDT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GoalID::UnPackTo(GoalIDT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = stamp(); if (_e) _o->stamp = std::unique_ptr<fb::RosTime>(new fb::RosTime(*_e)); }
  { auto _e = id(); if (_e) _o->id = _e->str(); }
}

inline ::flatbuffers::Offset<GoalID> GoalID::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GoalIDT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGoalID(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GoalID> CreateGoalID(::flatbuffers::FlatBufferBuilder &_fbb, const GoalIDT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GoalIDT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _stamp = _o->stamp ? _o->stamp.get() : nullptr;
  auto _id = _fbb.CreateString(_o->id);
  return fb::actionlib_msgs::CreateGoalID(
      _fbb,
      ___metadata,
      _stamp,
      _id);
}

inline GoalStatusT::GoalStatusT(const GoalStatusT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        goal_id((o.goal_id) ? new fb::actionlib_msgs::GoalIDT(*o.goal_id) : nullptr),
        status(o.status),
        text(o.text) {
}

inline GoalStatusT &GoalStatusT::operator=(GoalStatusT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(goal_id, o.goal_id);
  std::swap(status, o.status);
  std::swap(text, o.text);
  return *this;
}

inline GoalStatusT *GoalStatus::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GoalStatusT>(new GoalStatusT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GoalStatus::UnPackTo(GoalStatusT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = goal_id(); if (_e) { if(_o->goal_id) { _e->UnPackTo(_o->goal_id.get(), _resolver); } else { _o->goal_id = std::unique_ptr<fb::actionlib_msgs::GoalIDT>(_e->UnPack(_resolver)); } } else if (_o->goal_id) { _o->goal_id.reset(); } }
  { auto _e = status(); _o->status = _e; }
  { auto _e = text(); if (_e) _o->text = _e->str(); }
}

inline ::flatbuffers::Offset<GoalStatus> GoalStatus::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GoalStatusT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGoalStatus(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GoalStatus> CreateGoalStatus(::flatbuffers::FlatBufferBuilder &_fbb, const GoalStatusT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GoalStatusT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _goal_id = _o->goal_id ? CreateGoalID(_fbb, _o->goal_id.get(), _rehasher) : 0;
  auto _status = _o->status;
  auto _text = _fbb.CreateString(_o->text);
  return fb::actionlib_msgs::CreateGoalStatus(
      _fbb,
      ___metadata,
      _goal_id,
      _status,
      _text);
}

inline GoalStatusArrayT::GoalStatusArrayT(const GoalStatusArrayT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr) {
  status_list.reserve(o.status_list.size());
  for (const auto &status_list_ : o.status_list) { status_list.emplace_back((status_list_) ? new fb::actionlib_msgs::GoalStatusT(*status_list_) : nullptr); }
}

inline GoalStatusArrayT &GoalStatusArrayT::operator=(GoalStatusArrayT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(status_list, o.status_list);
  return *this;
}

inline GoalStatusArrayT *GoalStatusArray::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GoalStatusArrayT>(new GoalStatusArrayT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GoalStatusArray::UnPackTo(GoalStatusArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = status_list(); if (_e) { _o->status_list.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->status_list[_i]) { _e->Get(_i)->UnPackTo(_o->status_list[_i].get(), _resolver); } else { _o->status_list[_i] = std::unique_ptr<fb::actionlib_msgs::GoalStatusT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->status_list.resize(0); } }
}

inline ::flatbuffers::Offset<GoalStatusArray> GoalStatusArray::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GoalStatusArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGoalStatusArray(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GoalStatusArray> CreateGoalStatusArray(::flatbuffers::FlatBufferBuilder &_fbb, const GoalStatusArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GoalStatusArrayT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _status_list = _fbb.CreateVector<::flatbuffers::Offset<fb::actionlib_msgs::GoalStatus>> (_o->status_list.size(), [](size_t i, _VectorArgs *__va) { return CreateGoalStatus(*__va->__fbb, __va->__o->status_list[i].get(), __va->__rehasher); }, &_va );
  return fb::actionlib_msgs::CreateGoalStatusArray(
      _fbb,
      ___metadata,
      _header,
      _status_list);
}

}  // namespace actionlib_msgs
}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_ACTIONLIBMSGS_FB_ACTIONLIB_MSGS_H_
