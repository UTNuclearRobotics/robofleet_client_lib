// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_AMRLMSGS_FB_AMRL_MSGS_H_
#define FLATBUFFERS_GENERATED_AMRLMSGS_FB_AMRL_MSGS_H_

#include "./flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 21,
             "Non-compatible flatbuffers version included");

#include "base_schema_generated.h"
#include "geometry_msgs_generated.h"
#include "sensor_msgs_generated.h"
#include "std_msgs_generated.h"

namespace fb {
namespace amrl_msgs {

struct HumanStateArrayMsg;
struct HumanStateArrayMsgBuilder;
struct HumanStateArrayMsgT;

struct RobofleetStatus;
struct RobofleetStatusBuilder;
struct RobofleetStatusT;

struct SocialPipsSrvRequest;
struct SocialPipsSrvRequestBuilder;
struct SocialPipsSrvRequestT;

struct SocialPipsSrvResponse;
struct SocialPipsSrvResponseBuilder;
struct SocialPipsSrvResponseT;

struct VisualizationMsg;
struct VisualizationMsgBuilder;
struct VisualizationMsgT;

struct Localization2DMsg;
struct Localization2DMsgBuilder;
struct Localization2DMsgT;

struct HumanStateMsg;
struct HumanStateMsgBuilder;
struct HumanStateMsgT;

struct ElevatorStatus;
struct ElevatorStatusBuilder;
struct ElevatorStatusT;

struct ColoredLine2D;
struct ColoredLine2DBuilder;
struct ColoredLine2DT;

struct RobofleetSubscription;
struct RobofleetSubscriptionBuilder;
struct RobofleetSubscriptionT;

struct Point2D;
struct Point2DBuilder;
struct Point2DT;

struct Pose2Df;
struct Pose2DfBuilder;
struct Pose2DfT;

struct ColoredPoint2D;
struct ColoredPoint2DBuilder;
struct ColoredPoint2DT;

struct PathVisualization;
struct PathVisualizationBuilder;
struct PathVisualizationT;

struct AckermannCurvatureDriveMsg;
struct AckermannCurvatureDriveMsgBuilder;
struct AckermannCurvatureDriveMsgT;

struct ErrorReport;
struct ErrorReportBuilder;
struct ErrorReportT;

struct DetectedItem;
struct DetectedItemBuilder;
struct DetectedItemT;

struct ColoredArc2D;
struct ColoredArc2DBuilder;
struct ColoredArc2DT;

struct PlanarObjDetection;
struct PlanarObjDetectionBuilder;
struct PlanarObjDetectionT;

struct ElevatorCommand;
struct ElevatorCommandBuilder;
struct ElevatorCommandT;

struct HumanStateArrayMsgT : public ::flatbuffers::NativeTable {
  typedef HumanStateArrayMsg TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::vector<std::unique_ptr<fb::amrl_msgs::HumanStateMsgT>> human_states{};
  HumanStateArrayMsgT() = default;
  HumanStateArrayMsgT(const HumanStateArrayMsgT &o);
  HumanStateArrayMsgT(HumanStateArrayMsgT&&) FLATBUFFERS_NOEXCEPT = default;
  HumanStateArrayMsgT &operator=(HumanStateArrayMsgT o) FLATBUFFERS_NOEXCEPT;
};

struct HumanStateArrayMsg FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HumanStateArrayMsgT NativeTableType;
  typedef HumanStateArrayMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_HUMAN_STATES = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::HumanStateMsg>> *human_states() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::HumanStateMsg>> *>(VT_HUMAN_STATES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_HUMAN_STATES) &&
           verifier.VerifyVector(human_states()) &&
           verifier.VerifyVectorOfTables(human_states()) &&
           verifier.EndTable();
  }
  HumanStateArrayMsgT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HumanStateArrayMsgT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<HumanStateArrayMsg> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HumanStateArrayMsgT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HumanStateArrayMsgBuilder {
  typedef HumanStateArrayMsg Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(HumanStateArrayMsg::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(HumanStateArrayMsg::VT_HEADER, header);
  }
  void add_human_states(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::HumanStateMsg>>> human_states) {
    fbb_.AddOffset(HumanStateArrayMsg::VT_HUMAN_STATES, human_states);
  }
  explicit HumanStateArrayMsgBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HumanStateArrayMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HumanStateArrayMsg>(end);
    fbb_.Required(o, HumanStateArrayMsg::VT_HEADER);
    fbb_.Required(o, HumanStateArrayMsg::VT_HUMAN_STATES);
    return o;
  }
};

inline ::flatbuffers::Offset<HumanStateArrayMsg> CreateHumanStateArrayMsg(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::HumanStateMsg>>> human_states = 0) {
  HumanStateArrayMsgBuilder builder_(_fbb);
  builder_.add_human_states(human_states);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HumanStateArrayMsg> CreateHumanStateArrayMsgDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const std::vector<::flatbuffers::Offset<fb::amrl_msgs::HumanStateMsg>> *human_states = nullptr) {
  auto human_states__ = human_states ? _fbb.CreateVector<::flatbuffers::Offset<fb::amrl_msgs::HumanStateMsg>>(*human_states) : 0;
  return fb::amrl_msgs::CreateHumanStateArrayMsg(
      _fbb,
      __metadata,
      header,
      human_states__);
}

::flatbuffers::Offset<HumanStateArrayMsg> CreateHumanStateArrayMsg(::flatbuffers::FlatBufferBuilder &_fbb, const HumanStateArrayMsgT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RobofleetStatusT : public ::flatbuffers::NativeTable {
  typedef RobofleetStatus TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string status{};
  bool is_ok = false;
  float battery_level = 0.0f;
  std::string location{};
  RobofleetStatusT() = default;
  RobofleetStatusT(const RobofleetStatusT &o);
  RobofleetStatusT(RobofleetStatusT&&) FLATBUFFERS_NOEXCEPT = default;
  RobofleetStatusT &operator=(RobofleetStatusT o) FLATBUFFERS_NOEXCEPT;
};

struct RobofleetStatus FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RobofleetStatusT NativeTableType;
  typedef RobofleetStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_STATUS = 6,
    VT_IS_OK = 8,
    VT_BATTERY_LEVEL = 10,
    VT_LOCATION = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *status() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATUS);
  }
  bool is_ok() const {
    return GetField<uint8_t>(VT_IS_OK, 0) != 0;
  }
  float battery_level() const {
    return GetField<float>(VT_BATTERY_LEVEL, 0.0f);
  }
  const ::flatbuffers::String *location() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LOCATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_STATUS) &&
           verifier.VerifyString(status()) &&
           VerifyField<uint8_t>(verifier, VT_IS_OK, 1) &&
           VerifyField<float>(verifier, VT_BATTERY_LEVEL, 4) &&
           VerifyOffsetRequired(verifier, VT_LOCATION) &&
           verifier.VerifyString(location()) &&
           verifier.EndTable();
  }
  RobofleetStatusT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RobofleetStatusT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RobofleetStatus> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RobofleetStatusT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RobofleetStatusBuilder {
  typedef RobofleetStatus Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(RobofleetStatus::VT___METADATA, __metadata);
  }
  void add_status(::flatbuffers::Offset<::flatbuffers::String> status) {
    fbb_.AddOffset(RobofleetStatus::VT_STATUS, status);
  }
  void add_is_ok(bool is_ok) {
    fbb_.AddElement<uint8_t>(RobofleetStatus::VT_IS_OK, static_cast<uint8_t>(is_ok), 0);
  }
  void add_battery_level(float battery_level) {
    fbb_.AddElement<float>(RobofleetStatus::VT_BATTERY_LEVEL, battery_level, 0.0f);
  }
  void add_location(::flatbuffers::Offset<::flatbuffers::String> location) {
    fbb_.AddOffset(RobofleetStatus::VT_LOCATION, location);
  }
  explicit RobofleetStatusBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RobofleetStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RobofleetStatus>(end);
    fbb_.Required(o, RobofleetStatus::VT_STATUS);
    fbb_.Required(o, RobofleetStatus::VT_LOCATION);
    return o;
  }
};

inline ::flatbuffers::Offset<RobofleetStatus> CreateRobofleetStatus(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> status = 0,
    bool is_ok = false,
    float battery_level = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> location = 0) {
  RobofleetStatusBuilder builder_(_fbb);
  builder_.add_location(location);
  builder_.add_battery_level(battery_level);
  builder_.add_status(status);
  builder_.add___metadata(__metadata);
  builder_.add_is_ok(is_ok);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RobofleetStatus> CreateRobofleetStatusDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *status = nullptr,
    bool is_ok = false,
    float battery_level = 0.0f,
    const char *location = nullptr) {
  auto status__ = status ? _fbb.CreateString(status) : 0;
  auto location__ = location ? _fbb.CreateString(location) : 0;
  return fb::amrl_msgs::CreateRobofleetStatus(
      _fbb,
      __metadata,
      status__,
      is_ok,
      battery_level,
      location__);
}

::flatbuffers::Offset<RobofleetStatus> CreateRobofleetStatus(::flatbuffers::FlatBufferBuilder &_fbb, const RobofleetStatusT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SocialPipsSrvRequestT : public ::flatbuffers::NativeTable {
  typedef SocialPipsSrvRequest TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::vector<std::unique_ptr<fb::amrl_msgs::Pose2DfT>> robot_poses{};
  std::vector<std::unique_ptr<fb::amrl_msgs::Pose2DfT>> robot_vels{};
  std::vector<std::unique_ptr<fb::amrl_msgs::Pose2DfT>> human_poses{};
  std::vector<std::unique_ptr<fb::amrl_msgs::Pose2DfT>> human_vels{};
  std::unique_ptr<fb::amrl_msgs::Pose2DfT> goal_pose{};
  std::unique_ptr<fb::amrl_msgs::Pose2DfT> local_target{};
  std::unique_ptr<fb::amrl_msgs::Pose2DfT> door_pose{};
  uint8_t door_state = 0;
  uint8_t robot_state = 0;
  int32_t follow_target = 0;
  SocialPipsSrvRequestT() = default;
  SocialPipsSrvRequestT(const SocialPipsSrvRequestT &o);
  SocialPipsSrvRequestT(SocialPipsSrvRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  SocialPipsSrvRequestT &operator=(SocialPipsSrvRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct SocialPipsSrvRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SocialPipsSrvRequestT NativeTableType;
  typedef SocialPipsSrvRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_ROBOT_POSES = 6,
    VT_ROBOT_VELS = 8,
    VT_HUMAN_POSES = 10,
    VT_HUMAN_VELS = 12,
    VT_GOAL_POSE = 14,
    VT_LOCAL_TARGET = 16,
    VT_DOOR_POSE = 18,
    VT_DOOR_STATE = 20,
    VT_ROBOT_STATE = 22,
    VT_FOLLOW_TARGET = 24
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> *robot_poses() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> *>(VT_ROBOT_POSES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> *robot_vels() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> *>(VT_ROBOT_VELS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> *human_poses() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> *>(VT_HUMAN_POSES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> *human_vels() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> *>(VT_HUMAN_VELS);
  }
  const fb::amrl_msgs::Pose2Df *goal_pose() const {
    return GetPointer<const fb::amrl_msgs::Pose2Df *>(VT_GOAL_POSE);
  }
  const fb::amrl_msgs::Pose2Df *local_target() const {
    return GetPointer<const fb::amrl_msgs::Pose2Df *>(VT_LOCAL_TARGET);
  }
  const fb::amrl_msgs::Pose2Df *door_pose() const {
    return GetPointer<const fb::amrl_msgs::Pose2Df *>(VT_DOOR_POSE);
  }
  uint8_t door_state() const {
    return GetField<uint8_t>(VT_DOOR_STATE, 0);
  }
  uint8_t robot_state() const {
    return GetField<uint8_t>(VT_ROBOT_STATE, 0);
  }
  int32_t follow_target() const {
    return GetField<int32_t>(VT_FOLLOW_TARGET, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_ROBOT_POSES) &&
           verifier.VerifyVector(robot_poses()) &&
           verifier.VerifyVectorOfTables(robot_poses()) &&
           VerifyOffsetRequired(verifier, VT_ROBOT_VELS) &&
           verifier.VerifyVector(robot_vels()) &&
           verifier.VerifyVectorOfTables(robot_vels()) &&
           VerifyOffsetRequired(verifier, VT_HUMAN_POSES) &&
           verifier.VerifyVector(human_poses()) &&
           verifier.VerifyVectorOfTables(human_poses()) &&
           VerifyOffsetRequired(verifier, VT_HUMAN_VELS) &&
           verifier.VerifyVector(human_vels()) &&
           verifier.VerifyVectorOfTables(human_vels()) &&
           VerifyOffsetRequired(verifier, VT_GOAL_POSE) &&
           verifier.VerifyTable(goal_pose()) &&
           VerifyOffsetRequired(verifier, VT_LOCAL_TARGET) &&
           verifier.VerifyTable(local_target()) &&
           VerifyOffsetRequired(verifier, VT_DOOR_POSE) &&
           verifier.VerifyTable(door_pose()) &&
           VerifyField<uint8_t>(verifier, VT_DOOR_STATE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ROBOT_STATE, 1) &&
           VerifyField<int32_t>(verifier, VT_FOLLOW_TARGET, 4) &&
           verifier.EndTable();
  }
  SocialPipsSrvRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SocialPipsSrvRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SocialPipsSrvRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SocialPipsSrvRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SocialPipsSrvRequestBuilder {
  typedef SocialPipsSrvRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(SocialPipsSrvRequest::VT___METADATA, __metadata);
  }
  void add_robot_poses(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>>> robot_poses) {
    fbb_.AddOffset(SocialPipsSrvRequest::VT_ROBOT_POSES, robot_poses);
  }
  void add_robot_vels(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>>> robot_vels) {
    fbb_.AddOffset(SocialPipsSrvRequest::VT_ROBOT_VELS, robot_vels);
  }
  void add_human_poses(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>>> human_poses) {
    fbb_.AddOffset(SocialPipsSrvRequest::VT_HUMAN_POSES, human_poses);
  }
  void add_human_vels(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>>> human_vels) {
    fbb_.AddOffset(SocialPipsSrvRequest::VT_HUMAN_VELS, human_vels);
  }
  void add_goal_pose(::flatbuffers::Offset<fb::amrl_msgs::Pose2Df> goal_pose) {
    fbb_.AddOffset(SocialPipsSrvRequest::VT_GOAL_POSE, goal_pose);
  }
  void add_local_target(::flatbuffers::Offset<fb::amrl_msgs::Pose2Df> local_target) {
    fbb_.AddOffset(SocialPipsSrvRequest::VT_LOCAL_TARGET, local_target);
  }
  void add_door_pose(::flatbuffers::Offset<fb::amrl_msgs::Pose2Df> door_pose) {
    fbb_.AddOffset(SocialPipsSrvRequest::VT_DOOR_POSE, door_pose);
  }
  void add_door_state(uint8_t door_state) {
    fbb_.AddElement<uint8_t>(SocialPipsSrvRequest::VT_DOOR_STATE, door_state, 0);
  }
  void add_robot_state(uint8_t robot_state) {
    fbb_.AddElement<uint8_t>(SocialPipsSrvRequest::VT_ROBOT_STATE, robot_state, 0);
  }
  void add_follow_target(int32_t follow_target) {
    fbb_.AddElement<int32_t>(SocialPipsSrvRequest::VT_FOLLOW_TARGET, follow_target, 0);
  }
  explicit SocialPipsSrvRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SocialPipsSrvRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SocialPipsSrvRequest>(end);
    fbb_.Required(o, SocialPipsSrvRequest::VT_ROBOT_POSES);
    fbb_.Required(o, SocialPipsSrvRequest::VT_ROBOT_VELS);
    fbb_.Required(o, SocialPipsSrvRequest::VT_HUMAN_POSES);
    fbb_.Required(o, SocialPipsSrvRequest::VT_HUMAN_VELS);
    fbb_.Required(o, SocialPipsSrvRequest::VT_GOAL_POSE);
    fbb_.Required(o, SocialPipsSrvRequest::VT_LOCAL_TARGET);
    fbb_.Required(o, SocialPipsSrvRequest::VT_DOOR_POSE);
    return o;
  }
};

inline ::flatbuffers::Offset<SocialPipsSrvRequest> CreateSocialPipsSrvRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>>> robot_poses = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>>> robot_vels = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>>> human_poses = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>>> human_vels = 0,
    ::flatbuffers::Offset<fb::amrl_msgs::Pose2Df> goal_pose = 0,
    ::flatbuffers::Offset<fb::amrl_msgs::Pose2Df> local_target = 0,
    ::flatbuffers::Offset<fb::amrl_msgs::Pose2Df> door_pose = 0,
    uint8_t door_state = 0,
    uint8_t robot_state = 0,
    int32_t follow_target = 0) {
  SocialPipsSrvRequestBuilder builder_(_fbb);
  builder_.add_follow_target(follow_target);
  builder_.add_door_pose(door_pose);
  builder_.add_local_target(local_target);
  builder_.add_goal_pose(goal_pose);
  builder_.add_human_vels(human_vels);
  builder_.add_human_poses(human_poses);
  builder_.add_robot_vels(robot_vels);
  builder_.add_robot_poses(robot_poses);
  builder_.add___metadata(__metadata);
  builder_.add_robot_state(robot_state);
  builder_.add_door_state(door_state);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SocialPipsSrvRequest> CreateSocialPipsSrvRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const std::vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> *robot_poses = nullptr,
    const std::vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> *robot_vels = nullptr,
    const std::vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> *human_poses = nullptr,
    const std::vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> *human_vels = nullptr,
    ::flatbuffers::Offset<fb::amrl_msgs::Pose2Df> goal_pose = 0,
    ::flatbuffers::Offset<fb::amrl_msgs::Pose2Df> local_target = 0,
    ::flatbuffers::Offset<fb::amrl_msgs::Pose2Df> door_pose = 0,
    uint8_t door_state = 0,
    uint8_t robot_state = 0,
    int32_t follow_target = 0) {
  auto robot_poses__ = robot_poses ? _fbb.CreateVector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>>(*robot_poses) : 0;
  auto robot_vels__ = robot_vels ? _fbb.CreateVector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>>(*robot_vels) : 0;
  auto human_poses__ = human_poses ? _fbb.CreateVector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>>(*human_poses) : 0;
  auto human_vels__ = human_vels ? _fbb.CreateVector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>>(*human_vels) : 0;
  return fb::amrl_msgs::CreateSocialPipsSrvRequest(
      _fbb,
      __metadata,
      robot_poses__,
      robot_vels__,
      human_poses__,
      human_vels__,
      goal_pose,
      local_target,
      door_pose,
      door_state,
      robot_state,
      follow_target);
}

::flatbuffers::Offset<SocialPipsSrvRequest> CreateSocialPipsSrvRequest(::flatbuffers::FlatBufferBuilder &_fbb, const SocialPipsSrvRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SocialPipsSrvResponseT : public ::flatbuffers::NativeTable {
  typedef SocialPipsSrvResponse TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  int32_t action = 0;
  SocialPipsSrvResponseT() = default;
  SocialPipsSrvResponseT(const SocialPipsSrvResponseT &o);
  SocialPipsSrvResponseT(SocialPipsSrvResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  SocialPipsSrvResponseT &operator=(SocialPipsSrvResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct SocialPipsSrvResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SocialPipsSrvResponseT NativeTableType;
  typedef SocialPipsSrvResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_ACTION = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  int32_t action() const {
    return GetField<int32_t>(VT_ACTION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<int32_t>(verifier, VT_ACTION, 4) &&
           verifier.EndTable();
  }
  SocialPipsSrvResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SocialPipsSrvResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SocialPipsSrvResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SocialPipsSrvResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SocialPipsSrvResponseBuilder {
  typedef SocialPipsSrvResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(SocialPipsSrvResponse::VT___METADATA, __metadata);
  }
  void add_action(int32_t action) {
    fbb_.AddElement<int32_t>(SocialPipsSrvResponse::VT_ACTION, action, 0);
  }
  explicit SocialPipsSrvResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SocialPipsSrvResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SocialPipsSrvResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SocialPipsSrvResponse> CreateSocialPipsSrvResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    int32_t action = 0) {
  SocialPipsSrvResponseBuilder builder_(_fbb);
  builder_.add_action(action);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<SocialPipsSrvResponse> CreateSocialPipsSrvResponse(::flatbuffers::FlatBufferBuilder &_fbb, const SocialPipsSrvResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct VisualizationMsgT : public ::flatbuffers::NativeTable {
  typedef VisualizationMsg TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::string ns{};
  std::vector<std::unique_ptr<fb::amrl_msgs::Pose2DfT>> particles{};
  std::vector<std::unique_ptr<fb::amrl_msgs::PathVisualizationT>> path_options{};
  std::vector<std::unique_ptr<fb::amrl_msgs::ColoredPoint2DT>> points{};
  std::vector<std::unique_ptr<fb::amrl_msgs::ColoredLine2DT>> lines{};
  std::vector<std::unique_ptr<fb::amrl_msgs::ColoredArc2DT>> arcs{};
  VisualizationMsgT() = default;
  VisualizationMsgT(const VisualizationMsgT &o);
  VisualizationMsgT(VisualizationMsgT&&) FLATBUFFERS_NOEXCEPT = default;
  VisualizationMsgT &operator=(VisualizationMsgT o) FLATBUFFERS_NOEXCEPT;
};

struct VisualizationMsg FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VisualizationMsgT NativeTableType;
  typedef VisualizationMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_NS = 8,
    VT_PARTICLES = 10,
    VT_PATH_OPTIONS = 12,
    VT_POINTS = 14,
    VT_LINES = 16,
    VT_ARCS = 18
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const ::flatbuffers::String *ns() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> *particles() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> *>(VT_PARTICLES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::PathVisualization>> *path_options() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::PathVisualization>> *>(VT_PATH_OPTIONS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredPoint2D>> *points() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredPoint2D>> *>(VT_POINTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredLine2D>> *lines() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredLine2D>> *>(VT_LINES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredArc2D>> *arcs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredArc2D>> *>(VT_ARCS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_NS) &&
           verifier.VerifyString(ns()) &&
           VerifyOffsetRequired(verifier, VT_PARTICLES) &&
           verifier.VerifyVector(particles()) &&
           verifier.VerifyVectorOfTables(particles()) &&
           VerifyOffsetRequired(verifier, VT_PATH_OPTIONS) &&
           verifier.VerifyVector(path_options()) &&
           verifier.VerifyVectorOfTables(path_options()) &&
           VerifyOffsetRequired(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.VerifyVectorOfTables(points()) &&
           VerifyOffsetRequired(verifier, VT_LINES) &&
           verifier.VerifyVector(lines()) &&
           verifier.VerifyVectorOfTables(lines()) &&
           VerifyOffsetRequired(verifier, VT_ARCS) &&
           verifier.VerifyVector(arcs()) &&
           verifier.VerifyVectorOfTables(arcs()) &&
           verifier.EndTable();
  }
  VisualizationMsgT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VisualizationMsgT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<VisualizationMsg> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const VisualizationMsgT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VisualizationMsgBuilder {
  typedef VisualizationMsg Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(VisualizationMsg::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(VisualizationMsg::VT_HEADER, header);
  }
  void add_ns(::flatbuffers::Offset<::flatbuffers::String> ns) {
    fbb_.AddOffset(VisualizationMsg::VT_NS, ns);
  }
  void add_particles(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>>> particles) {
    fbb_.AddOffset(VisualizationMsg::VT_PARTICLES, particles);
  }
  void add_path_options(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::PathVisualization>>> path_options) {
    fbb_.AddOffset(VisualizationMsg::VT_PATH_OPTIONS, path_options);
  }
  void add_points(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredPoint2D>>> points) {
    fbb_.AddOffset(VisualizationMsg::VT_POINTS, points);
  }
  void add_lines(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredLine2D>>> lines) {
    fbb_.AddOffset(VisualizationMsg::VT_LINES, lines);
  }
  void add_arcs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredArc2D>>> arcs) {
    fbb_.AddOffset(VisualizationMsg::VT_ARCS, arcs);
  }
  explicit VisualizationMsgBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VisualizationMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VisualizationMsg>(end);
    fbb_.Required(o, VisualizationMsg::VT_HEADER);
    fbb_.Required(o, VisualizationMsg::VT_NS);
    fbb_.Required(o, VisualizationMsg::VT_PARTICLES);
    fbb_.Required(o, VisualizationMsg::VT_PATH_OPTIONS);
    fbb_.Required(o, VisualizationMsg::VT_POINTS);
    fbb_.Required(o, VisualizationMsg::VT_LINES);
    fbb_.Required(o, VisualizationMsg::VT_ARCS);
    return o;
  }
};

inline ::flatbuffers::Offset<VisualizationMsg> CreateVisualizationMsg(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ns = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>>> particles = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::PathVisualization>>> path_options = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredPoint2D>>> points = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredLine2D>>> lines = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredArc2D>>> arcs = 0) {
  VisualizationMsgBuilder builder_(_fbb);
  builder_.add_arcs(arcs);
  builder_.add_lines(lines);
  builder_.add_points(points);
  builder_.add_path_options(path_options);
  builder_.add_particles(particles);
  builder_.add_ns(ns);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VisualizationMsg> CreateVisualizationMsgDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const char *ns = nullptr,
    const std::vector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> *particles = nullptr,
    const std::vector<::flatbuffers::Offset<fb::amrl_msgs::PathVisualization>> *path_options = nullptr,
    const std::vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredPoint2D>> *points = nullptr,
    const std::vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredLine2D>> *lines = nullptr,
    const std::vector<::flatbuffers::Offset<fb::amrl_msgs::ColoredArc2D>> *arcs = nullptr) {
  auto ns__ = ns ? _fbb.CreateString(ns) : 0;
  auto particles__ = particles ? _fbb.CreateVector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>>(*particles) : 0;
  auto path_options__ = path_options ? _fbb.CreateVector<::flatbuffers::Offset<fb::amrl_msgs::PathVisualization>>(*path_options) : 0;
  auto points__ = points ? _fbb.CreateVector<::flatbuffers::Offset<fb::amrl_msgs::ColoredPoint2D>>(*points) : 0;
  auto lines__ = lines ? _fbb.CreateVector<::flatbuffers::Offset<fb::amrl_msgs::ColoredLine2D>>(*lines) : 0;
  auto arcs__ = arcs ? _fbb.CreateVector<::flatbuffers::Offset<fb::amrl_msgs::ColoredArc2D>>(*arcs) : 0;
  return fb::amrl_msgs::CreateVisualizationMsg(
      _fbb,
      __metadata,
      header,
      ns__,
      particles__,
      path_options__,
      points__,
      lines__,
      arcs__);
}

::flatbuffers::Offset<VisualizationMsg> CreateVisualizationMsg(::flatbuffers::FlatBufferBuilder &_fbb, const VisualizationMsgT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Localization2DMsgT : public ::flatbuffers::NativeTable {
  typedef Localization2DMsg TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::amrl_msgs::Pose2DfT> pose{};
  std::string map{};
  Localization2DMsgT() = default;
  Localization2DMsgT(const Localization2DMsgT &o);
  Localization2DMsgT(Localization2DMsgT&&) FLATBUFFERS_NOEXCEPT = default;
  Localization2DMsgT &operator=(Localization2DMsgT o) FLATBUFFERS_NOEXCEPT;
};

struct Localization2DMsg FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Localization2DMsgT NativeTableType;
  typedef Localization2DMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_POSE = 8,
    VT_MAP = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::amrl_msgs::Pose2Df *pose() const {
    return GetPointer<const fb::amrl_msgs::Pose2Df *>(VT_POSE);
  }
  const ::flatbuffers::String *map() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MAP);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           VerifyOffsetRequired(verifier, VT_MAP) &&
           verifier.VerifyString(map()) &&
           verifier.EndTable();
  }
  Localization2DMsgT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Localization2DMsgT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Localization2DMsg> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Localization2DMsgT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Localization2DMsgBuilder {
  typedef Localization2DMsg Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Localization2DMsg::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(Localization2DMsg::VT_HEADER, header);
  }
  void add_pose(::flatbuffers::Offset<fb::amrl_msgs::Pose2Df> pose) {
    fbb_.AddOffset(Localization2DMsg::VT_POSE, pose);
  }
  void add_map(::flatbuffers::Offset<::flatbuffers::String> map) {
    fbb_.AddOffset(Localization2DMsg::VT_MAP, map);
  }
  explicit Localization2DMsgBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Localization2DMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Localization2DMsg>(end);
    fbb_.Required(o, Localization2DMsg::VT_HEADER);
    fbb_.Required(o, Localization2DMsg::VT_POSE);
    fbb_.Required(o, Localization2DMsg::VT_MAP);
    return o;
  }
};

inline ::flatbuffers::Offset<Localization2DMsg> CreateLocalization2DMsg(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::amrl_msgs::Pose2Df> pose = 0,
    ::flatbuffers::Offset<::flatbuffers::String> map = 0) {
  Localization2DMsgBuilder builder_(_fbb);
  builder_.add_map(map);
  builder_.add_pose(pose);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Localization2DMsg> CreateLocalization2DMsgDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::amrl_msgs::Pose2Df> pose = 0,
    const char *map = nullptr) {
  auto map__ = map ? _fbb.CreateString(map) : 0;
  return fb::amrl_msgs::CreateLocalization2DMsg(
      _fbb,
      __metadata,
      header,
      pose,
      map__);
}

::flatbuffers::Offset<Localization2DMsg> CreateLocalization2DMsg(::flatbuffers::FlatBufferBuilder &_fbb, const Localization2DMsgT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HumanStateMsgT : public ::flatbuffers::NativeTable {
  typedef HumanStateMsg TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::geometry_msgs::Pose2DT> pose{};
  std::unique_ptr<fb::geometry_msgs::Vector3T> translational_velocity{};
  double rotational_velocity = 0.0;
  int64_t id = 0;
  HumanStateMsgT() = default;
  HumanStateMsgT(const HumanStateMsgT &o);
  HumanStateMsgT(HumanStateMsgT&&) FLATBUFFERS_NOEXCEPT = default;
  HumanStateMsgT &operator=(HumanStateMsgT o) FLATBUFFERS_NOEXCEPT;
};

struct HumanStateMsg FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HumanStateMsgT NativeTableType;
  typedef HumanStateMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_POSE = 6,
    VT_TRANSLATIONAL_VELOCITY = 8,
    VT_ROTATIONAL_VELOCITY = 10,
    VT_ID = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Pose2D *pose() const {
    return GetPointer<const fb::geometry_msgs::Pose2D *>(VT_POSE);
  }
  const fb::geometry_msgs::Vector3 *translational_velocity() const {
    return GetPointer<const fb::geometry_msgs::Vector3 *>(VT_TRANSLATIONAL_VELOCITY);
  }
  double rotational_velocity() const {
    return GetField<double>(VT_ROTATIONAL_VELOCITY, 0.0);
  }
  int64_t id() const {
    return GetField<int64_t>(VT_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           VerifyOffsetRequired(verifier, VT_TRANSLATIONAL_VELOCITY) &&
           verifier.VerifyTable(translational_velocity()) &&
           VerifyField<double>(verifier, VT_ROTATIONAL_VELOCITY, 8) &&
           VerifyField<int64_t>(verifier, VT_ID, 8) &&
           verifier.EndTable();
  }
  HumanStateMsgT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HumanStateMsgT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<HumanStateMsg> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HumanStateMsgT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HumanStateMsgBuilder {
  typedef HumanStateMsg Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(HumanStateMsg::VT___METADATA, __metadata);
  }
  void add_pose(::flatbuffers::Offset<fb::geometry_msgs::Pose2D> pose) {
    fbb_.AddOffset(HumanStateMsg::VT_POSE, pose);
  }
  void add_translational_velocity(::flatbuffers::Offset<fb::geometry_msgs::Vector3> translational_velocity) {
    fbb_.AddOffset(HumanStateMsg::VT_TRANSLATIONAL_VELOCITY, translational_velocity);
  }
  void add_rotational_velocity(double rotational_velocity) {
    fbb_.AddElement<double>(HumanStateMsg::VT_ROTATIONAL_VELOCITY, rotational_velocity, 0.0);
  }
  void add_id(int64_t id) {
    fbb_.AddElement<int64_t>(HumanStateMsg::VT_ID, id, 0);
  }
  explicit HumanStateMsgBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HumanStateMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HumanStateMsg>(end);
    fbb_.Required(o, HumanStateMsg::VT_POSE);
    fbb_.Required(o, HumanStateMsg::VT_TRANSLATIONAL_VELOCITY);
    return o;
  }
};

inline ::flatbuffers::Offset<HumanStateMsg> CreateHumanStateMsg(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Pose2D> pose = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Vector3> translational_velocity = 0,
    double rotational_velocity = 0.0,
    int64_t id = 0) {
  HumanStateMsgBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_rotational_velocity(rotational_velocity);
  builder_.add_translational_velocity(translational_velocity);
  builder_.add_pose(pose);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<HumanStateMsg> CreateHumanStateMsg(::flatbuffers::FlatBufferBuilder &_fbb, const HumanStateMsgT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ElevatorStatusT : public ::flatbuffers::NativeTable {
  typedef ElevatorStatus TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  uint8_t floor = 0;
  uint8_t door = 0;
  ElevatorStatusT() = default;
  ElevatorStatusT(const ElevatorStatusT &o);
  ElevatorStatusT(ElevatorStatusT&&) FLATBUFFERS_NOEXCEPT = default;
  ElevatorStatusT &operator=(ElevatorStatusT o) FLATBUFFERS_NOEXCEPT;
};

struct ElevatorStatus FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ElevatorStatusT NativeTableType;
  typedef ElevatorStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_FLOOR = 6,
    VT_DOOR = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  uint8_t floor() const {
    return GetField<uint8_t>(VT_FLOOR, 0);
  }
  uint8_t door() const {
    return GetField<uint8_t>(VT_DOOR, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint8_t>(verifier, VT_FLOOR, 1) &&
           VerifyField<uint8_t>(verifier, VT_DOOR, 1) &&
           verifier.EndTable();
  }
  ElevatorStatusT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ElevatorStatusT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ElevatorStatus> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ElevatorStatusT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ElevatorStatusBuilder {
  typedef ElevatorStatus Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ElevatorStatus::VT___METADATA, __metadata);
  }
  void add_floor(uint8_t floor) {
    fbb_.AddElement<uint8_t>(ElevatorStatus::VT_FLOOR, floor, 0);
  }
  void add_door(uint8_t door) {
    fbb_.AddElement<uint8_t>(ElevatorStatus::VT_DOOR, door, 0);
  }
  explicit ElevatorStatusBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ElevatorStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ElevatorStatus>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ElevatorStatus> CreateElevatorStatus(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint8_t floor = 0,
    uint8_t door = 0) {
  ElevatorStatusBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  builder_.add_door(door);
  builder_.add_floor(floor);
  return builder_.Finish();
}

::flatbuffers::Offset<ElevatorStatus> CreateElevatorStatus(::flatbuffers::FlatBufferBuilder &_fbb, const ElevatorStatusT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ColoredLine2DT : public ::flatbuffers::NativeTable {
  typedef ColoredLine2D TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::amrl_msgs::Point2DT> p0{};
  std::unique_ptr<fb::amrl_msgs::Point2DT> p1{};
  uint32_t color = 0;
  ColoredLine2DT() = default;
  ColoredLine2DT(const ColoredLine2DT &o);
  ColoredLine2DT(ColoredLine2DT&&) FLATBUFFERS_NOEXCEPT = default;
  ColoredLine2DT &operator=(ColoredLine2DT o) FLATBUFFERS_NOEXCEPT;
};

struct ColoredLine2D FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ColoredLine2DT NativeTableType;
  typedef ColoredLine2DBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_P0 = 6,
    VT_P1 = 8,
    VT_COLOR = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::amrl_msgs::Point2D *p0() const {
    return GetPointer<const fb::amrl_msgs::Point2D *>(VT_P0);
  }
  const fb::amrl_msgs::Point2D *p1() const {
    return GetPointer<const fb::amrl_msgs::Point2D *>(VT_P1);
  }
  uint32_t color() const {
    return GetField<uint32_t>(VT_COLOR, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_P0) &&
           verifier.VerifyTable(p0()) &&
           VerifyOffsetRequired(verifier, VT_P1) &&
           verifier.VerifyTable(p1()) &&
           VerifyField<uint32_t>(verifier, VT_COLOR, 4) &&
           verifier.EndTable();
  }
  ColoredLine2DT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ColoredLine2DT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ColoredLine2D> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ColoredLine2DT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ColoredLine2DBuilder {
  typedef ColoredLine2D Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ColoredLine2D::VT___METADATA, __metadata);
  }
  void add_p0(::flatbuffers::Offset<fb::amrl_msgs::Point2D> p0) {
    fbb_.AddOffset(ColoredLine2D::VT_P0, p0);
  }
  void add_p1(::flatbuffers::Offset<fb::amrl_msgs::Point2D> p1) {
    fbb_.AddOffset(ColoredLine2D::VT_P1, p1);
  }
  void add_color(uint32_t color) {
    fbb_.AddElement<uint32_t>(ColoredLine2D::VT_COLOR, color, 0);
  }
  explicit ColoredLine2DBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ColoredLine2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ColoredLine2D>(end);
    fbb_.Required(o, ColoredLine2D::VT_P0);
    fbb_.Required(o, ColoredLine2D::VT_P1);
    return o;
  }
};

inline ::flatbuffers::Offset<ColoredLine2D> CreateColoredLine2D(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::amrl_msgs::Point2D> p0 = 0,
    ::flatbuffers::Offset<fb::amrl_msgs::Point2D> p1 = 0,
    uint32_t color = 0) {
  ColoredLine2DBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_p1(p1);
  builder_.add_p0(p0);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<ColoredLine2D> CreateColoredLine2D(::flatbuffers::FlatBufferBuilder &_fbb, const ColoredLine2DT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RobofleetSubscriptionT : public ::flatbuffers::NativeTable {
  typedef RobofleetSubscription TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string topic_regex{};
  uint8_t action = 0;
  RobofleetSubscriptionT() = default;
  RobofleetSubscriptionT(const RobofleetSubscriptionT &o);
  RobofleetSubscriptionT(RobofleetSubscriptionT&&) FLATBUFFERS_NOEXCEPT = default;
  RobofleetSubscriptionT &operator=(RobofleetSubscriptionT o) FLATBUFFERS_NOEXCEPT;
};

struct RobofleetSubscription FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RobofleetSubscriptionT NativeTableType;
  typedef RobofleetSubscriptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_TOPIC_REGEX = 6,
    VT_ACTION = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *topic_regex() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TOPIC_REGEX);
  }
  uint8_t action() const {
    return GetField<uint8_t>(VT_ACTION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_TOPIC_REGEX) &&
           verifier.VerifyString(topic_regex()) &&
           VerifyField<uint8_t>(verifier, VT_ACTION, 1) &&
           verifier.EndTable();
  }
  RobofleetSubscriptionT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RobofleetSubscriptionT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RobofleetSubscription> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RobofleetSubscriptionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RobofleetSubscriptionBuilder {
  typedef RobofleetSubscription Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(RobofleetSubscription::VT___METADATA, __metadata);
  }
  void add_topic_regex(::flatbuffers::Offset<::flatbuffers::String> topic_regex) {
    fbb_.AddOffset(RobofleetSubscription::VT_TOPIC_REGEX, topic_regex);
  }
  void add_action(uint8_t action) {
    fbb_.AddElement<uint8_t>(RobofleetSubscription::VT_ACTION, action, 0);
  }
  explicit RobofleetSubscriptionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RobofleetSubscription> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RobofleetSubscription>(end);
    fbb_.Required(o, RobofleetSubscription::VT_TOPIC_REGEX);
    return o;
  }
};

inline ::flatbuffers::Offset<RobofleetSubscription> CreateRobofleetSubscription(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> topic_regex = 0,
    uint8_t action = 0) {
  RobofleetSubscriptionBuilder builder_(_fbb);
  builder_.add_topic_regex(topic_regex);
  builder_.add___metadata(__metadata);
  builder_.add_action(action);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RobofleetSubscription> CreateRobofleetSubscriptionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *topic_regex = nullptr,
    uint8_t action = 0) {
  auto topic_regex__ = topic_regex ? _fbb.CreateString(topic_regex) : 0;
  return fb::amrl_msgs::CreateRobofleetSubscription(
      _fbb,
      __metadata,
      topic_regex__,
      action);
}

::flatbuffers::Offset<RobofleetSubscription> CreateRobofleetSubscription(::flatbuffers::FlatBufferBuilder &_fbb, const RobofleetSubscriptionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Point2DT : public ::flatbuffers::NativeTable {
  typedef Point2D TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  float x = 0.0f;
  float y = 0.0f;
  Point2DT() = default;
  Point2DT(const Point2DT &o);
  Point2DT(Point2DT&&) FLATBUFFERS_NOEXCEPT = default;
  Point2DT &operator=(Point2DT o) FLATBUFFERS_NOEXCEPT;
};

struct Point2D FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Point2DT NativeTableType;
  typedef Point2DBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_X = 6,
    VT_Y = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           verifier.EndTable();
  }
  Point2DT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Point2DT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Point2D> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Point2DT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Point2DBuilder {
  typedef Point2D Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Point2D::VT___METADATA, __metadata);
  }
  void add_x(float x) {
    fbb_.AddElement<float>(Point2D::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Point2D::VT_Y, y, 0.0f);
  }
  explicit Point2DBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Point2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Point2D>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Point2D> CreatePoint2D(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    float x = 0.0f,
    float y = 0.0f) {
  Point2DBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<Point2D> CreatePoint2D(::flatbuffers::FlatBufferBuilder &_fbb, const Point2DT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Pose2DfT : public ::flatbuffers::NativeTable {
  typedef Pose2Df TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  float x = 0.0f;
  float y = 0.0f;
  float theta = 0.0f;
  Pose2DfT() = default;
  Pose2DfT(const Pose2DfT &o);
  Pose2DfT(Pose2DfT&&) FLATBUFFERS_NOEXCEPT = default;
  Pose2DfT &operator=(Pose2DfT o) FLATBUFFERS_NOEXCEPT;
};

struct Pose2Df FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Pose2DfT NativeTableType;
  typedef Pose2DfBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_THETA = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float theta() const {
    return GetField<float>(VT_THETA, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           VerifyField<float>(verifier, VT_THETA, 4) &&
           verifier.EndTable();
  }
  Pose2DfT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Pose2DfT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Pose2Df> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Pose2DfT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Pose2DfBuilder {
  typedef Pose2Df Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Pose2Df::VT___METADATA, __metadata);
  }
  void add_x(float x) {
    fbb_.AddElement<float>(Pose2Df::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Pose2Df::VT_Y, y, 0.0f);
  }
  void add_theta(float theta) {
    fbb_.AddElement<float>(Pose2Df::VT_THETA, theta, 0.0f);
  }
  explicit Pose2DfBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Pose2Df> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Pose2Df>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Pose2Df> CreatePose2Df(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    float x = 0.0f,
    float y = 0.0f,
    float theta = 0.0f) {
  Pose2DfBuilder builder_(_fbb);
  builder_.add_theta(theta);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<Pose2Df> CreatePose2Df(::flatbuffers::FlatBufferBuilder &_fbb, const Pose2DfT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ColoredPoint2DT : public ::flatbuffers::NativeTable {
  typedef ColoredPoint2D TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::amrl_msgs::Point2DT> point{};
  uint32_t color = 0;
  ColoredPoint2DT() = default;
  ColoredPoint2DT(const ColoredPoint2DT &o);
  ColoredPoint2DT(ColoredPoint2DT&&) FLATBUFFERS_NOEXCEPT = default;
  ColoredPoint2DT &operator=(ColoredPoint2DT o) FLATBUFFERS_NOEXCEPT;
};

struct ColoredPoint2D FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ColoredPoint2DT NativeTableType;
  typedef ColoredPoint2DBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_POINT = 6,
    VT_COLOR = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::amrl_msgs::Point2D *point() const {
    return GetPointer<const fb::amrl_msgs::Point2D *>(VT_POINT);
  }
  uint32_t color() const {
    return GetField<uint32_t>(VT_COLOR, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_POINT) &&
           verifier.VerifyTable(point()) &&
           VerifyField<uint32_t>(verifier, VT_COLOR, 4) &&
           verifier.EndTable();
  }
  ColoredPoint2DT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ColoredPoint2DT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ColoredPoint2D> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ColoredPoint2DT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ColoredPoint2DBuilder {
  typedef ColoredPoint2D Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ColoredPoint2D::VT___METADATA, __metadata);
  }
  void add_point(::flatbuffers::Offset<fb::amrl_msgs::Point2D> point) {
    fbb_.AddOffset(ColoredPoint2D::VT_POINT, point);
  }
  void add_color(uint32_t color) {
    fbb_.AddElement<uint32_t>(ColoredPoint2D::VT_COLOR, color, 0);
  }
  explicit ColoredPoint2DBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ColoredPoint2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ColoredPoint2D>(end);
    fbb_.Required(o, ColoredPoint2D::VT_POINT);
    return o;
  }
};

inline ::flatbuffers::Offset<ColoredPoint2D> CreateColoredPoint2D(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::amrl_msgs::Point2D> point = 0,
    uint32_t color = 0) {
  ColoredPoint2DBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_point(point);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<ColoredPoint2D> CreateColoredPoint2D(::flatbuffers::FlatBufferBuilder &_fbb, const ColoredPoint2DT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PathVisualizationT : public ::flatbuffers::NativeTable {
  typedef PathVisualization TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  float curvature = 0.0f;
  float distance = 0.0f;
  float clearance = 0.0f;
  PathVisualizationT() = default;
  PathVisualizationT(const PathVisualizationT &o);
  PathVisualizationT(PathVisualizationT&&) FLATBUFFERS_NOEXCEPT = default;
  PathVisualizationT &operator=(PathVisualizationT o) FLATBUFFERS_NOEXCEPT;
};

struct PathVisualization FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PathVisualizationT NativeTableType;
  typedef PathVisualizationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_CURVATURE = 6,
    VT_DISTANCE = 8,
    VT_CLEARANCE = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  float curvature() const {
    return GetField<float>(VT_CURVATURE, 0.0f);
  }
  float distance() const {
    return GetField<float>(VT_DISTANCE, 0.0f);
  }
  float clearance() const {
    return GetField<float>(VT_CLEARANCE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<float>(verifier, VT_CURVATURE, 4) &&
           VerifyField<float>(verifier, VT_DISTANCE, 4) &&
           VerifyField<float>(verifier, VT_CLEARANCE, 4) &&
           verifier.EndTable();
  }
  PathVisualizationT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PathVisualizationT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PathVisualization> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PathVisualizationT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PathVisualizationBuilder {
  typedef PathVisualization Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PathVisualization::VT___METADATA, __metadata);
  }
  void add_curvature(float curvature) {
    fbb_.AddElement<float>(PathVisualization::VT_CURVATURE, curvature, 0.0f);
  }
  void add_distance(float distance) {
    fbb_.AddElement<float>(PathVisualization::VT_DISTANCE, distance, 0.0f);
  }
  void add_clearance(float clearance) {
    fbb_.AddElement<float>(PathVisualization::VT_CLEARANCE, clearance, 0.0f);
  }
  explicit PathVisualizationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PathVisualization> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PathVisualization>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PathVisualization> CreatePathVisualization(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    float curvature = 0.0f,
    float distance = 0.0f,
    float clearance = 0.0f) {
  PathVisualizationBuilder builder_(_fbb);
  builder_.add_clearance(clearance);
  builder_.add_distance(distance);
  builder_.add_curvature(curvature);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<PathVisualization> CreatePathVisualization(::flatbuffers::FlatBufferBuilder &_fbb, const PathVisualizationT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AckermannCurvatureDriveMsgT : public ::flatbuffers::NativeTable {
  typedef AckermannCurvatureDriveMsg TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  float velocity = 0.0f;
  float curvature = 0.0f;
  AckermannCurvatureDriveMsgT() = default;
  AckermannCurvatureDriveMsgT(const AckermannCurvatureDriveMsgT &o);
  AckermannCurvatureDriveMsgT(AckermannCurvatureDriveMsgT&&) FLATBUFFERS_NOEXCEPT = default;
  AckermannCurvatureDriveMsgT &operator=(AckermannCurvatureDriveMsgT o) FLATBUFFERS_NOEXCEPT;
};

struct AckermannCurvatureDriveMsg FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AckermannCurvatureDriveMsgT NativeTableType;
  typedef AckermannCurvatureDriveMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_VELOCITY = 8,
    VT_CURVATURE = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  float velocity() const {
    return GetField<float>(VT_VELOCITY, 0.0f);
  }
  float curvature() const {
    return GetField<float>(VT_CURVATURE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<float>(verifier, VT_VELOCITY, 4) &&
           VerifyField<float>(verifier, VT_CURVATURE, 4) &&
           verifier.EndTable();
  }
  AckermannCurvatureDriveMsgT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AckermannCurvatureDriveMsgT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AckermannCurvatureDriveMsg> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AckermannCurvatureDriveMsgT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AckermannCurvatureDriveMsgBuilder {
  typedef AckermannCurvatureDriveMsg Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(AckermannCurvatureDriveMsg::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(AckermannCurvatureDriveMsg::VT_HEADER, header);
  }
  void add_velocity(float velocity) {
    fbb_.AddElement<float>(AckermannCurvatureDriveMsg::VT_VELOCITY, velocity, 0.0f);
  }
  void add_curvature(float curvature) {
    fbb_.AddElement<float>(AckermannCurvatureDriveMsg::VT_CURVATURE, curvature, 0.0f);
  }
  explicit AckermannCurvatureDriveMsgBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AckermannCurvatureDriveMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AckermannCurvatureDriveMsg>(end);
    fbb_.Required(o, AckermannCurvatureDriveMsg::VT_HEADER);
    return o;
  }
};

inline ::flatbuffers::Offset<AckermannCurvatureDriveMsg> CreateAckermannCurvatureDriveMsg(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    float velocity = 0.0f,
    float curvature = 0.0f) {
  AckermannCurvatureDriveMsgBuilder builder_(_fbb);
  builder_.add_curvature(curvature);
  builder_.add_velocity(velocity);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<AckermannCurvatureDriveMsg> CreateAckermannCurvatureDriveMsg(::flatbuffers::FlatBufferBuilder &_fbb, const AckermannCurvatureDriveMsgT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ErrorReportT : public ::flatbuffers::NativeTable {
  typedef ErrorReport TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::std_msgs::HeaderT> laser_header{};
  uint8_t severity_level = 0;
  uint8_t failed_subsystem = 0;
  std::string detailed_error_msg{};
  ErrorReportT() = default;
  ErrorReportT(const ErrorReportT &o);
  ErrorReportT(ErrorReportT&&) FLATBUFFERS_NOEXCEPT = default;
  ErrorReportT &operator=(ErrorReportT o) FLATBUFFERS_NOEXCEPT;
};

struct ErrorReport FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ErrorReportT NativeTableType;
  typedef ErrorReportBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_LASER_HEADER = 8,
    VT_SEVERITY_LEVEL = 10,
    VT_FAILED_SUBSYSTEM = 12,
    VT_DETAILED_ERROR_MSG = 14
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::std_msgs::Header *laser_header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_LASER_HEADER);
  }
  uint8_t severity_level() const {
    return GetField<uint8_t>(VT_SEVERITY_LEVEL, 0);
  }
  uint8_t failed_subsystem() const {
    return GetField<uint8_t>(VT_FAILED_SUBSYSTEM, 0);
  }
  const ::flatbuffers::String *detailed_error_msg() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DETAILED_ERROR_MSG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_LASER_HEADER) &&
           verifier.VerifyTable(laser_header()) &&
           VerifyField<uint8_t>(verifier, VT_SEVERITY_LEVEL, 1) &&
           VerifyField<uint8_t>(verifier, VT_FAILED_SUBSYSTEM, 1) &&
           VerifyOffsetRequired(verifier, VT_DETAILED_ERROR_MSG) &&
           verifier.VerifyString(detailed_error_msg()) &&
           verifier.EndTable();
  }
  ErrorReportT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ErrorReportT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ErrorReport> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ErrorReportT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ErrorReportBuilder {
  typedef ErrorReport Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ErrorReport::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(ErrorReport::VT_HEADER, header);
  }
  void add_laser_header(::flatbuffers::Offset<fb::std_msgs::Header> laser_header) {
    fbb_.AddOffset(ErrorReport::VT_LASER_HEADER, laser_header);
  }
  void add_severity_level(uint8_t severity_level) {
    fbb_.AddElement<uint8_t>(ErrorReport::VT_SEVERITY_LEVEL, severity_level, 0);
  }
  void add_failed_subsystem(uint8_t failed_subsystem) {
    fbb_.AddElement<uint8_t>(ErrorReport::VT_FAILED_SUBSYSTEM, failed_subsystem, 0);
  }
  void add_detailed_error_msg(::flatbuffers::Offset<::flatbuffers::String> detailed_error_msg) {
    fbb_.AddOffset(ErrorReport::VT_DETAILED_ERROR_MSG, detailed_error_msg);
  }
  explicit ErrorReportBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ErrorReport> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ErrorReport>(end);
    fbb_.Required(o, ErrorReport::VT_HEADER);
    fbb_.Required(o, ErrorReport::VT_LASER_HEADER);
    fbb_.Required(o, ErrorReport::VT_DETAILED_ERROR_MSG);
    return o;
  }
};

inline ::flatbuffers::Offset<ErrorReport> CreateErrorReport(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> laser_header = 0,
    uint8_t severity_level = 0,
    uint8_t failed_subsystem = 0,
    ::flatbuffers::Offset<::flatbuffers::String> detailed_error_msg = 0) {
  ErrorReportBuilder builder_(_fbb);
  builder_.add_detailed_error_msg(detailed_error_msg);
  builder_.add_laser_header(laser_header);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  builder_.add_failed_subsystem(failed_subsystem);
  builder_.add_severity_level(severity_level);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ErrorReport> CreateErrorReportDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> laser_header = 0,
    uint8_t severity_level = 0,
    uint8_t failed_subsystem = 0,
    const char *detailed_error_msg = nullptr) {
  auto detailed_error_msg__ = detailed_error_msg ? _fbb.CreateString(detailed_error_msg) : 0;
  return fb::amrl_msgs::CreateErrorReport(
      _fbb,
      __metadata,
      header,
      laser_header,
      severity_level,
      failed_subsystem,
      detailed_error_msg__);
}

::flatbuffers::Offset<ErrorReport> CreateErrorReport(::flatbuffers::FlatBufferBuilder &_fbb, const ErrorReportT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DetectedItemT : public ::flatbuffers::NativeTable {
  typedef DetectedItem TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string name{};
  std::string repid{};
  std::string anchorid{};
  double x = 0.0;
  double y = 0.0;
  double z = 0.0;
  double lat = 0.0;
  double lon = 0.0;
  double elv = 0.0;
  std::unique_ptr<fb::sensor_msgs::CompressedImageT> cmpr_image{};
  DetectedItemT() = default;
  DetectedItemT(const DetectedItemT &o);
  DetectedItemT(DetectedItemT&&) FLATBUFFERS_NOEXCEPT = default;
  DetectedItemT &operator=(DetectedItemT o) FLATBUFFERS_NOEXCEPT;
};

struct DetectedItem FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DetectedItemT NativeTableType;
  typedef DetectedItemBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_NAME = 6,
    VT_REPID = 8,
    VT_ANCHORID = 10,
    VT_X = 12,
    VT_Y = 14,
    VT_Z = 16,
    VT_LAT = 18,
    VT_LON = 20,
    VT_ELV = 22,
    VT_CMPR_IMAGE = 24
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *repid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REPID);
  }
  const ::flatbuffers::String *anchorid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ANCHORID);
  }
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  double lat() const {
    return GetField<double>(VT_LAT, 0.0);
  }
  double lon() const {
    return GetField<double>(VT_LON, 0.0);
  }
  double elv() const {
    return GetField<double>(VT_ELV, 0.0);
  }
  const fb::sensor_msgs::CompressedImage *cmpr_image() const {
    return GetPointer<const fb::sensor_msgs::CompressedImage *>(VT_CMPR_IMAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_REPID) &&
           verifier.VerifyString(repid()) &&
           VerifyOffsetRequired(verifier, VT_ANCHORID) &&
           verifier.VerifyString(anchorid()) &&
           VerifyField<double>(verifier, VT_X, 8) &&
           VerifyField<double>(verifier, VT_Y, 8) &&
           VerifyField<double>(verifier, VT_Z, 8) &&
           VerifyField<double>(verifier, VT_LAT, 8) &&
           VerifyField<double>(verifier, VT_LON, 8) &&
           VerifyField<double>(verifier, VT_ELV, 8) &&
           VerifyOffsetRequired(verifier, VT_CMPR_IMAGE) &&
           verifier.VerifyTable(cmpr_image()) &&
           verifier.EndTable();
  }
  DetectedItemT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DetectedItemT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DetectedItem> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DetectedItemT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DetectedItemBuilder {
  typedef DetectedItem Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(DetectedItem::VT___METADATA, __metadata);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(DetectedItem::VT_NAME, name);
  }
  void add_repid(::flatbuffers::Offset<::flatbuffers::String> repid) {
    fbb_.AddOffset(DetectedItem::VT_REPID, repid);
  }
  void add_anchorid(::flatbuffers::Offset<::flatbuffers::String> anchorid) {
    fbb_.AddOffset(DetectedItem::VT_ANCHORID, anchorid);
  }
  void add_x(double x) {
    fbb_.AddElement<double>(DetectedItem::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(DetectedItem::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(DetectedItem::VT_Z, z, 0.0);
  }
  void add_lat(double lat) {
    fbb_.AddElement<double>(DetectedItem::VT_LAT, lat, 0.0);
  }
  void add_lon(double lon) {
    fbb_.AddElement<double>(DetectedItem::VT_LON, lon, 0.0);
  }
  void add_elv(double elv) {
    fbb_.AddElement<double>(DetectedItem::VT_ELV, elv, 0.0);
  }
  void add_cmpr_image(::flatbuffers::Offset<fb::sensor_msgs::CompressedImage> cmpr_image) {
    fbb_.AddOffset(DetectedItem::VT_CMPR_IMAGE, cmpr_image);
  }
  explicit DetectedItemBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DetectedItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DetectedItem>(end);
    fbb_.Required(o, DetectedItem::VT_NAME);
    fbb_.Required(o, DetectedItem::VT_REPID);
    fbb_.Required(o, DetectedItem::VT_ANCHORID);
    fbb_.Required(o, DetectedItem::VT_CMPR_IMAGE);
    return o;
  }
};

inline ::flatbuffers::Offset<DetectedItem> CreateDetectedItem(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> repid = 0,
    ::flatbuffers::Offset<::flatbuffers::String> anchorid = 0,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0,
    double lat = 0.0,
    double lon = 0.0,
    double elv = 0.0,
    ::flatbuffers::Offset<fb::sensor_msgs::CompressedImage> cmpr_image = 0) {
  DetectedItemBuilder builder_(_fbb);
  builder_.add_elv(elv);
  builder_.add_lon(lon);
  builder_.add_lat(lat);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_cmpr_image(cmpr_image);
  builder_.add_anchorid(anchorid);
  builder_.add_repid(repid);
  builder_.add_name(name);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DetectedItem> CreateDetectedItemDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *name = nullptr,
    const char *repid = nullptr,
    const char *anchorid = nullptr,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0,
    double lat = 0.0,
    double lon = 0.0,
    double elv = 0.0,
    ::flatbuffers::Offset<fb::sensor_msgs::CompressedImage> cmpr_image = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto repid__ = repid ? _fbb.CreateString(repid) : 0;
  auto anchorid__ = anchorid ? _fbb.CreateString(anchorid) : 0;
  return fb::amrl_msgs::CreateDetectedItem(
      _fbb,
      __metadata,
      name__,
      repid__,
      anchorid__,
      x,
      y,
      z,
      lat,
      lon,
      elv,
      cmpr_image);
}

::flatbuffers::Offset<DetectedItem> CreateDetectedItem(::flatbuffers::FlatBufferBuilder &_fbb, const DetectedItemT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ColoredArc2DT : public ::flatbuffers::NativeTable {
  typedef ColoredArc2D TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::amrl_msgs::Point2DT> center{};
  float radius = 0.0f;
  float start_angle = 0.0f;
  float end_angle = 0.0f;
  uint32_t color = 0;
  ColoredArc2DT() = default;
  ColoredArc2DT(const ColoredArc2DT &o);
  ColoredArc2DT(ColoredArc2DT&&) FLATBUFFERS_NOEXCEPT = default;
  ColoredArc2DT &operator=(ColoredArc2DT o) FLATBUFFERS_NOEXCEPT;
};

struct ColoredArc2D FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ColoredArc2DT NativeTableType;
  typedef ColoredArc2DBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_CENTER = 6,
    VT_RADIUS = 8,
    VT_START_ANGLE = 10,
    VT_END_ANGLE = 12,
    VT_COLOR = 14
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::amrl_msgs::Point2D *center() const {
    return GetPointer<const fb::amrl_msgs::Point2D *>(VT_CENTER);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  float start_angle() const {
    return GetField<float>(VT_START_ANGLE, 0.0f);
  }
  float end_angle() const {
    return GetField<float>(VT_END_ANGLE, 0.0f);
  }
  uint32_t color() const {
    return GetField<uint32_t>(VT_COLOR, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_CENTER) &&
           verifier.VerifyTable(center()) &&
           VerifyField<float>(verifier, VT_RADIUS, 4) &&
           VerifyField<float>(verifier, VT_START_ANGLE, 4) &&
           VerifyField<float>(verifier, VT_END_ANGLE, 4) &&
           VerifyField<uint32_t>(verifier, VT_COLOR, 4) &&
           verifier.EndTable();
  }
  ColoredArc2DT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ColoredArc2DT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ColoredArc2D> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ColoredArc2DT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ColoredArc2DBuilder {
  typedef ColoredArc2D Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ColoredArc2D::VT___METADATA, __metadata);
  }
  void add_center(::flatbuffers::Offset<fb::amrl_msgs::Point2D> center) {
    fbb_.AddOffset(ColoredArc2D::VT_CENTER, center);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(ColoredArc2D::VT_RADIUS, radius, 0.0f);
  }
  void add_start_angle(float start_angle) {
    fbb_.AddElement<float>(ColoredArc2D::VT_START_ANGLE, start_angle, 0.0f);
  }
  void add_end_angle(float end_angle) {
    fbb_.AddElement<float>(ColoredArc2D::VT_END_ANGLE, end_angle, 0.0f);
  }
  void add_color(uint32_t color) {
    fbb_.AddElement<uint32_t>(ColoredArc2D::VT_COLOR, color, 0);
  }
  explicit ColoredArc2DBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ColoredArc2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ColoredArc2D>(end);
    fbb_.Required(o, ColoredArc2D::VT_CENTER);
    return o;
  }
};

inline ::flatbuffers::Offset<ColoredArc2D> CreateColoredArc2D(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::amrl_msgs::Point2D> center = 0,
    float radius = 0.0f,
    float start_angle = 0.0f,
    float end_angle = 0.0f,
    uint32_t color = 0) {
  ColoredArc2DBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_end_angle(end_angle);
  builder_.add_start_angle(start_angle);
  builder_.add_radius(radius);
  builder_.add_center(center);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<ColoredArc2D> CreateColoredArc2D(::flatbuffers::FlatBufferBuilder &_fbb, const ColoredArc2DT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PlanarObjDetectionT : public ::flatbuffers::NativeTable {
  typedef PlanarObjDetection TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::string semantic_class{};
  std::unique_ptr<fb::amrl_msgs::Pose2DfT> pose{};
  PlanarObjDetectionT() = default;
  PlanarObjDetectionT(const PlanarObjDetectionT &o);
  PlanarObjDetectionT(PlanarObjDetectionT&&) FLATBUFFERS_NOEXCEPT = default;
  PlanarObjDetectionT &operator=(PlanarObjDetectionT o) FLATBUFFERS_NOEXCEPT;
};

struct PlanarObjDetection FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlanarObjDetectionT NativeTableType;
  typedef PlanarObjDetectionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_SEMANTIC_CLASS = 8,
    VT_POSE = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const ::flatbuffers::String *semantic_class() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SEMANTIC_CLASS);
  }
  const fb::amrl_msgs::Pose2Df *pose() const {
    return GetPointer<const fb::amrl_msgs::Pose2Df *>(VT_POSE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_SEMANTIC_CLASS) &&
           verifier.VerifyString(semantic_class()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           verifier.EndTable();
  }
  PlanarObjDetectionT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PlanarObjDetectionT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PlanarObjDetection> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PlanarObjDetectionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PlanarObjDetectionBuilder {
  typedef PlanarObjDetection Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PlanarObjDetection::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(PlanarObjDetection::VT_HEADER, header);
  }
  void add_semantic_class(::flatbuffers::Offset<::flatbuffers::String> semantic_class) {
    fbb_.AddOffset(PlanarObjDetection::VT_SEMANTIC_CLASS, semantic_class);
  }
  void add_pose(::flatbuffers::Offset<fb::amrl_msgs::Pose2Df> pose) {
    fbb_.AddOffset(PlanarObjDetection::VT_POSE, pose);
  }
  explicit PlanarObjDetectionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlanarObjDetection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlanarObjDetection>(end);
    fbb_.Required(o, PlanarObjDetection::VT_HEADER);
    fbb_.Required(o, PlanarObjDetection::VT_SEMANTIC_CLASS);
    fbb_.Required(o, PlanarObjDetection::VT_POSE);
    return o;
  }
};

inline ::flatbuffers::Offset<PlanarObjDetection> CreatePlanarObjDetection(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<::flatbuffers::String> semantic_class = 0,
    ::flatbuffers::Offset<fb::amrl_msgs::Pose2Df> pose = 0) {
  PlanarObjDetectionBuilder builder_(_fbb);
  builder_.add_pose(pose);
  builder_.add_semantic_class(semantic_class);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PlanarObjDetection> CreatePlanarObjDetectionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const char *semantic_class = nullptr,
    ::flatbuffers::Offset<fb::amrl_msgs::Pose2Df> pose = 0) {
  auto semantic_class__ = semantic_class ? _fbb.CreateString(semantic_class) : 0;
  return fb::amrl_msgs::CreatePlanarObjDetection(
      _fbb,
      __metadata,
      header,
      semantic_class__,
      pose);
}

::flatbuffers::Offset<PlanarObjDetection> CreatePlanarObjDetection(::flatbuffers::FlatBufferBuilder &_fbb, const PlanarObjDetectionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ElevatorCommandT : public ::flatbuffers::NativeTable {
  typedef ElevatorCommand TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  uint8_t floor_cmd = 0;
  bool hold_door = false;
  ElevatorCommandT() = default;
  ElevatorCommandT(const ElevatorCommandT &o);
  ElevatorCommandT(ElevatorCommandT&&) FLATBUFFERS_NOEXCEPT = default;
  ElevatorCommandT &operator=(ElevatorCommandT o) FLATBUFFERS_NOEXCEPT;
};

struct ElevatorCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ElevatorCommandT NativeTableType;
  typedef ElevatorCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_FLOOR_CMD = 6,
    VT_HOLD_DOOR = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  uint8_t floor_cmd() const {
    return GetField<uint8_t>(VT_FLOOR_CMD, 0);
  }
  bool hold_door() const {
    return GetField<uint8_t>(VT_HOLD_DOOR, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint8_t>(verifier, VT_FLOOR_CMD, 1) &&
           VerifyField<uint8_t>(verifier, VT_HOLD_DOOR, 1) &&
           verifier.EndTable();
  }
  ElevatorCommandT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ElevatorCommandT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ElevatorCommand> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ElevatorCommandT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ElevatorCommandBuilder {
  typedef ElevatorCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ElevatorCommand::VT___METADATA, __metadata);
  }
  void add_floor_cmd(uint8_t floor_cmd) {
    fbb_.AddElement<uint8_t>(ElevatorCommand::VT_FLOOR_CMD, floor_cmd, 0);
  }
  void add_hold_door(bool hold_door) {
    fbb_.AddElement<uint8_t>(ElevatorCommand::VT_HOLD_DOOR, static_cast<uint8_t>(hold_door), 0);
  }
  explicit ElevatorCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ElevatorCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ElevatorCommand>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ElevatorCommand> CreateElevatorCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint8_t floor_cmd = 0,
    bool hold_door = false) {
  ElevatorCommandBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  builder_.add_hold_door(hold_door);
  builder_.add_floor_cmd(floor_cmd);
  return builder_.Finish();
}

::flatbuffers::Offset<ElevatorCommand> CreateElevatorCommand(::flatbuffers::FlatBufferBuilder &_fbb, const ElevatorCommandT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline HumanStateArrayMsgT::HumanStateArrayMsgT(const HumanStateArrayMsgT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr) {
  human_states.reserve(o.human_states.size());
  for (const auto &human_states_ : o.human_states) { human_states.emplace_back((human_states_) ? new fb::amrl_msgs::HumanStateMsgT(*human_states_) : nullptr); }
}

inline HumanStateArrayMsgT &HumanStateArrayMsgT::operator=(HumanStateArrayMsgT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(human_states, o.human_states);
  return *this;
}

inline HumanStateArrayMsgT *HumanStateArrayMsg::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<HumanStateArrayMsgT>(new HumanStateArrayMsgT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HumanStateArrayMsg::UnPackTo(HumanStateArrayMsgT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = human_states(); if (_e) { _o->human_states.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->human_states[_i]) { _e->Get(_i)->UnPackTo(_o->human_states[_i].get(), _resolver); } else { _o->human_states[_i] = std::unique_ptr<fb::amrl_msgs::HumanStateMsgT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->human_states.resize(0); } }
}

inline ::flatbuffers::Offset<HumanStateArrayMsg> HumanStateArrayMsg::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HumanStateArrayMsgT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHumanStateArrayMsg(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<HumanStateArrayMsg> CreateHumanStateArrayMsg(::flatbuffers::FlatBufferBuilder &_fbb, const HumanStateArrayMsgT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const HumanStateArrayMsgT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _human_states = _fbb.CreateVector<::flatbuffers::Offset<fb::amrl_msgs::HumanStateMsg>> (_o->human_states.size(), [](size_t i, _VectorArgs *__va) { return CreateHumanStateMsg(*__va->__fbb, __va->__o->human_states[i].get(), __va->__rehasher); }, &_va );
  return fb::amrl_msgs::CreateHumanStateArrayMsg(
      _fbb,
      ___metadata,
      _header,
      _human_states);
}

inline RobofleetStatusT::RobofleetStatusT(const RobofleetStatusT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        status(o.status),
        is_ok(o.is_ok),
        battery_level(o.battery_level),
        location(o.location) {
}

inline RobofleetStatusT &RobofleetStatusT::operator=(RobofleetStatusT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(status, o.status);
  std::swap(is_ok, o.is_ok);
  std::swap(battery_level, o.battery_level);
  std::swap(location, o.location);
  return *this;
}

inline RobofleetStatusT *RobofleetStatus::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RobofleetStatusT>(new RobofleetStatusT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RobofleetStatus::UnPackTo(RobofleetStatusT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = status(); if (_e) _o->status = _e->str(); }
  { auto _e = is_ok(); _o->is_ok = _e; }
  { auto _e = battery_level(); _o->battery_level = _e; }
  { auto _e = location(); if (_e) _o->location = _e->str(); }
}

inline ::flatbuffers::Offset<RobofleetStatus> RobofleetStatus::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RobofleetStatusT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRobofleetStatus(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RobofleetStatus> CreateRobofleetStatus(::flatbuffers::FlatBufferBuilder &_fbb, const RobofleetStatusT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RobofleetStatusT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _status = _fbb.CreateString(_o->status);
  auto _is_ok = _o->is_ok;
  auto _battery_level = _o->battery_level;
  auto _location = _fbb.CreateString(_o->location);
  return fb::amrl_msgs::CreateRobofleetStatus(
      _fbb,
      ___metadata,
      _status,
      _is_ok,
      _battery_level,
      _location);
}

inline SocialPipsSrvRequestT::SocialPipsSrvRequestT(const SocialPipsSrvRequestT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        goal_pose((o.goal_pose) ? new fb::amrl_msgs::Pose2DfT(*o.goal_pose) : nullptr),
        local_target((o.local_target) ? new fb::amrl_msgs::Pose2DfT(*o.local_target) : nullptr),
        door_pose((o.door_pose) ? new fb::amrl_msgs::Pose2DfT(*o.door_pose) : nullptr),
        door_state(o.door_state),
        robot_state(o.robot_state),
        follow_target(o.follow_target) {
  robot_poses.reserve(o.robot_poses.size());
  for (const auto &robot_poses_ : o.robot_poses) { robot_poses.emplace_back((robot_poses_) ? new fb::amrl_msgs::Pose2DfT(*robot_poses_) : nullptr); }
  robot_vels.reserve(o.robot_vels.size());
  for (const auto &robot_vels_ : o.robot_vels) { robot_vels.emplace_back((robot_vels_) ? new fb::amrl_msgs::Pose2DfT(*robot_vels_) : nullptr); }
  human_poses.reserve(o.human_poses.size());
  for (const auto &human_poses_ : o.human_poses) { human_poses.emplace_back((human_poses_) ? new fb::amrl_msgs::Pose2DfT(*human_poses_) : nullptr); }
  human_vels.reserve(o.human_vels.size());
  for (const auto &human_vels_ : o.human_vels) { human_vels.emplace_back((human_vels_) ? new fb::amrl_msgs::Pose2DfT(*human_vels_) : nullptr); }
}

inline SocialPipsSrvRequestT &SocialPipsSrvRequestT::operator=(SocialPipsSrvRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(robot_poses, o.robot_poses);
  std::swap(robot_vels, o.robot_vels);
  std::swap(human_poses, o.human_poses);
  std::swap(human_vels, o.human_vels);
  std::swap(goal_pose, o.goal_pose);
  std::swap(local_target, o.local_target);
  std::swap(door_pose, o.door_pose);
  std::swap(door_state, o.door_state);
  std::swap(robot_state, o.robot_state);
  std::swap(follow_target, o.follow_target);
  return *this;
}

inline SocialPipsSrvRequestT *SocialPipsSrvRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SocialPipsSrvRequestT>(new SocialPipsSrvRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SocialPipsSrvRequest::UnPackTo(SocialPipsSrvRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = robot_poses(); if (_e) { _o->robot_poses.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->robot_poses[_i]) { _e->Get(_i)->UnPackTo(_o->robot_poses[_i].get(), _resolver); } else { _o->robot_poses[_i] = std::unique_ptr<fb::amrl_msgs::Pose2DfT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->robot_poses.resize(0); } }
  { auto _e = robot_vels(); if (_e) { _o->robot_vels.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->robot_vels[_i]) { _e->Get(_i)->UnPackTo(_o->robot_vels[_i].get(), _resolver); } else { _o->robot_vels[_i] = std::unique_ptr<fb::amrl_msgs::Pose2DfT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->robot_vels.resize(0); } }
  { auto _e = human_poses(); if (_e) { _o->human_poses.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->human_poses[_i]) { _e->Get(_i)->UnPackTo(_o->human_poses[_i].get(), _resolver); } else { _o->human_poses[_i] = std::unique_ptr<fb::amrl_msgs::Pose2DfT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->human_poses.resize(0); } }
  { auto _e = human_vels(); if (_e) { _o->human_vels.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->human_vels[_i]) { _e->Get(_i)->UnPackTo(_o->human_vels[_i].get(), _resolver); } else { _o->human_vels[_i] = std::unique_ptr<fb::amrl_msgs::Pose2DfT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->human_vels.resize(0); } }
  { auto _e = goal_pose(); if (_e) { if(_o->goal_pose) { _e->UnPackTo(_o->goal_pose.get(), _resolver); } else { _o->goal_pose = std::unique_ptr<fb::amrl_msgs::Pose2DfT>(_e->UnPack(_resolver)); } } else if (_o->goal_pose) { _o->goal_pose.reset(); } }
  { auto _e = local_target(); if (_e) { if(_o->local_target) { _e->UnPackTo(_o->local_target.get(), _resolver); } else { _o->local_target = std::unique_ptr<fb::amrl_msgs::Pose2DfT>(_e->UnPack(_resolver)); } } else if (_o->local_target) { _o->local_target.reset(); } }
  { auto _e = door_pose(); if (_e) { if(_o->door_pose) { _e->UnPackTo(_o->door_pose.get(), _resolver); } else { _o->door_pose = std::unique_ptr<fb::amrl_msgs::Pose2DfT>(_e->UnPack(_resolver)); } } else if (_o->door_pose) { _o->door_pose.reset(); } }
  { auto _e = door_state(); _o->door_state = _e; }
  { auto _e = robot_state(); _o->robot_state = _e; }
  { auto _e = follow_target(); _o->follow_target = _e; }
}

inline ::flatbuffers::Offset<SocialPipsSrvRequest> SocialPipsSrvRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SocialPipsSrvRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSocialPipsSrvRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SocialPipsSrvRequest> CreateSocialPipsSrvRequest(::flatbuffers::FlatBufferBuilder &_fbb, const SocialPipsSrvRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SocialPipsSrvRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _robot_poses = _fbb.CreateVector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> (_o->robot_poses.size(), [](size_t i, _VectorArgs *__va) { return CreatePose2Df(*__va->__fbb, __va->__o->robot_poses[i].get(), __va->__rehasher); }, &_va );
  auto _robot_vels = _fbb.CreateVector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> (_o->robot_vels.size(), [](size_t i, _VectorArgs *__va) { return CreatePose2Df(*__va->__fbb, __va->__o->robot_vels[i].get(), __va->__rehasher); }, &_va );
  auto _human_poses = _fbb.CreateVector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> (_o->human_poses.size(), [](size_t i, _VectorArgs *__va) { return CreatePose2Df(*__va->__fbb, __va->__o->human_poses[i].get(), __va->__rehasher); }, &_va );
  auto _human_vels = _fbb.CreateVector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> (_o->human_vels.size(), [](size_t i, _VectorArgs *__va) { return CreatePose2Df(*__va->__fbb, __va->__o->human_vels[i].get(), __va->__rehasher); }, &_va );
  auto _goal_pose = _o->goal_pose ? CreatePose2Df(_fbb, _o->goal_pose.get(), _rehasher) : 0;
  auto _local_target = _o->local_target ? CreatePose2Df(_fbb, _o->local_target.get(), _rehasher) : 0;
  auto _door_pose = _o->door_pose ? CreatePose2Df(_fbb, _o->door_pose.get(), _rehasher) : 0;
  auto _door_state = _o->door_state;
  auto _robot_state = _o->robot_state;
  auto _follow_target = _o->follow_target;
  return fb::amrl_msgs::CreateSocialPipsSrvRequest(
      _fbb,
      ___metadata,
      _robot_poses,
      _robot_vels,
      _human_poses,
      _human_vels,
      _goal_pose,
      _local_target,
      _door_pose,
      _door_state,
      _robot_state,
      _follow_target);
}

inline SocialPipsSrvResponseT::SocialPipsSrvResponseT(const SocialPipsSrvResponseT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        action(o.action) {
}

inline SocialPipsSrvResponseT &SocialPipsSrvResponseT::operator=(SocialPipsSrvResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(action, o.action);
  return *this;
}

inline SocialPipsSrvResponseT *SocialPipsSrvResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SocialPipsSrvResponseT>(new SocialPipsSrvResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SocialPipsSrvResponse::UnPackTo(SocialPipsSrvResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = action(); _o->action = _e; }
}

inline ::flatbuffers::Offset<SocialPipsSrvResponse> SocialPipsSrvResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SocialPipsSrvResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSocialPipsSrvResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SocialPipsSrvResponse> CreateSocialPipsSrvResponse(::flatbuffers::FlatBufferBuilder &_fbb, const SocialPipsSrvResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SocialPipsSrvResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _action = _o->action;
  return fb::amrl_msgs::CreateSocialPipsSrvResponse(
      _fbb,
      ___metadata,
      _action);
}

inline VisualizationMsgT::VisualizationMsgT(const VisualizationMsgT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        ns(o.ns) {
  particles.reserve(o.particles.size());
  for (const auto &particles_ : o.particles) { particles.emplace_back((particles_) ? new fb::amrl_msgs::Pose2DfT(*particles_) : nullptr); }
  path_options.reserve(o.path_options.size());
  for (const auto &path_options_ : o.path_options) { path_options.emplace_back((path_options_) ? new fb::amrl_msgs::PathVisualizationT(*path_options_) : nullptr); }
  points.reserve(o.points.size());
  for (const auto &points_ : o.points) { points.emplace_back((points_) ? new fb::amrl_msgs::ColoredPoint2DT(*points_) : nullptr); }
  lines.reserve(o.lines.size());
  for (const auto &lines_ : o.lines) { lines.emplace_back((lines_) ? new fb::amrl_msgs::ColoredLine2DT(*lines_) : nullptr); }
  arcs.reserve(o.arcs.size());
  for (const auto &arcs_ : o.arcs) { arcs.emplace_back((arcs_) ? new fb::amrl_msgs::ColoredArc2DT(*arcs_) : nullptr); }
}

inline VisualizationMsgT &VisualizationMsgT::operator=(VisualizationMsgT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(ns, o.ns);
  std::swap(particles, o.particles);
  std::swap(path_options, o.path_options);
  std::swap(points, o.points);
  std::swap(lines, o.lines);
  std::swap(arcs, o.arcs);
  return *this;
}

inline VisualizationMsgT *VisualizationMsg::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<VisualizationMsgT>(new VisualizationMsgT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void VisualizationMsg::UnPackTo(VisualizationMsgT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = ns(); if (_e) _o->ns = _e->str(); }
  { auto _e = particles(); if (_e) { _o->particles.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->particles[_i]) { _e->Get(_i)->UnPackTo(_o->particles[_i].get(), _resolver); } else { _o->particles[_i] = std::unique_ptr<fb::amrl_msgs::Pose2DfT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->particles.resize(0); } }
  { auto _e = path_options(); if (_e) { _o->path_options.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->path_options[_i]) { _e->Get(_i)->UnPackTo(_o->path_options[_i].get(), _resolver); } else { _o->path_options[_i] = std::unique_ptr<fb::amrl_msgs::PathVisualizationT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->path_options.resize(0); } }
  { auto _e = points(); if (_e) { _o->points.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->points[_i]) { _e->Get(_i)->UnPackTo(_o->points[_i].get(), _resolver); } else { _o->points[_i] = std::unique_ptr<fb::amrl_msgs::ColoredPoint2DT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->points.resize(0); } }
  { auto _e = lines(); if (_e) { _o->lines.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->lines[_i]) { _e->Get(_i)->UnPackTo(_o->lines[_i].get(), _resolver); } else { _o->lines[_i] = std::unique_ptr<fb::amrl_msgs::ColoredLine2DT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->lines.resize(0); } }
  { auto _e = arcs(); if (_e) { _o->arcs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->arcs[_i]) { _e->Get(_i)->UnPackTo(_o->arcs[_i].get(), _resolver); } else { _o->arcs[_i] = std::unique_ptr<fb::amrl_msgs::ColoredArc2DT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->arcs.resize(0); } }
}

inline ::flatbuffers::Offset<VisualizationMsg> VisualizationMsg::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const VisualizationMsgT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVisualizationMsg(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<VisualizationMsg> CreateVisualizationMsg(::flatbuffers::FlatBufferBuilder &_fbb, const VisualizationMsgT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const VisualizationMsgT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _ns = _fbb.CreateString(_o->ns);
  auto _particles = _fbb.CreateVector<::flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> (_o->particles.size(), [](size_t i, _VectorArgs *__va) { return CreatePose2Df(*__va->__fbb, __va->__o->particles[i].get(), __va->__rehasher); }, &_va );
  auto _path_options = _fbb.CreateVector<::flatbuffers::Offset<fb::amrl_msgs::PathVisualization>> (_o->path_options.size(), [](size_t i, _VectorArgs *__va) { return CreatePathVisualization(*__va->__fbb, __va->__o->path_options[i].get(), __va->__rehasher); }, &_va );
  auto _points = _fbb.CreateVector<::flatbuffers::Offset<fb::amrl_msgs::ColoredPoint2D>> (_o->points.size(), [](size_t i, _VectorArgs *__va) { return CreateColoredPoint2D(*__va->__fbb, __va->__o->points[i].get(), __va->__rehasher); }, &_va );
  auto _lines = _fbb.CreateVector<::flatbuffers::Offset<fb::amrl_msgs::ColoredLine2D>> (_o->lines.size(), [](size_t i, _VectorArgs *__va) { return CreateColoredLine2D(*__va->__fbb, __va->__o->lines[i].get(), __va->__rehasher); }, &_va );
  auto _arcs = _fbb.CreateVector<::flatbuffers::Offset<fb::amrl_msgs::ColoredArc2D>> (_o->arcs.size(), [](size_t i, _VectorArgs *__va) { return CreateColoredArc2D(*__va->__fbb, __va->__o->arcs[i].get(), __va->__rehasher); }, &_va );
  return fb::amrl_msgs::CreateVisualizationMsg(
      _fbb,
      ___metadata,
      _header,
      _ns,
      _particles,
      _path_options,
      _points,
      _lines,
      _arcs);
}

inline Localization2DMsgT::Localization2DMsgT(const Localization2DMsgT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        pose((o.pose) ? new fb::amrl_msgs::Pose2DfT(*o.pose) : nullptr),
        map(o.map) {
}

inline Localization2DMsgT &Localization2DMsgT::operator=(Localization2DMsgT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(pose, o.pose);
  std::swap(map, o.map);
  return *this;
}

inline Localization2DMsgT *Localization2DMsg::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Localization2DMsgT>(new Localization2DMsgT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Localization2DMsg::UnPackTo(Localization2DMsgT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = pose(); if (_e) { if(_o->pose) { _e->UnPackTo(_o->pose.get(), _resolver); } else { _o->pose = std::unique_ptr<fb::amrl_msgs::Pose2DfT>(_e->UnPack(_resolver)); } } else if (_o->pose) { _o->pose.reset(); } }
  { auto _e = map(); if (_e) _o->map = _e->str(); }
}

inline ::flatbuffers::Offset<Localization2DMsg> Localization2DMsg::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Localization2DMsgT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLocalization2DMsg(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Localization2DMsg> CreateLocalization2DMsg(::flatbuffers::FlatBufferBuilder &_fbb, const Localization2DMsgT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Localization2DMsgT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _pose = _o->pose ? CreatePose2Df(_fbb, _o->pose.get(), _rehasher) : 0;
  auto _map = _fbb.CreateString(_o->map);
  return fb::amrl_msgs::CreateLocalization2DMsg(
      _fbb,
      ___metadata,
      _header,
      _pose,
      _map);
}

inline HumanStateMsgT::HumanStateMsgT(const HumanStateMsgT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        pose((o.pose) ? new fb::geometry_msgs::Pose2DT(*o.pose) : nullptr),
        translational_velocity((o.translational_velocity) ? new fb::geometry_msgs::Vector3T(*o.translational_velocity) : nullptr),
        rotational_velocity(o.rotational_velocity),
        id(o.id) {
}

inline HumanStateMsgT &HumanStateMsgT::operator=(HumanStateMsgT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(pose, o.pose);
  std::swap(translational_velocity, o.translational_velocity);
  std::swap(rotational_velocity, o.rotational_velocity);
  std::swap(id, o.id);
  return *this;
}

inline HumanStateMsgT *HumanStateMsg::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<HumanStateMsgT>(new HumanStateMsgT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HumanStateMsg::UnPackTo(HumanStateMsgT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = pose(); if (_e) { if(_o->pose) { _e->UnPackTo(_o->pose.get(), _resolver); } else { _o->pose = std::unique_ptr<fb::geometry_msgs::Pose2DT>(_e->UnPack(_resolver)); } } else if (_o->pose) { _o->pose.reset(); } }
  { auto _e = translational_velocity(); if (_e) { if(_o->translational_velocity) { _e->UnPackTo(_o->translational_velocity.get(), _resolver); } else { _o->translational_velocity = std::unique_ptr<fb::geometry_msgs::Vector3T>(_e->UnPack(_resolver)); } } else if (_o->translational_velocity) { _o->translational_velocity.reset(); } }
  { auto _e = rotational_velocity(); _o->rotational_velocity = _e; }
  { auto _e = id(); _o->id = _e; }
}

inline ::flatbuffers::Offset<HumanStateMsg> HumanStateMsg::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HumanStateMsgT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHumanStateMsg(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<HumanStateMsg> CreateHumanStateMsg(::flatbuffers::FlatBufferBuilder &_fbb, const HumanStateMsgT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const HumanStateMsgT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _pose = _o->pose ? CreatePose2D(_fbb, _o->pose.get(), _rehasher) : 0;
  auto _translational_velocity = _o->translational_velocity ? CreateVector3(_fbb, _o->translational_velocity.get(), _rehasher) : 0;
  auto _rotational_velocity = _o->rotational_velocity;
  auto _id = _o->id;
  return fb::amrl_msgs::CreateHumanStateMsg(
      _fbb,
      ___metadata,
      _pose,
      _translational_velocity,
      _rotational_velocity,
      _id);
}

inline ElevatorStatusT::ElevatorStatusT(const ElevatorStatusT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        floor(o.floor),
        door(o.door) {
}

inline ElevatorStatusT &ElevatorStatusT::operator=(ElevatorStatusT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(floor, o.floor);
  std::swap(door, o.door);
  return *this;
}

inline ElevatorStatusT *ElevatorStatus::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ElevatorStatusT>(new ElevatorStatusT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ElevatorStatus::UnPackTo(ElevatorStatusT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = floor(); _o->floor = _e; }
  { auto _e = door(); _o->door = _e; }
}

inline ::flatbuffers::Offset<ElevatorStatus> ElevatorStatus::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ElevatorStatusT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateElevatorStatus(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ElevatorStatus> CreateElevatorStatus(::flatbuffers::FlatBufferBuilder &_fbb, const ElevatorStatusT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ElevatorStatusT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _floor = _o->floor;
  auto _door = _o->door;
  return fb::amrl_msgs::CreateElevatorStatus(
      _fbb,
      ___metadata,
      _floor,
      _door);
}

inline ColoredLine2DT::ColoredLine2DT(const ColoredLine2DT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        p0((o.p0) ? new fb::amrl_msgs::Point2DT(*o.p0) : nullptr),
        p1((o.p1) ? new fb::amrl_msgs::Point2DT(*o.p1) : nullptr),
        color(o.color) {
}

inline ColoredLine2DT &ColoredLine2DT::operator=(ColoredLine2DT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(p0, o.p0);
  std::swap(p1, o.p1);
  std::swap(color, o.color);
  return *this;
}

inline ColoredLine2DT *ColoredLine2D::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ColoredLine2DT>(new ColoredLine2DT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ColoredLine2D::UnPackTo(ColoredLine2DT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = p0(); if (_e) { if(_o->p0) { _e->UnPackTo(_o->p0.get(), _resolver); } else { _o->p0 = std::unique_ptr<fb::amrl_msgs::Point2DT>(_e->UnPack(_resolver)); } } else if (_o->p0) { _o->p0.reset(); } }
  { auto _e = p1(); if (_e) { if(_o->p1) { _e->UnPackTo(_o->p1.get(), _resolver); } else { _o->p1 = std::unique_ptr<fb::amrl_msgs::Point2DT>(_e->UnPack(_resolver)); } } else if (_o->p1) { _o->p1.reset(); } }
  { auto _e = color(); _o->color = _e; }
}

inline ::flatbuffers::Offset<ColoredLine2D> ColoredLine2D::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ColoredLine2DT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateColoredLine2D(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ColoredLine2D> CreateColoredLine2D(::flatbuffers::FlatBufferBuilder &_fbb, const ColoredLine2DT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ColoredLine2DT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _p0 = _o->p0 ? CreatePoint2D(_fbb, _o->p0.get(), _rehasher) : 0;
  auto _p1 = _o->p1 ? CreatePoint2D(_fbb, _o->p1.get(), _rehasher) : 0;
  auto _color = _o->color;
  return fb::amrl_msgs::CreateColoredLine2D(
      _fbb,
      ___metadata,
      _p0,
      _p1,
      _color);
}

inline RobofleetSubscriptionT::RobofleetSubscriptionT(const RobofleetSubscriptionT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        topic_regex(o.topic_regex),
        action(o.action) {
}

inline RobofleetSubscriptionT &RobofleetSubscriptionT::operator=(RobofleetSubscriptionT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(topic_regex, o.topic_regex);
  std::swap(action, o.action);
  return *this;
}

inline RobofleetSubscriptionT *RobofleetSubscription::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RobofleetSubscriptionT>(new RobofleetSubscriptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RobofleetSubscription::UnPackTo(RobofleetSubscriptionT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = topic_regex(); if (_e) _o->topic_regex = _e->str(); }
  { auto _e = action(); _o->action = _e; }
}

inline ::flatbuffers::Offset<RobofleetSubscription> RobofleetSubscription::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RobofleetSubscriptionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRobofleetSubscription(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RobofleetSubscription> CreateRobofleetSubscription(::flatbuffers::FlatBufferBuilder &_fbb, const RobofleetSubscriptionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RobofleetSubscriptionT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _topic_regex = _fbb.CreateString(_o->topic_regex);
  auto _action = _o->action;
  return fb::amrl_msgs::CreateRobofleetSubscription(
      _fbb,
      ___metadata,
      _topic_regex,
      _action);
}

inline Point2DT::Point2DT(const Point2DT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        x(o.x),
        y(o.y) {
}

inline Point2DT &Point2DT::operator=(Point2DT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(x, o.x);
  std::swap(y, o.y);
  return *this;
}

inline Point2DT *Point2D::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Point2DT>(new Point2DT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Point2D::UnPackTo(Point2DT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
}

inline ::flatbuffers::Offset<Point2D> Point2D::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Point2DT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePoint2D(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Point2D> CreatePoint2D(::flatbuffers::FlatBufferBuilder &_fbb, const Point2DT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Point2DT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _x = _o->x;
  auto _y = _o->y;
  return fb::amrl_msgs::CreatePoint2D(
      _fbb,
      ___metadata,
      _x,
      _y);
}

inline Pose2DfT::Pose2DfT(const Pose2DfT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        x(o.x),
        y(o.y),
        theta(o.theta) {
}

inline Pose2DfT &Pose2DfT::operator=(Pose2DfT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(x, o.x);
  std::swap(y, o.y);
  std::swap(theta, o.theta);
  return *this;
}

inline Pose2DfT *Pose2Df::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Pose2DfT>(new Pose2DfT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pose2Df::UnPackTo(Pose2DfT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = theta(); _o->theta = _e; }
}

inline ::flatbuffers::Offset<Pose2Df> Pose2Df::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Pose2DfT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePose2Df(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Pose2Df> CreatePose2Df(::flatbuffers::FlatBufferBuilder &_fbb, const Pose2DfT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Pose2DfT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _theta = _o->theta;
  return fb::amrl_msgs::CreatePose2Df(
      _fbb,
      ___metadata,
      _x,
      _y,
      _theta);
}

inline ColoredPoint2DT::ColoredPoint2DT(const ColoredPoint2DT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        point((o.point) ? new fb::amrl_msgs::Point2DT(*o.point) : nullptr),
        color(o.color) {
}

inline ColoredPoint2DT &ColoredPoint2DT::operator=(ColoredPoint2DT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(point, o.point);
  std::swap(color, o.color);
  return *this;
}

inline ColoredPoint2DT *ColoredPoint2D::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ColoredPoint2DT>(new ColoredPoint2DT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ColoredPoint2D::UnPackTo(ColoredPoint2DT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = point(); if (_e) { if(_o->point) { _e->UnPackTo(_o->point.get(), _resolver); } else { _o->point = std::unique_ptr<fb::amrl_msgs::Point2DT>(_e->UnPack(_resolver)); } } else if (_o->point) { _o->point.reset(); } }
  { auto _e = color(); _o->color = _e; }
}

inline ::flatbuffers::Offset<ColoredPoint2D> ColoredPoint2D::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ColoredPoint2DT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateColoredPoint2D(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ColoredPoint2D> CreateColoredPoint2D(::flatbuffers::FlatBufferBuilder &_fbb, const ColoredPoint2DT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ColoredPoint2DT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _point = _o->point ? CreatePoint2D(_fbb, _o->point.get(), _rehasher) : 0;
  auto _color = _o->color;
  return fb::amrl_msgs::CreateColoredPoint2D(
      _fbb,
      ___metadata,
      _point,
      _color);
}

inline PathVisualizationT::PathVisualizationT(const PathVisualizationT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        curvature(o.curvature),
        distance(o.distance),
        clearance(o.clearance) {
}

inline PathVisualizationT &PathVisualizationT::operator=(PathVisualizationT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(curvature, o.curvature);
  std::swap(distance, o.distance);
  std::swap(clearance, o.clearance);
  return *this;
}

inline PathVisualizationT *PathVisualization::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PathVisualizationT>(new PathVisualizationT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PathVisualization::UnPackTo(PathVisualizationT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = curvature(); _o->curvature = _e; }
  { auto _e = distance(); _o->distance = _e; }
  { auto _e = clearance(); _o->clearance = _e; }
}

inline ::flatbuffers::Offset<PathVisualization> PathVisualization::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PathVisualizationT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePathVisualization(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PathVisualization> CreatePathVisualization(::flatbuffers::FlatBufferBuilder &_fbb, const PathVisualizationT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PathVisualizationT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _curvature = _o->curvature;
  auto _distance = _o->distance;
  auto _clearance = _o->clearance;
  return fb::amrl_msgs::CreatePathVisualization(
      _fbb,
      ___metadata,
      _curvature,
      _distance,
      _clearance);
}

inline AckermannCurvatureDriveMsgT::AckermannCurvatureDriveMsgT(const AckermannCurvatureDriveMsgT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        velocity(o.velocity),
        curvature(o.curvature) {
}

inline AckermannCurvatureDriveMsgT &AckermannCurvatureDriveMsgT::operator=(AckermannCurvatureDriveMsgT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(velocity, o.velocity);
  std::swap(curvature, o.curvature);
  return *this;
}

inline AckermannCurvatureDriveMsgT *AckermannCurvatureDriveMsg::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AckermannCurvatureDriveMsgT>(new AckermannCurvatureDriveMsgT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AckermannCurvatureDriveMsg::UnPackTo(AckermannCurvatureDriveMsgT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = velocity(); _o->velocity = _e; }
  { auto _e = curvature(); _o->curvature = _e; }
}

inline ::flatbuffers::Offset<AckermannCurvatureDriveMsg> AckermannCurvatureDriveMsg::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AckermannCurvatureDriveMsgT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAckermannCurvatureDriveMsg(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AckermannCurvatureDriveMsg> CreateAckermannCurvatureDriveMsg(::flatbuffers::FlatBufferBuilder &_fbb, const AckermannCurvatureDriveMsgT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AckermannCurvatureDriveMsgT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _velocity = _o->velocity;
  auto _curvature = _o->curvature;
  return fb::amrl_msgs::CreateAckermannCurvatureDriveMsg(
      _fbb,
      ___metadata,
      _header,
      _velocity,
      _curvature);
}

inline ErrorReportT::ErrorReportT(const ErrorReportT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        laser_header((o.laser_header) ? new fb::std_msgs::HeaderT(*o.laser_header) : nullptr),
        severity_level(o.severity_level),
        failed_subsystem(o.failed_subsystem),
        detailed_error_msg(o.detailed_error_msg) {
}

inline ErrorReportT &ErrorReportT::operator=(ErrorReportT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(laser_header, o.laser_header);
  std::swap(severity_level, o.severity_level);
  std::swap(failed_subsystem, o.failed_subsystem);
  std::swap(detailed_error_msg, o.detailed_error_msg);
  return *this;
}

inline ErrorReportT *ErrorReport::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ErrorReportT>(new ErrorReportT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ErrorReport::UnPackTo(ErrorReportT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = laser_header(); if (_e) { if(_o->laser_header) { _e->UnPackTo(_o->laser_header.get(), _resolver); } else { _o->laser_header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->laser_header) { _o->laser_header.reset(); } }
  { auto _e = severity_level(); _o->severity_level = _e; }
  { auto _e = failed_subsystem(); _o->failed_subsystem = _e; }
  { auto _e = detailed_error_msg(); if (_e) _o->detailed_error_msg = _e->str(); }
}

inline ::flatbuffers::Offset<ErrorReport> ErrorReport::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ErrorReportT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateErrorReport(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ErrorReport> CreateErrorReport(::flatbuffers::FlatBufferBuilder &_fbb, const ErrorReportT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ErrorReportT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _laser_header = _o->laser_header ? CreateHeader(_fbb, _o->laser_header.get(), _rehasher) : 0;
  auto _severity_level = _o->severity_level;
  auto _failed_subsystem = _o->failed_subsystem;
  auto _detailed_error_msg = _fbb.CreateString(_o->detailed_error_msg);
  return fb::amrl_msgs::CreateErrorReport(
      _fbb,
      ___metadata,
      _header,
      _laser_header,
      _severity_level,
      _failed_subsystem,
      _detailed_error_msg);
}

inline DetectedItemT::DetectedItemT(const DetectedItemT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        name(o.name),
        repid(o.repid),
        anchorid(o.anchorid),
        x(o.x),
        y(o.y),
        z(o.z),
        lat(o.lat),
        lon(o.lon),
        elv(o.elv),
        cmpr_image((o.cmpr_image) ? new fb::sensor_msgs::CompressedImageT(*o.cmpr_image) : nullptr) {
}

inline DetectedItemT &DetectedItemT::operator=(DetectedItemT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(name, o.name);
  std::swap(repid, o.repid);
  std::swap(anchorid, o.anchorid);
  std::swap(x, o.x);
  std::swap(y, o.y);
  std::swap(z, o.z);
  std::swap(lat, o.lat);
  std::swap(lon, o.lon);
  std::swap(elv, o.elv);
  std::swap(cmpr_image, o.cmpr_image);
  return *this;
}

inline DetectedItemT *DetectedItem::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DetectedItemT>(new DetectedItemT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DetectedItem::UnPackTo(DetectedItemT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = repid(); if (_e) _o->repid = _e->str(); }
  { auto _e = anchorid(); if (_e) _o->anchorid = _e->str(); }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
  { auto _e = lat(); _o->lat = _e; }
  { auto _e = lon(); _o->lon = _e; }
  { auto _e = elv(); _o->elv = _e; }
  { auto _e = cmpr_image(); if (_e) { if(_o->cmpr_image) { _e->UnPackTo(_o->cmpr_image.get(), _resolver); } else { _o->cmpr_image = std::unique_ptr<fb::sensor_msgs::CompressedImageT>(_e->UnPack(_resolver)); } } else if (_o->cmpr_image) { _o->cmpr_image.reset(); } }
}

inline ::flatbuffers::Offset<DetectedItem> DetectedItem::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DetectedItemT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDetectedItem(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DetectedItem> CreateDetectedItem(::flatbuffers::FlatBufferBuilder &_fbb, const DetectedItemT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DetectedItemT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _name = _fbb.CreateString(_o->name);
  auto _repid = _fbb.CreateString(_o->repid);
  auto _anchorid = _fbb.CreateString(_o->anchorid);
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  auto _lat = _o->lat;
  auto _lon = _o->lon;
  auto _elv = _o->elv;
  auto _cmpr_image = _o->cmpr_image ? CreateCompressedImage(_fbb, _o->cmpr_image.get(), _rehasher) : 0;
  return fb::amrl_msgs::CreateDetectedItem(
      _fbb,
      ___metadata,
      _name,
      _repid,
      _anchorid,
      _x,
      _y,
      _z,
      _lat,
      _lon,
      _elv,
      _cmpr_image);
}

inline ColoredArc2DT::ColoredArc2DT(const ColoredArc2DT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        center((o.center) ? new fb::amrl_msgs::Point2DT(*o.center) : nullptr),
        radius(o.radius),
        start_angle(o.start_angle),
        end_angle(o.end_angle),
        color(o.color) {
}

inline ColoredArc2DT &ColoredArc2DT::operator=(ColoredArc2DT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(center, o.center);
  std::swap(radius, o.radius);
  std::swap(start_angle, o.start_angle);
  std::swap(end_angle, o.end_angle);
  std::swap(color, o.color);
  return *this;
}

inline ColoredArc2DT *ColoredArc2D::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ColoredArc2DT>(new ColoredArc2DT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ColoredArc2D::UnPackTo(ColoredArc2DT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = center(); if (_e) { if(_o->center) { _e->UnPackTo(_o->center.get(), _resolver); } else { _o->center = std::unique_ptr<fb::amrl_msgs::Point2DT>(_e->UnPack(_resolver)); } } else if (_o->center) { _o->center.reset(); } }
  { auto _e = radius(); _o->radius = _e; }
  { auto _e = start_angle(); _o->start_angle = _e; }
  { auto _e = end_angle(); _o->end_angle = _e; }
  { auto _e = color(); _o->color = _e; }
}

inline ::flatbuffers::Offset<ColoredArc2D> ColoredArc2D::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ColoredArc2DT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateColoredArc2D(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ColoredArc2D> CreateColoredArc2D(::flatbuffers::FlatBufferBuilder &_fbb, const ColoredArc2DT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ColoredArc2DT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _center = _o->center ? CreatePoint2D(_fbb, _o->center.get(), _rehasher) : 0;
  auto _radius = _o->radius;
  auto _start_angle = _o->start_angle;
  auto _end_angle = _o->end_angle;
  auto _color = _o->color;
  return fb::amrl_msgs::CreateColoredArc2D(
      _fbb,
      ___metadata,
      _center,
      _radius,
      _start_angle,
      _end_angle,
      _color);
}

inline PlanarObjDetectionT::PlanarObjDetectionT(const PlanarObjDetectionT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        semantic_class(o.semantic_class),
        pose((o.pose) ? new fb::amrl_msgs::Pose2DfT(*o.pose) : nullptr) {
}

inline PlanarObjDetectionT &PlanarObjDetectionT::operator=(PlanarObjDetectionT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(semantic_class, o.semantic_class);
  std::swap(pose, o.pose);
  return *this;
}

inline PlanarObjDetectionT *PlanarObjDetection::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PlanarObjDetectionT>(new PlanarObjDetectionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PlanarObjDetection::UnPackTo(PlanarObjDetectionT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = semantic_class(); if (_e) _o->semantic_class = _e->str(); }
  { auto _e = pose(); if (_e) { if(_o->pose) { _e->UnPackTo(_o->pose.get(), _resolver); } else { _o->pose = std::unique_ptr<fb::amrl_msgs::Pose2DfT>(_e->UnPack(_resolver)); } } else if (_o->pose) { _o->pose.reset(); } }
}

inline ::flatbuffers::Offset<PlanarObjDetection> PlanarObjDetection::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PlanarObjDetectionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePlanarObjDetection(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PlanarObjDetection> CreatePlanarObjDetection(::flatbuffers::FlatBufferBuilder &_fbb, const PlanarObjDetectionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PlanarObjDetectionT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _semantic_class = _fbb.CreateString(_o->semantic_class);
  auto _pose = _o->pose ? CreatePose2Df(_fbb, _o->pose.get(), _rehasher) : 0;
  return fb::amrl_msgs::CreatePlanarObjDetection(
      _fbb,
      ___metadata,
      _header,
      _semantic_class,
      _pose);
}

inline ElevatorCommandT::ElevatorCommandT(const ElevatorCommandT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        floor_cmd(o.floor_cmd),
        hold_door(o.hold_door) {
}

inline ElevatorCommandT &ElevatorCommandT::operator=(ElevatorCommandT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(floor_cmd, o.floor_cmd);
  std::swap(hold_door, o.hold_door);
  return *this;
}

inline ElevatorCommandT *ElevatorCommand::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ElevatorCommandT>(new ElevatorCommandT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ElevatorCommand::UnPackTo(ElevatorCommandT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = floor_cmd(); _o->floor_cmd = _e; }
  { auto _e = hold_door(); _o->hold_door = _e; }
}

inline ::flatbuffers::Offset<ElevatorCommand> ElevatorCommand::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ElevatorCommandT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateElevatorCommand(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ElevatorCommand> CreateElevatorCommand(::flatbuffers::FlatBufferBuilder &_fbb, const ElevatorCommandT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ElevatorCommandT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _floor_cmd = _o->floor_cmd;
  auto _hold_door = _o->hold_door;
  return fb::amrl_msgs::CreateElevatorCommand(
      _fbb,
      ___metadata,
      _floor_cmd,
      _hold_door);
}

}  // namespace amrl_msgs
}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_AMRLMSGS_FB_AMRL_MSGS_H_
