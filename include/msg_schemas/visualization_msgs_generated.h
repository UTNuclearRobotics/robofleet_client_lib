// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_VISUALIZATIONMSGS_FB_VISUALIZATION_MSGS_H_
#define FLATBUFFERS_GENERATED_VISUALIZATIONMSGS_FB_VISUALIZATION_MSGS_H_

#include "./flatbuffers/flatbuffers.h"

#include "geometry_msgs_generated.h"
#include "std_msgs_generated.h"
#include "base_schema_generated.h"

namespace fb {
namespace visualization_msgs {

struct InteractiveMarkerInit;
struct InteractiveMarkerInitBuilder;
struct InteractiveMarkerInitT;

struct InteractiveMarker;
struct InteractiveMarkerBuilder;
struct InteractiveMarkerT;

struct InteractiveMarkerFeedback;
struct InteractiveMarkerFeedbackBuilder;
struct InteractiveMarkerFeedbackT;

struct InteractiveMarkerUpdate;
struct InteractiveMarkerUpdateBuilder;
struct InteractiveMarkerUpdateT;

struct Marker;
struct MarkerBuilder;
struct MarkerT;

struct InteractiveMarkerPose;
struct InteractiveMarkerPoseBuilder;
struct InteractiveMarkerPoseT;

struct MenuEntry;
struct MenuEntryBuilder;
struct MenuEntryT;

struct ImageMarker;
struct ImageMarkerBuilder;
struct ImageMarkerT;

struct InteractiveMarkerControl;
struct InteractiveMarkerControlBuilder;
struct InteractiveMarkerControlT;

struct MarkerArray;
struct MarkerArrayBuilder;
struct MarkerArrayT;

struct InteractiveMarkerInitT : public flatbuffers::NativeTable {
  typedef InteractiveMarkerInit TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string server_id{};
  uint64_t seq_num = 0;
  std::vector<std::unique_ptr<fb::visualization_msgs::InteractiveMarkerT>> markers{};
  InteractiveMarkerInitT() = default;
  InteractiveMarkerInitT(const InteractiveMarkerInitT &o);
  InteractiveMarkerInitT(InteractiveMarkerInitT&&) FLATBUFFERS_NOEXCEPT = default;
  InteractiveMarkerInitT &operator=(InteractiveMarkerInitT o) FLATBUFFERS_NOEXCEPT;
};

struct InteractiveMarkerInit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InteractiveMarkerInitT NativeTableType;
  typedef InteractiveMarkerInitBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_SERVER_ID = 6,
    VT_SEQ_NUM = 8,
    VT_MARKERS = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const flatbuffers::String *server_id() const {
    return GetPointer<const flatbuffers::String *>(VT_SERVER_ID);
  }
  uint64_t seq_num() const {
    return GetField<uint64_t>(VT_SEQ_NUM, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::visualization_msgs::InteractiveMarker>> *markers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::visualization_msgs::InteractiveMarker>> *>(VT_MARKERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_SERVER_ID) &&
           verifier.VerifyString(server_id()) &&
           VerifyField<uint64_t>(verifier, VT_SEQ_NUM, 8) &&
           VerifyOffsetRequired(verifier, VT_MARKERS) &&
           verifier.VerifyVector(markers()) &&
           verifier.VerifyVectorOfTables(markers()) &&
           verifier.EndTable();
  }
  InteractiveMarkerInitT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InteractiveMarkerInitT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InteractiveMarkerInit> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InteractiveMarkerInitT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InteractiveMarkerInitBuilder {
  typedef InteractiveMarkerInit Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(InteractiveMarkerInit::VT___METADATA, __metadata);
  }
  void add_server_id(flatbuffers::Offset<flatbuffers::String> server_id) {
    fbb_.AddOffset(InteractiveMarkerInit::VT_SERVER_ID, server_id);
  }
  void add_seq_num(uint64_t seq_num) {
    fbb_.AddElement<uint64_t>(InteractiveMarkerInit::VT_SEQ_NUM, seq_num, 0);
  }
  void add_markers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::visualization_msgs::InteractiveMarker>>> markers) {
    fbb_.AddOffset(InteractiveMarkerInit::VT_MARKERS, markers);
  }
  explicit InteractiveMarkerInitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InteractiveMarkerInit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InteractiveMarkerInit>(end);
    fbb_.Required(o, InteractiveMarkerInit::VT_SERVER_ID);
    fbb_.Required(o, InteractiveMarkerInit::VT_MARKERS);
    return o;
  }
};

inline flatbuffers::Offset<InteractiveMarkerInit> CreateInteractiveMarkerInit(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<flatbuffers::String> server_id = 0,
    uint64_t seq_num = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::visualization_msgs::InteractiveMarker>>> markers = 0) {
  InteractiveMarkerInitBuilder builder_(_fbb);
  builder_.add_seq_num(seq_num);
  builder_.add_markers(markers);
  builder_.add_server_id(server_id);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<InteractiveMarkerInit> CreateInteractiveMarkerInitDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *server_id = nullptr,
    uint64_t seq_num = 0,
    const std::vector<flatbuffers::Offset<fb::visualization_msgs::InteractiveMarker>> *markers = nullptr) {
  auto server_id__ = server_id ? _fbb.CreateString(server_id) : 0;
  auto markers__ = markers ? _fbb.CreateVector<flatbuffers::Offset<fb::visualization_msgs::InteractiveMarker>>(*markers) : 0;
  return fb::visualization_msgs::CreateInteractiveMarkerInit(
      _fbb,
      __metadata,
      server_id__,
      seq_num,
      markers__);
}

flatbuffers::Offset<InteractiveMarkerInit> CreateInteractiveMarkerInit(flatbuffers::FlatBufferBuilder &_fbb, const InteractiveMarkerInitT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InteractiveMarkerT : public flatbuffers::NativeTable {
  typedef InteractiveMarker TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::geometry_msgs::PoseT> pose{};
  std::string name{};
  std::string description{};
  float scale = 0.0f;
  std::vector<std::unique_ptr<fb::visualization_msgs::MenuEntryT>> menu_entries{};
  std::vector<std::unique_ptr<fb::visualization_msgs::InteractiveMarkerControlT>> controls{};
  InteractiveMarkerT() = default;
  InteractiveMarkerT(const InteractiveMarkerT &o);
  InteractiveMarkerT(InteractiveMarkerT&&) FLATBUFFERS_NOEXCEPT = default;
  InteractiveMarkerT &operator=(InteractiveMarkerT o) FLATBUFFERS_NOEXCEPT;
};

struct InteractiveMarker FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InteractiveMarkerT NativeTableType;
  typedef InteractiveMarkerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_POSE = 8,
    VT_NAME = 10,
    VT_DESCRIPTION = 12,
    VT_SCALE = 14,
    VT_MENU_ENTRIES = 16,
    VT_CONTROLS = 18
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geometry_msgs::Pose *pose() const {
    return GetPointer<const fb::geometry_msgs::Pose *>(VT_POSE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *description() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  float scale() const {
    return GetField<float>(VT_SCALE, 0.0f);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::visualization_msgs::MenuEntry>> *menu_entries() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::visualization_msgs::MenuEntry>> *>(VT_MENU_ENTRIES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::visualization_msgs::InteractiveMarkerControl>> *controls() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::visualization_msgs::InteractiveMarkerControl>> *>(VT_CONTROLS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyField<float>(verifier, VT_SCALE, 4) &&
           VerifyOffsetRequired(verifier, VT_MENU_ENTRIES) &&
           verifier.VerifyVector(menu_entries()) &&
           verifier.VerifyVectorOfTables(menu_entries()) &&
           VerifyOffsetRequired(verifier, VT_CONTROLS) &&
           verifier.VerifyVector(controls()) &&
           verifier.VerifyVectorOfTables(controls()) &&
           verifier.EndTable();
  }
  InteractiveMarkerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InteractiveMarkerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InteractiveMarker> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InteractiveMarkerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InteractiveMarkerBuilder {
  typedef InteractiveMarker Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(InteractiveMarker::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(InteractiveMarker::VT_HEADER, header);
  }
  void add_pose(flatbuffers::Offset<fb::geometry_msgs::Pose> pose) {
    fbb_.AddOffset(InteractiveMarker::VT_POSE, pose);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(InteractiveMarker::VT_NAME, name);
  }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(InteractiveMarker::VT_DESCRIPTION, description);
  }
  void add_scale(float scale) {
    fbb_.AddElement<float>(InteractiveMarker::VT_SCALE, scale, 0.0f);
  }
  void add_menu_entries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::visualization_msgs::MenuEntry>>> menu_entries) {
    fbb_.AddOffset(InteractiveMarker::VT_MENU_ENTRIES, menu_entries);
  }
  void add_controls(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::visualization_msgs::InteractiveMarkerControl>>> controls) {
    fbb_.AddOffset(InteractiveMarker::VT_CONTROLS, controls);
  }
  explicit InteractiveMarkerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InteractiveMarker> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InteractiveMarker>(end);
    fbb_.Required(o, InteractiveMarker::VT_HEADER);
    fbb_.Required(o, InteractiveMarker::VT_POSE);
    fbb_.Required(o, InteractiveMarker::VT_NAME);
    fbb_.Required(o, InteractiveMarker::VT_DESCRIPTION);
    fbb_.Required(o, InteractiveMarker::VT_MENU_ENTRIES);
    fbb_.Required(o, InteractiveMarker::VT_CONTROLS);
    return o;
  }
};

inline flatbuffers::Offset<InteractiveMarker> CreateInteractiveMarker(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<fb::geometry_msgs::Pose> pose = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> description = 0,
    float scale = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::visualization_msgs::MenuEntry>>> menu_entries = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::visualization_msgs::InteractiveMarkerControl>>> controls = 0) {
  InteractiveMarkerBuilder builder_(_fbb);
  builder_.add_controls(controls);
  builder_.add_menu_entries(menu_entries);
  builder_.add_scale(scale);
  builder_.add_description(description);
  builder_.add_name(name);
  builder_.add_pose(pose);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<InteractiveMarker> CreateInteractiveMarkerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<fb::geometry_msgs::Pose> pose = 0,
    const char *name = nullptr,
    const char *description = nullptr,
    float scale = 0.0f,
    const std::vector<flatbuffers::Offset<fb::visualization_msgs::MenuEntry>> *menu_entries = nullptr,
    const std::vector<flatbuffers::Offset<fb::visualization_msgs::InteractiveMarkerControl>> *controls = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto menu_entries__ = menu_entries ? _fbb.CreateVector<flatbuffers::Offset<fb::visualization_msgs::MenuEntry>>(*menu_entries) : 0;
  auto controls__ = controls ? _fbb.CreateVector<flatbuffers::Offset<fb::visualization_msgs::InteractiveMarkerControl>>(*controls) : 0;
  return fb::visualization_msgs::CreateInteractiveMarker(
      _fbb,
      __metadata,
      header,
      pose,
      name__,
      description__,
      scale,
      menu_entries__,
      controls__);
}

flatbuffers::Offset<InteractiveMarker> CreateInteractiveMarker(flatbuffers::FlatBufferBuilder &_fbb, const InteractiveMarkerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InteractiveMarkerFeedbackT : public flatbuffers::NativeTable {
  typedef InteractiveMarkerFeedback TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::string client_id{};
  std::string marker_name{};
  std::string control_name{};
  uint8_t event_type = 0;
  std::unique_ptr<fb::geometry_msgs::PoseT> pose{};
  uint32_t menu_entry_id = 0;
  std::unique_ptr<fb::geometry_msgs::PointT> mouse_point{};
  bool mouse_point_valid = false;
  InteractiveMarkerFeedbackT() = default;
  InteractiveMarkerFeedbackT(const InteractiveMarkerFeedbackT &o);
  InteractiveMarkerFeedbackT(InteractiveMarkerFeedbackT&&) FLATBUFFERS_NOEXCEPT = default;
  InteractiveMarkerFeedbackT &operator=(InteractiveMarkerFeedbackT o) FLATBUFFERS_NOEXCEPT;
};

struct InteractiveMarkerFeedback FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InteractiveMarkerFeedbackT NativeTableType;
  typedef InteractiveMarkerFeedbackBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_CLIENT_ID = 8,
    VT_MARKER_NAME = 10,
    VT_CONTROL_NAME = 12,
    VT_EVENT_TYPE = 14,
    VT_POSE = 16,
    VT_MENU_ENTRY_ID = 18,
    VT_MOUSE_POINT = 20,
    VT_MOUSE_POINT_VALID = 22
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const flatbuffers::String *client_id() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENT_ID);
  }
  const flatbuffers::String *marker_name() const {
    return GetPointer<const flatbuffers::String *>(VT_MARKER_NAME);
  }
  const flatbuffers::String *control_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CONTROL_NAME);
  }
  uint8_t event_type() const {
    return GetField<uint8_t>(VT_EVENT_TYPE, 0);
  }
  const fb::geometry_msgs::Pose *pose() const {
    return GetPointer<const fb::geometry_msgs::Pose *>(VT_POSE);
  }
  uint32_t menu_entry_id() const {
    return GetField<uint32_t>(VT_MENU_ENTRY_ID, 0);
  }
  const fb::geometry_msgs::Point *mouse_point() const {
    return GetPointer<const fb::geometry_msgs::Point *>(VT_MOUSE_POINT);
  }
  bool mouse_point_valid() const {
    return GetField<uint8_t>(VT_MOUSE_POINT_VALID, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_CLIENT_ID) &&
           verifier.VerifyString(client_id()) &&
           VerifyOffsetRequired(verifier, VT_MARKER_NAME) &&
           verifier.VerifyString(marker_name()) &&
           VerifyOffsetRequired(verifier, VT_CONTROL_NAME) &&
           verifier.VerifyString(control_name()) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           VerifyField<uint32_t>(verifier, VT_MENU_ENTRY_ID, 4) &&
           VerifyOffsetRequired(verifier, VT_MOUSE_POINT) &&
           verifier.VerifyTable(mouse_point()) &&
           VerifyField<uint8_t>(verifier, VT_MOUSE_POINT_VALID, 1) &&
           verifier.EndTable();
  }
  InteractiveMarkerFeedbackT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InteractiveMarkerFeedbackT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InteractiveMarkerFeedback> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InteractiveMarkerFeedbackT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InteractiveMarkerFeedbackBuilder {
  typedef InteractiveMarkerFeedback Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(InteractiveMarkerFeedback::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(InteractiveMarkerFeedback::VT_HEADER, header);
  }
  void add_client_id(flatbuffers::Offset<flatbuffers::String> client_id) {
    fbb_.AddOffset(InteractiveMarkerFeedback::VT_CLIENT_ID, client_id);
  }
  void add_marker_name(flatbuffers::Offset<flatbuffers::String> marker_name) {
    fbb_.AddOffset(InteractiveMarkerFeedback::VT_MARKER_NAME, marker_name);
  }
  void add_control_name(flatbuffers::Offset<flatbuffers::String> control_name) {
    fbb_.AddOffset(InteractiveMarkerFeedback::VT_CONTROL_NAME, control_name);
  }
  void add_event_type(uint8_t event_type) {
    fbb_.AddElement<uint8_t>(InteractiveMarkerFeedback::VT_EVENT_TYPE, event_type, 0);
  }
  void add_pose(flatbuffers::Offset<fb::geometry_msgs::Pose> pose) {
    fbb_.AddOffset(InteractiveMarkerFeedback::VT_POSE, pose);
  }
  void add_menu_entry_id(uint32_t menu_entry_id) {
    fbb_.AddElement<uint32_t>(InteractiveMarkerFeedback::VT_MENU_ENTRY_ID, menu_entry_id, 0);
  }
  void add_mouse_point(flatbuffers::Offset<fb::geometry_msgs::Point> mouse_point) {
    fbb_.AddOffset(InteractiveMarkerFeedback::VT_MOUSE_POINT, mouse_point);
  }
  void add_mouse_point_valid(bool mouse_point_valid) {
    fbb_.AddElement<uint8_t>(InteractiveMarkerFeedback::VT_MOUSE_POINT_VALID, static_cast<uint8_t>(mouse_point_valid), 0);
  }
  explicit InteractiveMarkerFeedbackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InteractiveMarkerFeedback> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InteractiveMarkerFeedback>(end);
    fbb_.Required(o, InteractiveMarkerFeedback::VT_HEADER);
    fbb_.Required(o, InteractiveMarkerFeedback::VT_CLIENT_ID);
    fbb_.Required(o, InteractiveMarkerFeedback::VT_MARKER_NAME);
    fbb_.Required(o, InteractiveMarkerFeedback::VT_CONTROL_NAME);
    fbb_.Required(o, InteractiveMarkerFeedback::VT_POSE);
    fbb_.Required(o, InteractiveMarkerFeedback::VT_MOUSE_POINT);
    return o;
  }
};

inline flatbuffers::Offset<InteractiveMarkerFeedback> CreateInteractiveMarkerFeedback(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<flatbuffers::String> client_id = 0,
    flatbuffers::Offset<flatbuffers::String> marker_name = 0,
    flatbuffers::Offset<flatbuffers::String> control_name = 0,
    uint8_t event_type = 0,
    flatbuffers::Offset<fb::geometry_msgs::Pose> pose = 0,
    uint32_t menu_entry_id = 0,
    flatbuffers::Offset<fb::geometry_msgs::Point> mouse_point = 0,
    bool mouse_point_valid = false) {
  InteractiveMarkerFeedbackBuilder builder_(_fbb);
  builder_.add_mouse_point(mouse_point);
  builder_.add_menu_entry_id(menu_entry_id);
  builder_.add_pose(pose);
  builder_.add_control_name(control_name);
  builder_.add_marker_name(marker_name);
  builder_.add_client_id(client_id);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  builder_.add_mouse_point_valid(mouse_point_valid);
  builder_.add_event_type(event_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<InteractiveMarkerFeedback> CreateInteractiveMarkerFeedbackDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const char *client_id = nullptr,
    const char *marker_name = nullptr,
    const char *control_name = nullptr,
    uint8_t event_type = 0,
    flatbuffers::Offset<fb::geometry_msgs::Pose> pose = 0,
    uint32_t menu_entry_id = 0,
    flatbuffers::Offset<fb::geometry_msgs::Point> mouse_point = 0,
    bool mouse_point_valid = false) {
  auto client_id__ = client_id ? _fbb.CreateString(client_id) : 0;
  auto marker_name__ = marker_name ? _fbb.CreateString(marker_name) : 0;
  auto control_name__ = control_name ? _fbb.CreateString(control_name) : 0;
  return fb::visualization_msgs::CreateInteractiveMarkerFeedback(
      _fbb,
      __metadata,
      header,
      client_id__,
      marker_name__,
      control_name__,
      event_type,
      pose,
      menu_entry_id,
      mouse_point,
      mouse_point_valid);
}

flatbuffers::Offset<InteractiveMarkerFeedback> CreateInteractiveMarkerFeedback(flatbuffers::FlatBufferBuilder &_fbb, const InteractiveMarkerFeedbackT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InteractiveMarkerUpdateT : public flatbuffers::NativeTable {
  typedef InteractiveMarkerUpdate TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string server_id{};
  uint64_t seq_num = 0;
  uint8_t type = 0;
  std::vector<std::unique_ptr<fb::visualization_msgs::InteractiveMarkerT>> markers{};
  std::vector<std::unique_ptr<fb::visualization_msgs::InteractiveMarkerPoseT>> poses{};
  std::vector<std::string> erases{};
  InteractiveMarkerUpdateT() = default;
  InteractiveMarkerUpdateT(const InteractiveMarkerUpdateT &o);
  InteractiveMarkerUpdateT(InteractiveMarkerUpdateT&&) FLATBUFFERS_NOEXCEPT = default;
  InteractiveMarkerUpdateT &operator=(InteractiveMarkerUpdateT o) FLATBUFFERS_NOEXCEPT;
};

struct InteractiveMarkerUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InteractiveMarkerUpdateT NativeTableType;
  typedef InteractiveMarkerUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_SERVER_ID = 6,
    VT_SEQ_NUM = 8,
    VT_TYPE = 10,
    VT_MARKERS = 12,
    VT_POSES = 14,
    VT_ERASES = 16
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const flatbuffers::String *server_id() const {
    return GetPointer<const flatbuffers::String *>(VT_SERVER_ID);
  }
  uint64_t seq_num() const {
    return GetField<uint64_t>(VT_SEQ_NUM, 0);
  }
  uint8_t type() const {
    return GetField<uint8_t>(VT_TYPE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::visualization_msgs::InteractiveMarker>> *markers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::visualization_msgs::InteractiveMarker>> *>(VT_MARKERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::visualization_msgs::InteractiveMarkerPose>> *poses() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::visualization_msgs::InteractiveMarkerPose>> *>(VT_POSES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *erases() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ERASES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_SERVER_ID) &&
           verifier.VerifyString(server_id()) &&
           VerifyField<uint64_t>(verifier, VT_SEQ_NUM, 8) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_MARKERS) &&
           verifier.VerifyVector(markers()) &&
           verifier.VerifyVectorOfTables(markers()) &&
           VerifyOffsetRequired(verifier, VT_POSES) &&
           verifier.VerifyVector(poses()) &&
           verifier.VerifyVectorOfTables(poses()) &&
           VerifyOffsetRequired(verifier, VT_ERASES) &&
           verifier.VerifyVector(erases()) &&
           verifier.VerifyVectorOfStrings(erases()) &&
           verifier.EndTable();
  }
  InteractiveMarkerUpdateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InteractiveMarkerUpdateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InteractiveMarkerUpdate> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InteractiveMarkerUpdateT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InteractiveMarkerUpdateBuilder {
  typedef InteractiveMarkerUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(InteractiveMarkerUpdate::VT___METADATA, __metadata);
  }
  void add_server_id(flatbuffers::Offset<flatbuffers::String> server_id) {
    fbb_.AddOffset(InteractiveMarkerUpdate::VT_SERVER_ID, server_id);
  }
  void add_seq_num(uint64_t seq_num) {
    fbb_.AddElement<uint64_t>(InteractiveMarkerUpdate::VT_SEQ_NUM, seq_num, 0);
  }
  void add_type(uint8_t type) {
    fbb_.AddElement<uint8_t>(InteractiveMarkerUpdate::VT_TYPE, type, 0);
  }
  void add_markers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::visualization_msgs::InteractiveMarker>>> markers) {
    fbb_.AddOffset(InteractiveMarkerUpdate::VT_MARKERS, markers);
  }
  void add_poses(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::visualization_msgs::InteractiveMarkerPose>>> poses) {
    fbb_.AddOffset(InteractiveMarkerUpdate::VT_POSES, poses);
  }
  void add_erases(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> erases) {
    fbb_.AddOffset(InteractiveMarkerUpdate::VT_ERASES, erases);
  }
  explicit InteractiveMarkerUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InteractiveMarkerUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InteractiveMarkerUpdate>(end);
    fbb_.Required(o, InteractiveMarkerUpdate::VT_SERVER_ID);
    fbb_.Required(o, InteractiveMarkerUpdate::VT_MARKERS);
    fbb_.Required(o, InteractiveMarkerUpdate::VT_POSES);
    fbb_.Required(o, InteractiveMarkerUpdate::VT_ERASES);
    return o;
  }
};

inline flatbuffers::Offset<InteractiveMarkerUpdate> CreateInteractiveMarkerUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<flatbuffers::String> server_id = 0,
    uint64_t seq_num = 0,
    uint8_t type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::visualization_msgs::InteractiveMarker>>> markers = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::visualization_msgs::InteractiveMarkerPose>>> poses = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> erases = 0) {
  InteractiveMarkerUpdateBuilder builder_(_fbb);
  builder_.add_seq_num(seq_num);
  builder_.add_erases(erases);
  builder_.add_poses(poses);
  builder_.add_markers(markers);
  builder_.add_server_id(server_id);
  builder_.add___metadata(__metadata);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<InteractiveMarkerUpdate> CreateInteractiveMarkerUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *server_id = nullptr,
    uint64_t seq_num = 0,
    uint8_t type = 0,
    const std::vector<flatbuffers::Offset<fb::visualization_msgs::InteractiveMarker>> *markers = nullptr,
    const std::vector<flatbuffers::Offset<fb::visualization_msgs::InteractiveMarkerPose>> *poses = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *erases = nullptr) {
  auto server_id__ = server_id ? _fbb.CreateString(server_id) : 0;
  auto markers__ = markers ? _fbb.CreateVector<flatbuffers::Offset<fb::visualization_msgs::InteractiveMarker>>(*markers) : 0;
  auto poses__ = poses ? _fbb.CreateVector<flatbuffers::Offset<fb::visualization_msgs::InteractiveMarkerPose>>(*poses) : 0;
  auto erases__ = erases ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*erases) : 0;
  return fb::visualization_msgs::CreateInteractiveMarkerUpdate(
      _fbb,
      __metadata,
      server_id__,
      seq_num,
      type,
      markers__,
      poses__,
      erases__);
}

flatbuffers::Offset<InteractiveMarkerUpdate> CreateInteractiveMarkerUpdate(flatbuffers::FlatBufferBuilder &_fbb, const InteractiveMarkerUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MarkerT : public flatbuffers::NativeTable {
  typedef Marker TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::string ns{};
  int32_t id = 0;
  int32_t type = 0;
  int32_t action = 0;
  std::unique_ptr<fb::geometry_msgs::PoseT> pose{};
  std::unique_ptr<fb::geometry_msgs::Vector3T> scale{};
  std::unique_ptr<fb::std_msgs::ColorRGBAT> color{};
  std::unique_ptr<fb::RosDuration> lifetime{};
  bool frame_locked = false;
  std::vector<std::unique_ptr<fb::geometry_msgs::PointT>> points{};
  std::vector<std::unique_ptr<fb::std_msgs::ColorRGBAT>> colors{};
  std::string text{};
  std::string mesh_resource{};
  bool mesh_use_embedded_materials = false;
  MarkerT() = default;
  MarkerT(const MarkerT &o);
  MarkerT(MarkerT&&) FLATBUFFERS_NOEXCEPT = default;
  MarkerT &operator=(MarkerT o) FLATBUFFERS_NOEXCEPT;
};

struct Marker FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MarkerT NativeTableType;
  typedef MarkerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_NS = 8,
    VT_ID = 10,
    VT_TYPE = 12,
    VT_ACTION = 14,
    VT_POSE = 16,
    VT_SCALE = 18,
    VT_COLOR = 20,
    VT_LIFETIME = 22,
    VT_FRAME_LOCKED = 24,
    VT_POINTS = 26,
    VT_COLORS = 28,
    VT_TEXT = 30,
    VT_MESH_RESOURCE = 32,
    VT_MESH_USE_EMBEDDED_MATERIALS = 34
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const flatbuffers::String *ns() const {
    return GetPointer<const flatbuffers::String *>(VT_NS);
  }
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  int32_t action() const {
    return GetField<int32_t>(VT_ACTION, 0);
  }
  const fb::geometry_msgs::Pose *pose() const {
    return GetPointer<const fb::geometry_msgs::Pose *>(VT_POSE);
  }
  const fb::geometry_msgs::Vector3 *scale() const {
    return GetPointer<const fb::geometry_msgs::Vector3 *>(VT_SCALE);
  }
  const fb::std_msgs::ColorRGBA *color() const {
    return GetPointer<const fb::std_msgs::ColorRGBA *>(VT_COLOR);
  }
  const fb::RosDuration *lifetime() const {
    return GetStruct<const fb::RosDuration *>(VT_LIFETIME);
  }
  bool frame_locked() const {
    return GetField<uint8_t>(VT_FRAME_LOCKED, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::geometry_msgs::Point>> *points() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::geometry_msgs::Point>> *>(VT_POINTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::std_msgs::ColorRGBA>> *colors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::std_msgs::ColorRGBA>> *>(VT_COLORS);
  }
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  const flatbuffers::String *mesh_resource() const {
    return GetPointer<const flatbuffers::String *>(VT_MESH_RESOURCE);
  }
  bool mesh_use_embedded_materials() const {
    return GetField<uint8_t>(VT_MESH_USE_EMBEDDED_MATERIALS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_NS) &&
           verifier.VerifyString(ns()) &&
           VerifyField<int32_t>(verifier, VT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyField<int32_t>(verifier, VT_ACTION, 4) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           VerifyOffsetRequired(verifier, VT_SCALE) &&
           verifier.VerifyTable(scale()) &&
           VerifyOffsetRequired(verifier, VT_COLOR) &&
           verifier.VerifyTable(color()) &&
           VerifyFieldRequired<fb::RosDuration>(verifier, VT_LIFETIME, 4) &&
           VerifyField<uint8_t>(verifier, VT_FRAME_LOCKED, 1) &&
           VerifyOffsetRequired(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.VerifyVectorOfTables(points()) &&
           VerifyOffsetRequired(verifier, VT_COLORS) &&
           verifier.VerifyVector(colors()) &&
           verifier.VerifyVectorOfTables(colors()) &&
           VerifyOffsetRequired(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyOffsetRequired(verifier, VT_MESH_RESOURCE) &&
           verifier.VerifyString(mesh_resource()) &&
           VerifyField<uint8_t>(verifier, VT_MESH_USE_EMBEDDED_MATERIALS, 1) &&
           verifier.EndTable();
  }
  MarkerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MarkerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Marker> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MarkerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MarkerBuilder {
  typedef Marker Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Marker::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(Marker::VT_HEADER, header);
  }
  void add_ns(flatbuffers::Offset<flatbuffers::String> ns) {
    fbb_.AddOffset(Marker::VT_NS, ns);
  }
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Marker::VT_ID, id, 0);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(Marker::VT_TYPE, type, 0);
  }
  void add_action(int32_t action) {
    fbb_.AddElement<int32_t>(Marker::VT_ACTION, action, 0);
  }
  void add_pose(flatbuffers::Offset<fb::geometry_msgs::Pose> pose) {
    fbb_.AddOffset(Marker::VT_POSE, pose);
  }
  void add_scale(flatbuffers::Offset<fb::geometry_msgs::Vector3> scale) {
    fbb_.AddOffset(Marker::VT_SCALE, scale);
  }
  void add_color(flatbuffers::Offset<fb::std_msgs::ColorRGBA> color) {
    fbb_.AddOffset(Marker::VT_COLOR, color);
  }
  void add_lifetime(const fb::RosDuration *lifetime) {
    fbb_.AddStruct(Marker::VT_LIFETIME, lifetime);
  }
  void add_frame_locked(bool frame_locked) {
    fbb_.AddElement<uint8_t>(Marker::VT_FRAME_LOCKED, static_cast<uint8_t>(frame_locked), 0);
  }
  void add_points(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::geometry_msgs::Point>>> points) {
    fbb_.AddOffset(Marker::VT_POINTS, points);
  }
  void add_colors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::std_msgs::ColorRGBA>>> colors) {
    fbb_.AddOffset(Marker::VT_COLORS, colors);
  }
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(Marker::VT_TEXT, text);
  }
  void add_mesh_resource(flatbuffers::Offset<flatbuffers::String> mesh_resource) {
    fbb_.AddOffset(Marker::VT_MESH_RESOURCE, mesh_resource);
  }
  void add_mesh_use_embedded_materials(bool mesh_use_embedded_materials) {
    fbb_.AddElement<uint8_t>(Marker::VT_MESH_USE_EMBEDDED_MATERIALS, static_cast<uint8_t>(mesh_use_embedded_materials), 0);
  }
  explicit MarkerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Marker> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Marker>(end);
    fbb_.Required(o, Marker::VT_HEADER);
    fbb_.Required(o, Marker::VT_NS);
    fbb_.Required(o, Marker::VT_POSE);
    fbb_.Required(o, Marker::VT_SCALE);
    fbb_.Required(o, Marker::VT_COLOR);
    fbb_.Required(o, Marker::VT_LIFETIME);
    fbb_.Required(o, Marker::VT_POINTS);
    fbb_.Required(o, Marker::VT_COLORS);
    fbb_.Required(o, Marker::VT_TEXT);
    fbb_.Required(o, Marker::VT_MESH_RESOURCE);
    return o;
  }
};

inline flatbuffers::Offset<Marker> CreateMarker(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<flatbuffers::String> ns = 0,
    int32_t id = 0,
    int32_t type = 0,
    int32_t action = 0,
    flatbuffers::Offset<fb::geometry_msgs::Pose> pose = 0,
    flatbuffers::Offset<fb::geometry_msgs::Vector3> scale = 0,
    flatbuffers::Offset<fb::std_msgs::ColorRGBA> color = 0,
    const fb::RosDuration *lifetime = nullptr,
    bool frame_locked = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::geometry_msgs::Point>>> points = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::std_msgs::ColorRGBA>>> colors = 0,
    flatbuffers::Offset<flatbuffers::String> text = 0,
    flatbuffers::Offset<flatbuffers::String> mesh_resource = 0,
    bool mesh_use_embedded_materials = false) {
  MarkerBuilder builder_(_fbb);
  builder_.add_mesh_resource(mesh_resource);
  builder_.add_text(text);
  builder_.add_colors(colors);
  builder_.add_points(points);
  builder_.add_lifetime(lifetime);
  builder_.add_color(color);
  builder_.add_scale(scale);
  builder_.add_pose(pose);
  builder_.add_action(action);
  builder_.add_type(type);
  builder_.add_id(id);
  builder_.add_ns(ns);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  builder_.add_mesh_use_embedded_materials(mesh_use_embedded_materials);
  builder_.add_frame_locked(frame_locked);
  return builder_.Finish();
}

inline flatbuffers::Offset<Marker> CreateMarkerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const char *ns = nullptr,
    int32_t id = 0,
    int32_t type = 0,
    int32_t action = 0,
    flatbuffers::Offset<fb::geometry_msgs::Pose> pose = 0,
    flatbuffers::Offset<fb::geometry_msgs::Vector3> scale = 0,
    flatbuffers::Offset<fb::std_msgs::ColorRGBA> color = 0,
    const fb::RosDuration *lifetime = nullptr,
    bool frame_locked = false,
    const std::vector<flatbuffers::Offset<fb::geometry_msgs::Point>> *points = nullptr,
    const std::vector<flatbuffers::Offset<fb::std_msgs::ColorRGBA>> *colors = nullptr,
    const char *text = nullptr,
    const char *mesh_resource = nullptr,
    bool mesh_use_embedded_materials = false) {
  auto ns__ = ns ? _fbb.CreateString(ns) : 0;
  auto points__ = points ? _fbb.CreateVector<flatbuffers::Offset<fb::geometry_msgs::Point>>(*points) : 0;
  auto colors__ = colors ? _fbb.CreateVector<flatbuffers::Offset<fb::std_msgs::ColorRGBA>>(*colors) : 0;
  auto text__ = text ? _fbb.CreateString(text) : 0;
  auto mesh_resource__ = mesh_resource ? _fbb.CreateString(mesh_resource) : 0;
  return fb::visualization_msgs::CreateMarker(
      _fbb,
      __metadata,
      header,
      ns__,
      id,
      type,
      action,
      pose,
      scale,
      color,
      lifetime,
      frame_locked,
      points__,
      colors__,
      text__,
      mesh_resource__,
      mesh_use_embedded_materials);
}

flatbuffers::Offset<Marker> CreateMarker(flatbuffers::FlatBufferBuilder &_fbb, const MarkerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InteractiveMarkerPoseT : public flatbuffers::NativeTable {
  typedef InteractiveMarkerPose TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::geometry_msgs::PoseT> pose{};
  std::string name{};
  InteractiveMarkerPoseT() = default;
  InteractiveMarkerPoseT(const InteractiveMarkerPoseT &o);
  InteractiveMarkerPoseT(InteractiveMarkerPoseT&&) FLATBUFFERS_NOEXCEPT = default;
  InteractiveMarkerPoseT &operator=(InteractiveMarkerPoseT o) FLATBUFFERS_NOEXCEPT;
};

struct InteractiveMarkerPose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InteractiveMarkerPoseT NativeTableType;
  typedef InteractiveMarkerPoseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_POSE = 8,
    VT_NAME = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geometry_msgs::Pose *pose() const {
    return GetPointer<const fb::geometry_msgs::Pose *>(VT_POSE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
  InteractiveMarkerPoseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InteractiveMarkerPoseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InteractiveMarkerPose> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InteractiveMarkerPoseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InteractiveMarkerPoseBuilder {
  typedef InteractiveMarkerPose Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(InteractiveMarkerPose::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(InteractiveMarkerPose::VT_HEADER, header);
  }
  void add_pose(flatbuffers::Offset<fb::geometry_msgs::Pose> pose) {
    fbb_.AddOffset(InteractiveMarkerPose::VT_POSE, pose);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(InteractiveMarkerPose::VT_NAME, name);
  }
  explicit InteractiveMarkerPoseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InteractiveMarkerPose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InteractiveMarkerPose>(end);
    fbb_.Required(o, InteractiveMarkerPose::VT_HEADER);
    fbb_.Required(o, InteractiveMarkerPose::VT_POSE);
    fbb_.Required(o, InteractiveMarkerPose::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<InteractiveMarkerPose> CreateInteractiveMarkerPose(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<fb::geometry_msgs::Pose> pose = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  InteractiveMarkerPoseBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_pose(pose);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<InteractiveMarkerPose> CreateInteractiveMarkerPoseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<fb::geometry_msgs::Pose> pose = 0,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return fb::visualization_msgs::CreateInteractiveMarkerPose(
      _fbb,
      __metadata,
      header,
      pose,
      name__);
}

flatbuffers::Offset<InteractiveMarkerPose> CreateInteractiveMarkerPose(flatbuffers::FlatBufferBuilder &_fbb, const InteractiveMarkerPoseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MenuEntryT : public flatbuffers::NativeTable {
  typedef MenuEntry TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  uint32_t id = 0;
  uint32_t parent_id = 0;
  std::string title{};
  std::string command{};
  uint8_t command_type = 0;
  MenuEntryT() = default;
  MenuEntryT(const MenuEntryT &o);
  MenuEntryT(MenuEntryT&&) FLATBUFFERS_NOEXCEPT = default;
  MenuEntryT &operator=(MenuEntryT o) FLATBUFFERS_NOEXCEPT;
};

struct MenuEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MenuEntryT NativeTableType;
  typedef MenuEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_ID = 6,
    VT_PARENT_ID = 8,
    VT_TITLE = 10,
    VT_COMMAND = 12,
    VT_COMMAND_TYPE = 14
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  uint32_t parent_id() const {
    return GetField<uint32_t>(VT_PARENT_ID, 0);
  }
  const flatbuffers::String *title() const {
    return GetPointer<const flatbuffers::String *>(VT_TITLE);
  }
  const flatbuffers::String *command() const {
    return GetPointer<const flatbuffers::String *>(VT_COMMAND);
  }
  uint8_t command_type() const {
    return GetField<uint8_t>(VT_COMMAND_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_PARENT_ID, 4) &&
           VerifyOffsetRequired(verifier, VT_TITLE) &&
           verifier.VerifyString(title()) &&
           VerifyOffsetRequired(verifier, VT_COMMAND) &&
           verifier.VerifyString(command()) &&
           VerifyField<uint8_t>(verifier, VT_COMMAND_TYPE, 1) &&
           verifier.EndTable();
  }
  MenuEntryT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MenuEntryT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MenuEntry> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MenuEntryT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MenuEntryBuilder {
  typedef MenuEntry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(MenuEntry::VT___METADATA, __metadata);
  }
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(MenuEntry::VT_ID, id, 0);
  }
  void add_parent_id(uint32_t parent_id) {
    fbb_.AddElement<uint32_t>(MenuEntry::VT_PARENT_ID, parent_id, 0);
  }
  void add_title(flatbuffers::Offset<flatbuffers::String> title) {
    fbb_.AddOffset(MenuEntry::VT_TITLE, title);
  }
  void add_command(flatbuffers::Offset<flatbuffers::String> command) {
    fbb_.AddOffset(MenuEntry::VT_COMMAND, command);
  }
  void add_command_type(uint8_t command_type) {
    fbb_.AddElement<uint8_t>(MenuEntry::VT_COMMAND_TYPE, command_type, 0);
  }
  explicit MenuEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MenuEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MenuEntry>(end);
    fbb_.Required(o, MenuEntry::VT_TITLE);
    fbb_.Required(o, MenuEntry::VT_COMMAND);
    return o;
  }
};

inline flatbuffers::Offset<MenuEntry> CreateMenuEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint32_t id = 0,
    uint32_t parent_id = 0,
    flatbuffers::Offset<flatbuffers::String> title = 0,
    flatbuffers::Offset<flatbuffers::String> command = 0,
    uint8_t command_type = 0) {
  MenuEntryBuilder builder_(_fbb);
  builder_.add_command(command);
  builder_.add_title(title);
  builder_.add_parent_id(parent_id);
  builder_.add_id(id);
  builder_.add___metadata(__metadata);
  builder_.add_command_type(command_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<MenuEntry> CreateMenuEntryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint32_t id = 0,
    uint32_t parent_id = 0,
    const char *title = nullptr,
    const char *command = nullptr,
    uint8_t command_type = 0) {
  auto title__ = title ? _fbb.CreateString(title) : 0;
  auto command__ = command ? _fbb.CreateString(command) : 0;
  return fb::visualization_msgs::CreateMenuEntry(
      _fbb,
      __metadata,
      id,
      parent_id,
      title__,
      command__,
      command_type);
}

flatbuffers::Offset<MenuEntry> CreateMenuEntry(flatbuffers::FlatBufferBuilder &_fbb, const MenuEntryT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ImageMarkerT : public flatbuffers::NativeTable {
  typedef ImageMarker TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::string ns{};
  int32_t id = 0;
  int32_t type = 0;
  int32_t action = 0;
  std::unique_ptr<fb::geometry_msgs::PointT> position{};
  float scale = 0.0f;
  std::unique_ptr<fb::std_msgs::ColorRGBAT> outline_color{};
  uint8_t filled = 0;
  std::unique_ptr<fb::std_msgs::ColorRGBAT> fill_color{};
  std::unique_ptr<fb::RosDuration> lifetime{};
  std::vector<std::unique_ptr<fb::geometry_msgs::PointT>> points{};
  std::vector<std::unique_ptr<fb::std_msgs::ColorRGBAT>> outline_colors{};
  ImageMarkerT() = default;
  ImageMarkerT(const ImageMarkerT &o);
  ImageMarkerT(ImageMarkerT&&) FLATBUFFERS_NOEXCEPT = default;
  ImageMarkerT &operator=(ImageMarkerT o) FLATBUFFERS_NOEXCEPT;
};

struct ImageMarker FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ImageMarkerT NativeTableType;
  typedef ImageMarkerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_NS = 8,
    VT_ID = 10,
    VT_TYPE = 12,
    VT_ACTION = 14,
    VT_POSITION = 16,
    VT_SCALE = 18,
    VT_OUTLINE_COLOR = 20,
    VT_FILLED = 22,
    VT_FILL_COLOR = 24,
    VT_LIFETIME = 26,
    VT_POINTS = 28,
    VT_OUTLINE_COLORS = 30
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const flatbuffers::String *ns() const {
    return GetPointer<const flatbuffers::String *>(VT_NS);
  }
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  int32_t action() const {
    return GetField<int32_t>(VT_ACTION, 0);
  }
  const fb::geometry_msgs::Point *position() const {
    return GetPointer<const fb::geometry_msgs::Point *>(VT_POSITION);
  }
  float scale() const {
    return GetField<float>(VT_SCALE, 0.0f);
  }
  const fb::std_msgs::ColorRGBA *outline_color() const {
    return GetPointer<const fb::std_msgs::ColorRGBA *>(VT_OUTLINE_COLOR);
  }
  uint8_t filled() const {
    return GetField<uint8_t>(VT_FILLED, 0);
  }
  const fb::std_msgs::ColorRGBA *fill_color() const {
    return GetPointer<const fb::std_msgs::ColorRGBA *>(VT_FILL_COLOR);
  }
  const fb::RosDuration *lifetime() const {
    return GetStruct<const fb::RosDuration *>(VT_LIFETIME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::geometry_msgs::Point>> *points() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::geometry_msgs::Point>> *>(VT_POINTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::std_msgs::ColorRGBA>> *outline_colors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::std_msgs::ColorRGBA>> *>(VT_OUTLINE_COLORS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_NS) &&
           verifier.VerifyString(ns()) &&
           VerifyField<int32_t>(verifier, VT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyField<int32_t>(verifier, VT_ACTION, 4) &&
           VerifyOffsetRequired(verifier, VT_POSITION) &&
           verifier.VerifyTable(position()) &&
           VerifyField<float>(verifier, VT_SCALE, 4) &&
           VerifyOffsetRequired(verifier, VT_OUTLINE_COLOR) &&
           verifier.VerifyTable(outline_color()) &&
           VerifyField<uint8_t>(verifier, VT_FILLED, 1) &&
           VerifyOffsetRequired(verifier, VT_FILL_COLOR) &&
           verifier.VerifyTable(fill_color()) &&
           VerifyFieldRequired<fb::RosDuration>(verifier, VT_LIFETIME, 4) &&
           VerifyOffsetRequired(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.VerifyVectorOfTables(points()) &&
           VerifyOffsetRequired(verifier, VT_OUTLINE_COLORS) &&
           verifier.VerifyVector(outline_colors()) &&
           verifier.VerifyVectorOfTables(outline_colors()) &&
           verifier.EndTable();
  }
  ImageMarkerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ImageMarkerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ImageMarker> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ImageMarkerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ImageMarkerBuilder {
  typedef ImageMarker Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ImageMarker::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(ImageMarker::VT_HEADER, header);
  }
  void add_ns(flatbuffers::Offset<flatbuffers::String> ns) {
    fbb_.AddOffset(ImageMarker::VT_NS, ns);
  }
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(ImageMarker::VT_ID, id, 0);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ImageMarker::VT_TYPE, type, 0);
  }
  void add_action(int32_t action) {
    fbb_.AddElement<int32_t>(ImageMarker::VT_ACTION, action, 0);
  }
  void add_position(flatbuffers::Offset<fb::geometry_msgs::Point> position) {
    fbb_.AddOffset(ImageMarker::VT_POSITION, position);
  }
  void add_scale(float scale) {
    fbb_.AddElement<float>(ImageMarker::VT_SCALE, scale, 0.0f);
  }
  void add_outline_color(flatbuffers::Offset<fb::std_msgs::ColorRGBA> outline_color) {
    fbb_.AddOffset(ImageMarker::VT_OUTLINE_COLOR, outline_color);
  }
  void add_filled(uint8_t filled) {
    fbb_.AddElement<uint8_t>(ImageMarker::VT_FILLED, filled, 0);
  }
  void add_fill_color(flatbuffers::Offset<fb::std_msgs::ColorRGBA> fill_color) {
    fbb_.AddOffset(ImageMarker::VT_FILL_COLOR, fill_color);
  }
  void add_lifetime(const fb::RosDuration *lifetime) {
    fbb_.AddStruct(ImageMarker::VT_LIFETIME, lifetime);
  }
  void add_points(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::geometry_msgs::Point>>> points) {
    fbb_.AddOffset(ImageMarker::VT_POINTS, points);
  }
  void add_outline_colors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::std_msgs::ColorRGBA>>> outline_colors) {
    fbb_.AddOffset(ImageMarker::VT_OUTLINE_COLORS, outline_colors);
  }
  explicit ImageMarkerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ImageMarker> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ImageMarker>(end);
    fbb_.Required(o, ImageMarker::VT_HEADER);
    fbb_.Required(o, ImageMarker::VT_NS);
    fbb_.Required(o, ImageMarker::VT_POSITION);
    fbb_.Required(o, ImageMarker::VT_OUTLINE_COLOR);
    fbb_.Required(o, ImageMarker::VT_FILL_COLOR);
    fbb_.Required(o, ImageMarker::VT_LIFETIME);
    fbb_.Required(o, ImageMarker::VT_POINTS);
    fbb_.Required(o, ImageMarker::VT_OUTLINE_COLORS);
    return o;
  }
};

inline flatbuffers::Offset<ImageMarker> CreateImageMarker(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<flatbuffers::String> ns = 0,
    int32_t id = 0,
    int32_t type = 0,
    int32_t action = 0,
    flatbuffers::Offset<fb::geometry_msgs::Point> position = 0,
    float scale = 0.0f,
    flatbuffers::Offset<fb::std_msgs::ColorRGBA> outline_color = 0,
    uint8_t filled = 0,
    flatbuffers::Offset<fb::std_msgs::ColorRGBA> fill_color = 0,
    const fb::RosDuration *lifetime = nullptr,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::geometry_msgs::Point>>> points = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::std_msgs::ColorRGBA>>> outline_colors = 0) {
  ImageMarkerBuilder builder_(_fbb);
  builder_.add_outline_colors(outline_colors);
  builder_.add_points(points);
  builder_.add_lifetime(lifetime);
  builder_.add_fill_color(fill_color);
  builder_.add_outline_color(outline_color);
  builder_.add_scale(scale);
  builder_.add_position(position);
  builder_.add_action(action);
  builder_.add_type(type);
  builder_.add_id(id);
  builder_.add_ns(ns);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  builder_.add_filled(filled);
  return builder_.Finish();
}

inline flatbuffers::Offset<ImageMarker> CreateImageMarkerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const char *ns = nullptr,
    int32_t id = 0,
    int32_t type = 0,
    int32_t action = 0,
    flatbuffers::Offset<fb::geometry_msgs::Point> position = 0,
    float scale = 0.0f,
    flatbuffers::Offset<fb::std_msgs::ColorRGBA> outline_color = 0,
    uint8_t filled = 0,
    flatbuffers::Offset<fb::std_msgs::ColorRGBA> fill_color = 0,
    const fb::RosDuration *lifetime = nullptr,
    const std::vector<flatbuffers::Offset<fb::geometry_msgs::Point>> *points = nullptr,
    const std::vector<flatbuffers::Offset<fb::std_msgs::ColorRGBA>> *outline_colors = nullptr) {
  auto ns__ = ns ? _fbb.CreateString(ns) : 0;
  auto points__ = points ? _fbb.CreateVector<flatbuffers::Offset<fb::geometry_msgs::Point>>(*points) : 0;
  auto outline_colors__ = outline_colors ? _fbb.CreateVector<flatbuffers::Offset<fb::std_msgs::ColorRGBA>>(*outline_colors) : 0;
  return fb::visualization_msgs::CreateImageMarker(
      _fbb,
      __metadata,
      header,
      ns__,
      id,
      type,
      action,
      position,
      scale,
      outline_color,
      filled,
      fill_color,
      lifetime,
      points__,
      outline_colors__);
}

flatbuffers::Offset<ImageMarker> CreateImageMarker(flatbuffers::FlatBufferBuilder &_fbb, const ImageMarkerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InteractiveMarkerControlT : public flatbuffers::NativeTable {
  typedef InteractiveMarkerControl TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string name{};
  std::unique_ptr<fb::geometry_msgs::QuaternionT> orientation{};
  uint8_t orientation_mode = 0;
  uint8_t interaction_mode = 0;
  bool always_visible = false;
  std::vector<std::unique_ptr<fb::visualization_msgs::MarkerT>> markers{};
  bool independent_marker_orientation = false;
  std::string description{};
  InteractiveMarkerControlT() = default;
  InteractiveMarkerControlT(const InteractiveMarkerControlT &o);
  InteractiveMarkerControlT(InteractiveMarkerControlT&&) FLATBUFFERS_NOEXCEPT = default;
  InteractiveMarkerControlT &operator=(InteractiveMarkerControlT o) FLATBUFFERS_NOEXCEPT;
};

struct InteractiveMarkerControl FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InteractiveMarkerControlT NativeTableType;
  typedef InteractiveMarkerControlBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_NAME = 6,
    VT_ORIENTATION = 8,
    VT_ORIENTATION_MODE = 10,
    VT_INTERACTION_MODE = 12,
    VT_ALWAYS_VISIBLE = 14,
    VT_MARKERS = 16,
    VT_INDEPENDENT_MARKER_ORIENTATION = 18,
    VT_DESCRIPTION = 20
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const fb::geometry_msgs::Quaternion *orientation() const {
    return GetPointer<const fb::geometry_msgs::Quaternion *>(VT_ORIENTATION);
  }
  uint8_t orientation_mode() const {
    return GetField<uint8_t>(VT_ORIENTATION_MODE, 0);
  }
  uint8_t interaction_mode() const {
    return GetField<uint8_t>(VT_INTERACTION_MODE, 0);
  }
  bool always_visible() const {
    return GetField<uint8_t>(VT_ALWAYS_VISIBLE, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::visualization_msgs::Marker>> *markers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::visualization_msgs::Marker>> *>(VT_MARKERS);
  }
  bool independent_marker_orientation() const {
    return GetField<uint8_t>(VT_INDEPENDENT_MARKER_ORIENTATION, 0) != 0;
  }
  const flatbuffers::String *description() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_ORIENTATION) &&
           verifier.VerifyTable(orientation()) &&
           VerifyField<uint8_t>(verifier, VT_ORIENTATION_MODE, 1) &&
           VerifyField<uint8_t>(verifier, VT_INTERACTION_MODE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ALWAYS_VISIBLE, 1) &&
           VerifyOffsetRequired(verifier, VT_MARKERS) &&
           verifier.VerifyVector(markers()) &&
           verifier.VerifyVectorOfTables(markers()) &&
           VerifyField<uint8_t>(verifier, VT_INDEPENDENT_MARKER_ORIENTATION, 1) &&
           VerifyOffsetRequired(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           verifier.EndTable();
  }
  InteractiveMarkerControlT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InteractiveMarkerControlT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InteractiveMarkerControl> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InteractiveMarkerControlT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InteractiveMarkerControlBuilder {
  typedef InteractiveMarkerControl Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(InteractiveMarkerControl::VT___METADATA, __metadata);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(InteractiveMarkerControl::VT_NAME, name);
  }
  void add_orientation(flatbuffers::Offset<fb::geometry_msgs::Quaternion> orientation) {
    fbb_.AddOffset(InteractiveMarkerControl::VT_ORIENTATION, orientation);
  }
  void add_orientation_mode(uint8_t orientation_mode) {
    fbb_.AddElement<uint8_t>(InteractiveMarkerControl::VT_ORIENTATION_MODE, orientation_mode, 0);
  }
  void add_interaction_mode(uint8_t interaction_mode) {
    fbb_.AddElement<uint8_t>(InteractiveMarkerControl::VT_INTERACTION_MODE, interaction_mode, 0);
  }
  void add_always_visible(bool always_visible) {
    fbb_.AddElement<uint8_t>(InteractiveMarkerControl::VT_ALWAYS_VISIBLE, static_cast<uint8_t>(always_visible), 0);
  }
  void add_markers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::visualization_msgs::Marker>>> markers) {
    fbb_.AddOffset(InteractiveMarkerControl::VT_MARKERS, markers);
  }
  void add_independent_marker_orientation(bool independent_marker_orientation) {
    fbb_.AddElement<uint8_t>(InteractiveMarkerControl::VT_INDEPENDENT_MARKER_ORIENTATION, static_cast<uint8_t>(independent_marker_orientation), 0);
  }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(InteractiveMarkerControl::VT_DESCRIPTION, description);
  }
  explicit InteractiveMarkerControlBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InteractiveMarkerControl> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InteractiveMarkerControl>(end);
    fbb_.Required(o, InteractiveMarkerControl::VT_NAME);
    fbb_.Required(o, InteractiveMarkerControl::VT_ORIENTATION);
    fbb_.Required(o, InteractiveMarkerControl::VT_MARKERS);
    fbb_.Required(o, InteractiveMarkerControl::VT_DESCRIPTION);
    return o;
  }
};

inline flatbuffers::Offset<InteractiveMarkerControl> CreateInteractiveMarkerControl(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<fb::geometry_msgs::Quaternion> orientation = 0,
    uint8_t orientation_mode = 0,
    uint8_t interaction_mode = 0,
    bool always_visible = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::visualization_msgs::Marker>>> markers = 0,
    bool independent_marker_orientation = false,
    flatbuffers::Offset<flatbuffers::String> description = 0) {
  InteractiveMarkerControlBuilder builder_(_fbb);
  builder_.add_description(description);
  builder_.add_markers(markers);
  builder_.add_orientation(orientation);
  builder_.add_name(name);
  builder_.add___metadata(__metadata);
  builder_.add_independent_marker_orientation(independent_marker_orientation);
  builder_.add_always_visible(always_visible);
  builder_.add_interaction_mode(interaction_mode);
  builder_.add_orientation_mode(orientation_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<InteractiveMarkerControl> CreateInteractiveMarkerControlDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *name = nullptr,
    flatbuffers::Offset<fb::geometry_msgs::Quaternion> orientation = 0,
    uint8_t orientation_mode = 0,
    uint8_t interaction_mode = 0,
    bool always_visible = false,
    const std::vector<flatbuffers::Offset<fb::visualization_msgs::Marker>> *markers = nullptr,
    bool independent_marker_orientation = false,
    const char *description = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto markers__ = markers ? _fbb.CreateVector<flatbuffers::Offset<fb::visualization_msgs::Marker>>(*markers) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  return fb::visualization_msgs::CreateInteractiveMarkerControl(
      _fbb,
      __metadata,
      name__,
      orientation,
      orientation_mode,
      interaction_mode,
      always_visible,
      markers__,
      independent_marker_orientation,
      description__);
}

flatbuffers::Offset<InteractiveMarkerControl> CreateInteractiveMarkerControl(flatbuffers::FlatBufferBuilder &_fbb, const InteractiveMarkerControlT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MarkerArrayT : public flatbuffers::NativeTable {
  typedef MarkerArray TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::vector<std::unique_ptr<fb::visualization_msgs::MarkerT>> markers{};
  MarkerArrayT() = default;
  MarkerArrayT(const MarkerArrayT &o);
  MarkerArrayT(MarkerArrayT&&) FLATBUFFERS_NOEXCEPT = default;
  MarkerArrayT &operator=(MarkerArrayT o) FLATBUFFERS_NOEXCEPT;
};

struct MarkerArray FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MarkerArrayT NativeTableType;
  typedef MarkerArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_MARKERS = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::visualization_msgs::Marker>> *markers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::visualization_msgs::Marker>> *>(VT_MARKERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_MARKERS) &&
           verifier.VerifyVector(markers()) &&
           verifier.VerifyVectorOfTables(markers()) &&
           verifier.EndTable();
  }
  MarkerArrayT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MarkerArrayT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MarkerArray> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MarkerArrayT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MarkerArrayBuilder {
  typedef MarkerArray Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(MarkerArray::VT___METADATA, __metadata);
  }
  void add_markers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::visualization_msgs::Marker>>> markers) {
    fbb_.AddOffset(MarkerArray::VT_MARKERS, markers);
  }
  explicit MarkerArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MarkerArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MarkerArray>(end);
    fbb_.Required(o, MarkerArray::VT_MARKERS);
    return o;
  }
};

inline flatbuffers::Offset<MarkerArray> CreateMarkerArray(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::visualization_msgs::Marker>>> markers = 0) {
  MarkerArrayBuilder builder_(_fbb);
  builder_.add_markers(markers);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<MarkerArray> CreateMarkerArrayDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const std::vector<flatbuffers::Offset<fb::visualization_msgs::Marker>> *markers = nullptr) {
  auto markers__ = markers ? _fbb.CreateVector<flatbuffers::Offset<fb::visualization_msgs::Marker>>(*markers) : 0;
  return fb::visualization_msgs::CreateMarkerArray(
      _fbb,
      __metadata,
      markers__);
}

flatbuffers::Offset<MarkerArray> CreateMarkerArray(flatbuffers::FlatBufferBuilder &_fbb, const MarkerArrayT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline InteractiveMarkerInitT::InteractiveMarkerInitT(const InteractiveMarkerInitT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        server_id(o.server_id),
        seq_num(o.seq_num) {
  markers.reserve(o.markers.size());
  for (const auto &v : o.markers) { markers.emplace_back((v) ? new fb::visualization_msgs::InteractiveMarkerT(*v) : nullptr); }
}

inline InteractiveMarkerInitT &InteractiveMarkerInitT::operator=(InteractiveMarkerInitT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(server_id, o.server_id);
  std::swap(seq_num, o.seq_num);
  std::swap(markers, o.markers);
  return *this;
}

inline InteractiveMarkerInitT *InteractiveMarkerInit::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InteractiveMarkerInitT>(new InteractiveMarkerInitT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InteractiveMarkerInit::UnPackTo(InteractiveMarkerInitT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = server_id(); if (_e) _o->server_id = _e->str(); }
  { auto _e = seq_num(); _o->seq_num = _e; }
  { auto _e = markers(); if (_e) { _o->markers.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->markers[_i]) { _e->Get(_i)->UnPackTo(_o->markers[_i].get(), _resolver); } else { _o->markers[_i] = std::unique_ptr<fb::visualization_msgs::InteractiveMarkerT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<InteractiveMarkerInit> InteractiveMarkerInit::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InteractiveMarkerInitT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInteractiveMarkerInit(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InteractiveMarkerInit> CreateInteractiveMarkerInit(flatbuffers::FlatBufferBuilder &_fbb, const InteractiveMarkerInitT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InteractiveMarkerInitT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _server_id = _fbb.CreateString(_o->server_id);
  auto _seq_num = _o->seq_num;
  auto _markers = _fbb.CreateVector<flatbuffers::Offset<fb::visualization_msgs::InteractiveMarker>> (_o->markers.size(), [](size_t i, _VectorArgs *__va) { return CreateInteractiveMarker(*__va->__fbb, __va->__o->markers[i].get(), __va->__rehasher); }, &_va );
  return fb::visualization_msgs::CreateInteractiveMarkerInit(
      _fbb,
      ___metadata,
      _server_id,
      _seq_num,
      _markers);
}

inline InteractiveMarkerT::InteractiveMarkerT(const InteractiveMarkerT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        pose((o.pose) ? new fb::geometry_msgs::PoseT(*o.pose) : nullptr),
        name(o.name),
        description(o.description),
        scale(o.scale) {
  menu_entries.reserve(o.menu_entries.size());
  for (const auto &v : o.menu_entries) { menu_entries.emplace_back((v) ? new fb::visualization_msgs::MenuEntryT(*v) : nullptr); }
  controls.reserve(o.controls.size());
  for (const auto &v : o.controls) { controls.emplace_back((v) ? new fb::visualization_msgs::InteractiveMarkerControlT(*v) : nullptr); }
}

inline InteractiveMarkerT &InteractiveMarkerT::operator=(InteractiveMarkerT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(pose, o.pose);
  std::swap(name, o.name);
  std::swap(description, o.description);
  std::swap(scale, o.scale);
  std::swap(menu_entries, o.menu_entries);
  std::swap(controls, o.controls);
  return *this;
}

inline InteractiveMarkerT *InteractiveMarker::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InteractiveMarkerT>(new InteractiveMarkerT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InteractiveMarker::UnPackTo(InteractiveMarkerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } }
  { auto _e = pose(); if (_e) { if(_o->pose) { _e->UnPackTo(_o->pose.get(), _resolver); } else { _o->pose = std::unique_ptr<fb::geometry_msgs::PoseT>(_e->UnPack(_resolver)); } } }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = description(); if (_e) _o->description = _e->str(); }
  { auto _e = scale(); _o->scale = _e; }
  { auto _e = menu_entries(); if (_e) { _o->menu_entries.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->menu_entries[_i]) { _e->Get(_i)->UnPackTo(_o->menu_entries[_i].get(), _resolver); } else { _o->menu_entries[_i] = std::unique_ptr<fb::visualization_msgs::MenuEntryT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = controls(); if (_e) { _o->controls.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->controls[_i]) { _e->Get(_i)->UnPackTo(_o->controls[_i].get(), _resolver); } else { _o->controls[_i] = std::unique_ptr<fb::visualization_msgs::InteractiveMarkerControlT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<InteractiveMarker> InteractiveMarker::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InteractiveMarkerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInteractiveMarker(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InteractiveMarker> CreateInteractiveMarker(flatbuffers::FlatBufferBuilder &_fbb, const InteractiveMarkerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InteractiveMarkerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _pose = _o->pose ? CreatePose(_fbb, _o->pose.get(), _rehasher) : 0;
  auto _name = _fbb.CreateString(_o->name);
  auto _description = _fbb.CreateString(_o->description);
  auto _scale = _o->scale;
  auto _menu_entries = _fbb.CreateVector<flatbuffers::Offset<fb::visualization_msgs::MenuEntry>> (_o->menu_entries.size(), [](size_t i, _VectorArgs *__va) { return CreateMenuEntry(*__va->__fbb, __va->__o->menu_entries[i].get(), __va->__rehasher); }, &_va );
  auto _controls = _fbb.CreateVector<flatbuffers::Offset<fb::visualization_msgs::InteractiveMarkerControl>> (_o->controls.size(), [](size_t i, _VectorArgs *__va) { return CreateInteractiveMarkerControl(*__va->__fbb, __va->__o->controls[i].get(), __va->__rehasher); }, &_va );
  return fb::visualization_msgs::CreateInteractiveMarker(
      _fbb,
      ___metadata,
      _header,
      _pose,
      _name,
      _description,
      _scale,
      _menu_entries,
      _controls);
}

inline InteractiveMarkerFeedbackT::InteractiveMarkerFeedbackT(const InteractiveMarkerFeedbackT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        client_id(o.client_id),
        marker_name(o.marker_name),
        control_name(o.control_name),
        event_type(o.event_type),
        pose((o.pose) ? new fb::geometry_msgs::PoseT(*o.pose) : nullptr),
        menu_entry_id(o.menu_entry_id),
        mouse_point((o.mouse_point) ? new fb::geometry_msgs::PointT(*o.mouse_point) : nullptr),
        mouse_point_valid(o.mouse_point_valid) {
}

inline InteractiveMarkerFeedbackT &InteractiveMarkerFeedbackT::operator=(InteractiveMarkerFeedbackT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(client_id, o.client_id);
  std::swap(marker_name, o.marker_name);
  std::swap(control_name, o.control_name);
  std::swap(event_type, o.event_type);
  std::swap(pose, o.pose);
  std::swap(menu_entry_id, o.menu_entry_id);
  std::swap(mouse_point, o.mouse_point);
  std::swap(mouse_point_valid, o.mouse_point_valid);
  return *this;
}

inline InteractiveMarkerFeedbackT *InteractiveMarkerFeedback::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InteractiveMarkerFeedbackT>(new InteractiveMarkerFeedbackT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InteractiveMarkerFeedback::UnPackTo(InteractiveMarkerFeedbackT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } }
  { auto _e = client_id(); if (_e) _o->client_id = _e->str(); }
  { auto _e = marker_name(); if (_e) _o->marker_name = _e->str(); }
  { auto _e = control_name(); if (_e) _o->control_name = _e->str(); }
  { auto _e = event_type(); _o->event_type = _e; }
  { auto _e = pose(); if (_e) { if(_o->pose) { _e->UnPackTo(_o->pose.get(), _resolver); } else { _o->pose = std::unique_ptr<fb::geometry_msgs::PoseT>(_e->UnPack(_resolver)); } } }
  { auto _e = menu_entry_id(); _o->menu_entry_id = _e; }
  { auto _e = mouse_point(); if (_e) { if(_o->mouse_point) { _e->UnPackTo(_o->mouse_point.get(), _resolver); } else { _o->mouse_point = std::unique_ptr<fb::geometry_msgs::PointT>(_e->UnPack(_resolver)); } } }
  { auto _e = mouse_point_valid(); _o->mouse_point_valid = _e; }
}

inline flatbuffers::Offset<InteractiveMarkerFeedback> InteractiveMarkerFeedback::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InteractiveMarkerFeedbackT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInteractiveMarkerFeedback(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InteractiveMarkerFeedback> CreateInteractiveMarkerFeedback(flatbuffers::FlatBufferBuilder &_fbb, const InteractiveMarkerFeedbackT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InteractiveMarkerFeedbackT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _client_id = _fbb.CreateString(_o->client_id);
  auto _marker_name = _fbb.CreateString(_o->marker_name);
  auto _control_name = _fbb.CreateString(_o->control_name);
  auto _event_type = _o->event_type;
  auto _pose = _o->pose ? CreatePose(_fbb, _o->pose.get(), _rehasher) : 0;
  auto _menu_entry_id = _o->menu_entry_id;
  auto _mouse_point = _o->mouse_point ? CreatePoint(_fbb, _o->mouse_point.get(), _rehasher) : 0;
  auto _mouse_point_valid = _o->mouse_point_valid;
  return fb::visualization_msgs::CreateInteractiveMarkerFeedback(
      _fbb,
      ___metadata,
      _header,
      _client_id,
      _marker_name,
      _control_name,
      _event_type,
      _pose,
      _menu_entry_id,
      _mouse_point,
      _mouse_point_valid);
}

inline InteractiveMarkerUpdateT::InteractiveMarkerUpdateT(const InteractiveMarkerUpdateT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        server_id(o.server_id),
        seq_num(o.seq_num),
        type(o.type),
        erases(o.erases) {
  markers.reserve(o.markers.size());
  for (const auto &v : o.markers) { markers.emplace_back((v) ? new fb::visualization_msgs::InteractiveMarkerT(*v) : nullptr); }
  poses.reserve(o.poses.size());
  for (const auto &v : o.poses) { poses.emplace_back((v) ? new fb::visualization_msgs::InteractiveMarkerPoseT(*v) : nullptr); }
}

inline InteractiveMarkerUpdateT &InteractiveMarkerUpdateT::operator=(InteractiveMarkerUpdateT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(server_id, o.server_id);
  std::swap(seq_num, o.seq_num);
  std::swap(type, o.type);
  std::swap(markers, o.markers);
  std::swap(poses, o.poses);
  std::swap(erases, o.erases);
  return *this;
}

inline InteractiveMarkerUpdateT *InteractiveMarkerUpdate::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InteractiveMarkerUpdateT>(new InteractiveMarkerUpdateT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InteractiveMarkerUpdate::UnPackTo(InteractiveMarkerUpdateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = server_id(); if (_e) _o->server_id = _e->str(); }
  { auto _e = seq_num(); _o->seq_num = _e; }
  { auto _e = type(); _o->type = _e; }
  { auto _e = markers(); if (_e) { _o->markers.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->markers[_i]) { _e->Get(_i)->UnPackTo(_o->markers[_i].get(), _resolver); } else { _o->markers[_i] = std::unique_ptr<fb::visualization_msgs::InteractiveMarkerT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = poses(); if (_e) { _o->poses.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->poses[_i]) { _e->Get(_i)->UnPackTo(_o->poses[_i].get(), _resolver); } else { _o->poses[_i] = std::unique_ptr<fb::visualization_msgs::InteractiveMarkerPoseT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = erases(); if (_e) { _o->erases.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->erases[_i] = _e->Get(_i)->str(); } } }
}

inline flatbuffers::Offset<InteractiveMarkerUpdate> InteractiveMarkerUpdate::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InteractiveMarkerUpdateT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInteractiveMarkerUpdate(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InteractiveMarkerUpdate> CreateInteractiveMarkerUpdate(flatbuffers::FlatBufferBuilder &_fbb, const InteractiveMarkerUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InteractiveMarkerUpdateT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _server_id = _fbb.CreateString(_o->server_id);
  auto _seq_num = _o->seq_num;
  auto _type = _o->type;
  auto _markers = _fbb.CreateVector<flatbuffers::Offset<fb::visualization_msgs::InteractiveMarker>> (_o->markers.size(), [](size_t i, _VectorArgs *__va) { return CreateInteractiveMarker(*__va->__fbb, __va->__o->markers[i].get(), __va->__rehasher); }, &_va );
  auto _poses = _fbb.CreateVector<flatbuffers::Offset<fb::visualization_msgs::InteractiveMarkerPose>> (_o->poses.size(), [](size_t i, _VectorArgs *__va) { return CreateInteractiveMarkerPose(*__va->__fbb, __va->__o->poses[i].get(), __va->__rehasher); }, &_va );
  auto _erases = _fbb.CreateVectorOfStrings(_o->erases);
  return fb::visualization_msgs::CreateInteractiveMarkerUpdate(
      _fbb,
      ___metadata,
      _server_id,
      _seq_num,
      _type,
      _markers,
      _poses,
      _erases);
}

inline MarkerT::MarkerT(const MarkerT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        ns(o.ns),
        id(o.id),
        type(o.type),
        action(o.action),
        pose((o.pose) ? new fb::geometry_msgs::PoseT(*o.pose) : nullptr),
        scale((o.scale) ? new fb::geometry_msgs::Vector3T(*o.scale) : nullptr),
        color((o.color) ? new fb::std_msgs::ColorRGBAT(*o.color) : nullptr),
        lifetime((o.lifetime) ? new fb::RosDuration(*o.lifetime) : nullptr),
        frame_locked(o.frame_locked),
        text(o.text),
        mesh_resource(o.mesh_resource),
        mesh_use_embedded_materials(o.mesh_use_embedded_materials) {
  points.reserve(o.points.size());
  for (const auto &v : o.points) { points.emplace_back((v) ? new fb::geometry_msgs::PointT(*v) : nullptr); }
  colors.reserve(o.colors.size());
  for (const auto &v : o.colors) { colors.emplace_back((v) ? new fb::std_msgs::ColorRGBAT(*v) : nullptr); }
}

inline MarkerT &MarkerT::operator=(MarkerT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(ns, o.ns);
  std::swap(id, o.id);
  std::swap(type, o.type);
  std::swap(action, o.action);
  std::swap(pose, o.pose);
  std::swap(scale, o.scale);
  std::swap(color, o.color);
  std::swap(lifetime, o.lifetime);
  std::swap(frame_locked, o.frame_locked);
  std::swap(points, o.points);
  std::swap(colors, o.colors);
  std::swap(text, o.text);
  std::swap(mesh_resource, o.mesh_resource);
  std::swap(mesh_use_embedded_materials, o.mesh_use_embedded_materials);
  return *this;
}

inline MarkerT *Marker::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MarkerT>(new MarkerT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Marker::UnPackTo(MarkerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } }
  { auto _e = ns(); if (_e) _o->ns = _e->str(); }
  { auto _e = id(); _o->id = _e; }
  { auto _e = type(); _o->type = _e; }
  { auto _e = action(); _o->action = _e; }
  { auto _e = pose(); if (_e) { if(_o->pose) { _e->UnPackTo(_o->pose.get(), _resolver); } else { _o->pose = std::unique_ptr<fb::geometry_msgs::PoseT>(_e->UnPack(_resolver)); } } }
  { auto _e = scale(); if (_e) { if(_o->scale) { _e->UnPackTo(_o->scale.get(), _resolver); } else { _o->scale = std::unique_ptr<fb::geometry_msgs::Vector3T>(_e->UnPack(_resolver)); } } }
  { auto _e = color(); if (_e) { if(_o->color) { _e->UnPackTo(_o->color.get(), _resolver); } else { _o->color = std::unique_ptr<fb::std_msgs::ColorRGBAT>(_e->UnPack(_resolver)); } } }
  { auto _e = lifetime(); if (_e) _o->lifetime = std::unique_ptr<fb::RosDuration>(new fb::RosDuration(*_e)); }
  { auto _e = frame_locked(); _o->frame_locked = _e; }
  { auto _e = points(); if (_e) { _o->points.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->points[_i]) { _e->Get(_i)->UnPackTo(_o->points[_i].get(), _resolver); } else { _o->points[_i] = std::unique_ptr<fb::geometry_msgs::PointT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = colors(); if (_e) { _o->colors.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->colors[_i]) { _e->Get(_i)->UnPackTo(_o->colors[_i].get(), _resolver); } else { _o->colors[_i] = std::unique_ptr<fb::std_msgs::ColorRGBAT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = text(); if (_e) _o->text = _e->str(); }
  { auto _e = mesh_resource(); if (_e) _o->mesh_resource = _e->str(); }
  { auto _e = mesh_use_embedded_materials(); _o->mesh_use_embedded_materials = _e; }
}

inline flatbuffers::Offset<Marker> Marker::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MarkerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMarker(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Marker> CreateMarker(flatbuffers::FlatBufferBuilder &_fbb, const MarkerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MarkerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _ns = _fbb.CreateString(_o->ns);
  auto _id = _o->id;
  auto _type = _o->type;
  auto _action = _o->action;
  auto _pose = _o->pose ? CreatePose(_fbb, _o->pose.get(), _rehasher) : 0;
  auto _scale = _o->scale ? CreateVector3(_fbb, _o->scale.get(), _rehasher) : 0;
  auto _color = _o->color ? CreateColorRGBA(_fbb, _o->color.get(), _rehasher) : 0;
  auto _lifetime = _o->lifetime ? _o->lifetime.get() : 0;
  auto _frame_locked = _o->frame_locked;
  auto _points = _fbb.CreateVector<flatbuffers::Offset<fb::geometry_msgs::Point>> (_o->points.size(), [](size_t i, _VectorArgs *__va) { return CreatePoint(*__va->__fbb, __va->__o->points[i].get(), __va->__rehasher); }, &_va );
  auto _colors = _fbb.CreateVector<flatbuffers::Offset<fb::std_msgs::ColorRGBA>> (_o->colors.size(), [](size_t i, _VectorArgs *__va) { return CreateColorRGBA(*__va->__fbb, __va->__o->colors[i].get(), __va->__rehasher); }, &_va );
  auto _text = _fbb.CreateString(_o->text);
  auto _mesh_resource = _fbb.CreateString(_o->mesh_resource);
  auto _mesh_use_embedded_materials = _o->mesh_use_embedded_materials;
  return fb::visualization_msgs::CreateMarker(
      _fbb,
      ___metadata,
      _header,
      _ns,
      _id,
      _type,
      _action,
      _pose,
      _scale,
      _color,
      _lifetime,
      _frame_locked,
      _points,
      _colors,
      _text,
      _mesh_resource,
      _mesh_use_embedded_materials);
}

inline InteractiveMarkerPoseT::InteractiveMarkerPoseT(const InteractiveMarkerPoseT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        pose((o.pose) ? new fb::geometry_msgs::PoseT(*o.pose) : nullptr),
        name(o.name) {
}

inline InteractiveMarkerPoseT &InteractiveMarkerPoseT::operator=(InteractiveMarkerPoseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(pose, o.pose);
  std::swap(name, o.name);
  return *this;
}

inline InteractiveMarkerPoseT *InteractiveMarkerPose::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InteractiveMarkerPoseT>(new InteractiveMarkerPoseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InteractiveMarkerPose::UnPackTo(InteractiveMarkerPoseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } }
  { auto _e = pose(); if (_e) { if(_o->pose) { _e->UnPackTo(_o->pose.get(), _resolver); } else { _o->pose = std::unique_ptr<fb::geometry_msgs::PoseT>(_e->UnPack(_resolver)); } } }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
}

inline flatbuffers::Offset<InteractiveMarkerPose> InteractiveMarkerPose::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InteractiveMarkerPoseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInteractiveMarkerPose(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InteractiveMarkerPose> CreateInteractiveMarkerPose(flatbuffers::FlatBufferBuilder &_fbb, const InteractiveMarkerPoseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InteractiveMarkerPoseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _pose = _o->pose ? CreatePose(_fbb, _o->pose.get(), _rehasher) : 0;
  auto _name = _fbb.CreateString(_o->name);
  return fb::visualization_msgs::CreateInteractiveMarkerPose(
      _fbb,
      ___metadata,
      _header,
      _pose,
      _name);
}

inline MenuEntryT::MenuEntryT(const MenuEntryT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        id(o.id),
        parent_id(o.parent_id),
        title(o.title),
        command(o.command),
        command_type(o.command_type) {
}

inline MenuEntryT &MenuEntryT::operator=(MenuEntryT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(id, o.id);
  std::swap(parent_id, o.parent_id);
  std::swap(title, o.title);
  std::swap(command, o.command);
  std::swap(command_type, o.command_type);
  return *this;
}

inline MenuEntryT *MenuEntry::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MenuEntryT>(new MenuEntryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MenuEntry::UnPackTo(MenuEntryT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = id(); _o->id = _e; }
  { auto _e = parent_id(); _o->parent_id = _e; }
  { auto _e = title(); if (_e) _o->title = _e->str(); }
  { auto _e = command(); if (_e) _o->command = _e->str(); }
  { auto _e = command_type(); _o->command_type = _e; }
}

inline flatbuffers::Offset<MenuEntry> MenuEntry::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MenuEntryT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMenuEntry(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MenuEntry> CreateMenuEntry(flatbuffers::FlatBufferBuilder &_fbb, const MenuEntryT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MenuEntryT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _id = _o->id;
  auto _parent_id = _o->parent_id;
  auto _title = _fbb.CreateString(_o->title);
  auto _command = _fbb.CreateString(_o->command);
  auto _command_type = _o->command_type;
  return fb::visualization_msgs::CreateMenuEntry(
      _fbb,
      ___metadata,
      _id,
      _parent_id,
      _title,
      _command,
      _command_type);
}

inline ImageMarkerT::ImageMarkerT(const ImageMarkerT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        ns(o.ns),
        id(o.id),
        type(o.type),
        action(o.action),
        position((o.position) ? new fb::geometry_msgs::PointT(*o.position) : nullptr),
        scale(o.scale),
        outline_color((o.outline_color) ? new fb::std_msgs::ColorRGBAT(*o.outline_color) : nullptr),
        filled(o.filled),
        fill_color((o.fill_color) ? new fb::std_msgs::ColorRGBAT(*o.fill_color) : nullptr),
        lifetime((o.lifetime) ? new fb::RosDuration(*o.lifetime) : nullptr) {
  points.reserve(o.points.size());
  for (const auto &v : o.points) { points.emplace_back((v) ? new fb::geometry_msgs::PointT(*v) : nullptr); }
  outline_colors.reserve(o.outline_colors.size());
  for (const auto &v : o.outline_colors) { outline_colors.emplace_back((v) ? new fb::std_msgs::ColorRGBAT(*v) : nullptr); }
}

inline ImageMarkerT &ImageMarkerT::operator=(ImageMarkerT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(ns, o.ns);
  std::swap(id, o.id);
  std::swap(type, o.type);
  std::swap(action, o.action);
  std::swap(position, o.position);
  std::swap(scale, o.scale);
  std::swap(outline_color, o.outline_color);
  std::swap(filled, o.filled);
  std::swap(fill_color, o.fill_color);
  std::swap(lifetime, o.lifetime);
  std::swap(points, o.points);
  std::swap(outline_colors, o.outline_colors);
  return *this;
}

inline ImageMarkerT *ImageMarker::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ImageMarkerT>(new ImageMarkerT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ImageMarker::UnPackTo(ImageMarkerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } }
  { auto _e = ns(); if (_e) _o->ns = _e->str(); }
  { auto _e = id(); _o->id = _e; }
  { auto _e = type(); _o->type = _e; }
  { auto _e = action(); _o->action = _e; }
  { auto _e = position(); if (_e) { if(_o->position) { _e->UnPackTo(_o->position.get(), _resolver); } else { _o->position = std::unique_ptr<fb::geometry_msgs::PointT>(_e->UnPack(_resolver)); } } }
  { auto _e = scale(); _o->scale = _e; }
  { auto _e = outline_color(); if (_e) { if(_o->outline_color) { _e->UnPackTo(_o->outline_color.get(), _resolver); } else { _o->outline_color = std::unique_ptr<fb::std_msgs::ColorRGBAT>(_e->UnPack(_resolver)); } } }
  { auto _e = filled(); _o->filled = _e; }
  { auto _e = fill_color(); if (_e) { if(_o->fill_color) { _e->UnPackTo(_o->fill_color.get(), _resolver); } else { _o->fill_color = std::unique_ptr<fb::std_msgs::ColorRGBAT>(_e->UnPack(_resolver)); } } }
  { auto _e = lifetime(); if (_e) _o->lifetime = std::unique_ptr<fb::RosDuration>(new fb::RosDuration(*_e)); }
  { auto _e = points(); if (_e) { _o->points.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->points[_i]) { _e->Get(_i)->UnPackTo(_o->points[_i].get(), _resolver); } else { _o->points[_i] = std::unique_ptr<fb::geometry_msgs::PointT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = outline_colors(); if (_e) { _o->outline_colors.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->outline_colors[_i]) { _e->Get(_i)->UnPackTo(_o->outline_colors[_i].get(), _resolver); } else { _o->outline_colors[_i] = std::unique_ptr<fb::std_msgs::ColorRGBAT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<ImageMarker> ImageMarker::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ImageMarkerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateImageMarker(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ImageMarker> CreateImageMarker(flatbuffers::FlatBufferBuilder &_fbb, const ImageMarkerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ImageMarkerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _ns = _fbb.CreateString(_o->ns);
  auto _id = _o->id;
  auto _type = _o->type;
  auto _action = _o->action;
  auto _position = _o->position ? CreatePoint(_fbb, _o->position.get(), _rehasher) : 0;
  auto _scale = _o->scale;
  auto _outline_color = _o->outline_color ? CreateColorRGBA(_fbb, _o->outline_color.get(), _rehasher) : 0;
  auto _filled = _o->filled;
  auto _fill_color = _o->fill_color ? CreateColorRGBA(_fbb, _o->fill_color.get(), _rehasher) : 0;
  auto _lifetime = _o->lifetime ? _o->lifetime.get() : 0;
  auto _points = _fbb.CreateVector<flatbuffers::Offset<fb::geometry_msgs::Point>> (_o->points.size(), [](size_t i, _VectorArgs *__va) { return CreatePoint(*__va->__fbb, __va->__o->points[i].get(), __va->__rehasher); }, &_va );
  auto _outline_colors = _fbb.CreateVector<flatbuffers::Offset<fb::std_msgs::ColorRGBA>> (_o->outline_colors.size(), [](size_t i, _VectorArgs *__va) { return CreateColorRGBA(*__va->__fbb, __va->__o->outline_colors[i].get(), __va->__rehasher); }, &_va );
  return fb::visualization_msgs::CreateImageMarker(
      _fbb,
      ___metadata,
      _header,
      _ns,
      _id,
      _type,
      _action,
      _position,
      _scale,
      _outline_color,
      _filled,
      _fill_color,
      _lifetime,
      _points,
      _outline_colors);
}

inline InteractiveMarkerControlT::InteractiveMarkerControlT(const InteractiveMarkerControlT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        name(o.name),
        orientation((o.orientation) ? new fb::geometry_msgs::QuaternionT(*o.orientation) : nullptr),
        orientation_mode(o.orientation_mode),
        interaction_mode(o.interaction_mode),
        always_visible(o.always_visible),
        independent_marker_orientation(o.independent_marker_orientation),
        description(o.description) {
  markers.reserve(o.markers.size());
  for (const auto &v : o.markers) { markers.emplace_back((v) ? new fb::visualization_msgs::MarkerT(*v) : nullptr); }
}

inline InteractiveMarkerControlT &InteractiveMarkerControlT::operator=(InteractiveMarkerControlT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(name, o.name);
  std::swap(orientation, o.orientation);
  std::swap(orientation_mode, o.orientation_mode);
  std::swap(interaction_mode, o.interaction_mode);
  std::swap(always_visible, o.always_visible);
  std::swap(markers, o.markers);
  std::swap(independent_marker_orientation, o.independent_marker_orientation);
  std::swap(description, o.description);
  return *this;
}

inline InteractiveMarkerControlT *InteractiveMarkerControl::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InteractiveMarkerControlT>(new InteractiveMarkerControlT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InteractiveMarkerControl::UnPackTo(InteractiveMarkerControlT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = orientation(); if (_e) { if(_o->orientation) { _e->UnPackTo(_o->orientation.get(), _resolver); } else { _o->orientation = std::unique_ptr<fb::geometry_msgs::QuaternionT>(_e->UnPack(_resolver)); } } }
  { auto _e = orientation_mode(); _o->orientation_mode = _e; }
  { auto _e = interaction_mode(); _o->interaction_mode = _e; }
  { auto _e = always_visible(); _o->always_visible = _e; }
  { auto _e = markers(); if (_e) { _o->markers.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->markers[_i]) { _e->Get(_i)->UnPackTo(_o->markers[_i].get(), _resolver); } else { _o->markers[_i] = std::unique_ptr<fb::visualization_msgs::MarkerT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = independent_marker_orientation(); _o->independent_marker_orientation = _e; }
  { auto _e = description(); if (_e) _o->description = _e->str(); }
}

inline flatbuffers::Offset<InteractiveMarkerControl> InteractiveMarkerControl::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InteractiveMarkerControlT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInteractiveMarkerControl(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InteractiveMarkerControl> CreateInteractiveMarkerControl(flatbuffers::FlatBufferBuilder &_fbb, const InteractiveMarkerControlT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InteractiveMarkerControlT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _name = _fbb.CreateString(_o->name);
  auto _orientation = _o->orientation ? CreateQuaternion(_fbb, _o->orientation.get(), _rehasher) : 0;
  auto _orientation_mode = _o->orientation_mode;
  auto _interaction_mode = _o->interaction_mode;
  auto _always_visible = _o->always_visible;
  auto _markers = _fbb.CreateVector<flatbuffers::Offset<fb::visualization_msgs::Marker>> (_o->markers.size(), [](size_t i, _VectorArgs *__va) { return CreateMarker(*__va->__fbb, __va->__o->markers[i].get(), __va->__rehasher); }, &_va );
  auto _independent_marker_orientation = _o->independent_marker_orientation;
  auto _description = _fbb.CreateString(_o->description);
  return fb::visualization_msgs::CreateInteractiveMarkerControl(
      _fbb,
      ___metadata,
      _name,
      _orientation,
      _orientation_mode,
      _interaction_mode,
      _always_visible,
      _markers,
      _independent_marker_orientation,
      _description);
}

inline MarkerArrayT::MarkerArrayT(const MarkerArrayT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr) {
  markers.reserve(o.markers.size());
  for (const auto &v : o.markers) { markers.emplace_back((v) ? new fb::visualization_msgs::MarkerT(*v) : nullptr); }
}

inline MarkerArrayT &MarkerArrayT::operator=(MarkerArrayT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(markers, o.markers);
  return *this;
}

inline MarkerArrayT *MarkerArray::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MarkerArrayT>(new MarkerArrayT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MarkerArray::UnPackTo(MarkerArrayT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = markers(); if (_e) { _o->markers.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->markers[_i]) { _e->Get(_i)->UnPackTo(_o->markers[_i].get(), _resolver); } else { _o->markers[_i] = std::unique_ptr<fb::visualization_msgs::MarkerT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<MarkerArray> MarkerArray::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MarkerArrayT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMarkerArray(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MarkerArray> CreateMarkerArray(flatbuffers::FlatBufferBuilder &_fbb, const MarkerArrayT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MarkerArrayT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _markers = _fbb.CreateVector<flatbuffers::Offset<fb::visualization_msgs::Marker>> (_o->markers.size(), [](size_t i, _VectorArgs *__va) { return CreateMarker(*__va->__fbb, __va->__o->markers[i].get(), __va->__rehasher); }, &_va );
  return fb::visualization_msgs::CreateMarkerArray(
      _fbb,
      ___metadata,
      _markers);
}

}  // namespace visualization_msgs
}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_VISUALIZATIONMSGS_FB_VISUALIZATION_MSGS_H_
