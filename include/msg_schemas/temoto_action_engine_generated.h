// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TEMOTOACTIONENGINE_FB_TEMOTO_ACTION_ENGINE_H_
#define FLATBUFFERS_GENERATED_TEMOTOACTIONENGINE_FB_TEMOTO_ACTION_ENGINE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 21,
             "Non-compatible flatbuffers version included");

#include "robofleet_client/base_schema_generated.h"

namespace fb {
namespace temoto_action_engine {

struct UmrfGraphDiff;
struct UmrfGraphDiffBuilder;
struct UmrfGraphDiffT;

struct GetUmrfGraphsRequest;
struct GetUmrfGraphsRequestBuilder;
struct GetUmrfGraphsRequestT;

struct GetUmrfGraphsResponse;
struct GetUmrfGraphsResponseBuilder;
struct GetUmrfGraphsResponseT;

struct StartUmrfGraphRequest;
struct StartUmrfGraphRequestBuilder;
struct StartUmrfGraphRequestT;

struct StartUmrfGraphResponse;
struct StartUmrfGraphResponseBuilder;
struct StartUmrfGraphResponseT;

struct StopUmrfGraphRequest;
struct StopUmrfGraphRequestBuilder;
struct StopUmrfGraphRequestT;

struct StopUmrfGraphResponse;
struct StopUmrfGraphResponseBuilder;
struct StopUmrfGraphResponseT;

struct BroadcastStartUmrfGraph;
struct BroadcastStartUmrfGraphBuilder;
struct BroadcastStartUmrfGraphT;

struct BroadcastStopUmrfGraph;
struct BroadcastStopUmrfGraphBuilder;
struct BroadcastStopUmrfGraphT;

struct UmrfGraphDiffT : public ::flatbuffers::NativeTable {
  typedef UmrfGraphDiff TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string add{};
  std::string subtract{};
  std::string operation{};
  std::string umrf_json{};
  UmrfGraphDiffT() = default;
  UmrfGraphDiffT(const UmrfGraphDiffT &o);
  UmrfGraphDiffT(UmrfGraphDiffT&&) FLATBUFFERS_NOEXCEPT = default;
  UmrfGraphDiffT &operator=(UmrfGraphDiffT o) FLATBUFFERS_NOEXCEPT;
};

struct UmrfGraphDiff FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UmrfGraphDiffT NativeTableType;
  typedef UmrfGraphDiffBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_ADD = 6,
    VT_SUBTRACT = 8,
    VT_OPERATION = 10,
    VT_UMRF_JSON = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *add() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ADD);
  }
  const ::flatbuffers::String *subtract() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SUBTRACT);
  }
  const ::flatbuffers::String *operation() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OPERATION);
  }
  const ::flatbuffers::String *umrf_json() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UMRF_JSON);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_ADD) &&
           verifier.VerifyString(add()) &&
           VerifyOffsetRequired(verifier, VT_SUBTRACT) &&
           verifier.VerifyString(subtract()) &&
           VerifyOffsetRequired(verifier, VT_OPERATION) &&
           verifier.VerifyString(operation()) &&
           VerifyOffsetRequired(verifier, VT_UMRF_JSON) &&
           verifier.VerifyString(umrf_json()) &&
           verifier.EndTable();
  }
  UmrfGraphDiffT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UmrfGraphDiffT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UmrfGraphDiff> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UmrfGraphDiffT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UmrfGraphDiffBuilder {
  typedef UmrfGraphDiff Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(UmrfGraphDiff::VT___METADATA, __metadata);
  }
  void add_add(::flatbuffers::Offset<::flatbuffers::String> add) {
    fbb_.AddOffset(UmrfGraphDiff::VT_ADD, add);
  }
  void add_subtract(::flatbuffers::Offset<::flatbuffers::String> subtract) {
    fbb_.AddOffset(UmrfGraphDiff::VT_SUBTRACT, subtract);
  }
  void add_operation(::flatbuffers::Offset<::flatbuffers::String> operation) {
    fbb_.AddOffset(UmrfGraphDiff::VT_OPERATION, operation);
  }
  void add_umrf_json(::flatbuffers::Offset<::flatbuffers::String> umrf_json) {
    fbb_.AddOffset(UmrfGraphDiff::VT_UMRF_JSON, umrf_json);
  }
  explicit UmrfGraphDiffBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UmrfGraphDiff> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UmrfGraphDiff>(end);
    fbb_.Required(o, UmrfGraphDiff::VT_ADD);
    fbb_.Required(o, UmrfGraphDiff::VT_SUBTRACT);
    fbb_.Required(o, UmrfGraphDiff::VT_OPERATION);
    fbb_.Required(o, UmrfGraphDiff::VT_UMRF_JSON);
    return o;
  }
};

inline ::flatbuffers::Offset<UmrfGraphDiff> CreateUmrfGraphDiff(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> add = 0,
    ::flatbuffers::Offset<::flatbuffers::String> subtract = 0,
    ::flatbuffers::Offset<::flatbuffers::String> operation = 0,
    ::flatbuffers::Offset<::flatbuffers::String> umrf_json = 0) {
  UmrfGraphDiffBuilder builder_(_fbb);
  builder_.add_umrf_json(umrf_json);
  builder_.add_operation(operation);
  builder_.add_subtract(subtract);
  builder_.add_add(add);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UmrfGraphDiff> CreateUmrfGraphDiffDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *add = nullptr,
    const char *subtract = nullptr,
    const char *operation = nullptr,
    const char *umrf_json = nullptr) {
  auto add__ = add ? _fbb.CreateString(add) : 0;
  auto subtract__ = subtract ? _fbb.CreateString(subtract) : 0;
  auto operation__ = operation ? _fbb.CreateString(operation) : 0;
  auto umrf_json__ = umrf_json ? _fbb.CreateString(umrf_json) : 0;
  return fb::temoto_action_engine::CreateUmrfGraphDiff(
      _fbb,
      __metadata,
      add__,
      subtract__,
      operation__,
      umrf_json__);
}

::flatbuffers::Offset<UmrfGraphDiff> CreateUmrfGraphDiff(::flatbuffers::FlatBufferBuilder &_fbb, const UmrfGraphDiffT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetUmrfGraphsRequestT : public ::flatbuffers::NativeTable {
  typedef GetUmrfGraphsRequest TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::vector<std::string> requested_graphs{};
  GetUmrfGraphsRequestT() = default;
  GetUmrfGraphsRequestT(const GetUmrfGraphsRequestT &o);
  GetUmrfGraphsRequestT(GetUmrfGraphsRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  GetUmrfGraphsRequestT &operator=(GetUmrfGraphsRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct GetUmrfGraphsRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetUmrfGraphsRequestT NativeTableType;
  typedef GetUmrfGraphsRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_REQUESTED_GRAPHS = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *requested_graphs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_REQUESTED_GRAPHS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_REQUESTED_GRAPHS) &&
           verifier.VerifyVector(requested_graphs()) &&
           verifier.VerifyVectorOfStrings(requested_graphs()) &&
           verifier.EndTable();
  }
  GetUmrfGraphsRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetUmrfGraphsRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GetUmrfGraphsRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetUmrfGraphsRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetUmrfGraphsRequestBuilder {
  typedef GetUmrfGraphsRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GetUmrfGraphsRequest::VT___METADATA, __metadata);
  }
  void add_requested_graphs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> requested_graphs) {
    fbb_.AddOffset(GetUmrfGraphsRequest::VT_REQUESTED_GRAPHS, requested_graphs);
  }
  explicit GetUmrfGraphsRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetUmrfGraphsRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetUmrfGraphsRequest>(end);
    fbb_.Required(o, GetUmrfGraphsRequest::VT_REQUESTED_GRAPHS);
    return o;
  }
};

inline ::flatbuffers::Offset<GetUmrfGraphsRequest> CreateGetUmrfGraphsRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> requested_graphs = 0) {
  GetUmrfGraphsRequestBuilder builder_(_fbb);
  builder_.add_requested_graphs(requested_graphs);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GetUmrfGraphsRequest> CreateGetUmrfGraphsRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *requested_graphs = nullptr) {
  auto requested_graphs__ = requested_graphs ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*requested_graphs) : 0;
  return fb::temoto_action_engine::CreateGetUmrfGraphsRequest(
      _fbb,
      __metadata,
      requested_graphs__);
}

::flatbuffers::Offset<GetUmrfGraphsRequest> CreateGetUmrfGraphsRequest(::flatbuffers::FlatBufferBuilder &_fbb, const GetUmrfGraphsRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetUmrfGraphsResponseT : public ::flatbuffers::NativeTable {
  typedef GetUmrfGraphsResponse TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::vector<std::string> umrf_graph_jsons{};
  GetUmrfGraphsResponseT() = default;
  GetUmrfGraphsResponseT(const GetUmrfGraphsResponseT &o);
  GetUmrfGraphsResponseT(GetUmrfGraphsResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  GetUmrfGraphsResponseT &operator=(GetUmrfGraphsResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct GetUmrfGraphsResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetUmrfGraphsResponseT NativeTableType;
  typedef GetUmrfGraphsResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_UMRF_GRAPH_JSONS = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *umrf_graph_jsons() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_UMRF_GRAPH_JSONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_UMRF_GRAPH_JSONS) &&
           verifier.VerifyVector(umrf_graph_jsons()) &&
           verifier.VerifyVectorOfStrings(umrf_graph_jsons()) &&
           verifier.EndTable();
  }
  GetUmrfGraphsResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetUmrfGraphsResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GetUmrfGraphsResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetUmrfGraphsResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetUmrfGraphsResponseBuilder {
  typedef GetUmrfGraphsResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GetUmrfGraphsResponse::VT___METADATA, __metadata);
  }
  void add_umrf_graph_jsons(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> umrf_graph_jsons) {
    fbb_.AddOffset(GetUmrfGraphsResponse::VT_UMRF_GRAPH_JSONS, umrf_graph_jsons);
  }
  explicit GetUmrfGraphsResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetUmrfGraphsResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetUmrfGraphsResponse>(end);
    fbb_.Required(o, GetUmrfGraphsResponse::VT_UMRF_GRAPH_JSONS);
    return o;
  }
};

inline ::flatbuffers::Offset<GetUmrfGraphsResponse> CreateGetUmrfGraphsResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> umrf_graph_jsons = 0) {
  GetUmrfGraphsResponseBuilder builder_(_fbb);
  builder_.add_umrf_graph_jsons(umrf_graph_jsons);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GetUmrfGraphsResponse> CreateGetUmrfGraphsResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *umrf_graph_jsons = nullptr) {
  auto umrf_graph_jsons__ = umrf_graph_jsons ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*umrf_graph_jsons) : 0;
  return fb::temoto_action_engine::CreateGetUmrfGraphsResponse(
      _fbb,
      __metadata,
      umrf_graph_jsons__);
}

::flatbuffers::Offset<GetUmrfGraphsResponse> CreateGetUmrfGraphsResponse(::flatbuffers::FlatBufferBuilder &_fbb, const GetUmrfGraphsResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StartUmrfGraphRequestT : public ::flatbuffers::NativeTable {
  typedef StartUmrfGraphRequest TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string umrf_graph_name{};
  std::string umrf_graph_json{};
  bool name_match_required = false;
  StartUmrfGraphRequestT() = default;
  StartUmrfGraphRequestT(const StartUmrfGraphRequestT &o);
  StartUmrfGraphRequestT(StartUmrfGraphRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  StartUmrfGraphRequestT &operator=(StartUmrfGraphRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct StartUmrfGraphRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StartUmrfGraphRequestT NativeTableType;
  typedef StartUmrfGraphRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_UMRF_GRAPH_NAME = 6,
    VT_UMRF_GRAPH_JSON = 8,
    VT_NAME_MATCH_REQUIRED = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *umrf_graph_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UMRF_GRAPH_NAME);
  }
  const ::flatbuffers::String *umrf_graph_json() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UMRF_GRAPH_JSON);
  }
  bool name_match_required() const {
    return GetField<uint8_t>(VT_NAME_MATCH_REQUIRED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_UMRF_GRAPH_NAME) &&
           verifier.VerifyString(umrf_graph_name()) &&
           VerifyOffsetRequired(verifier, VT_UMRF_GRAPH_JSON) &&
           verifier.VerifyString(umrf_graph_json()) &&
           VerifyField<uint8_t>(verifier, VT_NAME_MATCH_REQUIRED, 1) &&
           verifier.EndTable();
  }
  StartUmrfGraphRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StartUmrfGraphRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StartUmrfGraphRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StartUmrfGraphRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StartUmrfGraphRequestBuilder {
  typedef StartUmrfGraphRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(StartUmrfGraphRequest::VT___METADATA, __metadata);
  }
  void add_umrf_graph_name(::flatbuffers::Offset<::flatbuffers::String> umrf_graph_name) {
    fbb_.AddOffset(StartUmrfGraphRequest::VT_UMRF_GRAPH_NAME, umrf_graph_name);
  }
  void add_umrf_graph_json(::flatbuffers::Offset<::flatbuffers::String> umrf_graph_json) {
    fbb_.AddOffset(StartUmrfGraphRequest::VT_UMRF_GRAPH_JSON, umrf_graph_json);
  }
  void add_name_match_required(bool name_match_required) {
    fbb_.AddElement<uint8_t>(StartUmrfGraphRequest::VT_NAME_MATCH_REQUIRED, static_cast<uint8_t>(name_match_required), 0);
  }
  explicit StartUmrfGraphRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StartUmrfGraphRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StartUmrfGraphRequest>(end);
    fbb_.Required(o, StartUmrfGraphRequest::VT_UMRF_GRAPH_NAME);
    fbb_.Required(o, StartUmrfGraphRequest::VT_UMRF_GRAPH_JSON);
    return o;
  }
};

inline ::flatbuffers::Offset<StartUmrfGraphRequest> CreateStartUmrfGraphRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> umrf_graph_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> umrf_graph_json = 0,
    bool name_match_required = false) {
  StartUmrfGraphRequestBuilder builder_(_fbb);
  builder_.add_umrf_graph_json(umrf_graph_json);
  builder_.add_umrf_graph_name(umrf_graph_name);
  builder_.add___metadata(__metadata);
  builder_.add_name_match_required(name_match_required);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StartUmrfGraphRequest> CreateStartUmrfGraphRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *umrf_graph_name = nullptr,
    const char *umrf_graph_json = nullptr,
    bool name_match_required = false) {
  auto umrf_graph_name__ = umrf_graph_name ? _fbb.CreateString(umrf_graph_name) : 0;
  auto umrf_graph_json__ = umrf_graph_json ? _fbb.CreateString(umrf_graph_json) : 0;
  return fb::temoto_action_engine::CreateStartUmrfGraphRequest(
      _fbb,
      __metadata,
      umrf_graph_name__,
      umrf_graph_json__,
      name_match_required);
}

::flatbuffers::Offset<StartUmrfGraphRequest> CreateStartUmrfGraphRequest(::flatbuffers::FlatBufferBuilder &_fbb, const StartUmrfGraphRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StartUmrfGraphResponseT : public ::flatbuffers::NativeTable {
  typedef StartUmrfGraphResponse TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  bool success = false;
  StartUmrfGraphResponseT() = default;
  StartUmrfGraphResponseT(const StartUmrfGraphResponseT &o);
  StartUmrfGraphResponseT(StartUmrfGraphResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  StartUmrfGraphResponseT &operator=(StartUmrfGraphResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct StartUmrfGraphResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StartUmrfGraphResponseT NativeTableType;
  typedef StartUmrfGraphResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_SUCCESS = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           verifier.EndTable();
  }
  StartUmrfGraphResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StartUmrfGraphResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StartUmrfGraphResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StartUmrfGraphResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StartUmrfGraphResponseBuilder {
  typedef StartUmrfGraphResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(StartUmrfGraphResponse::VT___METADATA, __metadata);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(StartUmrfGraphResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit StartUmrfGraphResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StartUmrfGraphResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StartUmrfGraphResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StartUmrfGraphResponse> CreateStartUmrfGraphResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    bool success = false) {
  StartUmrfGraphResponseBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  builder_.add_success(success);
  return builder_.Finish();
}

::flatbuffers::Offset<StartUmrfGraphResponse> CreateStartUmrfGraphResponse(::flatbuffers::FlatBufferBuilder &_fbb, const StartUmrfGraphResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StopUmrfGraphRequestT : public ::flatbuffers::NativeTable {
  typedef StopUmrfGraphRequest TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string umrf_graph_name{};
  StopUmrfGraphRequestT() = default;
  StopUmrfGraphRequestT(const StopUmrfGraphRequestT &o);
  StopUmrfGraphRequestT(StopUmrfGraphRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  StopUmrfGraphRequestT &operator=(StopUmrfGraphRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct StopUmrfGraphRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StopUmrfGraphRequestT NativeTableType;
  typedef StopUmrfGraphRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_UMRF_GRAPH_NAME = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *umrf_graph_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UMRF_GRAPH_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_UMRF_GRAPH_NAME) &&
           verifier.VerifyString(umrf_graph_name()) &&
           verifier.EndTable();
  }
  StopUmrfGraphRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StopUmrfGraphRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StopUmrfGraphRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StopUmrfGraphRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StopUmrfGraphRequestBuilder {
  typedef StopUmrfGraphRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(StopUmrfGraphRequest::VT___METADATA, __metadata);
  }
  void add_umrf_graph_name(::flatbuffers::Offset<::flatbuffers::String> umrf_graph_name) {
    fbb_.AddOffset(StopUmrfGraphRequest::VT_UMRF_GRAPH_NAME, umrf_graph_name);
  }
  explicit StopUmrfGraphRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StopUmrfGraphRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StopUmrfGraphRequest>(end);
    fbb_.Required(o, StopUmrfGraphRequest::VT_UMRF_GRAPH_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<StopUmrfGraphRequest> CreateStopUmrfGraphRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> umrf_graph_name = 0) {
  StopUmrfGraphRequestBuilder builder_(_fbb);
  builder_.add_umrf_graph_name(umrf_graph_name);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StopUmrfGraphRequest> CreateStopUmrfGraphRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *umrf_graph_name = nullptr) {
  auto umrf_graph_name__ = umrf_graph_name ? _fbb.CreateString(umrf_graph_name) : 0;
  return fb::temoto_action_engine::CreateStopUmrfGraphRequest(
      _fbb,
      __metadata,
      umrf_graph_name__);
}

::flatbuffers::Offset<StopUmrfGraphRequest> CreateStopUmrfGraphRequest(::flatbuffers::FlatBufferBuilder &_fbb, const StopUmrfGraphRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StopUmrfGraphResponseT : public ::flatbuffers::NativeTable {
  typedef StopUmrfGraphResponse TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  bool success = false;
  StopUmrfGraphResponseT() = default;
  StopUmrfGraphResponseT(const StopUmrfGraphResponseT &o);
  StopUmrfGraphResponseT(StopUmrfGraphResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  StopUmrfGraphResponseT &operator=(StopUmrfGraphResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct StopUmrfGraphResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StopUmrfGraphResponseT NativeTableType;
  typedef StopUmrfGraphResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_SUCCESS = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           verifier.EndTable();
  }
  StopUmrfGraphResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StopUmrfGraphResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StopUmrfGraphResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StopUmrfGraphResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StopUmrfGraphResponseBuilder {
  typedef StopUmrfGraphResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(StopUmrfGraphResponse::VT___METADATA, __metadata);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(StopUmrfGraphResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit StopUmrfGraphResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StopUmrfGraphResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StopUmrfGraphResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StopUmrfGraphResponse> CreateStopUmrfGraphResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    bool success = false) {
  StopUmrfGraphResponseBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  builder_.add_success(success);
  return builder_.Finish();
}

::flatbuffers::Offset<StopUmrfGraphResponse> CreateStopUmrfGraphResponse(::flatbuffers::FlatBufferBuilder &_fbb, const StopUmrfGraphResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BroadcastStartUmrfGraphT : public ::flatbuffers::NativeTable {
  typedef BroadcastStartUmrfGraph TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string umrf_graph_name{};
  bool name_match_required = false;
  std::vector<std::string> targets{};
  std::string umrf_graph_json{};
  std::vector<std::unique_ptr<fb::temoto_action_engine::UmrfGraphDiffT>> umrf_graph_diffs{};
  BroadcastStartUmrfGraphT() = default;
  BroadcastStartUmrfGraphT(const BroadcastStartUmrfGraphT &o);
  BroadcastStartUmrfGraphT(BroadcastStartUmrfGraphT&&) FLATBUFFERS_NOEXCEPT = default;
  BroadcastStartUmrfGraphT &operator=(BroadcastStartUmrfGraphT o) FLATBUFFERS_NOEXCEPT;
};

struct BroadcastStartUmrfGraph FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BroadcastStartUmrfGraphT NativeTableType;
  typedef BroadcastStartUmrfGraphBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_UMRF_GRAPH_NAME = 6,
    VT_NAME_MATCH_REQUIRED = 8,
    VT_TARGETS = 10,
    VT_UMRF_GRAPH_JSON = 12,
    VT_UMRF_GRAPH_DIFFS = 14
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *umrf_graph_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UMRF_GRAPH_NAME);
  }
  bool name_match_required() const {
    return GetField<uint8_t>(VT_NAME_MATCH_REQUIRED, 0) != 0;
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *targets() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_TARGETS);
  }
  const ::flatbuffers::String *umrf_graph_json() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UMRF_GRAPH_JSON);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::temoto_action_engine::UmrfGraphDiff>> *umrf_graph_diffs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::temoto_action_engine::UmrfGraphDiff>> *>(VT_UMRF_GRAPH_DIFFS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_UMRF_GRAPH_NAME) &&
           verifier.VerifyString(umrf_graph_name()) &&
           VerifyField<uint8_t>(verifier, VT_NAME_MATCH_REQUIRED, 1) &&
           VerifyOffsetRequired(verifier, VT_TARGETS) &&
           verifier.VerifyVector(targets()) &&
           verifier.VerifyVectorOfStrings(targets()) &&
           VerifyOffsetRequired(verifier, VT_UMRF_GRAPH_JSON) &&
           verifier.VerifyString(umrf_graph_json()) &&
           VerifyOffsetRequired(verifier, VT_UMRF_GRAPH_DIFFS) &&
           verifier.VerifyVector(umrf_graph_diffs()) &&
           verifier.VerifyVectorOfTables(umrf_graph_diffs()) &&
           verifier.EndTable();
  }
  BroadcastStartUmrfGraphT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BroadcastStartUmrfGraphT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BroadcastStartUmrfGraph> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BroadcastStartUmrfGraphT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BroadcastStartUmrfGraphBuilder {
  typedef BroadcastStartUmrfGraph Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(BroadcastStartUmrfGraph::VT___METADATA, __metadata);
  }
  void add_umrf_graph_name(::flatbuffers::Offset<::flatbuffers::String> umrf_graph_name) {
    fbb_.AddOffset(BroadcastStartUmrfGraph::VT_UMRF_GRAPH_NAME, umrf_graph_name);
  }
  void add_name_match_required(bool name_match_required) {
    fbb_.AddElement<uint8_t>(BroadcastStartUmrfGraph::VT_NAME_MATCH_REQUIRED, static_cast<uint8_t>(name_match_required), 0);
  }
  void add_targets(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> targets) {
    fbb_.AddOffset(BroadcastStartUmrfGraph::VT_TARGETS, targets);
  }
  void add_umrf_graph_json(::flatbuffers::Offset<::flatbuffers::String> umrf_graph_json) {
    fbb_.AddOffset(BroadcastStartUmrfGraph::VT_UMRF_GRAPH_JSON, umrf_graph_json);
  }
  void add_umrf_graph_diffs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::temoto_action_engine::UmrfGraphDiff>>> umrf_graph_diffs) {
    fbb_.AddOffset(BroadcastStartUmrfGraph::VT_UMRF_GRAPH_DIFFS, umrf_graph_diffs);
  }
  explicit BroadcastStartUmrfGraphBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BroadcastStartUmrfGraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BroadcastStartUmrfGraph>(end);
    fbb_.Required(o, BroadcastStartUmrfGraph::VT_UMRF_GRAPH_NAME);
    fbb_.Required(o, BroadcastStartUmrfGraph::VT_TARGETS);
    fbb_.Required(o, BroadcastStartUmrfGraph::VT_UMRF_GRAPH_JSON);
    fbb_.Required(o, BroadcastStartUmrfGraph::VT_UMRF_GRAPH_DIFFS);
    return o;
  }
};

inline ::flatbuffers::Offset<BroadcastStartUmrfGraph> CreateBroadcastStartUmrfGraph(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> umrf_graph_name = 0,
    bool name_match_required = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> targets = 0,
    ::flatbuffers::Offset<::flatbuffers::String> umrf_graph_json = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::temoto_action_engine::UmrfGraphDiff>>> umrf_graph_diffs = 0) {
  BroadcastStartUmrfGraphBuilder builder_(_fbb);
  builder_.add_umrf_graph_diffs(umrf_graph_diffs);
  builder_.add_umrf_graph_json(umrf_graph_json);
  builder_.add_targets(targets);
  builder_.add_umrf_graph_name(umrf_graph_name);
  builder_.add___metadata(__metadata);
  builder_.add_name_match_required(name_match_required);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BroadcastStartUmrfGraph> CreateBroadcastStartUmrfGraphDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *umrf_graph_name = nullptr,
    bool name_match_required = false,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *targets = nullptr,
    const char *umrf_graph_json = nullptr,
    const std::vector<::flatbuffers::Offset<fb::temoto_action_engine::UmrfGraphDiff>> *umrf_graph_diffs = nullptr) {
  auto umrf_graph_name__ = umrf_graph_name ? _fbb.CreateString(umrf_graph_name) : 0;
  auto targets__ = targets ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*targets) : 0;
  auto umrf_graph_json__ = umrf_graph_json ? _fbb.CreateString(umrf_graph_json) : 0;
  auto umrf_graph_diffs__ = umrf_graph_diffs ? _fbb.CreateVector<::flatbuffers::Offset<fb::temoto_action_engine::UmrfGraphDiff>>(*umrf_graph_diffs) : 0;
  return fb::temoto_action_engine::CreateBroadcastStartUmrfGraph(
      _fbb,
      __metadata,
      umrf_graph_name__,
      name_match_required,
      targets__,
      umrf_graph_json__,
      umrf_graph_diffs__);
}

::flatbuffers::Offset<BroadcastStartUmrfGraph> CreateBroadcastStartUmrfGraph(::flatbuffers::FlatBufferBuilder &_fbb, const BroadcastStartUmrfGraphT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BroadcastStopUmrfGraphT : public ::flatbuffers::NativeTable {
  typedef BroadcastStopUmrfGraph TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string umrf_graph_name{};
  std::vector<std::string> targets{};
  BroadcastStopUmrfGraphT() = default;
  BroadcastStopUmrfGraphT(const BroadcastStopUmrfGraphT &o);
  BroadcastStopUmrfGraphT(BroadcastStopUmrfGraphT&&) FLATBUFFERS_NOEXCEPT = default;
  BroadcastStopUmrfGraphT &operator=(BroadcastStopUmrfGraphT o) FLATBUFFERS_NOEXCEPT;
};

struct BroadcastStopUmrfGraph FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BroadcastStopUmrfGraphT NativeTableType;
  typedef BroadcastStopUmrfGraphBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_UMRF_GRAPH_NAME = 6,
    VT_TARGETS = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *umrf_graph_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UMRF_GRAPH_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *targets() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_TARGETS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_UMRF_GRAPH_NAME) &&
           verifier.VerifyString(umrf_graph_name()) &&
           VerifyOffsetRequired(verifier, VT_TARGETS) &&
           verifier.VerifyVector(targets()) &&
           verifier.VerifyVectorOfStrings(targets()) &&
           verifier.EndTable();
  }
  BroadcastStopUmrfGraphT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BroadcastStopUmrfGraphT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BroadcastStopUmrfGraph> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BroadcastStopUmrfGraphT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BroadcastStopUmrfGraphBuilder {
  typedef BroadcastStopUmrfGraph Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(BroadcastStopUmrfGraph::VT___METADATA, __metadata);
  }
  void add_umrf_graph_name(::flatbuffers::Offset<::flatbuffers::String> umrf_graph_name) {
    fbb_.AddOffset(BroadcastStopUmrfGraph::VT_UMRF_GRAPH_NAME, umrf_graph_name);
  }
  void add_targets(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> targets) {
    fbb_.AddOffset(BroadcastStopUmrfGraph::VT_TARGETS, targets);
  }
  explicit BroadcastStopUmrfGraphBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BroadcastStopUmrfGraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BroadcastStopUmrfGraph>(end);
    fbb_.Required(o, BroadcastStopUmrfGraph::VT_UMRF_GRAPH_NAME);
    fbb_.Required(o, BroadcastStopUmrfGraph::VT_TARGETS);
    return o;
  }
};

inline ::flatbuffers::Offset<BroadcastStopUmrfGraph> CreateBroadcastStopUmrfGraph(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> umrf_graph_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> targets = 0) {
  BroadcastStopUmrfGraphBuilder builder_(_fbb);
  builder_.add_targets(targets);
  builder_.add_umrf_graph_name(umrf_graph_name);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BroadcastStopUmrfGraph> CreateBroadcastStopUmrfGraphDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *umrf_graph_name = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *targets = nullptr) {
  auto umrf_graph_name__ = umrf_graph_name ? _fbb.CreateString(umrf_graph_name) : 0;
  auto targets__ = targets ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*targets) : 0;
  return fb::temoto_action_engine::CreateBroadcastStopUmrfGraph(
      _fbb,
      __metadata,
      umrf_graph_name__,
      targets__);
}

::flatbuffers::Offset<BroadcastStopUmrfGraph> CreateBroadcastStopUmrfGraph(::flatbuffers::FlatBufferBuilder &_fbb, const BroadcastStopUmrfGraphT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline UmrfGraphDiffT::UmrfGraphDiffT(const UmrfGraphDiffT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        add(o.add),
        subtract(o.subtract),
        operation(o.operation),
        umrf_json(o.umrf_json) {
}

inline UmrfGraphDiffT &UmrfGraphDiffT::operator=(UmrfGraphDiffT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(add, o.add);
  std::swap(subtract, o.subtract);
  std::swap(operation, o.operation);
  std::swap(umrf_json, o.umrf_json);
  return *this;
}

inline UmrfGraphDiffT *UmrfGraphDiff::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UmrfGraphDiffT>(new UmrfGraphDiffT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UmrfGraphDiff::UnPackTo(UmrfGraphDiffT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = add(); if (_e) _o->add = _e->str(); }
  { auto _e = subtract(); if (_e) _o->subtract = _e->str(); }
  { auto _e = operation(); if (_e) _o->operation = _e->str(); }
  { auto _e = umrf_json(); if (_e) _o->umrf_json = _e->str(); }
}

inline ::flatbuffers::Offset<UmrfGraphDiff> UmrfGraphDiff::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UmrfGraphDiffT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUmrfGraphDiff(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UmrfGraphDiff> CreateUmrfGraphDiff(::flatbuffers::FlatBufferBuilder &_fbb, const UmrfGraphDiffT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UmrfGraphDiffT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _add = _fbb.CreateString(_o->add);
  auto _subtract = _fbb.CreateString(_o->subtract);
  auto _operation = _fbb.CreateString(_o->operation);
  auto _umrf_json = _fbb.CreateString(_o->umrf_json);
  return fb::temoto_action_engine::CreateUmrfGraphDiff(
      _fbb,
      ___metadata,
      _add,
      _subtract,
      _operation,
      _umrf_json);
}

inline GetUmrfGraphsRequestT::GetUmrfGraphsRequestT(const GetUmrfGraphsRequestT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        requested_graphs(o.requested_graphs) {
}

inline GetUmrfGraphsRequestT &GetUmrfGraphsRequestT::operator=(GetUmrfGraphsRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(requested_graphs, o.requested_graphs);
  return *this;
}

inline GetUmrfGraphsRequestT *GetUmrfGraphsRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetUmrfGraphsRequestT>(new GetUmrfGraphsRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetUmrfGraphsRequest::UnPackTo(GetUmrfGraphsRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = requested_graphs(); if (_e) { _o->requested_graphs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->requested_graphs[_i] = _e->Get(_i)->str(); } } else { _o->requested_graphs.resize(0); } }
}

inline ::flatbuffers::Offset<GetUmrfGraphsRequest> GetUmrfGraphsRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetUmrfGraphsRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetUmrfGraphsRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GetUmrfGraphsRequest> CreateGetUmrfGraphsRequest(::flatbuffers::FlatBufferBuilder &_fbb, const GetUmrfGraphsRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GetUmrfGraphsRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _requested_graphs = _fbb.CreateVectorOfStrings(_o->requested_graphs);
  return fb::temoto_action_engine::CreateGetUmrfGraphsRequest(
      _fbb,
      ___metadata,
      _requested_graphs);
}

inline GetUmrfGraphsResponseT::GetUmrfGraphsResponseT(const GetUmrfGraphsResponseT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        umrf_graph_jsons(o.umrf_graph_jsons) {
}

inline GetUmrfGraphsResponseT &GetUmrfGraphsResponseT::operator=(GetUmrfGraphsResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(umrf_graph_jsons, o.umrf_graph_jsons);
  return *this;
}

inline GetUmrfGraphsResponseT *GetUmrfGraphsResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetUmrfGraphsResponseT>(new GetUmrfGraphsResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetUmrfGraphsResponse::UnPackTo(GetUmrfGraphsResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = umrf_graph_jsons(); if (_e) { _o->umrf_graph_jsons.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->umrf_graph_jsons[_i] = _e->Get(_i)->str(); } } else { _o->umrf_graph_jsons.resize(0); } }
}

inline ::flatbuffers::Offset<GetUmrfGraphsResponse> GetUmrfGraphsResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetUmrfGraphsResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetUmrfGraphsResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GetUmrfGraphsResponse> CreateGetUmrfGraphsResponse(::flatbuffers::FlatBufferBuilder &_fbb, const GetUmrfGraphsResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GetUmrfGraphsResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _umrf_graph_jsons = _fbb.CreateVectorOfStrings(_o->umrf_graph_jsons);
  return fb::temoto_action_engine::CreateGetUmrfGraphsResponse(
      _fbb,
      ___metadata,
      _umrf_graph_jsons);
}

inline StartUmrfGraphRequestT::StartUmrfGraphRequestT(const StartUmrfGraphRequestT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        umrf_graph_name(o.umrf_graph_name),
        umrf_graph_json(o.umrf_graph_json),
        name_match_required(o.name_match_required) {
}

inline StartUmrfGraphRequestT &StartUmrfGraphRequestT::operator=(StartUmrfGraphRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(umrf_graph_name, o.umrf_graph_name);
  std::swap(umrf_graph_json, o.umrf_graph_json);
  std::swap(name_match_required, o.name_match_required);
  return *this;
}

inline StartUmrfGraphRequestT *StartUmrfGraphRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StartUmrfGraphRequestT>(new StartUmrfGraphRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StartUmrfGraphRequest::UnPackTo(StartUmrfGraphRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = umrf_graph_name(); if (_e) _o->umrf_graph_name = _e->str(); }
  { auto _e = umrf_graph_json(); if (_e) _o->umrf_graph_json = _e->str(); }
  { auto _e = name_match_required(); _o->name_match_required = _e; }
}

inline ::flatbuffers::Offset<StartUmrfGraphRequest> StartUmrfGraphRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StartUmrfGraphRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStartUmrfGraphRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StartUmrfGraphRequest> CreateStartUmrfGraphRequest(::flatbuffers::FlatBufferBuilder &_fbb, const StartUmrfGraphRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StartUmrfGraphRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _umrf_graph_name = _fbb.CreateString(_o->umrf_graph_name);
  auto _umrf_graph_json = _fbb.CreateString(_o->umrf_graph_json);
  auto _name_match_required = _o->name_match_required;
  return fb::temoto_action_engine::CreateStartUmrfGraphRequest(
      _fbb,
      ___metadata,
      _umrf_graph_name,
      _umrf_graph_json,
      _name_match_required);
}

inline StartUmrfGraphResponseT::StartUmrfGraphResponseT(const StartUmrfGraphResponseT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        success(o.success) {
}

inline StartUmrfGraphResponseT &StartUmrfGraphResponseT::operator=(StartUmrfGraphResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(success, o.success);
  return *this;
}

inline StartUmrfGraphResponseT *StartUmrfGraphResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StartUmrfGraphResponseT>(new StartUmrfGraphResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StartUmrfGraphResponse::UnPackTo(StartUmrfGraphResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = success(); _o->success = _e; }
}

inline ::flatbuffers::Offset<StartUmrfGraphResponse> StartUmrfGraphResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StartUmrfGraphResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStartUmrfGraphResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StartUmrfGraphResponse> CreateStartUmrfGraphResponse(::flatbuffers::FlatBufferBuilder &_fbb, const StartUmrfGraphResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StartUmrfGraphResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _success = _o->success;
  return fb::temoto_action_engine::CreateStartUmrfGraphResponse(
      _fbb,
      ___metadata,
      _success);
}

inline StopUmrfGraphRequestT::StopUmrfGraphRequestT(const StopUmrfGraphRequestT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        umrf_graph_name(o.umrf_graph_name) {
}

inline StopUmrfGraphRequestT &StopUmrfGraphRequestT::operator=(StopUmrfGraphRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(umrf_graph_name, o.umrf_graph_name);
  return *this;
}

inline StopUmrfGraphRequestT *StopUmrfGraphRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StopUmrfGraphRequestT>(new StopUmrfGraphRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StopUmrfGraphRequest::UnPackTo(StopUmrfGraphRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = umrf_graph_name(); if (_e) _o->umrf_graph_name = _e->str(); }
}

inline ::flatbuffers::Offset<StopUmrfGraphRequest> StopUmrfGraphRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StopUmrfGraphRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStopUmrfGraphRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StopUmrfGraphRequest> CreateStopUmrfGraphRequest(::flatbuffers::FlatBufferBuilder &_fbb, const StopUmrfGraphRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StopUmrfGraphRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _umrf_graph_name = _fbb.CreateString(_o->umrf_graph_name);
  return fb::temoto_action_engine::CreateStopUmrfGraphRequest(
      _fbb,
      ___metadata,
      _umrf_graph_name);
}

inline StopUmrfGraphResponseT::StopUmrfGraphResponseT(const StopUmrfGraphResponseT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        success(o.success) {
}

inline StopUmrfGraphResponseT &StopUmrfGraphResponseT::operator=(StopUmrfGraphResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(success, o.success);
  return *this;
}

inline StopUmrfGraphResponseT *StopUmrfGraphResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StopUmrfGraphResponseT>(new StopUmrfGraphResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StopUmrfGraphResponse::UnPackTo(StopUmrfGraphResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = success(); _o->success = _e; }
}

inline ::flatbuffers::Offset<StopUmrfGraphResponse> StopUmrfGraphResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StopUmrfGraphResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStopUmrfGraphResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StopUmrfGraphResponse> CreateStopUmrfGraphResponse(::flatbuffers::FlatBufferBuilder &_fbb, const StopUmrfGraphResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StopUmrfGraphResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _success = _o->success;
  return fb::temoto_action_engine::CreateStopUmrfGraphResponse(
      _fbb,
      ___metadata,
      _success);
}

inline BroadcastStartUmrfGraphT::BroadcastStartUmrfGraphT(const BroadcastStartUmrfGraphT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        umrf_graph_name(o.umrf_graph_name),
        name_match_required(o.name_match_required),
        targets(o.targets),
        umrf_graph_json(o.umrf_graph_json) {
  umrf_graph_diffs.reserve(o.umrf_graph_diffs.size());
  for (const auto &umrf_graph_diffs_ : o.umrf_graph_diffs) { umrf_graph_diffs.emplace_back((umrf_graph_diffs_) ? new fb::temoto_action_engine::UmrfGraphDiffT(*umrf_graph_diffs_) : nullptr); }
}

inline BroadcastStartUmrfGraphT &BroadcastStartUmrfGraphT::operator=(BroadcastStartUmrfGraphT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(umrf_graph_name, o.umrf_graph_name);
  std::swap(name_match_required, o.name_match_required);
  std::swap(targets, o.targets);
  std::swap(umrf_graph_json, o.umrf_graph_json);
  std::swap(umrf_graph_diffs, o.umrf_graph_diffs);
  return *this;
}

inline BroadcastStartUmrfGraphT *BroadcastStartUmrfGraph::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BroadcastStartUmrfGraphT>(new BroadcastStartUmrfGraphT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BroadcastStartUmrfGraph::UnPackTo(BroadcastStartUmrfGraphT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = umrf_graph_name(); if (_e) _o->umrf_graph_name = _e->str(); }
  { auto _e = name_match_required(); _o->name_match_required = _e; }
  { auto _e = targets(); if (_e) { _o->targets.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->targets[_i] = _e->Get(_i)->str(); } } else { _o->targets.resize(0); } }
  { auto _e = umrf_graph_json(); if (_e) _o->umrf_graph_json = _e->str(); }
  { auto _e = umrf_graph_diffs(); if (_e) { _o->umrf_graph_diffs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->umrf_graph_diffs[_i]) { _e->Get(_i)->UnPackTo(_o->umrf_graph_diffs[_i].get(), _resolver); } else { _o->umrf_graph_diffs[_i] = std::unique_ptr<fb::temoto_action_engine::UmrfGraphDiffT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->umrf_graph_diffs.resize(0); } }
}

inline ::flatbuffers::Offset<BroadcastStartUmrfGraph> BroadcastStartUmrfGraph::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BroadcastStartUmrfGraphT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBroadcastStartUmrfGraph(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BroadcastStartUmrfGraph> CreateBroadcastStartUmrfGraph(::flatbuffers::FlatBufferBuilder &_fbb, const BroadcastStartUmrfGraphT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BroadcastStartUmrfGraphT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _umrf_graph_name = _fbb.CreateString(_o->umrf_graph_name);
  auto _name_match_required = _o->name_match_required;
  auto _targets = _fbb.CreateVectorOfStrings(_o->targets);
  auto _umrf_graph_json = _fbb.CreateString(_o->umrf_graph_json);
  auto _umrf_graph_diffs = _fbb.CreateVector<::flatbuffers::Offset<fb::temoto_action_engine::UmrfGraphDiff>> (_o->umrf_graph_diffs.size(), [](size_t i, _VectorArgs *__va) { return CreateUmrfGraphDiff(*__va->__fbb, __va->__o->umrf_graph_diffs[i].get(), __va->__rehasher); }, &_va );
  return fb::temoto_action_engine::CreateBroadcastStartUmrfGraph(
      _fbb,
      ___metadata,
      _umrf_graph_name,
      _name_match_required,
      _targets,
      _umrf_graph_json,
      _umrf_graph_diffs);
}

inline BroadcastStopUmrfGraphT::BroadcastStopUmrfGraphT(const BroadcastStopUmrfGraphT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        umrf_graph_name(o.umrf_graph_name),
        targets(o.targets) {
}

inline BroadcastStopUmrfGraphT &BroadcastStopUmrfGraphT::operator=(BroadcastStopUmrfGraphT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(umrf_graph_name, o.umrf_graph_name);
  std::swap(targets, o.targets);
  return *this;
}

inline BroadcastStopUmrfGraphT *BroadcastStopUmrfGraph::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BroadcastStopUmrfGraphT>(new BroadcastStopUmrfGraphT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BroadcastStopUmrfGraph::UnPackTo(BroadcastStopUmrfGraphT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = umrf_graph_name(); if (_e) _o->umrf_graph_name = _e->str(); }
  { auto _e = targets(); if (_e) { _o->targets.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->targets[_i] = _e->Get(_i)->str(); } } else { _o->targets.resize(0); } }
}

inline ::flatbuffers::Offset<BroadcastStopUmrfGraph> BroadcastStopUmrfGraph::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BroadcastStopUmrfGraphT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBroadcastStopUmrfGraph(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BroadcastStopUmrfGraph> CreateBroadcastStopUmrfGraph(::flatbuffers::FlatBufferBuilder &_fbb, const BroadcastStopUmrfGraphT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BroadcastStopUmrfGraphT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _umrf_graph_name = _fbb.CreateString(_o->umrf_graph_name);
  auto _targets = _fbb.CreateVectorOfStrings(_o->targets);
  return fb::temoto_action_engine::CreateBroadcastStopUmrfGraph(
      _fbb,
      ___metadata,
      _umrf_graph_name,
      _targets);
}

}  // namespace temoto_action_engine
}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_TEMOTOACTIONENGINE_FB_TEMOTO_ACTION_ENGINE_H_
