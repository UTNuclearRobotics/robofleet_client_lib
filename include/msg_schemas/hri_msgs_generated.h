// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_HRIMSGS_FB_HRI_MSGS_H_
#define FLATBUFFERS_GENERATED_HRIMSGS_FB_HRI_MSGS_H_

#include "./flatbuffers/flatbuffers.h"

#include "base_schema_generated.h"
#include "std_msgs_generated.h"

namespace fb {
namespace hri_msgs {

struct Expression;
struct ExpressionBuilder;
struct ExpressionT;

struct FacialActionUnits;
struct FacialActionUnitsBuilder;
struct FacialActionUnitsT;

struct Skeleton2D;
struct Skeleton2DBuilder;
struct Skeleton2DT;

struct Group;
struct GroupBuilder;
struct GroupT;

struct Gesture;
struct GestureBuilder;
struct GestureT;

struct LiveSpeech;
struct LiveSpeechBuilder;
struct LiveSpeechT;

struct FacialLandmarks;
struct FacialLandmarksBuilder;
struct FacialLandmarksT;

struct Gaze;
struct GazeBuilder;
struct GazeT;

struct BodyPosture;
struct BodyPostureBuilder;
struct BodyPostureT;

struct NormalizedRegionOfInterest2D;
struct NormalizedRegionOfInterest2DBuilder;
struct NormalizedRegionOfInterest2DT;

struct IdsList;
struct IdsListBuilder;
struct IdsListT;

struct SoftBiometrics;
struct SoftBiometricsBuilder;
struct SoftBiometricsT;

struct IdsMatch;
struct IdsMatchBuilder;
struct IdsMatchT;

struct NormalizedPointOfInterest2D;
struct NormalizedPointOfInterest2DBuilder;
struct NormalizedPointOfInterest2DT;

struct NormalizedPointOfInterest2DStamped;
struct NormalizedPointOfInterest2DStampedBuilder;
struct NormalizedPointOfInterest2DStampedT;

struct AudioFeatures;
struct AudioFeaturesBuilder;
struct AudioFeaturesT;

struct EngagementLevel;
struct EngagementLevelBuilder;
struct EngagementLevelT;

struct ExpressionT : public flatbuffers::NativeTable {
  typedef Expression TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::string expression{};
  float valence = 0.0f;
  float arousal = 0.0f;
  float confidence = 0.0f;
  ExpressionT() = default;
  ExpressionT(const ExpressionT &o);
  ExpressionT(ExpressionT&&) FLATBUFFERS_NOEXCEPT = default;
  ExpressionT &operator=(ExpressionT o) FLATBUFFERS_NOEXCEPT;
};

struct Expression FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExpressionT NativeTableType;
  typedef ExpressionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_EXPRESSION = 8,
    VT_VALENCE = 10,
    VT_AROUSAL = 12,
    VT_CONFIDENCE = 14
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const flatbuffers::String *expression() const {
    return GetPointer<const flatbuffers::String *>(VT_EXPRESSION);
  }
  float valence() const {
    return GetField<float>(VT_VALENCE, 0.0f);
  }
  float arousal() const {
    return GetField<float>(VT_AROUSAL, 0.0f);
  }
  float confidence() const {
    return GetField<float>(VT_CONFIDENCE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_EXPRESSION) &&
           verifier.VerifyString(expression()) &&
           VerifyField<float>(verifier, VT_VALENCE, 4) &&
           VerifyField<float>(verifier, VT_AROUSAL, 4) &&
           VerifyField<float>(verifier, VT_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
  ExpressionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExpressionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Expression> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpressionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExpressionBuilder {
  typedef Expression Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Expression::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(Expression::VT_HEADER, header);
  }
  void add_expression(flatbuffers::Offset<flatbuffers::String> expression) {
    fbb_.AddOffset(Expression::VT_EXPRESSION, expression);
  }
  void add_valence(float valence) {
    fbb_.AddElement<float>(Expression::VT_VALENCE, valence, 0.0f);
  }
  void add_arousal(float arousal) {
    fbb_.AddElement<float>(Expression::VT_AROUSAL, arousal, 0.0f);
  }
  void add_confidence(float confidence) {
    fbb_.AddElement<float>(Expression::VT_CONFIDENCE, confidence, 0.0f);
  }
  explicit ExpressionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Expression> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Expression>(end);
    fbb_.Required(o, Expression::VT_HEADER);
    fbb_.Required(o, Expression::VT_EXPRESSION);
    return o;
  }
};

inline flatbuffers::Offset<Expression> CreateExpression(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<flatbuffers::String> expression = 0,
    float valence = 0.0f,
    float arousal = 0.0f,
    float confidence = 0.0f) {
  ExpressionBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  builder_.add_arousal(arousal);
  builder_.add_valence(valence);
  builder_.add_expression(expression);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<Expression> CreateExpressionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const char *expression = nullptr,
    float valence = 0.0f,
    float arousal = 0.0f,
    float confidence = 0.0f) {
  auto expression__ = expression ? _fbb.CreateString(expression) : 0;
  return fb::hri_msgs::CreateExpression(
      _fbb,
      __metadata,
      header,
      expression__,
      valence,
      arousal,
      confidence);
}

flatbuffers::Offset<Expression> CreateExpression(flatbuffers::FlatBufferBuilder &_fbb, const ExpressionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FacialActionUnitsT : public flatbuffers::NativeTable {
  typedef FacialActionUnits TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::vector<float> fau{};
  std::vector<float> intensity{};
  std::vector<float> confidence{};
  FacialActionUnitsT() = default;
  FacialActionUnitsT(const FacialActionUnitsT &o);
  FacialActionUnitsT(FacialActionUnitsT&&) FLATBUFFERS_NOEXCEPT = default;
  FacialActionUnitsT &operator=(FacialActionUnitsT o) FLATBUFFERS_NOEXCEPT;
};

struct FacialActionUnits FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FacialActionUnitsT NativeTableType;
  typedef FacialActionUnitsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_FAU = 8,
    VT_INTENSITY = 10,
    VT_CONFIDENCE = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const flatbuffers::Vector<float> *fau() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_FAU);
  }
  const flatbuffers::Vector<float> *intensity() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_INTENSITY);
  }
  const flatbuffers::Vector<float> *confidence() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_CONFIDENCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_FAU) &&
           verifier.VerifyVector(fau()) &&
           VerifyOffsetRequired(verifier, VT_INTENSITY) &&
           verifier.VerifyVector(intensity()) &&
           VerifyOffsetRequired(verifier, VT_CONFIDENCE) &&
           verifier.VerifyVector(confidence()) &&
           verifier.EndTable();
  }
  FacialActionUnitsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FacialActionUnitsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FacialActionUnits> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FacialActionUnitsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FacialActionUnitsBuilder {
  typedef FacialActionUnits Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(FacialActionUnits::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(FacialActionUnits::VT_HEADER, header);
  }
  void add_fau(flatbuffers::Offset<flatbuffers::Vector<float>> fau) {
    fbb_.AddOffset(FacialActionUnits::VT_FAU, fau);
  }
  void add_intensity(flatbuffers::Offset<flatbuffers::Vector<float>> intensity) {
    fbb_.AddOffset(FacialActionUnits::VT_INTENSITY, intensity);
  }
  void add_confidence(flatbuffers::Offset<flatbuffers::Vector<float>> confidence) {
    fbb_.AddOffset(FacialActionUnits::VT_CONFIDENCE, confidence);
  }
  explicit FacialActionUnitsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FacialActionUnits> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FacialActionUnits>(end);
    fbb_.Required(o, FacialActionUnits::VT_HEADER);
    fbb_.Required(o, FacialActionUnits::VT_FAU);
    fbb_.Required(o, FacialActionUnits::VT_INTENSITY);
    fbb_.Required(o, FacialActionUnits::VT_CONFIDENCE);
    return o;
  }
};

inline flatbuffers::Offset<FacialActionUnits> CreateFacialActionUnits(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> fau = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> intensity = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> confidence = 0) {
  FacialActionUnitsBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  builder_.add_intensity(intensity);
  builder_.add_fau(fau);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<FacialActionUnits> CreateFacialActionUnitsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const std::vector<float> *fau = nullptr,
    const std::vector<float> *intensity = nullptr,
    const std::vector<float> *confidence = nullptr) {
  auto fau__ = fau ? _fbb.CreateVector<float>(*fau) : 0;
  auto intensity__ = intensity ? _fbb.CreateVector<float>(*intensity) : 0;
  auto confidence__ = confidence ? _fbb.CreateVector<float>(*confidence) : 0;
  return fb::hri_msgs::CreateFacialActionUnits(
      _fbb,
      __metadata,
      header,
      fau__,
      intensity__,
      confidence__);
}

flatbuffers::Offset<FacialActionUnits> CreateFacialActionUnits(flatbuffers::FlatBufferBuilder &_fbb, const FacialActionUnitsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Skeleton2DT : public flatbuffers::NativeTable {
  typedef Skeleton2D TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::vector<std::unique_ptr<fb::hri_msgs::NormalizedPointOfInterest2DT>> skeleton{};
  Skeleton2DT() = default;
  Skeleton2DT(const Skeleton2DT &o);
  Skeleton2DT(Skeleton2DT&&) FLATBUFFERS_NOEXCEPT = default;
  Skeleton2DT &operator=(Skeleton2DT o) FLATBUFFERS_NOEXCEPT;
};

struct Skeleton2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Skeleton2DT NativeTableType;
  typedef Skeleton2DBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_SKELETON = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::hri_msgs::NormalizedPointOfInterest2D>> *skeleton() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::hri_msgs::NormalizedPointOfInterest2D>> *>(VT_SKELETON);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_SKELETON) &&
           verifier.VerifyVector(skeleton()) &&
           verifier.VerifyVectorOfTables(skeleton()) &&
           verifier.EndTable();
  }
  Skeleton2DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Skeleton2DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Skeleton2D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Skeleton2DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Skeleton2DBuilder {
  typedef Skeleton2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Skeleton2D::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(Skeleton2D::VT_HEADER, header);
  }
  void add_skeleton(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::hri_msgs::NormalizedPointOfInterest2D>>> skeleton) {
    fbb_.AddOffset(Skeleton2D::VT_SKELETON, skeleton);
  }
  explicit Skeleton2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Skeleton2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Skeleton2D>(end);
    fbb_.Required(o, Skeleton2D::VT_HEADER);
    fbb_.Required(o, Skeleton2D::VT_SKELETON);
    return o;
  }
};

inline flatbuffers::Offset<Skeleton2D> CreateSkeleton2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::hri_msgs::NormalizedPointOfInterest2D>>> skeleton = 0) {
  Skeleton2DBuilder builder_(_fbb);
  builder_.add_skeleton(skeleton);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<Skeleton2D> CreateSkeleton2DDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const std::vector<flatbuffers::Offset<fb::hri_msgs::NormalizedPointOfInterest2D>> *skeleton = nullptr) {
  auto skeleton__ = skeleton ? _fbb.CreateVector<flatbuffers::Offset<fb::hri_msgs::NormalizedPointOfInterest2D>>(*skeleton) : 0;
  return fb::hri_msgs::CreateSkeleton2D(
      _fbb,
      __metadata,
      header,
      skeleton__);
}

flatbuffers::Offset<Skeleton2D> CreateSkeleton2D(flatbuffers::FlatBufferBuilder &_fbb, const Skeleton2DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GroupT : public flatbuffers::NativeTable {
  typedef Group TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::string group_id{};
  std::vector<std::string> members{};
  GroupT() = default;
  GroupT(const GroupT &o);
  GroupT(GroupT&&) FLATBUFFERS_NOEXCEPT = default;
  GroupT &operator=(GroupT o) FLATBUFFERS_NOEXCEPT;
};

struct Group FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GroupT NativeTableType;
  typedef GroupBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_GROUP_ID = 8,
    VT_MEMBERS = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const flatbuffers::String *group_id() const {
    return GetPointer<const flatbuffers::String *>(VT_GROUP_ID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *members() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_MEMBERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_GROUP_ID) &&
           verifier.VerifyString(group_id()) &&
           VerifyOffsetRequired(verifier, VT_MEMBERS) &&
           verifier.VerifyVector(members()) &&
           verifier.VerifyVectorOfStrings(members()) &&
           verifier.EndTable();
  }
  GroupT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GroupT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Group> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GroupT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GroupBuilder {
  typedef Group Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Group::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(Group::VT_HEADER, header);
  }
  void add_group_id(flatbuffers::Offset<flatbuffers::String> group_id) {
    fbb_.AddOffset(Group::VT_GROUP_ID, group_id);
  }
  void add_members(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> members) {
    fbb_.AddOffset(Group::VT_MEMBERS, members);
  }
  explicit GroupBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Group> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Group>(end);
    fbb_.Required(o, Group::VT_HEADER);
    fbb_.Required(o, Group::VT_GROUP_ID);
    fbb_.Required(o, Group::VT_MEMBERS);
    return o;
  }
};

inline flatbuffers::Offset<Group> CreateGroup(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<flatbuffers::String> group_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> members = 0) {
  GroupBuilder builder_(_fbb);
  builder_.add_members(members);
  builder_.add_group_id(group_id);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<Group> CreateGroupDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const char *group_id = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *members = nullptr) {
  auto group_id__ = group_id ? _fbb.CreateString(group_id) : 0;
  auto members__ = members ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*members) : 0;
  return fb::hri_msgs::CreateGroup(
      _fbb,
      __metadata,
      header,
      group_id__,
      members__);
}

flatbuffers::Offset<Group> CreateGroup(flatbuffers::FlatBufferBuilder &_fbb, const GroupT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GestureT : public flatbuffers::NativeTable {
  typedef Gesture TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  uint8_t gesture = 0;
  GestureT() = default;
  GestureT(const GestureT &o);
  GestureT(GestureT&&) FLATBUFFERS_NOEXCEPT = default;
  GestureT &operator=(GestureT o) FLATBUFFERS_NOEXCEPT;
};

struct Gesture FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GestureT NativeTableType;
  typedef GestureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_GESTURE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  uint8_t gesture() const {
    return GetField<uint8_t>(VT_GESTURE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<uint8_t>(verifier, VT_GESTURE, 1) &&
           verifier.EndTable();
  }
  GestureT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GestureT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Gesture> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GestureT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GestureBuilder {
  typedef Gesture Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Gesture::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(Gesture::VT_HEADER, header);
  }
  void add_gesture(uint8_t gesture) {
    fbb_.AddElement<uint8_t>(Gesture::VT_GESTURE, gesture, 0);
  }
  explicit GestureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Gesture> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Gesture>(end);
    fbb_.Required(o, Gesture::VT_HEADER);
    return o;
  }
};

inline flatbuffers::Offset<Gesture> CreateGesture(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    uint8_t gesture = 0) {
  GestureBuilder builder_(_fbb);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  builder_.add_gesture(gesture);
  return builder_.Finish();
}

flatbuffers::Offset<Gesture> CreateGesture(flatbuffers::FlatBufferBuilder &_fbb, const GestureT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LiveSpeechT : public flatbuffers::NativeTable {
  typedef LiveSpeech TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::string incremental{};
  std::string final{};
  double confidence = 0.0;
  LiveSpeechT() = default;
  LiveSpeechT(const LiveSpeechT &o);
  LiveSpeechT(LiveSpeechT&&) FLATBUFFERS_NOEXCEPT = default;
  LiveSpeechT &operator=(LiveSpeechT o) FLATBUFFERS_NOEXCEPT;
};

struct LiveSpeech FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LiveSpeechT NativeTableType;
  typedef LiveSpeechBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_INCREMENTAL = 8,
    VT_FINAL = 10,
    VT_CONFIDENCE = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const flatbuffers::String *incremental() const {
    return GetPointer<const flatbuffers::String *>(VT_INCREMENTAL);
  }
  const flatbuffers::String *final() const {
    return GetPointer<const flatbuffers::String *>(VT_FINAL);
  }
  double confidence() const {
    return GetField<double>(VT_CONFIDENCE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_INCREMENTAL) &&
           verifier.VerifyString(incremental()) &&
           VerifyOffsetRequired(verifier, VT_FINAL) &&
           verifier.VerifyString(final()) &&
           VerifyField<double>(verifier, VT_CONFIDENCE, 8) &&
           verifier.EndTable();
  }
  LiveSpeechT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LiveSpeechT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LiveSpeech> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LiveSpeechT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LiveSpeechBuilder {
  typedef LiveSpeech Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(LiveSpeech::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(LiveSpeech::VT_HEADER, header);
  }
  void add_incremental(flatbuffers::Offset<flatbuffers::String> incremental) {
    fbb_.AddOffset(LiveSpeech::VT_INCREMENTAL, incremental);
  }
  void add_final(flatbuffers::Offset<flatbuffers::String> final) {
    fbb_.AddOffset(LiveSpeech::VT_FINAL, final);
  }
  void add_confidence(double confidence) {
    fbb_.AddElement<double>(LiveSpeech::VT_CONFIDENCE, confidence, 0.0);
  }
  explicit LiveSpeechBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LiveSpeech> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LiveSpeech>(end);
    fbb_.Required(o, LiveSpeech::VT_HEADER);
    fbb_.Required(o, LiveSpeech::VT_INCREMENTAL);
    fbb_.Required(o, LiveSpeech::VT_FINAL);
    return o;
  }
};

inline flatbuffers::Offset<LiveSpeech> CreateLiveSpeech(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<flatbuffers::String> incremental = 0,
    flatbuffers::Offset<flatbuffers::String> final = 0,
    double confidence = 0.0) {
  LiveSpeechBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  builder_.add_final(final);
  builder_.add_incremental(incremental);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<LiveSpeech> CreateLiveSpeechDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const char *incremental = nullptr,
    const char *final = nullptr,
    double confidence = 0.0) {
  auto incremental__ = incremental ? _fbb.CreateString(incremental) : 0;
  auto final__ = final ? _fbb.CreateString(final) : 0;
  return fb::hri_msgs::CreateLiveSpeech(
      _fbb,
      __metadata,
      header,
      incremental__,
      final__,
      confidence);
}

flatbuffers::Offset<LiveSpeech> CreateLiveSpeech(flatbuffers::FlatBufferBuilder &_fbb, const LiveSpeechT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FacialLandmarksT : public flatbuffers::NativeTable {
  typedef FacialLandmarks TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::vector<std::unique_ptr<fb::hri_msgs::NormalizedPointOfInterest2DT>> landmarks{};
  uint32_t height = 0;
  uint32_t width = 0;
  FacialLandmarksT() = default;
  FacialLandmarksT(const FacialLandmarksT &o);
  FacialLandmarksT(FacialLandmarksT&&) FLATBUFFERS_NOEXCEPT = default;
  FacialLandmarksT &operator=(FacialLandmarksT o) FLATBUFFERS_NOEXCEPT;
};

struct FacialLandmarks FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FacialLandmarksT NativeTableType;
  typedef FacialLandmarksBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_LANDMARKS = 8,
    VT_HEIGHT = 10,
    VT_WIDTH = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::hri_msgs::NormalizedPointOfInterest2D>> *landmarks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::hri_msgs::NormalizedPointOfInterest2D>> *>(VT_LANDMARKS);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  uint32_t width() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_LANDMARKS) &&
           verifier.VerifyVector(landmarks()) &&
           verifier.VerifyVectorOfTables(landmarks()) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT, 4) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH, 4) &&
           verifier.EndTable();
  }
  FacialLandmarksT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FacialLandmarksT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FacialLandmarks> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FacialLandmarksT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FacialLandmarksBuilder {
  typedef FacialLandmarks Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(FacialLandmarks::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(FacialLandmarks::VT_HEADER, header);
  }
  void add_landmarks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::hri_msgs::NormalizedPointOfInterest2D>>> landmarks) {
    fbb_.AddOffset(FacialLandmarks::VT_LANDMARKS, landmarks);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(FacialLandmarks::VT_HEIGHT, height, 0);
  }
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(FacialLandmarks::VT_WIDTH, width, 0);
  }
  explicit FacialLandmarksBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FacialLandmarks> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FacialLandmarks>(end);
    fbb_.Required(o, FacialLandmarks::VT_HEADER);
    fbb_.Required(o, FacialLandmarks::VT_LANDMARKS);
    return o;
  }
};

inline flatbuffers::Offset<FacialLandmarks> CreateFacialLandmarks(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::hri_msgs::NormalizedPointOfInterest2D>>> landmarks = 0,
    uint32_t height = 0,
    uint32_t width = 0) {
  FacialLandmarksBuilder builder_(_fbb);
  builder_.add_width(width);
  builder_.add_height(height);
  builder_.add_landmarks(landmarks);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<FacialLandmarks> CreateFacialLandmarksDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const std::vector<flatbuffers::Offset<fb::hri_msgs::NormalizedPointOfInterest2D>> *landmarks = nullptr,
    uint32_t height = 0,
    uint32_t width = 0) {
  auto landmarks__ = landmarks ? _fbb.CreateVector<flatbuffers::Offset<fb::hri_msgs::NormalizedPointOfInterest2D>>(*landmarks) : 0;
  return fb::hri_msgs::CreateFacialLandmarks(
      _fbb,
      __metadata,
      header,
      landmarks__,
      height,
      width);
}

flatbuffers::Offset<FacialLandmarks> CreateFacialLandmarks(flatbuffers::FlatBufferBuilder &_fbb, const FacialLandmarksT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GazeT : public flatbuffers::NativeTable {
  typedef Gaze TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::string sender{};
  std::string receiver{};
  GazeT() = default;
  GazeT(const GazeT &o);
  GazeT(GazeT&&) FLATBUFFERS_NOEXCEPT = default;
  GazeT &operator=(GazeT o) FLATBUFFERS_NOEXCEPT;
};

struct Gaze FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GazeT NativeTableType;
  typedef GazeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_SENDER = 8,
    VT_RECEIVER = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const flatbuffers::String *sender() const {
    return GetPointer<const flatbuffers::String *>(VT_SENDER);
  }
  const flatbuffers::String *receiver() const {
    return GetPointer<const flatbuffers::String *>(VT_RECEIVER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_SENDER) &&
           verifier.VerifyString(sender()) &&
           VerifyOffsetRequired(verifier, VT_RECEIVER) &&
           verifier.VerifyString(receiver()) &&
           verifier.EndTable();
  }
  GazeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GazeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Gaze> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GazeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GazeBuilder {
  typedef Gaze Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Gaze::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(Gaze::VT_HEADER, header);
  }
  void add_sender(flatbuffers::Offset<flatbuffers::String> sender) {
    fbb_.AddOffset(Gaze::VT_SENDER, sender);
  }
  void add_receiver(flatbuffers::Offset<flatbuffers::String> receiver) {
    fbb_.AddOffset(Gaze::VT_RECEIVER, receiver);
  }
  explicit GazeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Gaze> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Gaze>(end);
    fbb_.Required(o, Gaze::VT_HEADER);
    fbb_.Required(o, Gaze::VT_SENDER);
    fbb_.Required(o, Gaze::VT_RECEIVER);
    return o;
  }
};

inline flatbuffers::Offset<Gaze> CreateGaze(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<flatbuffers::String> sender = 0,
    flatbuffers::Offset<flatbuffers::String> receiver = 0) {
  GazeBuilder builder_(_fbb);
  builder_.add_receiver(receiver);
  builder_.add_sender(sender);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<Gaze> CreateGazeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const char *sender = nullptr,
    const char *receiver = nullptr) {
  auto sender__ = sender ? _fbb.CreateString(sender) : 0;
  auto receiver__ = receiver ? _fbb.CreateString(receiver) : 0;
  return fb::hri_msgs::CreateGaze(
      _fbb,
      __metadata,
      header,
      sender__,
      receiver__);
}

flatbuffers::Offset<Gaze> CreateGaze(flatbuffers::FlatBufferBuilder &_fbb, const GazeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BodyPostureT : public flatbuffers::NativeTable {
  typedef BodyPosture TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  uint8_t posture = 0;
  BodyPostureT() = default;
  BodyPostureT(const BodyPostureT &o);
  BodyPostureT(BodyPostureT&&) FLATBUFFERS_NOEXCEPT = default;
  BodyPostureT &operator=(BodyPostureT o) FLATBUFFERS_NOEXCEPT;
};

struct BodyPosture FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BodyPostureT NativeTableType;
  typedef BodyPostureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_POSTURE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  uint8_t posture() const {
    return GetField<uint8_t>(VT_POSTURE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<uint8_t>(verifier, VT_POSTURE, 1) &&
           verifier.EndTable();
  }
  BodyPostureT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BodyPostureT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BodyPosture> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BodyPostureT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BodyPostureBuilder {
  typedef BodyPosture Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(BodyPosture::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(BodyPosture::VT_HEADER, header);
  }
  void add_posture(uint8_t posture) {
    fbb_.AddElement<uint8_t>(BodyPosture::VT_POSTURE, posture, 0);
  }
  explicit BodyPostureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BodyPosture> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BodyPosture>(end);
    fbb_.Required(o, BodyPosture::VT_HEADER);
    return o;
  }
};

inline flatbuffers::Offset<BodyPosture> CreateBodyPosture(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    uint8_t posture = 0) {
  BodyPostureBuilder builder_(_fbb);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  builder_.add_posture(posture);
  return builder_.Finish();
}

flatbuffers::Offset<BodyPosture> CreateBodyPosture(flatbuffers::FlatBufferBuilder &_fbb, const BodyPostureT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NormalizedRegionOfInterest2DT : public flatbuffers::NativeTable {
  typedef NormalizedRegionOfInterest2D TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  float xmin = 0.0f;
  float ymin = 0.0f;
  float xmax = 0.0f;
  float ymax = 0.0f;
  float c = 0.0f;
  NormalizedRegionOfInterest2DT() = default;
  NormalizedRegionOfInterest2DT(const NormalizedRegionOfInterest2DT &o);
  NormalizedRegionOfInterest2DT(NormalizedRegionOfInterest2DT&&) FLATBUFFERS_NOEXCEPT = default;
  NormalizedRegionOfInterest2DT &operator=(NormalizedRegionOfInterest2DT o) FLATBUFFERS_NOEXCEPT;
};

struct NormalizedRegionOfInterest2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NormalizedRegionOfInterest2DT NativeTableType;
  typedef NormalizedRegionOfInterest2DBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_XMIN = 8,
    VT_YMIN = 10,
    VT_XMAX = 12,
    VT_YMAX = 14,
    VT_C = 16
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  float xmin() const {
    return GetField<float>(VT_XMIN, 0.0f);
  }
  float ymin() const {
    return GetField<float>(VT_YMIN, 0.0f);
  }
  float xmax() const {
    return GetField<float>(VT_XMAX, 0.0f);
  }
  float ymax() const {
    return GetField<float>(VT_YMAX, 0.0f);
  }
  float c() const {
    return GetField<float>(VT_C, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<float>(verifier, VT_XMIN, 4) &&
           VerifyField<float>(verifier, VT_YMIN, 4) &&
           VerifyField<float>(verifier, VT_XMAX, 4) &&
           VerifyField<float>(verifier, VT_YMAX, 4) &&
           VerifyField<float>(verifier, VT_C, 4) &&
           verifier.EndTable();
  }
  NormalizedRegionOfInterest2DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NormalizedRegionOfInterest2DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NormalizedRegionOfInterest2D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NormalizedRegionOfInterest2DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NormalizedRegionOfInterest2DBuilder {
  typedef NormalizedRegionOfInterest2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(NormalizedRegionOfInterest2D::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(NormalizedRegionOfInterest2D::VT_HEADER, header);
  }
  void add_xmin(float xmin) {
    fbb_.AddElement<float>(NormalizedRegionOfInterest2D::VT_XMIN, xmin, 0.0f);
  }
  void add_ymin(float ymin) {
    fbb_.AddElement<float>(NormalizedRegionOfInterest2D::VT_YMIN, ymin, 0.0f);
  }
  void add_xmax(float xmax) {
    fbb_.AddElement<float>(NormalizedRegionOfInterest2D::VT_XMAX, xmax, 0.0f);
  }
  void add_ymax(float ymax) {
    fbb_.AddElement<float>(NormalizedRegionOfInterest2D::VT_YMAX, ymax, 0.0f);
  }
  void add_c(float c) {
    fbb_.AddElement<float>(NormalizedRegionOfInterest2D::VT_C, c, 0.0f);
  }
  explicit NormalizedRegionOfInterest2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NormalizedRegionOfInterest2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NormalizedRegionOfInterest2D>(end);
    fbb_.Required(o, NormalizedRegionOfInterest2D::VT_HEADER);
    return o;
  }
};

inline flatbuffers::Offset<NormalizedRegionOfInterest2D> CreateNormalizedRegionOfInterest2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    float xmin = 0.0f,
    float ymin = 0.0f,
    float xmax = 0.0f,
    float ymax = 0.0f,
    float c = 0.0f) {
  NormalizedRegionOfInterest2DBuilder builder_(_fbb);
  builder_.add_c(c);
  builder_.add_ymax(ymax);
  builder_.add_xmax(xmax);
  builder_.add_ymin(ymin);
  builder_.add_xmin(xmin);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<NormalizedRegionOfInterest2D> CreateNormalizedRegionOfInterest2D(flatbuffers::FlatBufferBuilder &_fbb, const NormalizedRegionOfInterest2DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IdsListT : public flatbuffers::NativeTable {
  typedef IdsList TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::vector<std::string> ids{};
  IdsListT() = default;
  IdsListT(const IdsListT &o);
  IdsListT(IdsListT&&) FLATBUFFERS_NOEXCEPT = default;
  IdsListT &operator=(IdsListT o) FLATBUFFERS_NOEXCEPT;
};

struct IdsList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IdsListT NativeTableType;
  typedef IdsListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_IDS = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *ids() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_IDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_IDS) &&
           verifier.VerifyVector(ids()) &&
           verifier.VerifyVectorOfStrings(ids()) &&
           verifier.EndTable();
  }
  IdsListT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IdsListT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<IdsList> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IdsListT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IdsListBuilder {
  typedef IdsList Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(IdsList::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(IdsList::VT_HEADER, header);
  }
  void add_ids(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> ids) {
    fbb_.AddOffset(IdsList::VT_IDS, ids);
  }
  explicit IdsListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<IdsList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IdsList>(end);
    fbb_.Required(o, IdsList::VT_HEADER);
    fbb_.Required(o, IdsList::VT_IDS);
    return o;
  }
};

inline flatbuffers::Offset<IdsList> CreateIdsList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> ids = 0) {
  IdsListBuilder builder_(_fbb);
  builder_.add_ids(ids);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<IdsList> CreateIdsListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *ids = nullptr) {
  auto ids__ = ids ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*ids) : 0;
  return fb::hri_msgs::CreateIdsList(
      _fbb,
      __metadata,
      header,
      ids__);
}

flatbuffers::Offset<IdsList> CreateIdsList(flatbuffers::FlatBufferBuilder &_fbb, const IdsListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SoftBiometricsT : public flatbuffers::NativeTable {
  typedef SoftBiometrics TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  uint8_t age = 0;
  float age_confidence = 0.0f;
  uint8_t gender = 0;
  float gender_confidence = 0.0f;
  SoftBiometricsT() = default;
  SoftBiometricsT(const SoftBiometricsT &o);
  SoftBiometricsT(SoftBiometricsT&&) FLATBUFFERS_NOEXCEPT = default;
  SoftBiometricsT &operator=(SoftBiometricsT o) FLATBUFFERS_NOEXCEPT;
};

struct SoftBiometrics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SoftBiometricsT NativeTableType;
  typedef SoftBiometricsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_AGE = 8,
    VT_AGE_CONFIDENCE = 10,
    VT_GENDER = 12,
    VT_GENDER_CONFIDENCE = 14
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  uint8_t age() const {
    return GetField<uint8_t>(VT_AGE, 0);
  }
  float age_confidence() const {
    return GetField<float>(VT_AGE_CONFIDENCE, 0.0f);
  }
  uint8_t gender() const {
    return GetField<uint8_t>(VT_GENDER, 0);
  }
  float gender_confidence() const {
    return GetField<float>(VT_GENDER_CONFIDENCE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<uint8_t>(verifier, VT_AGE, 1) &&
           VerifyField<float>(verifier, VT_AGE_CONFIDENCE, 4) &&
           VerifyField<uint8_t>(verifier, VT_GENDER, 1) &&
           VerifyField<float>(verifier, VT_GENDER_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
  SoftBiometricsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SoftBiometricsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SoftBiometrics> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftBiometricsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SoftBiometricsBuilder {
  typedef SoftBiometrics Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(SoftBiometrics::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(SoftBiometrics::VT_HEADER, header);
  }
  void add_age(uint8_t age) {
    fbb_.AddElement<uint8_t>(SoftBiometrics::VT_AGE, age, 0);
  }
  void add_age_confidence(float age_confidence) {
    fbb_.AddElement<float>(SoftBiometrics::VT_AGE_CONFIDENCE, age_confidence, 0.0f);
  }
  void add_gender(uint8_t gender) {
    fbb_.AddElement<uint8_t>(SoftBiometrics::VT_GENDER, gender, 0);
  }
  void add_gender_confidence(float gender_confidence) {
    fbb_.AddElement<float>(SoftBiometrics::VT_GENDER_CONFIDENCE, gender_confidence, 0.0f);
  }
  explicit SoftBiometricsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SoftBiometrics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoftBiometrics>(end);
    fbb_.Required(o, SoftBiometrics::VT_HEADER);
    return o;
  }
};

inline flatbuffers::Offset<SoftBiometrics> CreateSoftBiometrics(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    uint8_t age = 0,
    float age_confidence = 0.0f,
    uint8_t gender = 0,
    float gender_confidence = 0.0f) {
  SoftBiometricsBuilder builder_(_fbb);
  builder_.add_gender_confidence(gender_confidence);
  builder_.add_age_confidence(age_confidence);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  builder_.add_gender(gender);
  builder_.add_age(age);
  return builder_.Finish();
}

flatbuffers::Offset<SoftBiometrics> CreateSoftBiometrics(flatbuffers::FlatBufferBuilder &_fbb, const SoftBiometricsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IdsMatchT : public flatbuffers::NativeTable {
  typedef IdsMatch TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string id1{};
  int8_t id1_type = 0;
  std::string id2{};
  int8_t id2_type = 0;
  float confidence = 0.0f;
  IdsMatchT() = default;
  IdsMatchT(const IdsMatchT &o);
  IdsMatchT(IdsMatchT&&) FLATBUFFERS_NOEXCEPT = default;
  IdsMatchT &operator=(IdsMatchT o) FLATBUFFERS_NOEXCEPT;
};

struct IdsMatch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IdsMatchT NativeTableType;
  typedef IdsMatchBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_ID1 = 6,
    VT_ID1_TYPE = 8,
    VT_ID2 = 10,
    VT_ID2_TYPE = 12,
    VT_CONFIDENCE = 14
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const flatbuffers::String *id1() const {
    return GetPointer<const flatbuffers::String *>(VT_ID1);
  }
  int8_t id1_type() const {
    return GetField<int8_t>(VT_ID1_TYPE, 0);
  }
  const flatbuffers::String *id2() const {
    return GetPointer<const flatbuffers::String *>(VT_ID2);
  }
  int8_t id2_type() const {
    return GetField<int8_t>(VT_ID2_TYPE, 0);
  }
  float confidence() const {
    return GetField<float>(VT_CONFIDENCE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_ID1) &&
           verifier.VerifyString(id1()) &&
           VerifyField<int8_t>(verifier, VT_ID1_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_ID2) &&
           verifier.VerifyString(id2()) &&
           VerifyField<int8_t>(verifier, VT_ID2_TYPE, 1) &&
           VerifyField<float>(verifier, VT_CONFIDENCE, 4) &&
           verifier.EndTable();
  }
  IdsMatchT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IdsMatchT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<IdsMatch> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IdsMatchT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IdsMatchBuilder {
  typedef IdsMatch Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(IdsMatch::VT___METADATA, __metadata);
  }
  void add_id1(flatbuffers::Offset<flatbuffers::String> id1) {
    fbb_.AddOffset(IdsMatch::VT_ID1, id1);
  }
  void add_id1_type(int8_t id1_type) {
    fbb_.AddElement<int8_t>(IdsMatch::VT_ID1_TYPE, id1_type, 0);
  }
  void add_id2(flatbuffers::Offset<flatbuffers::String> id2) {
    fbb_.AddOffset(IdsMatch::VT_ID2, id2);
  }
  void add_id2_type(int8_t id2_type) {
    fbb_.AddElement<int8_t>(IdsMatch::VT_ID2_TYPE, id2_type, 0);
  }
  void add_confidence(float confidence) {
    fbb_.AddElement<float>(IdsMatch::VT_CONFIDENCE, confidence, 0.0f);
  }
  explicit IdsMatchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<IdsMatch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IdsMatch>(end);
    fbb_.Required(o, IdsMatch::VT_ID1);
    fbb_.Required(o, IdsMatch::VT_ID2);
    return o;
  }
};

inline flatbuffers::Offset<IdsMatch> CreateIdsMatch(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<flatbuffers::String> id1 = 0,
    int8_t id1_type = 0,
    flatbuffers::Offset<flatbuffers::String> id2 = 0,
    int8_t id2_type = 0,
    float confidence = 0.0f) {
  IdsMatchBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  builder_.add_id2(id2);
  builder_.add_id1(id1);
  builder_.add___metadata(__metadata);
  builder_.add_id2_type(id2_type);
  builder_.add_id1_type(id1_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<IdsMatch> CreateIdsMatchDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *id1 = nullptr,
    int8_t id1_type = 0,
    const char *id2 = nullptr,
    int8_t id2_type = 0,
    float confidence = 0.0f) {
  auto id1__ = id1 ? _fbb.CreateString(id1) : 0;
  auto id2__ = id2 ? _fbb.CreateString(id2) : 0;
  return fb::hri_msgs::CreateIdsMatch(
      _fbb,
      __metadata,
      id1__,
      id1_type,
      id2__,
      id2_type,
      confidence);
}

flatbuffers::Offset<IdsMatch> CreateIdsMatch(flatbuffers::FlatBufferBuilder &_fbb, const IdsMatchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NormalizedPointOfInterest2DT : public flatbuffers::NativeTable {
  typedef NormalizedPointOfInterest2D TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  float x = 0.0f;
  float y = 0.0f;
  float c = 0.0f;
  NormalizedPointOfInterest2DT() = default;
  NormalizedPointOfInterest2DT(const NormalizedPointOfInterest2DT &o);
  NormalizedPointOfInterest2DT(NormalizedPointOfInterest2DT&&) FLATBUFFERS_NOEXCEPT = default;
  NormalizedPointOfInterest2DT &operator=(NormalizedPointOfInterest2DT o) FLATBUFFERS_NOEXCEPT;
};

struct NormalizedPointOfInterest2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NormalizedPointOfInterest2DT NativeTableType;
  typedef NormalizedPointOfInterest2DBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_C = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float c() const {
    return GetField<float>(VT_C, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           VerifyField<float>(verifier, VT_C, 4) &&
           verifier.EndTable();
  }
  NormalizedPointOfInterest2DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NormalizedPointOfInterest2DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NormalizedPointOfInterest2D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NormalizedPointOfInterest2DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NormalizedPointOfInterest2DBuilder {
  typedef NormalizedPointOfInterest2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(NormalizedPointOfInterest2D::VT___METADATA, __metadata);
  }
  void add_x(float x) {
    fbb_.AddElement<float>(NormalizedPointOfInterest2D::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(NormalizedPointOfInterest2D::VT_Y, y, 0.0f);
  }
  void add_c(float c) {
    fbb_.AddElement<float>(NormalizedPointOfInterest2D::VT_C, c, 0.0f);
  }
  explicit NormalizedPointOfInterest2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NormalizedPointOfInterest2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NormalizedPointOfInterest2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<NormalizedPointOfInterest2D> CreateNormalizedPointOfInterest2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    float x = 0.0f,
    float y = 0.0f,
    float c = 0.0f) {
  NormalizedPointOfInterest2DBuilder builder_(_fbb);
  builder_.add_c(c);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<NormalizedPointOfInterest2D> CreateNormalizedPointOfInterest2D(flatbuffers::FlatBufferBuilder &_fbb, const NormalizedPointOfInterest2DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NormalizedPointOfInterest2DStampedT : public flatbuffers::NativeTable {
  typedef NormalizedPointOfInterest2DStamped TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  float x = 0.0f;
  float y = 0.0f;
  float c = 0.0f;
  NormalizedPointOfInterest2DStampedT() = default;
  NormalizedPointOfInterest2DStampedT(const NormalizedPointOfInterest2DStampedT &o);
  NormalizedPointOfInterest2DStampedT(NormalizedPointOfInterest2DStampedT&&) FLATBUFFERS_NOEXCEPT = default;
  NormalizedPointOfInterest2DStampedT &operator=(NormalizedPointOfInterest2DStampedT o) FLATBUFFERS_NOEXCEPT;
};

struct NormalizedPointOfInterest2DStamped FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NormalizedPointOfInterest2DStampedT NativeTableType;
  typedef NormalizedPointOfInterest2DStampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_X = 8,
    VT_Y = 10,
    VT_C = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float c() const {
    return GetField<float>(VT_C, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           VerifyField<float>(verifier, VT_C, 4) &&
           verifier.EndTable();
  }
  NormalizedPointOfInterest2DStampedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NormalizedPointOfInterest2DStampedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NormalizedPointOfInterest2DStamped> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NormalizedPointOfInterest2DStampedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NormalizedPointOfInterest2DStampedBuilder {
  typedef NormalizedPointOfInterest2DStamped Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(NormalizedPointOfInterest2DStamped::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(NormalizedPointOfInterest2DStamped::VT_HEADER, header);
  }
  void add_x(float x) {
    fbb_.AddElement<float>(NormalizedPointOfInterest2DStamped::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(NormalizedPointOfInterest2DStamped::VT_Y, y, 0.0f);
  }
  void add_c(float c) {
    fbb_.AddElement<float>(NormalizedPointOfInterest2DStamped::VT_C, c, 0.0f);
  }
  explicit NormalizedPointOfInterest2DStampedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NormalizedPointOfInterest2DStamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NormalizedPointOfInterest2DStamped>(end);
    fbb_.Required(o, NormalizedPointOfInterest2DStamped::VT_HEADER);
    return o;
  }
};

inline flatbuffers::Offset<NormalizedPointOfInterest2DStamped> CreateNormalizedPointOfInterest2DStamped(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    float x = 0.0f,
    float y = 0.0f,
    float c = 0.0f) {
  NormalizedPointOfInterest2DStampedBuilder builder_(_fbb);
  builder_.add_c(c);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<NormalizedPointOfInterest2DStamped> CreateNormalizedPointOfInterest2DStamped(flatbuffers::FlatBufferBuilder &_fbb, const NormalizedPointOfInterest2DStampedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AudioFeaturesT : public flatbuffers::NativeTable {
  typedef AudioFeatures TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  float zcr = 0.0f;
  float rms = 0.0f;
  float pitch = 0.0f;
  float hnr = 0.0f;
  std::vector<float> mfcc{};
  AudioFeaturesT() = default;
  AudioFeaturesT(const AudioFeaturesT &o);
  AudioFeaturesT(AudioFeaturesT&&) FLATBUFFERS_NOEXCEPT = default;
  AudioFeaturesT &operator=(AudioFeaturesT o) FLATBUFFERS_NOEXCEPT;
};

struct AudioFeatures FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AudioFeaturesT NativeTableType;
  typedef AudioFeaturesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_ZCR = 6,
    VT_RMS = 8,
    VT_PITCH = 10,
    VT_HNR = 12,
    VT_MFCC = 14
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  float zcr() const {
    return GetField<float>(VT_ZCR, 0.0f);
  }
  float rms() const {
    return GetField<float>(VT_RMS, 0.0f);
  }
  float pitch() const {
    return GetField<float>(VT_PITCH, 0.0f);
  }
  float hnr() const {
    return GetField<float>(VT_HNR, 0.0f);
  }
  const flatbuffers::Vector<float> *mfcc() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MFCC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<float>(verifier, VT_ZCR, 4) &&
           VerifyField<float>(verifier, VT_RMS, 4) &&
           VerifyField<float>(verifier, VT_PITCH, 4) &&
           VerifyField<float>(verifier, VT_HNR, 4) &&
           VerifyOffsetRequired(verifier, VT_MFCC) &&
           verifier.VerifyVector(mfcc()) &&
           verifier.EndTable();
  }
  AudioFeaturesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AudioFeaturesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AudioFeatures> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AudioFeaturesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AudioFeaturesBuilder {
  typedef AudioFeatures Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(AudioFeatures::VT___METADATA, __metadata);
  }
  void add_zcr(float zcr) {
    fbb_.AddElement<float>(AudioFeatures::VT_ZCR, zcr, 0.0f);
  }
  void add_rms(float rms) {
    fbb_.AddElement<float>(AudioFeatures::VT_RMS, rms, 0.0f);
  }
  void add_pitch(float pitch) {
    fbb_.AddElement<float>(AudioFeatures::VT_PITCH, pitch, 0.0f);
  }
  void add_hnr(float hnr) {
    fbb_.AddElement<float>(AudioFeatures::VT_HNR, hnr, 0.0f);
  }
  void add_mfcc(flatbuffers::Offset<flatbuffers::Vector<float>> mfcc) {
    fbb_.AddOffset(AudioFeatures::VT_MFCC, mfcc);
  }
  explicit AudioFeaturesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AudioFeatures> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AudioFeatures>(end);
    fbb_.Required(o, AudioFeatures::VT_MFCC);
    return o;
  }
};

inline flatbuffers::Offset<AudioFeatures> CreateAudioFeatures(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    float zcr = 0.0f,
    float rms = 0.0f,
    float pitch = 0.0f,
    float hnr = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<float>> mfcc = 0) {
  AudioFeaturesBuilder builder_(_fbb);
  builder_.add_mfcc(mfcc);
  builder_.add_hnr(hnr);
  builder_.add_pitch(pitch);
  builder_.add_rms(rms);
  builder_.add_zcr(zcr);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<AudioFeatures> CreateAudioFeaturesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    float zcr = 0.0f,
    float rms = 0.0f,
    float pitch = 0.0f,
    float hnr = 0.0f,
    const std::vector<float> *mfcc = nullptr) {
  auto mfcc__ = mfcc ? _fbb.CreateVector<float>(*mfcc) : 0;
  return fb::hri_msgs::CreateAudioFeatures(
      _fbb,
      __metadata,
      zcr,
      rms,
      pitch,
      hnr,
      mfcc__);
}

flatbuffers::Offset<AudioFeatures> CreateAudioFeatures(flatbuffers::FlatBufferBuilder &_fbb, const AudioFeaturesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EngagementLevelT : public flatbuffers::NativeTable {
  typedef EngagementLevel TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  uint8_t level = 0;
  EngagementLevelT() = default;
  EngagementLevelT(const EngagementLevelT &o);
  EngagementLevelT(EngagementLevelT&&) FLATBUFFERS_NOEXCEPT = default;
  EngagementLevelT &operator=(EngagementLevelT o) FLATBUFFERS_NOEXCEPT;
};

struct EngagementLevel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EngagementLevelT NativeTableType;
  typedef EngagementLevelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_LEVEL = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  uint8_t level() const {
    return GetField<uint8_t>(VT_LEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<uint8_t>(verifier, VT_LEVEL, 1) &&
           verifier.EndTable();
  }
  EngagementLevelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EngagementLevelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EngagementLevel> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EngagementLevelT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EngagementLevelBuilder {
  typedef EngagementLevel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(EngagementLevel::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(EngagementLevel::VT_HEADER, header);
  }
  void add_level(uint8_t level) {
    fbb_.AddElement<uint8_t>(EngagementLevel::VT_LEVEL, level, 0);
  }
  explicit EngagementLevelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EngagementLevel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EngagementLevel>(end);
    fbb_.Required(o, EngagementLevel::VT_HEADER);
    return o;
  }
};

inline flatbuffers::Offset<EngagementLevel> CreateEngagementLevel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    uint8_t level = 0) {
  EngagementLevelBuilder builder_(_fbb);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  builder_.add_level(level);
  return builder_.Finish();
}

flatbuffers::Offset<EngagementLevel> CreateEngagementLevel(flatbuffers::FlatBufferBuilder &_fbb, const EngagementLevelT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ExpressionT::ExpressionT(const ExpressionT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        expression(o.expression),
        valence(o.valence),
        arousal(o.arousal),
        confidence(o.confidence) {
}

inline ExpressionT &ExpressionT::operator=(ExpressionT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(expression, o.expression);
  std::swap(valence, o.valence);
  std::swap(arousal, o.arousal);
  std::swap(confidence, o.confidence);
  return *this;
}

inline ExpressionT *Expression::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ExpressionT>(new ExpressionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Expression::UnPackTo(ExpressionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } }
  { auto _e = expression(); if (_e) _o->expression = _e->str(); }
  { auto _e = valence(); _o->valence = _e; }
  { auto _e = arousal(); _o->arousal = _e; }
  { auto _e = confidence(); _o->confidence = _e; }
}

inline flatbuffers::Offset<Expression> Expression::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExpressionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExpression(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Expression> CreateExpression(flatbuffers::FlatBufferBuilder &_fbb, const ExpressionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExpressionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _expression = _fbb.CreateString(_o->expression);
  auto _valence = _o->valence;
  auto _arousal = _o->arousal;
  auto _confidence = _o->confidence;
  return fb::hri_msgs::CreateExpression(
      _fbb,
      ___metadata,
      _header,
      _expression,
      _valence,
      _arousal,
      _confidence);
}

inline FacialActionUnitsT::FacialActionUnitsT(const FacialActionUnitsT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        fau(o.fau),
        intensity(o.intensity),
        confidence(o.confidence) {
}

inline FacialActionUnitsT &FacialActionUnitsT::operator=(FacialActionUnitsT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(fau, o.fau);
  std::swap(intensity, o.intensity);
  std::swap(confidence, o.confidence);
  return *this;
}

inline FacialActionUnitsT *FacialActionUnits::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FacialActionUnitsT>(new FacialActionUnitsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FacialActionUnits::UnPackTo(FacialActionUnitsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } }
  { auto _e = fau(); if (_e) { _o->fau.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->fau[_i] = _e->Get(_i); } } }
  { auto _e = intensity(); if (_e) { _o->intensity.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->intensity[_i] = _e->Get(_i); } } }
  { auto _e = confidence(); if (_e) { _o->confidence.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->confidence[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<FacialActionUnits> FacialActionUnits::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FacialActionUnitsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFacialActionUnits(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FacialActionUnits> CreateFacialActionUnits(flatbuffers::FlatBufferBuilder &_fbb, const FacialActionUnitsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FacialActionUnitsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _fau = _fbb.CreateVector(_o->fau);
  auto _intensity = _fbb.CreateVector(_o->intensity);
  auto _confidence = _fbb.CreateVector(_o->confidence);
  return fb::hri_msgs::CreateFacialActionUnits(
      _fbb,
      ___metadata,
      _header,
      _fau,
      _intensity,
      _confidence);
}

inline Skeleton2DT::Skeleton2DT(const Skeleton2DT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr) {
  skeleton.reserve(o.skeleton.size());
  for (const auto &v : o.skeleton) { skeleton.emplace_back((v) ? new fb::hri_msgs::NormalizedPointOfInterest2DT(*v) : nullptr); }
}

inline Skeleton2DT &Skeleton2DT::operator=(Skeleton2DT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(skeleton, o.skeleton);
  return *this;
}

inline Skeleton2DT *Skeleton2D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Skeleton2DT>(new Skeleton2DT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Skeleton2D::UnPackTo(Skeleton2DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } }
  { auto _e = skeleton(); if (_e) { _o->skeleton.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->skeleton[_i]) { _e->Get(_i)->UnPackTo(_o->skeleton[_i].get(), _resolver); } else { _o->skeleton[_i] = std::unique_ptr<fb::hri_msgs::NormalizedPointOfInterest2DT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<Skeleton2D> Skeleton2D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Skeleton2DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSkeleton2D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Skeleton2D> CreateSkeleton2D(flatbuffers::FlatBufferBuilder &_fbb, const Skeleton2DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Skeleton2DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _skeleton = _fbb.CreateVector<flatbuffers::Offset<fb::hri_msgs::NormalizedPointOfInterest2D>> (_o->skeleton.size(), [](size_t i, _VectorArgs *__va) { return CreateNormalizedPointOfInterest2D(*__va->__fbb, __va->__o->skeleton[i].get(), __va->__rehasher); }, &_va );
  return fb::hri_msgs::CreateSkeleton2D(
      _fbb,
      ___metadata,
      _header,
      _skeleton);
}

inline GroupT::GroupT(const GroupT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        group_id(o.group_id),
        members(o.members) {
}

inline GroupT &GroupT::operator=(GroupT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(group_id, o.group_id);
  std::swap(members, o.members);
  return *this;
}

inline GroupT *Group::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GroupT>(new GroupT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Group::UnPackTo(GroupT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } }
  { auto _e = group_id(); if (_e) _o->group_id = _e->str(); }
  { auto _e = members(); if (_e) { _o->members.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->members[_i] = _e->Get(_i)->str(); } } }
}

inline flatbuffers::Offset<Group> Group::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GroupT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGroup(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Group> CreateGroup(flatbuffers::FlatBufferBuilder &_fbb, const GroupT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GroupT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _group_id = _fbb.CreateString(_o->group_id);
  auto _members = _fbb.CreateVectorOfStrings(_o->members);
  return fb::hri_msgs::CreateGroup(
      _fbb,
      ___metadata,
      _header,
      _group_id,
      _members);
}

inline GestureT::GestureT(const GestureT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        gesture(o.gesture) {
}

inline GestureT &GestureT::operator=(GestureT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(gesture, o.gesture);
  return *this;
}

inline GestureT *Gesture::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GestureT>(new GestureT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Gesture::UnPackTo(GestureT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } }
  { auto _e = gesture(); _o->gesture = _e; }
}

inline flatbuffers::Offset<Gesture> Gesture::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GestureT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGesture(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Gesture> CreateGesture(flatbuffers::FlatBufferBuilder &_fbb, const GestureT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GestureT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _gesture = _o->gesture;
  return fb::hri_msgs::CreateGesture(
      _fbb,
      ___metadata,
      _header,
      _gesture);
}

inline LiveSpeechT::LiveSpeechT(const LiveSpeechT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        incremental(o.incremental),
        final(o.final),
        confidence(o.confidence) {
}

inline LiveSpeechT &LiveSpeechT::operator=(LiveSpeechT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(incremental, o.incremental);
  std::swap(final, o.final);
  std::swap(confidence, o.confidence);
  return *this;
}

inline LiveSpeechT *LiveSpeech::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LiveSpeechT>(new LiveSpeechT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LiveSpeech::UnPackTo(LiveSpeechT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } }
  { auto _e = incremental(); if (_e) _o->incremental = _e->str(); }
  { auto _e = final(); if (_e) _o->final = _e->str(); }
  { auto _e = confidence(); _o->confidence = _e; }
}

inline flatbuffers::Offset<LiveSpeech> LiveSpeech::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LiveSpeechT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLiveSpeech(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LiveSpeech> CreateLiveSpeech(flatbuffers::FlatBufferBuilder &_fbb, const LiveSpeechT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LiveSpeechT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _incremental = _fbb.CreateString(_o->incremental);
  auto _final = _fbb.CreateString(_o->final);
  auto _confidence = _o->confidence;
  return fb::hri_msgs::CreateLiveSpeech(
      _fbb,
      ___metadata,
      _header,
      _incremental,
      _final,
      _confidence);
}

inline FacialLandmarksT::FacialLandmarksT(const FacialLandmarksT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        height(o.height),
        width(o.width) {
  landmarks.reserve(o.landmarks.size());
  for (const auto &v : o.landmarks) { landmarks.emplace_back((v) ? new fb::hri_msgs::NormalizedPointOfInterest2DT(*v) : nullptr); }
}

inline FacialLandmarksT &FacialLandmarksT::operator=(FacialLandmarksT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(landmarks, o.landmarks);
  std::swap(height, o.height);
  std::swap(width, o.width);
  return *this;
}

inline FacialLandmarksT *FacialLandmarks::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FacialLandmarksT>(new FacialLandmarksT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FacialLandmarks::UnPackTo(FacialLandmarksT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } }
  { auto _e = landmarks(); if (_e) { _o->landmarks.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->landmarks[_i]) { _e->Get(_i)->UnPackTo(_o->landmarks[_i].get(), _resolver); } else { _o->landmarks[_i] = std::unique_ptr<fb::hri_msgs::NormalizedPointOfInterest2DT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = height(); _o->height = _e; }
  { auto _e = width(); _o->width = _e; }
}

inline flatbuffers::Offset<FacialLandmarks> FacialLandmarks::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FacialLandmarksT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFacialLandmarks(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FacialLandmarks> CreateFacialLandmarks(flatbuffers::FlatBufferBuilder &_fbb, const FacialLandmarksT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FacialLandmarksT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _landmarks = _fbb.CreateVector<flatbuffers::Offset<fb::hri_msgs::NormalizedPointOfInterest2D>> (_o->landmarks.size(), [](size_t i, _VectorArgs *__va) { return CreateNormalizedPointOfInterest2D(*__va->__fbb, __va->__o->landmarks[i].get(), __va->__rehasher); }, &_va );
  auto _height = _o->height;
  auto _width = _o->width;
  return fb::hri_msgs::CreateFacialLandmarks(
      _fbb,
      ___metadata,
      _header,
      _landmarks,
      _height,
      _width);
}

inline GazeT::GazeT(const GazeT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        sender(o.sender),
        receiver(o.receiver) {
}

inline GazeT &GazeT::operator=(GazeT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(sender, o.sender);
  std::swap(receiver, o.receiver);
  return *this;
}

inline GazeT *Gaze::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GazeT>(new GazeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Gaze::UnPackTo(GazeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } }
  { auto _e = sender(); if (_e) _o->sender = _e->str(); }
  { auto _e = receiver(); if (_e) _o->receiver = _e->str(); }
}

inline flatbuffers::Offset<Gaze> Gaze::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GazeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGaze(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Gaze> CreateGaze(flatbuffers::FlatBufferBuilder &_fbb, const GazeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GazeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _sender = _fbb.CreateString(_o->sender);
  auto _receiver = _fbb.CreateString(_o->receiver);
  return fb::hri_msgs::CreateGaze(
      _fbb,
      ___metadata,
      _header,
      _sender,
      _receiver);
}

inline BodyPostureT::BodyPostureT(const BodyPostureT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        posture(o.posture) {
}

inline BodyPostureT &BodyPostureT::operator=(BodyPostureT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(posture, o.posture);
  return *this;
}

inline BodyPostureT *BodyPosture::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BodyPostureT>(new BodyPostureT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BodyPosture::UnPackTo(BodyPostureT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } }
  { auto _e = posture(); _o->posture = _e; }
}

inline flatbuffers::Offset<BodyPosture> BodyPosture::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BodyPostureT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBodyPosture(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BodyPosture> CreateBodyPosture(flatbuffers::FlatBufferBuilder &_fbb, const BodyPostureT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BodyPostureT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _posture = _o->posture;
  return fb::hri_msgs::CreateBodyPosture(
      _fbb,
      ___metadata,
      _header,
      _posture);
}

inline NormalizedRegionOfInterest2DT::NormalizedRegionOfInterest2DT(const NormalizedRegionOfInterest2DT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        xmin(o.xmin),
        ymin(o.ymin),
        xmax(o.xmax),
        ymax(o.ymax),
        c(o.c) {
}

inline NormalizedRegionOfInterest2DT &NormalizedRegionOfInterest2DT::operator=(NormalizedRegionOfInterest2DT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(xmin, o.xmin);
  std::swap(ymin, o.ymin);
  std::swap(xmax, o.xmax);
  std::swap(ymax, o.ymax);
  std::swap(c, o.c);
  return *this;
}

inline NormalizedRegionOfInterest2DT *NormalizedRegionOfInterest2D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NormalizedRegionOfInterest2DT>(new NormalizedRegionOfInterest2DT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NormalizedRegionOfInterest2D::UnPackTo(NormalizedRegionOfInterest2DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } }
  { auto _e = xmin(); _o->xmin = _e; }
  { auto _e = ymin(); _o->ymin = _e; }
  { auto _e = xmax(); _o->xmax = _e; }
  { auto _e = ymax(); _o->ymax = _e; }
  { auto _e = c(); _o->c = _e; }
}

inline flatbuffers::Offset<NormalizedRegionOfInterest2D> NormalizedRegionOfInterest2D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NormalizedRegionOfInterest2DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNormalizedRegionOfInterest2D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NormalizedRegionOfInterest2D> CreateNormalizedRegionOfInterest2D(flatbuffers::FlatBufferBuilder &_fbb, const NormalizedRegionOfInterest2DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NormalizedRegionOfInterest2DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _xmin = _o->xmin;
  auto _ymin = _o->ymin;
  auto _xmax = _o->xmax;
  auto _ymax = _o->ymax;
  auto _c = _o->c;
  return fb::hri_msgs::CreateNormalizedRegionOfInterest2D(
      _fbb,
      ___metadata,
      _header,
      _xmin,
      _ymin,
      _xmax,
      _ymax,
      _c);
}

inline IdsListT::IdsListT(const IdsListT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        ids(o.ids) {
}

inline IdsListT &IdsListT::operator=(IdsListT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(ids, o.ids);
  return *this;
}

inline IdsListT *IdsList::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<IdsListT>(new IdsListT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void IdsList::UnPackTo(IdsListT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } }
  { auto _e = ids(); if (_e) { _o->ids.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ids[_i] = _e->Get(_i)->str(); } } }
}

inline flatbuffers::Offset<IdsList> IdsList::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IdsListT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIdsList(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<IdsList> CreateIdsList(flatbuffers::FlatBufferBuilder &_fbb, const IdsListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const IdsListT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _ids = _fbb.CreateVectorOfStrings(_o->ids);
  return fb::hri_msgs::CreateIdsList(
      _fbb,
      ___metadata,
      _header,
      _ids);
}

inline SoftBiometricsT::SoftBiometricsT(const SoftBiometricsT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        age(o.age),
        age_confidence(o.age_confidence),
        gender(o.gender),
        gender_confidence(o.gender_confidence) {
}

inline SoftBiometricsT &SoftBiometricsT::operator=(SoftBiometricsT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(age, o.age);
  std::swap(age_confidence, o.age_confidence);
  std::swap(gender, o.gender);
  std::swap(gender_confidence, o.gender_confidence);
  return *this;
}

inline SoftBiometricsT *SoftBiometrics::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SoftBiometricsT>(new SoftBiometricsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SoftBiometrics::UnPackTo(SoftBiometricsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } }
  { auto _e = age(); _o->age = _e; }
  { auto _e = age_confidence(); _o->age_confidence = _e; }
  { auto _e = gender(); _o->gender = _e; }
  { auto _e = gender_confidence(); _o->gender_confidence = _e; }
}

inline flatbuffers::Offset<SoftBiometrics> SoftBiometrics::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftBiometricsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSoftBiometrics(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SoftBiometrics> CreateSoftBiometrics(flatbuffers::FlatBufferBuilder &_fbb, const SoftBiometricsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SoftBiometricsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _age = _o->age;
  auto _age_confidence = _o->age_confidence;
  auto _gender = _o->gender;
  auto _gender_confidence = _o->gender_confidence;
  return fb::hri_msgs::CreateSoftBiometrics(
      _fbb,
      ___metadata,
      _header,
      _age,
      _age_confidence,
      _gender,
      _gender_confidence);
}

inline IdsMatchT::IdsMatchT(const IdsMatchT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        id1(o.id1),
        id1_type(o.id1_type),
        id2(o.id2),
        id2_type(o.id2_type),
        confidence(o.confidence) {
}

inline IdsMatchT &IdsMatchT::operator=(IdsMatchT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(id1, o.id1);
  std::swap(id1_type, o.id1_type);
  std::swap(id2, o.id2);
  std::swap(id2_type, o.id2_type);
  std::swap(confidence, o.confidence);
  return *this;
}

inline IdsMatchT *IdsMatch::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<IdsMatchT>(new IdsMatchT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void IdsMatch::UnPackTo(IdsMatchT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = id1(); if (_e) _o->id1 = _e->str(); }
  { auto _e = id1_type(); _o->id1_type = _e; }
  { auto _e = id2(); if (_e) _o->id2 = _e->str(); }
  { auto _e = id2_type(); _o->id2_type = _e; }
  { auto _e = confidence(); _o->confidence = _e; }
}

inline flatbuffers::Offset<IdsMatch> IdsMatch::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IdsMatchT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIdsMatch(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<IdsMatch> CreateIdsMatch(flatbuffers::FlatBufferBuilder &_fbb, const IdsMatchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const IdsMatchT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _id1 = _fbb.CreateString(_o->id1);
  auto _id1_type = _o->id1_type;
  auto _id2 = _fbb.CreateString(_o->id2);
  auto _id2_type = _o->id2_type;
  auto _confidence = _o->confidence;
  return fb::hri_msgs::CreateIdsMatch(
      _fbb,
      ___metadata,
      _id1,
      _id1_type,
      _id2,
      _id2_type,
      _confidence);
}

inline NormalizedPointOfInterest2DT::NormalizedPointOfInterest2DT(const NormalizedPointOfInterest2DT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        x(o.x),
        y(o.y),
        c(o.c) {
}

inline NormalizedPointOfInterest2DT &NormalizedPointOfInterest2DT::operator=(NormalizedPointOfInterest2DT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(x, o.x);
  std::swap(y, o.y);
  std::swap(c, o.c);
  return *this;
}

inline NormalizedPointOfInterest2DT *NormalizedPointOfInterest2D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NormalizedPointOfInterest2DT>(new NormalizedPointOfInterest2DT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NormalizedPointOfInterest2D::UnPackTo(NormalizedPointOfInterest2DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = c(); _o->c = _e; }
}

inline flatbuffers::Offset<NormalizedPointOfInterest2D> NormalizedPointOfInterest2D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NormalizedPointOfInterest2DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNormalizedPointOfInterest2D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NormalizedPointOfInterest2D> CreateNormalizedPointOfInterest2D(flatbuffers::FlatBufferBuilder &_fbb, const NormalizedPointOfInterest2DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NormalizedPointOfInterest2DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _c = _o->c;
  return fb::hri_msgs::CreateNormalizedPointOfInterest2D(
      _fbb,
      ___metadata,
      _x,
      _y,
      _c);
}

inline NormalizedPointOfInterest2DStampedT::NormalizedPointOfInterest2DStampedT(const NormalizedPointOfInterest2DStampedT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        x(o.x),
        y(o.y),
        c(o.c) {
}

inline NormalizedPointOfInterest2DStampedT &NormalizedPointOfInterest2DStampedT::operator=(NormalizedPointOfInterest2DStampedT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(x, o.x);
  std::swap(y, o.y);
  std::swap(c, o.c);
  return *this;
}

inline NormalizedPointOfInterest2DStampedT *NormalizedPointOfInterest2DStamped::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NormalizedPointOfInterest2DStampedT>(new NormalizedPointOfInterest2DStampedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NormalizedPointOfInterest2DStamped::UnPackTo(NormalizedPointOfInterest2DStampedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = c(); _o->c = _e; }
}

inline flatbuffers::Offset<NormalizedPointOfInterest2DStamped> NormalizedPointOfInterest2DStamped::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NormalizedPointOfInterest2DStampedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNormalizedPointOfInterest2DStamped(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NormalizedPointOfInterest2DStamped> CreateNormalizedPointOfInterest2DStamped(flatbuffers::FlatBufferBuilder &_fbb, const NormalizedPointOfInterest2DStampedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NormalizedPointOfInterest2DStampedT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _c = _o->c;
  return fb::hri_msgs::CreateNormalizedPointOfInterest2DStamped(
      _fbb,
      ___metadata,
      _header,
      _x,
      _y,
      _c);
}

inline AudioFeaturesT::AudioFeaturesT(const AudioFeaturesT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        zcr(o.zcr),
        rms(o.rms),
        pitch(o.pitch),
        hnr(o.hnr),
        mfcc(o.mfcc) {
}

inline AudioFeaturesT &AudioFeaturesT::operator=(AudioFeaturesT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(zcr, o.zcr);
  std::swap(rms, o.rms);
  std::swap(pitch, o.pitch);
  std::swap(hnr, o.hnr);
  std::swap(mfcc, o.mfcc);
  return *this;
}

inline AudioFeaturesT *AudioFeatures::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AudioFeaturesT>(new AudioFeaturesT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AudioFeatures::UnPackTo(AudioFeaturesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = zcr(); _o->zcr = _e; }
  { auto _e = rms(); _o->rms = _e; }
  { auto _e = pitch(); _o->pitch = _e; }
  { auto _e = hnr(); _o->hnr = _e; }
  { auto _e = mfcc(); if (_e) { _o->mfcc.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->mfcc[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<AudioFeatures> AudioFeatures::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AudioFeaturesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAudioFeatures(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AudioFeatures> CreateAudioFeatures(flatbuffers::FlatBufferBuilder &_fbb, const AudioFeaturesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AudioFeaturesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _zcr = _o->zcr;
  auto _rms = _o->rms;
  auto _pitch = _o->pitch;
  auto _hnr = _o->hnr;
  auto _mfcc = _fbb.CreateVector(_o->mfcc);
  return fb::hri_msgs::CreateAudioFeatures(
      _fbb,
      ___metadata,
      _zcr,
      _rms,
      _pitch,
      _hnr,
      _mfcc);
}

inline EngagementLevelT::EngagementLevelT(const EngagementLevelT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        level(o.level) {
}

inline EngagementLevelT &EngagementLevelT::operator=(EngagementLevelT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(level, o.level);
  return *this;
}

inline EngagementLevelT *EngagementLevel::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EngagementLevelT>(new EngagementLevelT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EngagementLevel::UnPackTo(EngagementLevelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } }
  { auto _e = level(); _o->level = _e; }
}

inline flatbuffers::Offset<EngagementLevel> EngagementLevel::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EngagementLevelT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEngagementLevel(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EngagementLevel> CreateEngagementLevel(flatbuffers::FlatBufferBuilder &_fbb, const EngagementLevelT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EngagementLevelT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _level = _o->level;
  return fb::hri_msgs::CreateEngagementLevel(
      _fbb,
      ___metadata,
      _header,
      _level);
}

}  // namespace hri_msgs
}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_HRIMSGS_FB_HRI_MSGS_H_
