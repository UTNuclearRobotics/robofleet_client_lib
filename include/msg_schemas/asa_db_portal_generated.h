// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ASADBPORTAL_FB_ASA_DB_PORTAL_H_
#define FLATBUFFERS_GENERATED_ASADBPORTAL_FB_ASA_DB_PORTAL_H_

#include "./flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 21,
             "Non-compatible flatbuffers version included");

#include "msg_schemas/geographic_msgs_generated.h"
#include "msg_schemas/geometry_msgs_generated.h"

namespace fb {
namespace asa_db_portal {

struct GetAnchorByIDRequest;
struct GetAnchorByIDRequestBuilder;
struct GetAnchorByIDRequestT;

struct GetAnchorByIDResponse;
struct GetAnchorByIDResponseBuilder;
struct GetAnchorByIDResponseT;

struct DeleteAnchorRequest;
struct DeleteAnchorRequestBuilder;
struct DeleteAnchorRequestT;

struct DeleteAnchorResponse;
struct DeleteAnchorResponseBuilder;
struct DeleteAnchorResponseT;

struct AzureSpatialAnchor;
struct AzureSpatialAnchorBuilder;
struct AzureSpatialAnchorT;

struct GetAllAnchorsRequest;
struct GetAllAnchorsRequestBuilder;
struct GetAllAnchorsRequestT;

struct GetAllAnchorsResponse;
struct GetAllAnchorsResponseBuilder;
struct GetAllAnchorsResponseT;

struct GetAnchorsByDistanceRequest;
struct GetAnchorsByDistanceRequestBuilder;
struct GetAnchorsByDistanceRequestT;

struct GetAnchorsByDistanceResponse;
struct GetAnchorsByDistanceResponseBuilder;
struct GetAnchorsByDistanceResponseT;

struct CreateOrUpdateAnchorRequest;
struct CreateOrUpdateAnchorRequestBuilder;
struct CreateOrUpdateAnchorRequestT;

struct CreateOrUpdateAnchorResponse;
struct CreateOrUpdateAnchorResponseBuilder;
struct CreateOrUpdateAnchorResponseT;

struct GetAnchorByIDRequestT : public ::flatbuffers::NativeTable {
  typedef GetAnchorByIDRequest TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string id{};
  std::string ns{};
  GetAnchorByIDRequestT() = default;
  GetAnchorByIDRequestT(const GetAnchorByIDRequestT &o);
  GetAnchorByIDRequestT(GetAnchorByIDRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  GetAnchorByIDRequestT &operator=(GetAnchorByIDRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct GetAnchorByIDRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetAnchorByIDRequestT NativeTableType;
  typedef GetAnchorByIDRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_ID = 6,
    VT_NS = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *ns() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffsetRequired(verifier, VT_NS) &&
           verifier.VerifyString(ns()) &&
           verifier.EndTable();
  }
  GetAnchorByIDRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetAnchorByIDRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GetAnchorByIDRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetAnchorByIDRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetAnchorByIDRequestBuilder {
  typedef GetAnchorByIDRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GetAnchorByIDRequest::VT___METADATA, __metadata);
  }
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(GetAnchorByIDRequest::VT_ID, id);
  }
  void add_ns(::flatbuffers::Offset<::flatbuffers::String> ns) {
    fbb_.AddOffset(GetAnchorByIDRequest::VT_NS, ns);
  }
  explicit GetAnchorByIDRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetAnchorByIDRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetAnchorByIDRequest>(end);
    fbb_.Required(o, GetAnchorByIDRequest::VT_ID);
    fbb_.Required(o, GetAnchorByIDRequest::VT_NS);
    return o;
  }
};

inline ::flatbuffers::Offset<GetAnchorByIDRequest> CreateGetAnchorByIDRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ns = 0) {
  GetAnchorByIDRequestBuilder builder_(_fbb);
  builder_.add_ns(ns);
  builder_.add_id(id);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GetAnchorByIDRequest> CreateGetAnchorByIDRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *id = nullptr,
    const char *ns = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto ns__ = ns ? _fbb.CreateString(ns) : 0;
  return fb::asa_db_portal::CreateGetAnchorByIDRequest(
      _fbb,
      __metadata,
      id__,
      ns__);
}

::flatbuffers::Offset<GetAnchorByIDRequest> CreateGetAnchorByIDRequest(::flatbuffers::FlatBufferBuilder &_fbb, const GetAnchorByIDRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetAnchorByIDResponseT : public ::flatbuffers::NativeTable {
  typedef GetAnchorByIDResponse TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  bool success = false;
  std::unique_ptr<fb::asa_db_portal::AzureSpatialAnchorT> anchor{};
  GetAnchorByIDResponseT() = default;
  GetAnchorByIDResponseT(const GetAnchorByIDResponseT &o);
  GetAnchorByIDResponseT(GetAnchorByIDResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  GetAnchorByIDResponseT &operator=(GetAnchorByIDResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct GetAnchorByIDResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetAnchorByIDResponseT NativeTableType;
  typedef GetAnchorByIDResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_SUCCESS = 6,
    VT_ANCHOR = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  const fb::asa_db_portal::AzureSpatialAnchor *anchor() const {
    return GetPointer<const fb::asa_db_portal::AzureSpatialAnchor *>(VT_ANCHOR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           VerifyOffsetRequired(verifier, VT_ANCHOR) &&
           verifier.VerifyTable(anchor()) &&
           verifier.EndTable();
  }
  GetAnchorByIDResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetAnchorByIDResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GetAnchorByIDResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetAnchorByIDResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetAnchorByIDResponseBuilder {
  typedef GetAnchorByIDResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GetAnchorByIDResponse::VT___METADATA, __metadata);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(GetAnchorByIDResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_anchor(::flatbuffers::Offset<fb::asa_db_portal::AzureSpatialAnchor> anchor) {
    fbb_.AddOffset(GetAnchorByIDResponse::VT_ANCHOR, anchor);
  }
  explicit GetAnchorByIDResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetAnchorByIDResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetAnchorByIDResponse>(end);
    fbb_.Required(o, GetAnchorByIDResponse::VT_ANCHOR);
    return o;
  }
};

inline ::flatbuffers::Offset<GetAnchorByIDResponse> CreateGetAnchorByIDResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    bool success = false,
    ::flatbuffers::Offset<fb::asa_db_portal::AzureSpatialAnchor> anchor = 0) {
  GetAnchorByIDResponseBuilder builder_(_fbb);
  builder_.add_anchor(anchor);
  builder_.add___metadata(__metadata);
  builder_.add_success(success);
  return builder_.Finish();
}

::flatbuffers::Offset<GetAnchorByIDResponse> CreateGetAnchorByIDResponse(::flatbuffers::FlatBufferBuilder &_fbb, const GetAnchorByIDResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DeleteAnchorRequestT : public ::flatbuffers::NativeTable {
  typedef DeleteAnchorRequest TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string id{};
  std::string ns{};
  DeleteAnchorRequestT() = default;
  DeleteAnchorRequestT(const DeleteAnchorRequestT &o);
  DeleteAnchorRequestT(DeleteAnchorRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  DeleteAnchorRequestT &operator=(DeleteAnchorRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct DeleteAnchorRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DeleteAnchorRequestT NativeTableType;
  typedef DeleteAnchorRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_ID = 6,
    VT_NS = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *ns() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffsetRequired(verifier, VT_NS) &&
           verifier.VerifyString(ns()) &&
           verifier.EndTable();
  }
  DeleteAnchorRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DeleteAnchorRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DeleteAnchorRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DeleteAnchorRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DeleteAnchorRequestBuilder {
  typedef DeleteAnchorRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(DeleteAnchorRequest::VT___METADATA, __metadata);
  }
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(DeleteAnchorRequest::VT_ID, id);
  }
  void add_ns(::flatbuffers::Offset<::flatbuffers::String> ns) {
    fbb_.AddOffset(DeleteAnchorRequest::VT_NS, ns);
  }
  explicit DeleteAnchorRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DeleteAnchorRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DeleteAnchorRequest>(end);
    fbb_.Required(o, DeleteAnchorRequest::VT_ID);
    fbb_.Required(o, DeleteAnchorRequest::VT_NS);
    return o;
  }
};

inline ::flatbuffers::Offset<DeleteAnchorRequest> CreateDeleteAnchorRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ns = 0) {
  DeleteAnchorRequestBuilder builder_(_fbb);
  builder_.add_ns(ns);
  builder_.add_id(id);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DeleteAnchorRequest> CreateDeleteAnchorRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *id = nullptr,
    const char *ns = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto ns__ = ns ? _fbb.CreateString(ns) : 0;
  return fb::asa_db_portal::CreateDeleteAnchorRequest(
      _fbb,
      __metadata,
      id__,
      ns__);
}

::flatbuffers::Offset<DeleteAnchorRequest> CreateDeleteAnchorRequest(::flatbuffers::FlatBufferBuilder &_fbb, const DeleteAnchorRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DeleteAnchorResponseT : public ::flatbuffers::NativeTable {
  typedef DeleteAnchorResponse TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  bool success = false;
  DeleteAnchorResponseT() = default;
  DeleteAnchorResponseT(const DeleteAnchorResponseT &o);
  DeleteAnchorResponseT(DeleteAnchorResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  DeleteAnchorResponseT &operator=(DeleteAnchorResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct DeleteAnchorResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DeleteAnchorResponseT NativeTableType;
  typedef DeleteAnchorResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_SUCCESS = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           verifier.EndTable();
  }
  DeleteAnchorResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DeleteAnchorResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DeleteAnchorResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DeleteAnchorResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DeleteAnchorResponseBuilder {
  typedef DeleteAnchorResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(DeleteAnchorResponse::VT___METADATA, __metadata);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(DeleteAnchorResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit DeleteAnchorResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DeleteAnchorResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DeleteAnchorResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DeleteAnchorResponse> CreateDeleteAnchorResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    bool success = false) {
  DeleteAnchorResponseBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  builder_.add_success(success);
  return builder_.Finish();
}

::flatbuffers::Offset<DeleteAnchorResponse> CreateDeleteAnchorResponse(::flatbuffers::FlatBufferBuilder &_fbb, const DeleteAnchorResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AzureSpatialAnchorT : public ::flatbuffers::NativeTable {
  typedef AzureSpatialAnchor TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string asa_id{};
  std::string rep_id{};
  std::string ns{};
  std::string anchor_type{};
  std::unique_ptr<fb::RosTime> timestamp{};
  std::unique_ptr<fb::geometry_msgs::PoseWithCovarianceStampedT> pose{};
  std::unique_ptr<fb::geographic_msgs::GeoPoseWithCovarianceStampedT> geopose{};
  std::vector<std::string> neighbors{};
  AzureSpatialAnchorT() = default;
  AzureSpatialAnchorT(const AzureSpatialAnchorT &o);
  AzureSpatialAnchorT(AzureSpatialAnchorT&&) FLATBUFFERS_NOEXCEPT = default;
  AzureSpatialAnchorT &operator=(AzureSpatialAnchorT o) FLATBUFFERS_NOEXCEPT;
};

struct AzureSpatialAnchor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AzureSpatialAnchorT NativeTableType;
  typedef AzureSpatialAnchorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_ASA_ID = 6,
    VT_REP_ID = 8,
    VT_NS = 10,
    VT_ANCHOR_TYPE = 12,
    VT_TIMESTAMP = 14,
    VT_POSE = 16,
    VT_GEOPOSE = 18,
    VT_NEIGHBORS = 20
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *asa_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ASA_ID);
  }
  const ::flatbuffers::String *rep_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REP_ID);
  }
  const ::flatbuffers::String *ns() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NS);
  }
  const ::flatbuffers::String *anchor_type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ANCHOR_TYPE);
  }
  const fb::RosTime *timestamp() const {
    return GetStruct<const fb::RosTime *>(VT_TIMESTAMP);
  }
  const fb::geometry_msgs::PoseWithCovarianceStamped *pose() const {
    return GetPointer<const fb::geometry_msgs::PoseWithCovarianceStamped *>(VT_POSE);
  }
  const fb::geographic_msgs::GeoPoseWithCovarianceStamped *geopose() const {
    return GetPointer<const fb::geographic_msgs::GeoPoseWithCovarianceStamped *>(VT_GEOPOSE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *neighbors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_NEIGHBORS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_ASA_ID) &&
           verifier.VerifyString(asa_id()) &&
           VerifyOffsetRequired(verifier, VT_REP_ID) &&
           verifier.VerifyString(rep_id()) &&
           VerifyOffsetRequired(verifier, VT_NS) &&
           verifier.VerifyString(ns()) &&
           VerifyOffsetRequired(verifier, VT_ANCHOR_TYPE) &&
           verifier.VerifyString(anchor_type()) &&
           VerifyFieldRequired<fb::RosTime>(verifier, VT_TIMESTAMP, 4) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           VerifyOffsetRequired(verifier, VT_GEOPOSE) &&
           verifier.VerifyTable(geopose()) &&
           VerifyOffsetRequired(verifier, VT_NEIGHBORS) &&
           verifier.VerifyVector(neighbors()) &&
           verifier.VerifyVectorOfStrings(neighbors()) &&
           verifier.EndTable();
  }
  AzureSpatialAnchorT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AzureSpatialAnchorT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AzureSpatialAnchor> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AzureSpatialAnchorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AzureSpatialAnchorBuilder {
  typedef AzureSpatialAnchor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(AzureSpatialAnchor::VT___METADATA, __metadata);
  }
  void add_asa_id(::flatbuffers::Offset<::flatbuffers::String> asa_id) {
    fbb_.AddOffset(AzureSpatialAnchor::VT_ASA_ID, asa_id);
  }
  void add_rep_id(::flatbuffers::Offset<::flatbuffers::String> rep_id) {
    fbb_.AddOffset(AzureSpatialAnchor::VT_REP_ID, rep_id);
  }
  void add_ns(::flatbuffers::Offset<::flatbuffers::String> ns) {
    fbb_.AddOffset(AzureSpatialAnchor::VT_NS, ns);
  }
  void add_anchor_type(::flatbuffers::Offset<::flatbuffers::String> anchor_type) {
    fbb_.AddOffset(AzureSpatialAnchor::VT_ANCHOR_TYPE, anchor_type);
  }
  void add_timestamp(const fb::RosTime *timestamp) {
    fbb_.AddStruct(AzureSpatialAnchor::VT_TIMESTAMP, timestamp);
  }
  void add_pose(::flatbuffers::Offset<fb::geometry_msgs::PoseWithCovarianceStamped> pose) {
    fbb_.AddOffset(AzureSpatialAnchor::VT_POSE, pose);
  }
  void add_geopose(::flatbuffers::Offset<fb::geographic_msgs::GeoPoseWithCovarianceStamped> geopose) {
    fbb_.AddOffset(AzureSpatialAnchor::VT_GEOPOSE, geopose);
  }
  void add_neighbors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> neighbors) {
    fbb_.AddOffset(AzureSpatialAnchor::VT_NEIGHBORS, neighbors);
  }
  explicit AzureSpatialAnchorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AzureSpatialAnchor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AzureSpatialAnchor>(end);
    fbb_.Required(o, AzureSpatialAnchor::VT_ASA_ID);
    fbb_.Required(o, AzureSpatialAnchor::VT_REP_ID);
    fbb_.Required(o, AzureSpatialAnchor::VT_NS);
    fbb_.Required(o, AzureSpatialAnchor::VT_ANCHOR_TYPE);
    fbb_.Required(o, AzureSpatialAnchor::VT_TIMESTAMP);
    fbb_.Required(o, AzureSpatialAnchor::VT_POSE);
    fbb_.Required(o, AzureSpatialAnchor::VT_GEOPOSE);
    fbb_.Required(o, AzureSpatialAnchor::VT_NEIGHBORS);
    return o;
  }
};

inline ::flatbuffers::Offset<AzureSpatialAnchor> CreateAzureSpatialAnchor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> asa_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> rep_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ns = 0,
    ::flatbuffers::Offset<::flatbuffers::String> anchor_type = 0,
    const fb::RosTime *timestamp = nullptr,
    ::flatbuffers::Offset<fb::geometry_msgs::PoseWithCovarianceStamped> pose = 0,
    ::flatbuffers::Offset<fb::geographic_msgs::GeoPoseWithCovarianceStamped> geopose = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> neighbors = 0) {
  AzureSpatialAnchorBuilder builder_(_fbb);
  builder_.add_neighbors(neighbors);
  builder_.add_geopose(geopose);
  builder_.add_pose(pose);
  builder_.add_timestamp(timestamp);
  builder_.add_anchor_type(anchor_type);
  builder_.add_ns(ns);
  builder_.add_rep_id(rep_id);
  builder_.add_asa_id(asa_id);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AzureSpatialAnchor> CreateAzureSpatialAnchorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *asa_id = nullptr,
    const char *rep_id = nullptr,
    const char *ns = nullptr,
    const char *anchor_type = nullptr,
    const fb::RosTime *timestamp = nullptr,
    ::flatbuffers::Offset<fb::geometry_msgs::PoseWithCovarianceStamped> pose = 0,
    ::flatbuffers::Offset<fb::geographic_msgs::GeoPoseWithCovarianceStamped> geopose = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *neighbors = nullptr) {
  auto asa_id__ = asa_id ? _fbb.CreateString(asa_id) : 0;
  auto rep_id__ = rep_id ? _fbb.CreateString(rep_id) : 0;
  auto ns__ = ns ? _fbb.CreateString(ns) : 0;
  auto anchor_type__ = anchor_type ? _fbb.CreateString(anchor_type) : 0;
  auto neighbors__ = neighbors ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*neighbors) : 0;
  return fb::asa_db_portal::CreateAzureSpatialAnchor(
      _fbb,
      __metadata,
      asa_id__,
      rep_id__,
      ns__,
      anchor_type__,
      timestamp,
      pose,
      geopose,
      neighbors__);
}

::flatbuffers::Offset<AzureSpatialAnchor> CreateAzureSpatialAnchor(::flatbuffers::FlatBufferBuilder &_fbb, const AzureSpatialAnchorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetAllAnchorsRequestT : public ::flatbuffers::NativeTable {
  typedef GetAllAnchorsRequest TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string ns{};
  GetAllAnchorsRequestT() = default;
  GetAllAnchorsRequestT(const GetAllAnchorsRequestT &o);
  GetAllAnchorsRequestT(GetAllAnchorsRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  GetAllAnchorsRequestT &operator=(GetAllAnchorsRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct GetAllAnchorsRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetAllAnchorsRequestT NativeTableType;
  typedef GetAllAnchorsRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_NS = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *ns() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_NS) &&
           verifier.VerifyString(ns()) &&
           verifier.EndTable();
  }
  GetAllAnchorsRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetAllAnchorsRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GetAllAnchorsRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetAllAnchorsRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetAllAnchorsRequestBuilder {
  typedef GetAllAnchorsRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GetAllAnchorsRequest::VT___METADATA, __metadata);
  }
  void add_ns(::flatbuffers::Offset<::flatbuffers::String> ns) {
    fbb_.AddOffset(GetAllAnchorsRequest::VT_NS, ns);
  }
  explicit GetAllAnchorsRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetAllAnchorsRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetAllAnchorsRequest>(end);
    fbb_.Required(o, GetAllAnchorsRequest::VT_NS);
    return o;
  }
};

inline ::flatbuffers::Offset<GetAllAnchorsRequest> CreateGetAllAnchorsRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ns = 0) {
  GetAllAnchorsRequestBuilder builder_(_fbb);
  builder_.add_ns(ns);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GetAllAnchorsRequest> CreateGetAllAnchorsRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *ns = nullptr) {
  auto ns__ = ns ? _fbb.CreateString(ns) : 0;
  return fb::asa_db_portal::CreateGetAllAnchorsRequest(
      _fbb,
      __metadata,
      ns__);
}

::flatbuffers::Offset<GetAllAnchorsRequest> CreateGetAllAnchorsRequest(::flatbuffers::FlatBufferBuilder &_fbb, const GetAllAnchorsRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetAllAnchorsResponseT : public ::flatbuffers::NativeTable {
  typedef GetAllAnchorsResponse TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::vector<std::unique_ptr<fb::asa_db_portal::AzureSpatialAnchorT>> anchors{};
  GetAllAnchorsResponseT() = default;
  GetAllAnchorsResponseT(const GetAllAnchorsResponseT &o);
  GetAllAnchorsResponseT(GetAllAnchorsResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  GetAllAnchorsResponseT &operator=(GetAllAnchorsResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct GetAllAnchorsResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetAllAnchorsResponseT NativeTableType;
  typedef GetAllAnchorsResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_ANCHORS = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::asa_db_portal::AzureSpatialAnchor>> *anchors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::asa_db_portal::AzureSpatialAnchor>> *>(VT_ANCHORS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_ANCHORS) &&
           verifier.VerifyVector(anchors()) &&
           verifier.VerifyVectorOfTables(anchors()) &&
           verifier.EndTable();
  }
  GetAllAnchorsResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetAllAnchorsResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GetAllAnchorsResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetAllAnchorsResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetAllAnchorsResponseBuilder {
  typedef GetAllAnchorsResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GetAllAnchorsResponse::VT___METADATA, __metadata);
  }
  void add_anchors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::asa_db_portal::AzureSpatialAnchor>>> anchors) {
    fbb_.AddOffset(GetAllAnchorsResponse::VT_ANCHORS, anchors);
  }
  explicit GetAllAnchorsResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetAllAnchorsResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetAllAnchorsResponse>(end);
    fbb_.Required(o, GetAllAnchorsResponse::VT_ANCHORS);
    return o;
  }
};

inline ::flatbuffers::Offset<GetAllAnchorsResponse> CreateGetAllAnchorsResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::asa_db_portal::AzureSpatialAnchor>>> anchors = 0) {
  GetAllAnchorsResponseBuilder builder_(_fbb);
  builder_.add_anchors(anchors);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GetAllAnchorsResponse> CreateGetAllAnchorsResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const std::vector<::flatbuffers::Offset<fb::asa_db_portal::AzureSpatialAnchor>> *anchors = nullptr) {
  auto anchors__ = anchors ? _fbb.CreateVector<::flatbuffers::Offset<fb::asa_db_portal::AzureSpatialAnchor>>(*anchors) : 0;
  return fb::asa_db_portal::CreateGetAllAnchorsResponse(
      _fbb,
      __metadata,
      anchors__);
}

::flatbuffers::Offset<GetAllAnchorsResponse> CreateGetAllAnchorsResponse(::flatbuffers::FlatBufferBuilder &_fbb, const GetAllAnchorsResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetAnchorsByDistanceRequestT : public ::flatbuffers::NativeTable {
  typedef GetAnchorsByDistanceRequest TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::geometry_msgs::PointStampedT> reference_point{};
  float distance = 0.0f;
  std::string ns{};
  GetAnchorsByDistanceRequestT() = default;
  GetAnchorsByDistanceRequestT(const GetAnchorsByDistanceRequestT &o);
  GetAnchorsByDistanceRequestT(GetAnchorsByDistanceRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  GetAnchorsByDistanceRequestT &operator=(GetAnchorsByDistanceRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct GetAnchorsByDistanceRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetAnchorsByDistanceRequestT NativeTableType;
  typedef GetAnchorsByDistanceRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_REFERENCE_POINT = 6,
    VT_DISTANCE = 8,
    VT_NS = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::PointStamped *reference_point() const {
    return GetPointer<const fb::geometry_msgs::PointStamped *>(VT_REFERENCE_POINT);
  }
  float distance() const {
    return GetField<float>(VT_DISTANCE, 0.0f);
  }
  const ::flatbuffers::String *ns() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_REFERENCE_POINT) &&
           verifier.VerifyTable(reference_point()) &&
           VerifyField<float>(verifier, VT_DISTANCE, 4) &&
           VerifyOffsetRequired(verifier, VT_NS) &&
           verifier.VerifyString(ns()) &&
           verifier.EndTable();
  }
  GetAnchorsByDistanceRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetAnchorsByDistanceRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GetAnchorsByDistanceRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetAnchorsByDistanceRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetAnchorsByDistanceRequestBuilder {
  typedef GetAnchorsByDistanceRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GetAnchorsByDistanceRequest::VT___METADATA, __metadata);
  }
  void add_reference_point(::flatbuffers::Offset<fb::geometry_msgs::PointStamped> reference_point) {
    fbb_.AddOffset(GetAnchorsByDistanceRequest::VT_REFERENCE_POINT, reference_point);
  }
  void add_distance(float distance) {
    fbb_.AddElement<float>(GetAnchorsByDistanceRequest::VT_DISTANCE, distance, 0.0f);
  }
  void add_ns(::flatbuffers::Offset<::flatbuffers::String> ns) {
    fbb_.AddOffset(GetAnchorsByDistanceRequest::VT_NS, ns);
  }
  explicit GetAnchorsByDistanceRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetAnchorsByDistanceRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetAnchorsByDistanceRequest>(end);
    fbb_.Required(o, GetAnchorsByDistanceRequest::VT_REFERENCE_POINT);
    fbb_.Required(o, GetAnchorsByDistanceRequest::VT_NS);
    return o;
  }
};

inline ::flatbuffers::Offset<GetAnchorsByDistanceRequest> CreateGetAnchorsByDistanceRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::PointStamped> reference_point = 0,
    float distance = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> ns = 0) {
  GetAnchorsByDistanceRequestBuilder builder_(_fbb);
  builder_.add_ns(ns);
  builder_.add_distance(distance);
  builder_.add_reference_point(reference_point);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GetAnchorsByDistanceRequest> CreateGetAnchorsByDistanceRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::PointStamped> reference_point = 0,
    float distance = 0.0f,
    const char *ns = nullptr) {
  auto ns__ = ns ? _fbb.CreateString(ns) : 0;
  return fb::asa_db_portal::CreateGetAnchorsByDistanceRequest(
      _fbb,
      __metadata,
      reference_point,
      distance,
      ns__);
}

::flatbuffers::Offset<GetAnchorsByDistanceRequest> CreateGetAnchorsByDistanceRequest(::flatbuffers::FlatBufferBuilder &_fbb, const GetAnchorsByDistanceRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetAnchorsByDistanceResponseT : public ::flatbuffers::NativeTable {
  typedef GetAnchorsByDistanceResponse TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::vector<std::unique_ptr<fb::asa_db_portal::AzureSpatialAnchorT>> anchors{};
  GetAnchorsByDistanceResponseT() = default;
  GetAnchorsByDistanceResponseT(const GetAnchorsByDistanceResponseT &o);
  GetAnchorsByDistanceResponseT(GetAnchorsByDistanceResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  GetAnchorsByDistanceResponseT &operator=(GetAnchorsByDistanceResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct GetAnchorsByDistanceResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetAnchorsByDistanceResponseT NativeTableType;
  typedef GetAnchorsByDistanceResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_ANCHORS = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::asa_db_portal::AzureSpatialAnchor>> *anchors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::asa_db_portal::AzureSpatialAnchor>> *>(VT_ANCHORS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_ANCHORS) &&
           verifier.VerifyVector(anchors()) &&
           verifier.VerifyVectorOfTables(anchors()) &&
           verifier.EndTable();
  }
  GetAnchorsByDistanceResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetAnchorsByDistanceResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GetAnchorsByDistanceResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetAnchorsByDistanceResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetAnchorsByDistanceResponseBuilder {
  typedef GetAnchorsByDistanceResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GetAnchorsByDistanceResponse::VT___METADATA, __metadata);
  }
  void add_anchors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::asa_db_portal::AzureSpatialAnchor>>> anchors) {
    fbb_.AddOffset(GetAnchorsByDistanceResponse::VT_ANCHORS, anchors);
  }
  explicit GetAnchorsByDistanceResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetAnchorsByDistanceResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetAnchorsByDistanceResponse>(end);
    fbb_.Required(o, GetAnchorsByDistanceResponse::VT_ANCHORS);
    return o;
  }
};

inline ::flatbuffers::Offset<GetAnchorsByDistanceResponse> CreateGetAnchorsByDistanceResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::asa_db_portal::AzureSpatialAnchor>>> anchors = 0) {
  GetAnchorsByDistanceResponseBuilder builder_(_fbb);
  builder_.add_anchors(anchors);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GetAnchorsByDistanceResponse> CreateGetAnchorsByDistanceResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const std::vector<::flatbuffers::Offset<fb::asa_db_portal::AzureSpatialAnchor>> *anchors = nullptr) {
  auto anchors__ = anchors ? _fbb.CreateVector<::flatbuffers::Offset<fb::asa_db_portal::AzureSpatialAnchor>>(*anchors) : 0;
  return fb::asa_db_portal::CreateGetAnchorsByDistanceResponse(
      _fbb,
      __metadata,
      anchors__);
}

::flatbuffers::Offset<GetAnchorsByDistanceResponse> CreateGetAnchorsByDistanceResponse(::flatbuffers::FlatBufferBuilder &_fbb, const GetAnchorsByDistanceResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CreateOrUpdateAnchorRequestT : public ::flatbuffers::NativeTable {
  typedef CreateOrUpdateAnchorRequest TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::asa_db_portal::AzureSpatialAnchorT> entry{};
  CreateOrUpdateAnchorRequestT() = default;
  CreateOrUpdateAnchorRequestT(const CreateOrUpdateAnchorRequestT &o);
  CreateOrUpdateAnchorRequestT(CreateOrUpdateAnchorRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  CreateOrUpdateAnchorRequestT &operator=(CreateOrUpdateAnchorRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct CreateOrUpdateAnchorRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CreateOrUpdateAnchorRequestT NativeTableType;
  typedef CreateOrUpdateAnchorRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_ENTRY = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::asa_db_portal::AzureSpatialAnchor *entry() const {
    return GetPointer<const fb::asa_db_portal::AzureSpatialAnchor *>(VT_ENTRY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_ENTRY) &&
           verifier.VerifyTable(entry()) &&
           verifier.EndTable();
  }
  CreateOrUpdateAnchorRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CreateOrUpdateAnchorRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CreateOrUpdateAnchorRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CreateOrUpdateAnchorRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CreateOrUpdateAnchorRequestBuilder {
  typedef CreateOrUpdateAnchorRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(CreateOrUpdateAnchorRequest::VT___METADATA, __metadata);
  }
  void add_entry(::flatbuffers::Offset<fb::asa_db_portal::AzureSpatialAnchor> entry) {
    fbb_.AddOffset(CreateOrUpdateAnchorRequest::VT_ENTRY, entry);
  }
  explicit CreateOrUpdateAnchorRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CreateOrUpdateAnchorRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CreateOrUpdateAnchorRequest>(end);
    fbb_.Required(o, CreateOrUpdateAnchorRequest::VT_ENTRY);
    return o;
  }
};

inline ::flatbuffers::Offset<CreateOrUpdateAnchorRequest> CreateCreateOrUpdateAnchorRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::asa_db_portal::AzureSpatialAnchor> entry = 0) {
  CreateOrUpdateAnchorRequestBuilder builder_(_fbb);
  builder_.add_entry(entry);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<CreateOrUpdateAnchorRequest> CreateCreateOrUpdateAnchorRequest(::flatbuffers::FlatBufferBuilder &_fbb, const CreateOrUpdateAnchorRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CreateOrUpdateAnchorResponseT : public ::flatbuffers::NativeTable {
  typedef CreateOrUpdateAnchorResponse TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  bool success = false;
  CreateOrUpdateAnchorResponseT() = default;
  CreateOrUpdateAnchorResponseT(const CreateOrUpdateAnchorResponseT &o);
  CreateOrUpdateAnchorResponseT(CreateOrUpdateAnchorResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  CreateOrUpdateAnchorResponseT &operator=(CreateOrUpdateAnchorResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct CreateOrUpdateAnchorResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CreateOrUpdateAnchorResponseT NativeTableType;
  typedef CreateOrUpdateAnchorResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_SUCCESS = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           verifier.EndTable();
  }
  CreateOrUpdateAnchorResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CreateOrUpdateAnchorResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CreateOrUpdateAnchorResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CreateOrUpdateAnchorResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CreateOrUpdateAnchorResponseBuilder {
  typedef CreateOrUpdateAnchorResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(CreateOrUpdateAnchorResponse::VT___METADATA, __metadata);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(CreateOrUpdateAnchorResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit CreateOrUpdateAnchorResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CreateOrUpdateAnchorResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CreateOrUpdateAnchorResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CreateOrUpdateAnchorResponse> CreateCreateOrUpdateAnchorResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    bool success = false) {
  CreateOrUpdateAnchorResponseBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  builder_.add_success(success);
  return builder_.Finish();
}

::flatbuffers::Offset<CreateOrUpdateAnchorResponse> CreateCreateOrUpdateAnchorResponse(::flatbuffers::FlatBufferBuilder &_fbb, const CreateOrUpdateAnchorResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline GetAnchorByIDRequestT::GetAnchorByIDRequestT(const GetAnchorByIDRequestT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        id(o.id),
        ns(o.ns) {
}

inline GetAnchorByIDRequestT &GetAnchorByIDRequestT::operator=(GetAnchorByIDRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(id, o.id);
  std::swap(ns, o.ns);
  return *this;
}

inline GetAnchorByIDRequestT *GetAnchorByIDRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetAnchorByIDRequestT>(new GetAnchorByIDRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetAnchorByIDRequest::UnPackTo(GetAnchorByIDRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = ns(); if (_e) _o->ns = _e->str(); }
}

inline ::flatbuffers::Offset<GetAnchorByIDRequest> GetAnchorByIDRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetAnchorByIDRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetAnchorByIDRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GetAnchorByIDRequest> CreateGetAnchorByIDRequest(::flatbuffers::FlatBufferBuilder &_fbb, const GetAnchorByIDRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GetAnchorByIDRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _id = _fbb.CreateString(_o->id);
  auto _ns = _fbb.CreateString(_o->ns);
  return fb::asa_db_portal::CreateGetAnchorByIDRequest(
      _fbb,
      ___metadata,
      _id,
      _ns);
}

inline GetAnchorByIDResponseT::GetAnchorByIDResponseT(const GetAnchorByIDResponseT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        success(o.success),
        anchor((o.anchor) ? new fb::asa_db_portal::AzureSpatialAnchorT(*o.anchor) : nullptr) {
}

inline GetAnchorByIDResponseT &GetAnchorByIDResponseT::operator=(GetAnchorByIDResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(success, o.success);
  std::swap(anchor, o.anchor);
  return *this;
}

inline GetAnchorByIDResponseT *GetAnchorByIDResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetAnchorByIDResponseT>(new GetAnchorByIDResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetAnchorByIDResponse::UnPackTo(GetAnchorByIDResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = success(); _o->success = _e; }
  { auto _e = anchor(); if (_e) { if(_o->anchor) { _e->UnPackTo(_o->anchor.get(), _resolver); } else { _o->anchor = std::unique_ptr<fb::asa_db_portal::AzureSpatialAnchorT>(_e->UnPack(_resolver)); } } else if (_o->anchor) { _o->anchor.reset(); } }
}

inline ::flatbuffers::Offset<GetAnchorByIDResponse> GetAnchorByIDResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetAnchorByIDResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetAnchorByIDResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GetAnchorByIDResponse> CreateGetAnchorByIDResponse(::flatbuffers::FlatBufferBuilder &_fbb, const GetAnchorByIDResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GetAnchorByIDResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _success = _o->success;
  auto _anchor = _o->anchor ? CreateAzureSpatialAnchor(_fbb, _o->anchor.get(), _rehasher) : 0;
  return fb::asa_db_portal::CreateGetAnchorByIDResponse(
      _fbb,
      ___metadata,
      _success,
      _anchor);
}

inline DeleteAnchorRequestT::DeleteAnchorRequestT(const DeleteAnchorRequestT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        id(o.id),
        ns(o.ns) {
}

inline DeleteAnchorRequestT &DeleteAnchorRequestT::operator=(DeleteAnchorRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(id, o.id);
  std::swap(ns, o.ns);
  return *this;
}

inline DeleteAnchorRequestT *DeleteAnchorRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DeleteAnchorRequestT>(new DeleteAnchorRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DeleteAnchorRequest::UnPackTo(DeleteAnchorRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = ns(); if (_e) _o->ns = _e->str(); }
}

inline ::flatbuffers::Offset<DeleteAnchorRequest> DeleteAnchorRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DeleteAnchorRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDeleteAnchorRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DeleteAnchorRequest> CreateDeleteAnchorRequest(::flatbuffers::FlatBufferBuilder &_fbb, const DeleteAnchorRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DeleteAnchorRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _id = _fbb.CreateString(_o->id);
  auto _ns = _fbb.CreateString(_o->ns);
  return fb::asa_db_portal::CreateDeleteAnchorRequest(
      _fbb,
      ___metadata,
      _id,
      _ns);
}

inline DeleteAnchorResponseT::DeleteAnchorResponseT(const DeleteAnchorResponseT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        success(o.success) {
}

inline DeleteAnchorResponseT &DeleteAnchorResponseT::operator=(DeleteAnchorResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(success, o.success);
  return *this;
}

inline DeleteAnchorResponseT *DeleteAnchorResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DeleteAnchorResponseT>(new DeleteAnchorResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DeleteAnchorResponse::UnPackTo(DeleteAnchorResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = success(); _o->success = _e; }
}

inline ::flatbuffers::Offset<DeleteAnchorResponse> DeleteAnchorResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DeleteAnchorResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDeleteAnchorResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DeleteAnchorResponse> CreateDeleteAnchorResponse(::flatbuffers::FlatBufferBuilder &_fbb, const DeleteAnchorResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DeleteAnchorResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _success = _o->success;
  return fb::asa_db_portal::CreateDeleteAnchorResponse(
      _fbb,
      ___metadata,
      _success);
}

inline AzureSpatialAnchorT::AzureSpatialAnchorT(const AzureSpatialAnchorT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        asa_id(o.asa_id),
        rep_id(o.rep_id),
        ns(o.ns),
        anchor_type(o.anchor_type),
        timestamp((o.timestamp) ? new fb::RosTime(*o.timestamp) : nullptr),
        pose((o.pose) ? new fb::geometry_msgs::PoseWithCovarianceStampedT(*o.pose) : nullptr),
        geopose((o.geopose) ? new fb::geographic_msgs::GeoPoseWithCovarianceStampedT(*o.geopose) : nullptr),
        neighbors(o.neighbors) {
}

inline AzureSpatialAnchorT &AzureSpatialAnchorT::operator=(AzureSpatialAnchorT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(asa_id, o.asa_id);
  std::swap(rep_id, o.rep_id);
  std::swap(ns, o.ns);
  std::swap(anchor_type, o.anchor_type);
  std::swap(timestamp, o.timestamp);
  std::swap(pose, o.pose);
  std::swap(geopose, o.geopose);
  std::swap(neighbors, o.neighbors);
  return *this;
}

inline AzureSpatialAnchorT *AzureSpatialAnchor::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AzureSpatialAnchorT>(new AzureSpatialAnchorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AzureSpatialAnchor::UnPackTo(AzureSpatialAnchorT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = asa_id(); if (_e) _o->asa_id = _e->str(); }
  { auto _e = rep_id(); if (_e) _o->rep_id = _e->str(); }
  { auto _e = ns(); if (_e) _o->ns = _e->str(); }
  { auto _e = anchor_type(); if (_e) _o->anchor_type = _e->str(); }
  { auto _e = timestamp(); if (_e) _o->timestamp = std::unique_ptr<fb::RosTime>(new fb::RosTime(*_e)); }
  { auto _e = pose(); if (_e) { if(_o->pose) { _e->UnPackTo(_o->pose.get(), _resolver); } else { _o->pose = std::unique_ptr<fb::geometry_msgs::PoseWithCovarianceStampedT>(_e->UnPack(_resolver)); } } else if (_o->pose) { _o->pose.reset(); } }
  { auto _e = geopose(); if (_e) { if(_o->geopose) { _e->UnPackTo(_o->geopose.get(), _resolver); } else { _o->geopose = std::unique_ptr<fb::geographic_msgs::GeoPoseWithCovarianceStampedT>(_e->UnPack(_resolver)); } } else if (_o->geopose) { _o->geopose.reset(); } }
  { auto _e = neighbors(); if (_e) { _o->neighbors.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->neighbors[_i] = _e->Get(_i)->str(); } } else { _o->neighbors.resize(0); } }
}

inline ::flatbuffers::Offset<AzureSpatialAnchor> AzureSpatialAnchor::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AzureSpatialAnchorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAzureSpatialAnchor(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AzureSpatialAnchor> CreateAzureSpatialAnchor(::flatbuffers::FlatBufferBuilder &_fbb, const AzureSpatialAnchorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AzureSpatialAnchorT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _asa_id = _fbb.CreateString(_o->asa_id);
  auto _rep_id = _fbb.CreateString(_o->rep_id);
  auto _ns = _fbb.CreateString(_o->ns);
  auto _anchor_type = _fbb.CreateString(_o->anchor_type);
  auto _timestamp = _o->timestamp ? _o->timestamp.get() : nullptr;
  auto _pose = _o->pose ? CreatePoseWithCovarianceStamped(_fbb, _o->pose.get(), _rehasher) : 0;
  auto _geopose = _o->geopose ? CreateGeoPoseWithCovarianceStamped(_fbb, _o->geopose.get(), _rehasher) : 0;
  auto _neighbors = _fbb.CreateVectorOfStrings(_o->neighbors);
  return fb::asa_db_portal::CreateAzureSpatialAnchor(
      _fbb,
      ___metadata,
      _asa_id,
      _rep_id,
      _ns,
      _anchor_type,
      _timestamp,
      _pose,
      _geopose,
      _neighbors);
}

inline GetAllAnchorsRequestT::GetAllAnchorsRequestT(const GetAllAnchorsRequestT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        ns(o.ns) {
}

inline GetAllAnchorsRequestT &GetAllAnchorsRequestT::operator=(GetAllAnchorsRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(ns, o.ns);
  return *this;
}

inline GetAllAnchorsRequestT *GetAllAnchorsRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetAllAnchorsRequestT>(new GetAllAnchorsRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetAllAnchorsRequest::UnPackTo(GetAllAnchorsRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = ns(); if (_e) _o->ns = _e->str(); }
}

inline ::flatbuffers::Offset<GetAllAnchorsRequest> GetAllAnchorsRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetAllAnchorsRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetAllAnchorsRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GetAllAnchorsRequest> CreateGetAllAnchorsRequest(::flatbuffers::FlatBufferBuilder &_fbb, const GetAllAnchorsRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GetAllAnchorsRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _ns = _fbb.CreateString(_o->ns);
  return fb::asa_db_portal::CreateGetAllAnchorsRequest(
      _fbb,
      ___metadata,
      _ns);
}

inline GetAllAnchorsResponseT::GetAllAnchorsResponseT(const GetAllAnchorsResponseT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr) {
  anchors.reserve(o.anchors.size());
  for (const auto &anchors_ : o.anchors) { anchors.emplace_back((anchors_) ? new fb::asa_db_portal::AzureSpatialAnchorT(*anchors_) : nullptr); }
}

inline GetAllAnchorsResponseT &GetAllAnchorsResponseT::operator=(GetAllAnchorsResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(anchors, o.anchors);
  return *this;
}

inline GetAllAnchorsResponseT *GetAllAnchorsResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetAllAnchorsResponseT>(new GetAllAnchorsResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetAllAnchorsResponse::UnPackTo(GetAllAnchorsResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = anchors(); if (_e) { _o->anchors.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->anchors[_i]) { _e->Get(_i)->UnPackTo(_o->anchors[_i].get(), _resolver); } else { _o->anchors[_i] = std::unique_ptr<fb::asa_db_portal::AzureSpatialAnchorT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->anchors.resize(0); } }
}

inline ::flatbuffers::Offset<GetAllAnchorsResponse> GetAllAnchorsResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetAllAnchorsResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetAllAnchorsResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GetAllAnchorsResponse> CreateGetAllAnchorsResponse(::flatbuffers::FlatBufferBuilder &_fbb, const GetAllAnchorsResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GetAllAnchorsResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _anchors = _fbb.CreateVector<::flatbuffers::Offset<fb::asa_db_portal::AzureSpatialAnchor>> (_o->anchors.size(), [](size_t i, _VectorArgs *__va) { return CreateAzureSpatialAnchor(*__va->__fbb, __va->__o->anchors[i].get(), __va->__rehasher); }, &_va );
  return fb::asa_db_portal::CreateGetAllAnchorsResponse(
      _fbb,
      ___metadata,
      _anchors);
}

inline GetAnchorsByDistanceRequestT::GetAnchorsByDistanceRequestT(const GetAnchorsByDistanceRequestT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        reference_point((o.reference_point) ? new fb::geometry_msgs::PointStampedT(*o.reference_point) : nullptr),
        distance(o.distance),
        ns(o.ns) {
}

inline GetAnchorsByDistanceRequestT &GetAnchorsByDistanceRequestT::operator=(GetAnchorsByDistanceRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(reference_point, o.reference_point);
  std::swap(distance, o.distance);
  std::swap(ns, o.ns);
  return *this;
}

inline GetAnchorsByDistanceRequestT *GetAnchorsByDistanceRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetAnchorsByDistanceRequestT>(new GetAnchorsByDistanceRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetAnchorsByDistanceRequest::UnPackTo(GetAnchorsByDistanceRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = reference_point(); if (_e) { if(_o->reference_point) { _e->UnPackTo(_o->reference_point.get(), _resolver); } else { _o->reference_point = std::unique_ptr<fb::geometry_msgs::PointStampedT>(_e->UnPack(_resolver)); } } else if (_o->reference_point) { _o->reference_point.reset(); } }
  { auto _e = distance(); _o->distance = _e; }
  { auto _e = ns(); if (_e) _o->ns = _e->str(); }
}

inline ::flatbuffers::Offset<GetAnchorsByDistanceRequest> GetAnchorsByDistanceRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetAnchorsByDistanceRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetAnchorsByDistanceRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GetAnchorsByDistanceRequest> CreateGetAnchorsByDistanceRequest(::flatbuffers::FlatBufferBuilder &_fbb, const GetAnchorsByDistanceRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GetAnchorsByDistanceRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _reference_point = _o->reference_point ? CreatePointStamped(_fbb, _o->reference_point.get(), _rehasher) : 0;
  auto _distance = _o->distance;
  auto _ns = _fbb.CreateString(_o->ns);
  return fb::asa_db_portal::CreateGetAnchorsByDistanceRequest(
      _fbb,
      ___metadata,
      _reference_point,
      _distance,
      _ns);
}

inline GetAnchorsByDistanceResponseT::GetAnchorsByDistanceResponseT(const GetAnchorsByDistanceResponseT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr) {
  anchors.reserve(o.anchors.size());
  for (const auto &anchors_ : o.anchors) { anchors.emplace_back((anchors_) ? new fb::asa_db_portal::AzureSpatialAnchorT(*anchors_) : nullptr); }
}

inline GetAnchorsByDistanceResponseT &GetAnchorsByDistanceResponseT::operator=(GetAnchorsByDistanceResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(anchors, o.anchors);
  return *this;
}

inline GetAnchorsByDistanceResponseT *GetAnchorsByDistanceResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetAnchorsByDistanceResponseT>(new GetAnchorsByDistanceResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetAnchorsByDistanceResponse::UnPackTo(GetAnchorsByDistanceResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = anchors(); if (_e) { _o->anchors.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->anchors[_i]) { _e->Get(_i)->UnPackTo(_o->anchors[_i].get(), _resolver); } else { _o->anchors[_i] = std::unique_ptr<fb::asa_db_portal::AzureSpatialAnchorT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->anchors.resize(0); } }
}

inline ::flatbuffers::Offset<GetAnchorsByDistanceResponse> GetAnchorsByDistanceResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetAnchorsByDistanceResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetAnchorsByDistanceResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GetAnchorsByDistanceResponse> CreateGetAnchorsByDistanceResponse(::flatbuffers::FlatBufferBuilder &_fbb, const GetAnchorsByDistanceResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GetAnchorsByDistanceResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _anchors = _fbb.CreateVector<::flatbuffers::Offset<fb::asa_db_portal::AzureSpatialAnchor>> (_o->anchors.size(), [](size_t i, _VectorArgs *__va) { return CreateAzureSpatialAnchor(*__va->__fbb, __va->__o->anchors[i].get(), __va->__rehasher); }, &_va );
  return fb::asa_db_portal::CreateGetAnchorsByDistanceResponse(
      _fbb,
      ___metadata,
      _anchors);
}

inline CreateOrUpdateAnchorRequestT::CreateOrUpdateAnchorRequestT(const CreateOrUpdateAnchorRequestT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        entry((o.entry) ? new fb::asa_db_portal::AzureSpatialAnchorT(*o.entry) : nullptr) {
}

inline CreateOrUpdateAnchorRequestT &CreateOrUpdateAnchorRequestT::operator=(CreateOrUpdateAnchorRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(entry, o.entry);
  return *this;
}

inline CreateOrUpdateAnchorRequestT *CreateOrUpdateAnchorRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CreateOrUpdateAnchorRequestT>(new CreateOrUpdateAnchorRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CreateOrUpdateAnchorRequest::UnPackTo(CreateOrUpdateAnchorRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = entry(); if (_e) { if(_o->entry) { _e->UnPackTo(_o->entry.get(), _resolver); } else { _o->entry = std::unique_ptr<fb::asa_db_portal::AzureSpatialAnchorT>(_e->UnPack(_resolver)); } } else if (_o->entry) { _o->entry.reset(); } }
}

inline ::flatbuffers::Offset<CreateOrUpdateAnchorRequest> CreateOrUpdateAnchorRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CreateOrUpdateAnchorRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCreateOrUpdateAnchorRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CreateOrUpdateAnchorRequest> CreateCreateOrUpdateAnchorRequest(::flatbuffers::FlatBufferBuilder &_fbb, const CreateOrUpdateAnchorRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CreateOrUpdateAnchorRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _entry = _o->entry ? CreateAzureSpatialAnchor(_fbb, _o->entry.get(), _rehasher) : 0;
  return fb::asa_db_portal::CreateCreateOrUpdateAnchorRequest(
      _fbb,
      ___metadata,
      _entry);
}

inline CreateOrUpdateAnchorResponseT::CreateOrUpdateAnchorResponseT(const CreateOrUpdateAnchorResponseT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        success(o.success) {
}

inline CreateOrUpdateAnchorResponseT &CreateOrUpdateAnchorResponseT::operator=(CreateOrUpdateAnchorResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(success, o.success);
  return *this;
}

inline CreateOrUpdateAnchorResponseT *CreateOrUpdateAnchorResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CreateOrUpdateAnchorResponseT>(new CreateOrUpdateAnchorResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CreateOrUpdateAnchorResponse::UnPackTo(CreateOrUpdateAnchorResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = success(); _o->success = _e; }
}

inline ::flatbuffers::Offset<CreateOrUpdateAnchorResponse> CreateOrUpdateAnchorResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CreateOrUpdateAnchorResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCreateOrUpdateAnchorResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CreateOrUpdateAnchorResponse> CreateCreateOrUpdateAnchorResponse(::flatbuffers::FlatBufferBuilder &_fbb, const CreateOrUpdateAnchorResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CreateOrUpdateAnchorResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _success = _o->success;
  return fb::asa_db_portal::CreateCreateOrUpdateAnchorResponse(
      _fbb,
      ___metadata,
      _success);
}

}  // namespace asa_db_portal
}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_ASADBPORTAL_FB_ASA_DB_PORTAL_H_
