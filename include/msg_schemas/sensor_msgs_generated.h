// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SENSORMSGS_FB_SENSOR_MSGS_H_
#define FLATBUFFERS_GENERATED_SENSORMSGS_FB_SENSOR_MSGS_H_

#include "./flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 21,
             "Non-compatible flatbuffers version included");

#include "base_schema_generated.h"
#include "geometry_msgs_generated.h"
#include "std_msgs_generated.h"

namespace fb {
namespace sensor_msgs {

struct JointState;
struct JointStateBuilder;
struct JointStateT;

struct PointField;
struct PointFieldBuilder;
struct PointFieldT;

struct Joy;
struct JoyBuilder;
struct JoyT;

struct BatteryState;
struct BatteryStateBuilder;
struct BatteryStateT;

struct CameraInfo;
struct CameraInfoBuilder;
struct CameraInfoT;

struct TimeReference;
struct TimeReferenceBuilder;
struct TimeReferenceT;

struct LaserEcho;
struct LaserEchoBuilder;
struct LaserEchoT;

struct Illuminance;
struct IlluminanceBuilder;
struct IlluminanceT;

struct MultiDOFJointState;
struct MultiDOFJointStateBuilder;
struct MultiDOFJointStateT;

struct MagneticField;
struct MagneticFieldBuilder;
struct MagneticFieldT;

struct CompressedImage;
struct CompressedImageBuilder;
struct CompressedImageT;

struct NavSatStatus;
struct NavSatStatusBuilder;
struct NavSatStatusT;

struct PointCloud2;
struct PointCloud2Builder;
struct PointCloud2T;

struct FluidPressure;
struct FluidPressureBuilder;
struct FluidPressureT;

struct JoyFeedbackArray;
struct JoyFeedbackArrayBuilder;
struct JoyFeedbackArrayT;

struct MultiEchoLaserScan;
struct MultiEchoLaserScanBuilder;
struct MultiEchoLaserScanT;

struct PointCloud;
struct PointCloudBuilder;
struct PointCloudT;

struct Image;
struct ImageBuilder;
struct ImageT;

struct ChannelFloat32;
struct ChannelFloat32Builder;
struct ChannelFloat32T;

struct Temperature;
struct TemperatureBuilder;
struct TemperatureT;

struct RegionOfInterest;
struct RegionOfInterestBuilder;
struct RegionOfInterestT;

struct JoyFeedback;
struct JoyFeedbackBuilder;
struct JoyFeedbackT;

struct SetCameraInfoRequest;
struct SetCameraInfoRequestBuilder;
struct SetCameraInfoRequestT;

struct SetCameraInfoResponse;
struct SetCameraInfoResponseBuilder;
struct SetCameraInfoResponseT;

struct NavSatFix;
struct NavSatFixBuilder;
struct NavSatFixT;

struct Imu;
struct ImuBuilder;
struct ImuT;

struct LaserScan;
struct LaserScanBuilder;
struct LaserScanT;

struct RelativeHumidity;
struct RelativeHumidityBuilder;
struct RelativeHumidityT;

struct Range;
struct RangeBuilder;
struct RangeT;

struct JointStateT : public ::flatbuffers::NativeTable {
  typedef JointState TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::vector<std::string> name{};
  std::vector<double> position{};
  std::vector<double> velocity{};
  std::vector<double> effort{};
  JointStateT() = default;
  JointStateT(const JointStateT &o);
  JointStateT(JointStateT&&) FLATBUFFERS_NOEXCEPT = default;
  JointStateT &operator=(JointStateT o) FLATBUFFERS_NOEXCEPT;
};

struct JointState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JointStateT NativeTableType;
  typedef JointStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_NAME = 8,
    VT_POSITION = 10,
    VT_VELOCITY = 12,
    VT_EFFORT = 14
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *name() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_NAME);
  }
  const ::flatbuffers::Vector<double> *position() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_POSITION);
  }
  const ::flatbuffers::Vector<double> *velocity() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_VELOCITY);
  }
  const ::flatbuffers::Vector<double> *effort() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_EFFORT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyVector(name()) &&
           verifier.VerifyVectorOfStrings(name()) &&
           VerifyOffsetRequired(verifier, VT_POSITION) &&
           verifier.VerifyVector(position()) &&
           VerifyOffsetRequired(verifier, VT_VELOCITY) &&
           verifier.VerifyVector(velocity()) &&
           VerifyOffsetRequired(verifier, VT_EFFORT) &&
           verifier.VerifyVector(effort()) &&
           verifier.EndTable();
  }
  JointStateT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(JointStateT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<JointState> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const JointStateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct JointStateBuilder {
  typedef JointState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(JointState::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(JointState::VT_HEADER, header);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> name) {
    fbb_.AddOffset(JointState::VT_NAME, name);
  }
  void add_position(::flatbuffers::Offset<::flatbuffers::Vector<double>> position) {
    fbb_.AddOffset(JointState::VT_POSITION, position);
  }
  void add_velocity(::flatbuffers::Offset<::flatbuffers::Vector<double>> velocity) {
    fbb_.AddOffset(JointState::VT_VELOCITY, velocity);
  }
  void add_effort(::flatbuffers::Offset<::flatbuffers::Vector<double>> effort) {
    fbb_.AddOffset(JointState::VT_EFFORT, effort);
  }
  explicit JointStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JointState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JointState>(end);
    fbb_.Required(o, JointState::VT_HEADER);
    fbb_.Required(o, JointState::VT_NAME);
    fbb_.Required(o, JointState::VT_POSITION);
    fbb_.Required(o, JointState::VT_VELOCITY);
    fbb_.Required(o, JointState::VT_EFFORT);
    return o;
  }
};

inline ::flatbuffers::Offset<JointState> CreateJointState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> position = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> velocity = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> effort = 0) {
  JointStateBuilder builder_(_fbb);
  builder_.add_effort(effort);
  builder_.add_velocity(velocity);
  builder_.add_position(position);
  builder_.add_name(name);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<JointState> CreateJointStateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *name = nullptr,
    const std::vector<double> *position = nullptr,
    const std::vector<double> *velocity = nullptr,
    const std::vector<double> *effort = nullptr) {
  auto name__ = name ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*name) : 0;
  auto position__ = position ? _fbb.CreateVector<double>(*position) : 0;
  auto velocity__ = velocity ? _fbb.CreateVector<double>(*velocity) : 0;
  auto effort__ = effort ? _fbb.CreateVector<double>(*effort) : 0;
  return fb::sensor_msgs::CreateJointState(
      _fbb,
      __metadata,
      header,
      name__,
      position__,
      velocity__,
      effort__);
}

::flatbuffers::Offset<JointState> CreateJointState(::flatbuffers::FlatBufferBuilder &_fbb, const JointStateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PointFieldT : public ::flatbuffers::NativeTable {
  typedef PointField TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string name{};
  uint32_t offset = 0;
  uint8_t datatype = 0;
  uint32_t count = 0;
  PointFieldT() = default;
  PointFieldT(const PointFieldT &o);
  PointFieldT(PointFieldT&&) FLATBUFFERS_NOEXCEPT = default;
  PointFieldT &operator=(PointFieldT o) FLATBUFFERS_NOEXCEPT;
};

struct PointField FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PointFieldT NativeTableType;
  typedef PointFieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_NAME = 6,
    VT_OFFSET = 8,
    VT_DATATYPE = 10,
    VT_COUNT = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint32_t offset() const {
    return GetField<uint32_t>(VT_OFFSET, 0);
  }
  uint8_t datatype() const {
    return GetField<uint8_t>(VT_DATATYPE, 0);
  }
  uint32_t count() const {
    return GetField<uint32_t>(VT_COUNT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_OFFSET, 4) &&
           VerifyField<uint8_t>(verifier, VT_DATATYPE, 1) &&
           VerifyField<uint32_t>(verifier, VT_COUNT, 4) &&
           verifier.EndTable();
  }
  PointFieldT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PointFieldT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PointField> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PointFieldT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PointFieldBuilder {
  typedef PointField Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PointField::VT___METADATA, __metadata);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(PointField::VT_NAME, name);
  }
  void add_offset(uint32_t offset) {
    fbb_.AddElement<uint32_t>(PointField::VT_OFFSET, offset, 0);
  }
  void add_datatype(uint8_t datatype) {
    fbb_.AddElement<uint8_t>(PointField::VT_DATATYPE, datatype, 0);
  }
  void add_count(uint32_t count) {
    fbb_.AddElement<uint32_t>(PointField::VT_COUNT, count, 0);
  }
  explicit PointFieldBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PointField> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PointField>(end);
    fbb_.Required(o, PointField::VT_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<PointField> CreatePointField(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint32_t offset = 0,
    uint8_t datatype = 0,
    uint32_t count = 0) {
  PointFieldBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_offset(offset);
  builder_.add_name(name);
  builder_.add___metadata(__metadata);
  builder_.add_datatype(datatype);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PointField> CreatePointFieldDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *name = nullptr,
    uint32_t offset = 0,
    uint8_t datatype = 0,
    uint32_t count = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return fb::sensor_msgs::CreatePointField(
      _fbb,
      __metadata,
      name__,
      offset,
      datatype,
      count);
}

::flatbuffers::Offset<PointField> CreatePointField(::flatbuffers::FlatBufferBuilder &_fbb, const PointFieldT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct JoyT : public ::flatbuffers::NativeTable {
  typedef Joy TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::vector<float> axes{};
  std::vector<int32_t> buttons{};
  JoyT() = default;
  JoyT(const JoyT &o);
  JoyT(JoyT&&) FLATBUFFERS_NOEXCEPT = default;
  JoyT &operator=(JoyT o) FLATBUFFERS_NOEXCEPT;
};

struct Joy FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JoyT NativeTableType;
  typedef JoyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_AXES = 8,
    VT_BUTTONS = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const ::flatbuffers::Vector<float> *axes() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_AXES);
  }
  const ::flatbuffers::Vector<int32_t> *buttons() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_BUTTONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_AXES) &&
           verifier.VerifyVector(axes()) &&
           VerifyOffsetRequired(verifier, VT_BUTTONS) &&
           verifier.VerifyVector(buttons()) &&
           verifier.EndTable();
  }
  JoyT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(JoyT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Joy> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const JoyT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct JoyBuilder {
  typedef Joy Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Joy::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(Joy::VT_HEADER, header);
  }
  void add_axes(::flatbuffers::Offset<::flatbuffers::Vector<float>> axes) {
    fbb_.AddOffset(Joy::VT_AXES, axes);
  }
  void add_buttons(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> buttons) {
    fbb_.AddOffset(Joy::VT_BUTTONS, buttons);
  }
  explicit JoyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Joy> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Joy>(end);
    fbb_.Required(o, Joy::VT_HEADER);
    fbb_.Required(o, Joy::VT_AXES);
    fbb_.Required(o, Joy::VT_BUTTONS);
    return o;
  }
};

inline ::flatbuffers::Offset<Joy> CreateJoy(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> axes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> buttons = 0) {
  JoyBuilder builder_(_fbb);
  builder_.add_buttons(buttons);
  builder_.add_axes(axes);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Joy> CreateJoyDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const std::vector<float> *axes = nullptr,
    const std::vector<int32_t> *buttons = nullptr) {
  auto axes__ = axes ? _fbb.CreateVector<float>(*axes) : 0;
  auto buttons__ = buttons ? _fbb.CreateVector<int32_t>(*buttons) : 0;
  return fb::sensor_msgs::CreateJoy(
      _fbb,
      __metadata,
      header,
      axes__,
      buttons__);
}

::flatbuffers::Offset<Joy> CreateJoy(::flatbuffers::FlatBufferBuilder &_fbb, const JoyT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatteryStateT : public ::flatbuffers::NativeTable {
  typedef BatteryState TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  float voltage = 0.0f;
  float temperature = 0.0f;
  float current = 0.0f;
  float charge = 0.0f;
  float capacity = 0.0f;
  float design_capacity = 0.0f;
  float percentage = 0.0f;
  uint8_t power_supply_status = 0;
  uint8_t power_supply_health = 0;
  uint8_t power_supply_technology = 0;
  bool present = false;
  std::vector<float> cell_voltage{};
  std::vector<float> cell_temperature{};
  std::string location{};
  std::string serial_number{};
  BatteryStateT() = default;
  BatteryStateT(const BatteryStateT &o);
  BatteryStateT(BatteryStateT&&) FLATBUFFERS_NOEXCEPT = default;
  BatteryStateT &operator=(BatteryStateT o) FLATBUFFERS_NOEXCEPT;
};

struct BatteryState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BatteryStateT NativeTableType;
  typedef BatteryStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_VOLTAGE = 8,
    VT_TEMPERATURE = 10,
    VT_CURRENT = 12,
    VT_CHARGE = 14,
    VT_CAPACITY = 16,
    VT_DESIGN_CAPACITY = 18,
    VT_PERCENTAGE = 20,
    VT_POWER_SUPPLY_STATUS = 22,
    VT_POWER_SUPPLY_HEALTH = 24,
    VT_POWER_SUPPLY_TECHNOLOGY = 26,
    VT_PRESENT = 28,
    VT_CELL_VOLTAGE = 30,
    VT_CELL_TEMPERATURE = 32,
    VT_LOCATION = 34,
    VT_SERIAL_NUMBER = 36
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  float voltage() const {
    return GetField<float>(VT_VOLTAGE, 0.0f);
  }
  float temperature() const {
    return GetField<float>(VT_TEMPERATURE, 0.0f);
  }
  float current() const {
    return GetField<float>(VT_CURRENT, 0.0f);
  }
  float charge() const {
    return GetField<float>(VT_CHARGE, 0.0f);
  }
  float capacity() const {
    return GetField<float>(VT_CAPACITY, 0.0f);
  }
  float design_capacity() const {
    return GetField<float>(VT_DESIGN_CAPACITY, 0.0f);
  }
  float percentage() const {
    return GetField<float>(VT_PERCENTAGE, 0.0f);
  }
  uint8_t power_supply_status() const {
    return GetField<uint8_t>(VT_POWER_SUPPLY_STATUS, 0);
  }
  uint8_t power_supply_health() const {
    return GetField<uint8_t>(VT_POWER_SUPPLY_HEALTH, 0);
  }
  uint8_t power_supply_technology() const {
    return GetField<uint8_t>(VT_POWER_SUPPLY_TECHNOLOGY, 0);
  }
  bool present() const {
    return GetField<uint8_t>(VT_PRESENT, 0) != 0;
  }
  const ::flatbuffers::Vector<float> *cell_voltage() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_CELL_VOLTAGE);
  }
  const ::flatbuffers::Vector<float> *cell_temperature() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_CELL_TEMPERATURE);
  }
  const ::flatbuffers::String *location() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LOCATION);
  }
  const ::flatbuffers::String *serial_number() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SERIAL_NUMBER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<float>(verifier, VT_VOLTAGE, 4) &&
           VerifyField<float>(verifier, VT_TEMPERATURE, 4) &&
           VerifyField<float>(verifier, VT_CURRENT, 4) &&
           VerifyField<float>(verifier, VT_CHARGE, 4) &&
           VerifyField<float>(verifier, VT_CAPACITY, 4) &&
           VerifyField<float>(verifier, VT_DESIGN_CAPACITY, 4) &&
           VerifyField<float>(verifier, VT_PERCENTAGE, 4) &&
           VerifyField<uint8_t>(verifier, VT_POWER_SUPPLY_STATUS, 1) &&
           VerifyField<uint8_t>(verifier, VT_POWER_SUPPLY_HEALTH, 1) &&
           VerifyField<uint8_t>(verifier, VT_POWER_SUPPLY_TECHNOLOGY, 1) &&
           VerifyField<uint8_t>(verifier, VT_PRESENT, 1) &&
           VerifyOffsetRequired(verifier, VT_CELL_VOLTAGE) &&
           verifier.VerifyVector(cell_voltage()) &&
           VerifyOffsetRequired(verifier, VT_CELL_TEMPERATURE) &&
           verifier.VerifyVector(cell_temperature()) &&
           VerifyOffsetRequired(verifier, VT_LOCATION) &&
           verifier.VerifyString(location()) &&
           VerifyOffsetRequired(verifier, VT_SERIAL_NUMBER) &&
           verifier.VerifyString(serial_number()) &&
           verifier.EndTable();
  }
  BatteryStateT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatteryStateT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BatteryState> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BatteryStateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatteryStateBuilder {
  typedef BatteryState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(BatteryState::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(BatteryState::VT_HEADER, header);
  }
  void add_voltage(float voltage) {
    fbb_.AddElement<float>(BatteryState::VT_VOLTAGE, voltage, 0.0f);
  }
  void add_temperature(float temperature) {
    fbb_.AddElement<float>(BatteryState::VT_TEMPERATURE, temperature, 0.0f);
  }
  void add_current(float current) {
    fbb_.AddElement<float>(BatteryState::VT_CURRENT, current, 0.0f);
  }
  void add_charge(float charge) {
    fbb_.AddElement<float>(BatteryState::VT_CHARGE, charge, 0.0f);
  }
  void add_capacity(float capacity) {
    fbb_.AddElement<float>(BatteryState::VT_CAPACITY, capacity, 0.0f);
  }
  void add_design_capacity(float design_capacity) {
    fbb_.AddElement<float>(BatteryState::VT_DESIGN_CAPACITY, design_capacity, 0.0f);
  }
  void add_percentage(float percentage) {
    fbb_.AddElement<float>(BatteryState::VT_PERCENTAGE, percentage, 0.0f);
  }
  void add_power_supply_status(uint8_t power_supply_status) {
    fbb_.AddElement<uint8_t>(BatteryState::VT_POWER_SUPPLY_STATUS, power_supply_status, 0);
  }
  void add_power_supply_health(uint8_t power_supply_health) {
    fbb_.AddElement<uint8_t>(BatteryState::VT_POWER_SUPPLY_HEALTH, power_supply_health, 0);
  }
  void add_power_supply_technology(uint8_t power_supply_technology) {
    fbb_.AddElement<uint8_t>(BatteryState::VT_POWER_SUPPLY_TECHNOLOGY, power_supply_technology, 0);
  }
  void add_present(bool present) {
    fbb_.AddElement<uint8_t>(BatteryState::VT_PRESENT, static_cast<uint8_t>(present), 0);
  }
  void add_cell_voltage(::flatbuffers::Offset<::flatbuffers::Vector<float>> cell_voltage) {
    fbb_.AddOffset(BatteryState::VT_CELL_VOLTAGE, cell_voltage);
  }
  void add_cell_temperature(::flatbuffers::Offset<::flatbuffers::Vector<float>> cell_temperature) {
    fbb_.AddOffset(BatteryState::VT_CELL_TEMPERATURE, cell_temperature);
  }
  void add_location(::flatbuffers::Offset<::flatbuffers::String> location) {
    fbb_.AddOffset(BatteryState::VT_LOCATION, location);
  }
  void add_serial_number(::flatbuffers::Offset<::flatbuffers::String> serial_number) {
    fbb_.AddOffset(BatteryState::VT_SERIAL_NUMBER, serial_number);
  }
  explicit BatteryStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BatteryState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BatteryState>(end);
    fbb_.Required(o, BatteryState::VT_HEADER);
    fbb_.Required(o, BatteryState::VT_CELL_VOLTAGE);
    fbb_.Required(o, BatteryState::VT_CELL_TEMPERATURE);
    fbb_.Required(o, BatteryState::VT_LOCATION);
    fbb_.Required(o, BatteryState::VT_SERIAL_NUMBER);
    return o;
  }
};

inline ::flatbuffers::Offset<BatteryState> CreateBatteryState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    float voltage = 0.0f,
    float temperature = 0.0f,
    float current = 0.0f,
    float charge = 0.0f,
    float capacity = 0.0f,
    float design_capacity = 0.0f,
    float percentage = 0.0f,
    uint8_t power_supply_status = 0,
    uint8_t power_supply_health = 0,
    uint8_t power_supply_technology = 0,
    bool present = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> cell_voltage = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> cell_temperature = 0,
    ::flatbuffers::Offset<::flatbuffers::String> location = 0,
    ::flatbuffers::Offset<::flatbuffers::String> serial_number = 0) {
  BatteryStateBuilder builder_(_fbb);
  builder_.add_serial_number(serial_number);
  builder_.add_location(location);
  builder_.add_cell_temperature(cell_temperature);
  builder_.add_cell_voltage(cell_voltage);
  builder_.add_percentage(percentage);
  builder_.add_design_capacity(design_capacity);
  builder_.add_capacity(capacity);
  builder_.add_charge(charge);
  builder_.add_current(current);
  builder_.add_temperature(temperature);
  builder_.add_voltage(voltage);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  builder_.add_present(present);
  builder_.add_power_supply_technology(power_supply_technology);
  builder_.add_power_supply_health(power_supply_health);
  builder_.add_power_supply_status(power_supply_status);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BatteryState> CreateBatteryStateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    float voltage = 0.0f,
    float temperature = 0.0f,
    float current = 0.0f,
    float charge = 0.0f,
    float capacity = 0.0f,
    float design_capacity = 0.0f,
    float percentage = 0.0f,
    uint8_t power_supply_status = 0,
    uint8_t power_supply_health = 0,
    uint8_t power_supply_technology = 0,
    bool present = false,
    const std::vector<float> *cell_voltage = nullptr,
    const std::vector<float> *cell_temperature = nullptr,
    const char *location = nullptr,
    const char *serial_number = nullptr) {
  auto cell_voltage__ = cell_voltage ? _fbb.CreateVector<float>(*cell_voltage) : 0;
  auto cell_temperature__ = cell_temperature ? _fbb.CreateVector<float>(*cell_temperature) : 0;
  auto location__ = location ? _fbb.CreateString(location) : 0;
  auto serial_number__ = serial_number ? _fbb.CreateString(serial_number) : 0;
  return fb::sensor_msgs::CreateBatteryState(
      _fbb,
      __metadata,
      header,
      voltage,
      temperature,
      current,
      charge,
      capacity,
      design_capacity,
      percentage,
      power_supply_status,
      power_supply_health,
      power_supply_technology,
      present,
      cell_voltage__,
      cell_temperature__,
      location__,
      serial_number__);
}

::flatbuffers::Offset<BatteryState> CreateBatteryState(::flatbuffers::FlatBufferBuilder &_fbb, const BatteryStateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CameraInfoT : public ::flatbuffers::NativeTable {
  typedef CameraInfo TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  uint32_t height = 0;
  uint32_t width = 0;
  std::string distortion_model{};
  std::vector<double> d{};
  std::vector<double> k{};
  std::vector<double> r{};
  std::vector<double> p{};
  uint32_t binning_x = 0;
  uint32_t binning_y = 0;
  std::unique_ptr<fb::sensor_msgs::RegionOfInterestT> roi{};
  CameraInfoT() = default;
  CameraInfoT(const CameraInfoT &o);
  CameraInfoT(CameraInfoT&&) FLATBUFFERS_NOEXCEPT = default;
  CameraInfoT &operator=(CameraInfoT o) FLATBUFFERS_NOEXCEPT;
};

struct CameraInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CameraInfoT NativeTableType;
  typedef CameraInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_HEIGHT = 8,
    VT_WIDTH = 10,
    VT_DISTORTION_MODEL = 12,
    VT_D = 14,
    VT_K = 16,
    VT_R = 18,
    VT_P = 20,
    VT_BINNING_X = 22,
    VT_BINNING_Y = 24,
    VT_ROI = 26
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  uint32_t width() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  const ::flatbuffers::String *distortion_model() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DISTORTION_MODEL);
  }
  const ::flatbuffers::Vector<double> *d() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_D);
  }
  const ::flatbuffers::Vector<double> *k() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_K);
  }
  const ::flatbuffers::Vector<double> *r() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_R);
  }
  const ::flatbuffers::Vector<double> *p() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_P);
  }
  uint32_t binning_x() const {
    return GetField<uint32_t>(VT_BINNING_X, 0);
  }
  uint32_t binning_y() const {
    return GetField<uint32_t>(VT_BINNING_Y, 0);
  }
  const fb::sensor_msgs::RegionOfInterest *roi() const {
    return GetPointer<const fb::sensor_msgs::RegionOfInterest *>(VT_ROI);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT, 4) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH, 4) &&
           VerifyOffsetRequired(verifier, VT_DISTORTION_MODEL) &&
           verifier.VerifyString(distortion_model()) &&
           VerifyOffsetRequired(verifier, VT_D) &&
           verifier.VerifyVector(d()) &&
           VerifyOffsetRequired(verifier, VT_K) &&
           verifier.VerifyVector(k()) &&
           VerifyOffsetRequired(verifier, VT_R) &&
           verifier.VerifyVector(r()) &&
           VerifyOffsetRequired(verifier, VT_P) &&
           verifier.VerifyVector(p()) &&
           VerifyField<uint32_t>(verifier, VT_BINNING_X, 4) &&
           VerifyField<uint32_t>(verifier, VT_BINNING_Y, 4) &&
           VerifyOffsetRequired(verifier, VT_ROI) &&
           verifier.VerifyTable(roi()) &&
           verifier.EndTable();
  }
  CameraInfoT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CameraInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CameraInfo> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CameraInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CameraInfoBuilder {
  typedef CameraInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(CameraInfo::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(CameraInfo::VT_HEADER, header);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(CameraInfo::VT_HEIGHT, height, 0);
  }
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(CameraInfo::VT_WIDTH, width, 0);
  }
  void add_distortion_model(::flatbuffers::Offset<::flatbuffers::String> distortion_model) {
    fbb_.AddOffset(CameraInfo::VT_DISTORTION_MODEL, distortion_model);
  }
  void add_d(::flatbuffers::Offset<::flatbuffers::Vector<double>> d) {
    fbb_.AddOffset(CameraInfo::VT_D, d);
  }
  void add_k(::flatbuffers::Offset<::flatbuffers::Vector<double>> k) {
    fbb_.AddOffset(CameraInfo::VT_K, k);
  }
  void add_r(::flatbuffers::Offset<::flatbuffers::Vector<double>> r) {
    fbb_.AddOffset(CameraInfo::VT_R, r);
  }
  void add_p(::flatbuffers::Offset<::flatbuffers::Vector<double>> p) {
    fbb_.AddOffset(CameraInfo::VT_P, p);
  }
  void add_binning_x(uint32_t binning_x) {
    fbb_.AddElement<uint32_t>(CameraInfo::VT_BINNING_X, binning_x, 0);
  }
  void add_binning_y(uint32_t binning_y) {
    fbb_.AddElement<uint32_t>(CameraInfo::VT_BINNING_Y, binning_y, 0);
  }
  void add_roi(::flatbuffers::Offset<fb::sensor_msgs::RegionOfInterest> roi) {
    fbb_.AddOffset(CameraInfo::VT_ROI, roi);
  }
  explicit CameraInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CameraInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CameraInfo>(end);
    fbb_.Required(o, CameraInfo::VT_HEADER);
    fbb_.Required(o, CameraInfo::VT_DISTORTION_MODEL);
    fbb_.Required(o, CameraInfo::VT_D);
    fbb_.Required(o, CameraInfo::VT_K);
    fbb_.Required(o, CameraInfo::VT_R);
    fbb_.Required(o, CameraInfo::VT_P);
    fbb_.Required(o, CameraInfo::VT_ROI);
    return o;
  }
};

inline ::flatbuffers::Offset<CameraInfo> CreateCameraInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    uint32_t height = 0,
    uint32_t width = 0,
    ::flatbuffers::Offset<::flatbuffers::String> distortion_model = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> d = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> k = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> r = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> p = 0,
    uint32_t binning_x = 0,
    uint32_t binning_y = 0,
    ::flatbuffers::Offset<fb::sensor_msgs::RegionOfInterest> roi = 0) {
  CameraInfoBuilder builder_(_fbb);
  builder_.add_roi(roi);
  builder_.add_binning_y(binning_y);
  builder_.add_binning_x(binning_x);
  builder_.add_p(p);
  builder_.add_r(r);
  builder_.add_k(k);
  builder_.add_d(d);
  builder_.add_distortion_model(distortion_model);
  builder_.add_width(width);
  builder_.add_height(height);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CameraInfo> CreateCameraInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    uint32_t height = 0,
    uint32_t width = 0,
    const char *distortion_model = nullptr,
    const std::vector<double> *d = nullptr,
    const std::vector<double> *k = nullptr,
    const std::vector<double> *r = nullptr,
    const std::vector<double> *p = nullptr,
    uint32_t binning_x = 0,
    uint32_t binning_y = 0,
    ::flatbuffers::Offset<fb::sensor_msgs::RegionOfInterest> roi = 0) {
  auto distortion_model__ = distortion_model ? _fbb.CreateString(distortion_model) : 0;
  auto d__ = d ? _fbb.CreateVector<double>(*d) : 0;
  auto k__ = k ? _fbb.CreateVector<double>(*k) : 0;
  auto r__ = r ? _fbb.CreateVector<double>(*r) : 0;
  auto p__ = p ? _fbb.CreateVector<double>(*p) : 0;
  return fb::sensor_msgs::CreateCameraInfo(
      _fbb,
      __metadata,
      header,
      height,
      width,
      distortion_model__,
      d__,
      k__,
      r__,
      p__,
      binning_x,
      binning_y,
      roi);
}

::flatbuffers::Offset<CameraInfo> CreateCameraInfo(::flatbuffers::FlatBufferBuilder &_fbb, const CameraInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TimeReferenceT : public ::flatbuffers::NativeTable {
  typedef TimeReference TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::RosTime> time_ref{};
  std::string source{};
  TimeReferenceT() = default;
  TimeReferenceT(const TimeReferenceT &o);
  TimeReferenceT(TimeReferenceT&&) FLATBUFFERS_NOEXCEPT = default;
  TimeReferenceT &operator=(TimeReferenceT o) FLATBUFFERS_NOEXCEPT;
};

struct TimeReference FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TimeReferenceT NativeTableType;
  typedef TimeReferenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_TIME_REF = 8,
    VT_SOURCE = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::RosTime *time_ref() const {
    return GetStruct<const fb::RosTime *>(VT_TIME_REF);
  }
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyFieldRequired<fb::RosTime>(verifier, VT_TIME_REF, 4) &&
           VerifyOffsetRequired(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           verifier.EndTable();
  }
  TimeReferenceT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TimeReferenceT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TimeReference> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TimeReferenceT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TimeReferenceBuilder {
  typedef TimeReference Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(TimeReference::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(TimeReference::VT_HEADER, header);
  }
  void add_time_ref(const fb::RosTime *time_ref) {
    fbb_.AddStruct(TimeReference::VT_TIME_REF, time_ref);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(TimeReference::VT_SOURCE, source);
  }
  explicit TimeReferenceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TimeReference> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TimeReference>(end);
    fbb_.Required(o, TimeReference::VT_HEADER);
    fbb_.Required(o, TimeReference::VT_TIME_REF);
    fbb_.Required(o, TimeReference::VT_SOURCE);
    return o;
  }
};

inline ::flatbuffers::Offset<TimeReference> CreateTimeReference(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const fb::RosTime *time_ref = nullptr,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0) {
  TimeReferenceBuilder builder_(_fbb);
  builder_.add_source(source);
  builder_.add_time_ref(time_ref);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TimeReference> CreateTimeReferenceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const fb::RosTime *time_ref = nullptr,
    const char *source = nullptr) {
  auto source__ = source ? _fbb.CreateString(source) : 0;
  return fb::sensor_msgs::CreateTimeReference(
      _fbb,
      __metadata,
      header,
      time_ref,
      source__);
}

::flatbuffers::Offset<TimeReference> CreateTimeReference(::flatbuffers::FlatBufferBuilder &_fbb, const TimeReferenceT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LaserEchoT : public ::flatbuffers::NativeTable {
  typedef LaserEcho TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::vector<float> echoes{};
  LaserEchoT() = default;
  LaserEchoT(const LaserEchoT &o);
  LaserEchoT(LaserEchoT&&) FLATBUFFERS_NOEXCEPT = default;
  LaserEchoT &operator=(LaserEchoT o) FLATBUFFERS_NOEXCEPT;
};

struct LaserEcho FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LaserEchoT NativeTableType;
  typedef LaserEchoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_ECHOES = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::Vector<float> *echoes() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_ECHOES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_ECHOES) &&
           verifier.VerifyVector(echoes()) &&
           verifier.EndTable();
  }
  LaserEchoT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LaserEchoT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<LaserEcho> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LaserEchoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LaserEchoBuilder {
  typedef LaserEcho Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(LaserEcho::VT___METADATA, __metadata);
  }
  void add_echoes(::flatbuffers::Offset<::flatbuffers::Vector<float>> echoes) {
    fbb_.AddOffset(LaserEcho::VT_ECHOES, echoes);
  }
  explicit LaserEchoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LaserEcho> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LaserEcho>(end);
    fbb_.Required(o, LaserEcho::VT_ECHOES);
    return o;
  }
};

inline ::flatbuffers::Offset<LaserEcho> CreateLaserEcho(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> echoes = 0) {
  LaserEchoBuilder builder_(_fbb);
  builder_.add_echoes(echoes);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LaserEcho> CreateLaserEchoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const std::vector<float> *echoes = nullptr) {
  auto echoes__ = echoes ? _fbb.CreateVector<float>(*echoes) : 0;
  return fb::sensor_msgs::CreateLaserEcho(
      _fbb,
      __metadata,
      echoes__);
}

::flatbuffers::Offset<LaserEcho> CreateLaserEcho(::flatbuffers::FlatBufferBuilder &_fbb, const LaserEchoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IlluminanceT : public ::flatbuffers::NativeTable {
  typedef Illuminance TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  double illuminance = 0.0;
  double variance = 0.0;
  IlluminanceT() = default;
  IlluminanceT(const IlluminanceT &o);
  IlluminanceT(IlluminanceT&&) FLATBUFFERS_NOEXCEPT = default;
  IlluminanceT &operator=(IlluminanceT o) FLATBUFFERS_NOEXCEPT;
};

struct Illuminance FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IlluminanceT NativeTableType;
  typedef IlluminanceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_ILLUMINANCE = 8,
    VT_VARIANCE = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  double illuminance() const {
    return GetField<double>(VT_ILLUMINANCE, 0.0);
  }
  double variance() const {
    return GetField<double>(VT_VARIANCE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<double>(verifier, VT_ILLUMINANCE, 8) &&
           VerifyField<double>(verifier, VT_VARIANCE, 8) &&
           verifier.EndTable();
  }
  IlluminanceT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IlluminanceT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Illuminance> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const IlluminanceT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IlluminanceBuilder {
  typedef Illuminance Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Illuminance::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(Illuminance::VT_HEADER, header);
  }
  void add_illuminance(double illuminance) {
    fbb_.AddElement<double>(Illuminance::VT_ILLUMINANCE, illuminance, 0.0);
  }
  void add_variance(double variance) {
    fbb_.AddElement<double>(Illuminance::VT_VARIANCE, variance, 0.0);
  }
  explicit IlluminanceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Illuminance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Illuminance>(end);
    fbb_.Required(o, Illuminance::VT_HEADER);
    return o;
  }
};

inline ::flatbuffers::Offset<Illuminance> CreateIlluminance(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    double illuminance = 0.0,
    double variance = 0.0) {
  IlluminanceBuilder builder_(_fbb);
  builder_.add_variance(variance);
  builder_.add_illuminance(illuminance);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<Illuminance> CreateIlluminance(::flatbuffers::FlatBufferBuilder &_fbb, const IlluminanceT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MultiDOFJointStateT : public ::flatbuffers::NativeTable {
  typedef MultiDOFJointState TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::vector<std::string> joint_names{};
  std::vector<std::unique_ptr<fb::geometry_msgs::TransformT>> transforms{};
  std::vector<std::unique_ptr<fb::geometry_msgs::TwistT>> twist{};
  std::vector<std::unique_ptr<fb::geometry_msgs::WrenchT>> wrench{};
  MultiDOFJointStateT() = default;
  MultiDOFJointStateT(const MultiDOFJointStateT &o);
  MultiDOFJointStateT(MultiDOFJointStateT&&) FLATBUFFERS_NOEXCEPT = default;
  MultiDOFJointStateT &operator=(MultiDOFJointStateT o) FLATBUFFERS_NOEXCEPT;
};

struct MultiDOFJointState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MultiDOFJointStateT NativeTableType;
  typedef MultiDOFJointStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_JOINT_NAMES = 8,
    VT_TRANSFORMS = 10,
    VT_TWIST = 12,
    VT_WRENCH = 14
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *joint_names() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_JOINT_NAMES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::Transform>> *transforms() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::Transform>> *>(VT_TRANSFORMS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::Twist>> *twist() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::Twist>> *>(VT_TWIST);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::Wrench>> *wrench() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::Wrench>> *>(VT_WRENCH);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_JOINT_NAMES) &&
           verifier.VerifyVector(joint_names()) &&
           verifier.VerifyVectorOfStrings(joint_names()) &&
           VerifyOffsetRequired(verifier, VT_TRANSFORMS) &&
           verifier.VerifyVector(transforms()) &&
           verifier.VerifyVectorOfTables(transforms()) &&
           VerifyOffsetRequired(verifier, VT_TWIST) &&
           verifier.VerifyVector(twist()) &&
           verifier.VerifyVectorOfTables(twist()) &&
           VerifyOffsetRequired(verifier, VT_WRENCH) &&
           verifier.VerifyVector(wrench()) &&
           verifier.VerifyVectorOfTables(wrench()) &&
           verifier.EndTable();
  }
  MultiDOFJointStateT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MultiDOFJointStateT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<MultiDOFJointState> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MultiDOFJointStateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MultiDOFJointStateBuilder {
  typedef MultiDOFJointState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(MultiDOFJointState::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(MultiDOFJointState::VT_HEADER, header);
  }
  void add_joint_names(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> joint_names) {
    fbb_.AddOffset(MultiDOFJointState::VT_JOINT_NAMES, joint_names);
  }
  void add_transforms(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::Transform>>> transforms) {
    fbb_.AddOffset(MultiDOFJointState::VT_TRANSFORMS, transforms);
  }
  void add_twist(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::Twist>>> twist) {
    fbb_.AddOffset(MultiDOFJointState::VT_TWIST, twist);
  }
  void add_wrench(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::Wrench>>> wrench) {
    fbb_.AddOffset(MultiDOFJointState::VT_WRENCH, wrench);
  }
  explicit MultiDOFJointStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MultiDOFJointState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MultiDOFJointState>(end);
    fbb_.Required(o, MultiDOFJointState::VT_HEADER);
    fbb_.Required(o, MultiDOFJointState::VT_JOINT_NAMES);
    fbb_.Required(o, MultiDOFJointState::VT_TRANSFORMS);
    fbb_.Required(o, MultiDOFJointState::VT_TWIST);
    fbb_.Required(o, MultiDOFJointState::VT_WRENCH);
    return o;
  }
};

inline ::flatbuffers::Offset<MultiDOFJointState> CreateMultiDOFJointState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> joint_names = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::Transform>>> transforms = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::Twist>>> twist = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::Wrench>>> wrench = 0) {
  MultiDOFJointStateBuilder builder_(_fbb);
  builder_.add_wrench(wrench);
  builder_.add_twist(twist);
  builder_.add_transforms(transforms);
  builder_.add_joint_names(joint_names);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MultiDOFJointState> CreateMultiDOFJointStateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *joint_names = nullptr,
    const std::vector<::flatbuffers::Offset<fb::geometry_msgs::Transform>> *transforms = nullptr,
    const std::vector<::flatbuffers::Offset<fb::geometry_msgs::Twist>> *twist = nullptr,
    const std::vector<::flatbuffers::Offset<fb::geometry_msgs::Wrench>> *wrench = nullptr) {
  auto joint_names__ = joint_names ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*joint_names) : 0;
  auto transforms__ = transforms ? _fbb.CreateVector<::flatbuffers::Offset<fb::geometry_msgs::Transform>>(*transforms) : 0;
  auto twist__ = twist ? _fbb.CreateVector<::flatbuffers::Offset<fb::geometry_msgs::Twist>>(*twist) : 0;
  auto wrench__ = wrench ? _fbb.CreateVector<::flatbuffers::Offset<fb::geometry_msgs::Wrench>>(*wrench) : 0;
  return fb::sensor_msgs::CreateMultiDOFJointState(
      _fbb,
      __metadata,
      header,
      joint_names__,
      transforms__,
      twist__,
      wrench__);
}

::flatbuffers::Offset<MultiDOFJointState> CreateMultiDOFJointState(::flatbuffers::FlatBufferBuilder &_fbb, const MultiDOFJointStateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MagneticFieldT : public ::flatbuffers::NativeTable {
  typedef MagneticField TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::geometry_msgs::Vector3T> magnetic_field{};
  std::vector<double> magnetic_field_covariance{};
  MagneticFieldT() = default;
  MagneticFieldT(const MagneticFieldT &o);
  MagneticFieldT(MagneticFieldT&&) FLATBUFFERS_NOEXCEPT = default;
  MagneticFieldT &operator=(MagneticFieldT o) FLATBUFFERS_NOEXCEPT;
};

struct MagneticField FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MagneticFieldT NativeTableType;
  typedef MagneticFieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_MAGNETIC_FIELD = 8,
    VT_MAGNETIC_FIELD_COVARIANCE = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geometry_msgs::Vector3 *magnetic_field() const {
    return GetPointer<const fb::geometry_msgs::Vector3 *>(VT_MAGNETIC_FIELD);
  }
  const ::flatbuffers::Vector<double> *magnetic_field_covariance() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_MAGNETIC_FIELD_COVARIANCE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_MAGNETIC_FIELD) &&
           verifier.VerifyTable(magnetic_field()) &&
           VerifyOffsetRequired(verifier, VT_MAGNETIC_FIELD_COVARIANCE) &&
           verifier.VerifyVector(magnetic_field_covariance()) &&
           verifier.EndTable();
  }
  MagneticFieldT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MagneticFieldT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<MagneticField> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MagneticFieldT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MagneticFieldBuilder {
  typedef MagneticField Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(MagneticField::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(MagneticField::VT_HEADER, header);
  }
  void add_magnetic_field(::flatbuffers::Offset<fb::geometry_msgs::Vector3> magnetic_field) {
    fbb_.AddOffset(MagneticField::VT_MAGNETIC_FIELD, magnetic_field);
  }
  void add_magnetic_field_covariance(::flatbuffers::Offset<::flatbuffers::Vector<double>> magnetic_field_covariance) {
    fbb_.AddOffset(MagneticField::VT_MAGNETIC_FIELD_COVARIANCE, magnetic_field_covariance);
  }
  explicit MagneticFieldBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MagneticField> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MagneticField>(end);
    fbb_.Required(o, MagneticField::VT_HEADER);
    fbb_.Required(o, MagneticField::VT_MAGNETIC_FIELD);
    fbb_.Required(o, MagneticField::VT_MAGNETIC_FIELD_COVARIANCE);
    return o;
  }
};

inline ::flatbuffers::Offset<MagneticField> CreateMagneticField(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Vector3> magnetic_field = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> magnetic_field_covariance = 0) {
  MagneticFieldBuilder builder_(_fbb);
  builder_.add_magnetic_field_covariance(magnetic_field_covariance);
  builder_.add_magnetic_field(magnetic_field);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MagneticField> CreateMagneticFieldDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Vector3> magnetic_field = 0,
    const std::vector<double> *magnetic_field_covariance = nullptr) {
  auto magnetic_field_covariance__ = magnetic_field_covariance ? _fbb.CreateVector<double>(*magnetic_field_covariance) : 0;
  return fb::sensor_msgs::CreateMagneticField(
      _fbb,
      __metadata,
      header,
      magnetic_field,
      magnetic_field_covariance__);
}

::flatbuffers::Offset<MagneticField> CreateMagneticField(::flatbuffers::FlatBufferBuilder &_fbb, const MagneticFieldT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CompressedImageT : public ::flatbuffers::NativeTable {
  typedef CompressedImage TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::string format{};
  std::vector<uint8_t> data{};
  CompressedImageT() = default;
  CompressedImageT(const CompressedImageT &o);
  CompressedImageT(CompressedImageT&&) FLATBUFFERS_NOEXCEPT = default;
  CompressedImageT &operator=(CompressedImageT o) FLATBUFFERS_NOEXCEPT;
};

struct CompressedImage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CompressedImageT NativeTableType;
  typedef CompressedImageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_FORMAT = 8,
    VT_DATA = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const ::flatbuffers::String *format() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FORMAT);
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_FORMAT) &&
           verifier.VerifyString(format()) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  CompressedImageT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CompressedImageT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CompressedImage> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CompressedImageT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CompressedImageBuilder {
  typedef CompressedImage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(CompressedImage::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(CompressedImage::VT_HEADER, header);
  }
  void add_format(::flatbuffers::Offset<::flatbuffers::String> format) {
    fbb_.AddOffset(CompressedImage::VT_FORMAT, format);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(CompressedImage::VT_DATA, data);
  }
  explicit CompressedImageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CompressedImage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CompressedImage>(end);
    fbb_.Required(o, CompressedImage::VT_HEADER);
    fbb_.Required(o, CompressedImage::VT_FORMAT);
    fbb_.Required(o, CompressedImage::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<CompressedImage> CreateCompressedImage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<::flatbuffers::String> format = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  CompressedImageBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_format(format);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CompressedImage> CreateCompressedImageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const char *format = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  auto format__ = format ? _fbb.CreateString(format) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return fb::sensor_msgs::CreateCompressedImage(
      _fbb,
      __metadata,
      header,
      format__,
      data__);
}

::flatbuffers::Offset<CompressedImage> CreateCompressedImage(::flatbuffers::FlatBufferBuilder &_fbb, const CompressedImageT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NavSatStatusT : public ::flatbuffers::NativeTable {
  typedef NavSatStatus TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  int8_t status = 0;
  uint16_t service = 0;
  NavSatStatusT() = default;
  NavSatStatusT(const NavSatStatusT &o);
  NavSatStatusT(NavSatStatusT&&) FLATBUFFERS_NOEXCEPT = default;
  NavSatStatusT &operator=(NavSatStatusT o) FLATBUFFERS_NOEXCEPT;
};

struct NavSatStatus FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NavSatStatusT NativeTableType;
  typedef NavSatStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_STATUS = 6,
    VT_SERVICE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  int8_t status() const {
    return GetField<int8_t>(VT_STATUS, 0);
  }
  uint16_t service() const {
    return GetField<uint16_t>(VT_SERVICE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<int8_t>(verifier, VT_STATUS, 1) &&
           VerifyField<uint16_t>(verifier, VT_SERVICE, 2) &&
           verifier.EndTable();
  }
  NavSatStatusT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NavSatStatusT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<NavSatStatus> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NavSatStatusT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NavSatStatusBuilder {
  typedef NavSatStatus Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(NavSatStatus::VT___METADATA, __metadata);
  }
  void add_status(int8_t status) {
    fbb_.AddElement<int8_t>(NavSatStatus::VT_STATUS, status, 0);
  }
  void add_service(uint16_t service) {
    fbb_.AddElement<uint16_t>(NavSatStatus::VT_SERVICE, service, 0);
  }
  explicit NavSatStatusBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NavSatStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NavSatStatus>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NavSatStatus> CreateNavSatStatus(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    int8_t status = 0,
    uint16_t service = 0) {
  NavSatStatusBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  builder_.add_service(service);
  builder_.add_status(status);
  return builder_.Finish();
}

::flatbuffers::Offset<NavSatStatus> CreateNavSatStatus(::flatbuffers::FlatBufferBuilder &_fbb, const NavSatStatusT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PointCloud2T : public ::flatbuffers::NativeTable {
  typedef PointCloud2 TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  uint32_t height = 0;
  uint32_t width = 0;
  std::vector<std::unique_ptr<fb::sensor_msgs::PointFieldT>> fields{};
  bool is_bigendian = false;
  uint32_t point_step = 0;
  uint32_t row_step = 0;
  std::vector<uint8_t> data{};
  bool is_dense = false;
  PointCloud2T() = default;
  PointCloud2T(const PointCloud2T &o);
  PointCloud2T(PointCloud2T&&) FLATBUFFERS_NOEXCEPT = default;
  PointCloud2T &operator=(PointCloud2T o) FLATBUFFERS_NOEXCEPT;
};

struct PointCloud2 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PointCloud2T NativeTableType;
  typedef PointCloud2Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_HEIGHT = 8,
    VT_WIDTH = 10,
    VT_FIELDS = 12,
    VT_IS_BIGENDIAN = 14,
    VT_POINT_STEP = 16,
    VT_ROW_STEP = 18,
    VT_DATA = 20,
    VT_IS_DENSE = 22
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  uint32_t width() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::sensor_msgs::PointField>> *fields() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::sensor_msgs::PointField>> *>(VT_FIELDS);
  }
  bool is_bigendian() const {
    return GetField<uint8_t>(VT_IS_BIGENDIAN, 0) != 0;
  }
  uint32_t point_step() const {
    return GetField<uint32_t>(VT_POINT_STEP, 0);
  }
  uint32_t row_step() const {
    return GetField<uint32_t>(VT_ROW_STEP, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool is_dense() const {
    return GetField<uint8_t>(VT_IS_DENSE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT, 4) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH, 4) &&
           VerifyOffsetRequired(verifier, VT_FIELDS) &&
           verifier.VerifyVector(fields()) &&
           verifier.VerifyVectorOfTables(fields()) &&
           VerifyField<uint8_t>(verifier, VT_IS_BIGENDIAN, 1) &&
           VerifyField<uint32_t>(verifier, VT_POINT_STEP, 4) &&
           VerifyField<uint32_t>(verifier, VT_ROW_STEP, 4) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyField<uint8_t>(verifier, VT_IS_DENSE, 1) &&
           verifier.EndTable();
  }
  PointCloud2T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PointCloud2T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PointCloud2> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PointCloud2T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PointCloud2Builder {
  typedef PointCloud2 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PointCloud2::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(PointCloud2::VT_HEADER, header);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(PointCloud2::VT_HEIGHT, height, 0);
  }
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(PointCloud2::VT_WIDTH, width, 0);
  }
  void add_fields(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::sensor_msgs::PointField>>> fields) {
    fbb_.AddOffset(PointCloud2::VT_FIELDS, fields);
  }
  void add_is_bigendian(bool is_bigendian) {
    fbb_.AddElement<uint8_t>(PointCloud2::VT_IS_BIGENDIAN, static_cast<uint8_t>(is_bigendian), 0);
  }
  void add_point_step(uint32_t point_step) {
    fbb_.AddElement<uint32_t>(PointCloud2::VT_POINT_STEP, point_step, 0);
  }
  void add_row_step(uint32_t row_step) {
    fbb_.AddElement<uint32_t>(PointCloud2::VT_ROW_STEP, row_step, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(PointCloud2::VT_DATA, data);
  }
  void add_is_dense(bool is_dense) {
    fbb_.AddElement<uint8_t>(PointCloud2::VT_IS_DENSE, static_cast<uint8_t>(is_dense), 0);
  }
  explicit PointCloud2Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PointCloud2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PointCloud2>(end);
    fbb_.Required(o, PointCloud2::VT_HEADER);
    fbb_.Required(o, PointCloud2::VT_FIELDS);
    fbb_.Required(o, PointCloud2::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<PointCloud2> CreatePointCloud2(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    uint32_t height = 0,
    uint32_t width = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::sensor_msgs::PointField>>> fields = 0,
    bool is_bigendian = false,
    uint32_t point_step = 0,
    uint32_t row_step = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0,
    bool is_dense = false) {
  PointCloud2Builder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_row_step(row_step);
  builder_.add_point_step(point_step);
  builder_.add_fields(fields);
  builder_.add_width(width);
  builder_.add_height(height);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  builder_.add_is_dense(is_dense);
  builder_.add_is_bigendian(is_bigendian);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PointCloud2> CreatePointCloud2Direct(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    uint32_t height = 0,
    uint32_t width = 0,
    const std::vector<::flatbuffers::Offset<fb::sensor_msgs::PointField>> *fields = nullptr,
    bool is_bigendian = false,
    uint32_t point_step = 0,
    uint32_t row_step = 0,
    const std::vector<uint8_t> *data = nullptr,
    bool is_dense = false) {
  auto fields__ = fields ? _fbb.CreateVector<::flatbuffers::Offset<fb::sensor_msgs::PointField>>(*fields) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return fb::sensor_msgs::CreatePointCloud2(
      _fbb,
      __metadata,
      header,
      height,
      width,
      fields__,
      is_bigendian,
      point_step,
      row_step,
      data__,
      is_dense);
}

::flatbuffers::Offset<PointCloud2> CreatePointCloud2(::flatbuffers::FlatBufferBuilder &_fbb, const PointCloud2T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FluidPressureT : public ::flatbuffers::NativeTable {
  typedef FluidPressure TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  double fluid_pressure = 0.0;
  double variance = 0.0;
  FluidPressureT() = default;
  FluidPressureT(const FluidPressureT &o);
  FluidPressureT(FluidPressureT&&) FLATBUFFERS_NOEXCEPT = default;
  FluidPressureT &operator=(FluidPressureT o) FLATBUFFERS_NOEXCEPT;
};

struct FluidPressure FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FluidPressureT NativeTableType;
  typedef FluidPressureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_FLUID_PRESSURE = 8,
    VT_VARIANCE = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  double fluid_pressure() const {
    return GetField<double>(VT_FLUID_PRESSURE, 0.0);
  }
  double variance() const {
    return GetField<double>(VT_VARIANCE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<double>(verifier, VT_FLUID_PRESSURE, 8) &&
           VerifyField<double>(verifier, VT_VARIANCE, 8) &&
           verifier.EndTable();
  }
  FluidPressureT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FluidPressureT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FluidPressure> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FluidPressureT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FluidPressureBuilder {
  typedef FluidPressure Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(FluidPressure::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(FluidPressure::VT_HEADER, header);
  }
  void add_fluid_pressure(double fluid_pressure) {
    fbb_.AddElement<double>(FluidPressure::VT_FLUID_PRESSURE, fluid_pressure, 0.0);
  }
  void add_variance(double variance) {
    fbb_.AddElement<double>(FluidPressure::VT_VARIANCE, variance, 0.0);
  }
  explicit FluidPressureBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FluidPressure> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FluidPressure>(end);
    fbb_.Required(o, FluidPressure::VT_HEADER);
    return o;
  }
};

inline ::flatbuffers::Offset<FluidPressure> CreateFluidPressure(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    double fluid_pressure = 0.0,
    double variance = 0.0) {
  FluidPressureBuilder builder_(_fbb);
  builder_.add_variance(variance);
  builder_.add_fluid_pressure(fluid_pressure);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<FluidPressure> CreateFluidPressure(::flatbuffers::FlatBufferBuilder &_fbb, const FluidPressureT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct JoyFeedbackArrayT : public ::flatbuffers::NativeTable {
  typedef JoyFeedbackArray TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::vector<std::unique_ptr<fb::sensor_msgs::JoyFeedbackT>> array{};
  JoyFeedbackArrayT() = default;
  JoyFeedbackArrayT(const JoyFeedbackArrayT &o);
  JoyFeedbackArrayT(JoyFeedbackArrayT&&) FLATBUFFERS_NOEXCEPT = default;
  JoyFeedbackArrayT &operator=(JoyFeedbackArrayT o) FLATBUFFERS_NOEXCEPT;
};

struct JoyFeedbackArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JoyFeedbackArrayT NativeTableType;
  typedef JoyFeedbackArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_ARRAY = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::sensor_msgs::JoyFeedback>> *array() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::sensor_msgs::JoyFeedback>> *>(VT_ARRAY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_ARRAY) &&
           verifier.VerifyVector(array()) &&
           verifier.VerifyVectorOfTables(array()) &&
           verifier.EndTable();
  }
  JoyFeedbackArrayT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(JoyFeedbackArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<JoyFeedbackArray> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const JoyFeedbackArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct JoyFeedbackArrayBuilder {
  typedef JoyFeedbackArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(JoyFeedbackArray::VT___METADATA, __metadata);
  }
  void add_array(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::sensor_msgs::JoyFeedback>>> array) {
    fbb_.AddOffset(JoyFeedbackArray::VT_ARRAY, array);
  }
  explicit JoyFeedbackArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JoyFeedbackArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JoyFeedbackArray>(end);
    fbb_.Required(o, JoyFeedbackArray::VT_ARRAY);
    return o;
  }
};

inline ::flatbuffers::Offset<JoyFeedbackArray> CreateJoyFeedbackArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::sensor_msgs::JoyFeedback>>> array = 0) {
  JoyFeedbackArrayBuilder builder_(_fbb);
  builder_.add_array(array);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<JoyFeedbackArray> CreateJoyFeedbackArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const std::vector<::flatbuffers::Offset<fb::sensor_msgs::JoyFeedback>> *array = nullptr) {
  auto array__ = array ? _fbb.CreateVector<::flatbuffers::Offset<fb::sensor_msgs::JoyFeedback>>(*array) : 0;
  return fb::sensor_msgs::CreateJoyFeedbackArray(
      _fbb,
      __metadata,
      array__);
}

::flatbuffers::Offset<JoyFeedbackArray> CreateJoyFeedbackArray(::flatbuffers::FlatBufferBuilder &_fbb, const JoyFeedbackArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MultiEchoLaserScanT : public ::flatbuffers::NativeTable {
  typedef MultiEchoLaserScan TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  float angle_min = 0.0f;
  float angle_max = 0.0f;
  float angle_increment = 0.0f;
  float time_increment = 0.0f;
  float scan_time = 0.0f;
  float range_min = 0.0f;
  float range_max = 0.0f;
  std::vector<std::unique_ptr<fb::sensor_msgs::LaserEchoT>> ranges{};
  std::vector<std::unique_ptr<fb::sensor_msgs::LaserEchoT>> intensities{};
  MultiEchoLaserScanT() = default;
  MultiEchoLaserScanT(const MultiEchoLaserScanT &o);
  MultiEchoLaserScanT(MultiEchoLaserScanT&&) FLATBUFFERS_NOEXCEPT = default;
  MultiEchoLaserScanT &operator=(MultiEchoLaserScanT o) FLATBUFFERS_NOEXCEPT;
};

struct MultiEchoLaserScan FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MultiEchoLaserScanT NativeTableType;
  typedef MultiEchoLaserScanBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_ANGLE_MIN = 8,
    VT_ANGLE_MAX = 10,
    VT_ANGLE_INCREMENT = 12,
    VT_TIME_INCREMENT = 14,
    VT_SCAN_TIME = 16,
    VT_RANGE_MIN = 18,
    VT_RANGE_MAX = 20,
    VT_RANGES = 22,
    VT_INTENSITIES = 24
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  float angle_min() const {
    return GetField<float>(VT_ANGLE_MIN, 0.0f);
  }
  float angle_max() const {
    return GetField<float>(VT_ANGLE_MAX, 0.0f);
  }
  float angle_increment() const {
    return GetField<float>(VT_ANGLE_INCREMENT, 0.0f);
  }
  float time_increment() const {
    return GetField<float>(VT_TIME_INCREMENT, 0.0f);
  }
  float scan_time() const {
    return GetField<float>(VT_SCAN_TIME, 0.0f);
  }
  float range_min() const {
    return GetField<float>(VT_RANGE_MIN, 0.0f);
  }
  float range_max() const {
    return GetField<float>(VT_RANGE_MAX, 0.0f);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::sensor_msgs::LaserEcho>> *ranges() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::sensor_msgs::LaserEcho>> *>(VT_RANGES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::sensor_msgs::LaserEcho>> *intensities() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::sensor_msgs::LaserEcho>> *>(VT_INTENSITIES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<float>(verifier, VT_ANGLE_MIN, 4) &&
           VerifyField<float>(verifier, VT_ANGLE_MAX, 4) &&
           VerifyField<float>(verifier, VT_ANGLE_INCREMENT, 4) &&
           VerifyField<float>(verifier, VT_TIME_INCREMENT, 4) &&
           VerifyField<float>(verifier, VT_SCAN_TIME, 4) &&
           VerifyField<float>(verifier, VT_RANGE_MIN, 4) &&
           VerifyField<float>(verifier, VT_RANGE_MAX, 4) &&
           VerifyOffsetRequired(verifier, VT_RANGES) &&
           verifier.VerifyVector(ranges()) &&
           verifier.VerifyVectorOfTables(ranges()) &&
           VerifyOffsetRequired(verifier, VT_INTENSITIES) &&
           verifier.VerifyVector(intensities()) &&
           verifier.VerifyVectorOfTables(intensities()) &&
           verifier.EndTable();
  }
  MultiEchoLaserScanT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MultiEchoLaserScanT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<MultiEchoLaserScan> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MultiEchoLaserScanT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MultiEchoLaserScanBuilder {
  typedef MultiEchoLaserScan Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(MultiEchoLaserScan::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(MultiEchoLaserScan::VT_HEADER, header);
  }
  void add_angle_min(float angle_min) {
    fbb_.AddElement<float>(MultiEchoLaserScan::VT_ANGLE_MIN, angle_min, 0.0f);
  }
  void add_angle_max(float angle_max) {
    fbb_.AddElement<float>(MultiEchoLaserScan::VT_ANGLE_MAX, angle_max, 0.0f);
  }
  void add_angle_increment(float angle_increment) {
    fbb_.AddElement<float>(MultiEchoLaserScan::VT_ANGLE_INCREMENT, angle_increment, 0.0f);
  }
  void add_time_increment(float time_increment) {
    fbb_.AddElement<float>(MultiEchoLaserScan::VT_TIME_INCREMENT, time_increment, 0.0f);
  }
  void add_scan_time(float scan_time) {
    fbb_.AddElement<float>(MultiEchoLaserScan::VT_SCAN_TIME, scan_time, 0.0f);
  }
  void add_range_min(float range_min) {
    fbb_.AddElement<float>(MultiEchoLaserScan::VT_RANGE_MIN, range_min, 0.0f);
  }
  void add_range_max(float range_max) {
    fbb_.AddElement<float>(MultiEchoLaserScan::VT_RANGE_MAX, range_max, 0.0f);
  }
  void add_ranges(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::sensor_msgs::LaserEcho>>> ranges) {
    fbb_.AddOffset(MultiEchoLaserScan::VT_RANGES, ranges);
  }
  void add_intensities(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::sensor_msgs::LaserEcho>>> intensities) {
    fbb_.AddOffset(MultiEchoLaserScan::VT_INTENSITIES, intensities);
  }
  explicit MultiEchoLaserScanBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MultiEchoLaserScan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MultiEchoLaserScan>(end);
    fbb_.Required(o, MultiEchoLaserScan::VT_HEADER);
    fbb_.Required(o, MultiEchoLaserScan::VT_RANGES);
    fbb_.Required(o, MultiEchoLaserScan::VT_INTENSITIES);
    return o;
  }
};

inline ::flatbuffers::Offset<MultiEchoLaserScan> CreateMultiEchoLaserScan(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    float angle_min = 0.0f,
    float angle_max = 0.0f,
    float angle_increment = 0.0f,
    float time_increment = 0.0f,
    float scan_time = 0.0f,
    float range_min = 0.0f,
    float range_max = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::sensor_msgs::LaserEcho>>> ranges = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::sensor_msgs::LaserEcho>>> intensities = 0) {
  MultiEchoLaserScanBuilder builder_(_fbb);
  builder_.add_intensities(intensities);
  builder_.add_ranges(ranges);
  builder_.add_range_max(range_max);
  builder_.add_range_min(range_min);
  builder_.add_scan_time(scan_time);
  builder_.add_time_increment(time_increment);
  builder_.add_angle_increment(angle_increment);
  builder_.add_angle_max(angle_max);
  builder_.add_angle_min(angle_min);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MultiEchoLaserScan> CreateMultiEchoLaserScanDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    float angle_min = 0.0f,
    float angle_max = 0.0f,
    float angle_increment = 0.0f,
    float time_increment = 0.0f,
    float scan_time = 0.0f,
    float range_min = 0.0f,
    float range_max = 0.0f,
    const std::vector<::flatbuffers::Offset<fb::sensor_msgs::LaserEcho>> *ranges = nullptr,
    const std::vector<::flatbuffers::Offset<fb::sensor_msgs::LaserEcho>> *intensities = nullptr) {
  auto ranges__ = ranges ? _fbb.CreateVector<::flatbuffers::Offset<fb::sensor_msgs::LaserEcho>>(*ranges) : 0;
  auto intensities__ = intensities ? _fbb.CreateVector<::flatbuffers::Offset<fb::sensor_msgs::LaserEcho>>(*intensities) : 0;
  return fb::sensor_msgs::CreateMultiEchoLaserScan(
      _fbb,
      __metadata,
      header,
      angle_min,
      angle_max,
      angle_increment,
      time_increment,
      scan_time,
      range_min,
      range_max,
      ranges__,
      intensities__);
}

::flatbuffers::Offset<MultiEchoLaserScan> CreateMultiEchoLaserScan(::flatbuffers::FlatBufferBuilder &_fbb, const MultiEchoLaserScanT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PointCloudT : public ::flatbuffers::NativeTable {
  typedef PointCloud TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::vector<std::unique_ptr<fb::geometry_msgs::Point32T>> points{};
  std::vector<std::unique_ptr<fb::sensor_msgs::ChannelFloat32T>> channels{};
  PointCloudT() = default;
  PointCloudT(const PointCloudT &o);
  PointCloudT(PointCloudT&&) FLATBUFFERS_NOEXCEPT = default;
  PointCloudT &operator=(PointCloudT o) FLATBUFFERS_NOEXCEPT;
};

struct PointCloud FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PointCloudT NativeTableType;
  typedef PointCloudBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_POINTS = 8,
    VT_CHANNELS = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::Point32>> *points() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::Point32>> *>(VT_POINTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::sensor_msgs::ChannelFloat32>> *channels() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::sensor_msgs::ChannelFloat32>> *>(VT_CHANNELS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.VerifyVectorOfTables(points()) &&
           VerifyOffsetRequired(verifier, VT_CHANNELS) &&
           verifier.VerifyVector(channels()) &&
           verifier.VerifyVectorOfTables(channels()) &&
           verifier.EndTable();
  }
  PointCloudT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PointCloudT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PointCloud> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PointCloudT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PointCloudBuilder {
  typedef PointCloud Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PointCloud::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(PointCloud::VT_HEADER, header);
  }
  void add_points(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::Point32>>> points) {
    fbb_.AddOffset(PointCloud::VT_POINTS, points);
  }
  void add_channels(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::sensor_msgs::ChannelFloat32>>> channels) {
    fbb_.AddOffset(PointCloud::VT_CHANNELS, channels);
  }
  explicit PointCloudBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PointCloud> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PointCloud>(end);
    fbb_.Required(o, PointCloud::VT_HEADER);
    fbb_.Required(o, PointCloud::VT_POINTS);
    fbb_.Required(o, PointCloud::VT_CHANNELS);
    return o;
  }
};

inline ::flatbuffers::Offset<PointCloud> CreatePointCloud(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::Point32>>> points = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::sensor_msgs::ChannelFloat32>>> channels = 0) {
  PointCloudBuilder builder_(_fbb);
  builder_.add_channels(channels);
  builder_.add_points(points);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PointCloud> CreatePointCloudDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const std::vector<::flatbuffers::Offset<fb::geometry_msgs::Point32>> *points = nullptr,
    const std::vector<::flatbuffers::Offset<fb::sensor_msgs::ChannelFloat32>> *channels = nullptr) {
  auto points__ = points ? _fbb.CreateVector<::flatbuffers::Offset<fb::geometry_msgs::Point32>>(*points) : 0;
  auto channels__ = channels ? _fbb.CreateVector<::flatbuffers::Offset<fb::sensor_msgs::ChannelFloat32>>(*channels) : 0;
  return fb::sensor_msgs::CreatePointCloud(
      _fbb,
      __metadata,
      header,
      points__,
      channels__);
}

::flatbuffers::Offset<PointCloud> CreatePointCloud(::flatbuffers::FlatBufferBuilder &_fbb, const PointCloudT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ImageT : public ::flatbuffers::NativeTable {
  typedef Image TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  uint32_t height = 0;
  uint32_t width = 0;
  std::string encoding{};
  uint8_t is_bigendian = 0;
  uint32_t step = 0;
  std::vector<uint8_t> data{};
  ImageT() = default;
  ImageT(const ImageT &o);
  ImageT(ImageT&&) FLATBUFFERS_NOEXCEPT = default;
  ImageT &operator=(ImageT o) FLATBUFFERS_NOEXCEPT;
};

struct Image FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ImageT NativeTableType;
  typedef ImageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_HEIGHT = 8,
    VT_WIDTH = 10,
    VT_ENCODING = 12,
    VT_IS_BIGENDIAN = 14,
    VT_STEP = 16,
    VT_DATA = 18
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  uint32_t width() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  const ::flatbuffers::String *encoding() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ENCODING);
  }
  uint8_t is_bigendian() const {
    return GetField<uint8_t>(VT_IS_BIGENDIAN, 0);
  }
  uint32_t step() const {
    return GetField<uint32_t>(VT_STEP, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT, 4) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH, 4) &&
           VerifyOffsetRequired(verifier, VT_ENCODING) &&
           verifier.VerifyString(encoding()) &&
           VerifyField<uint8_t>(verifier, VT_IS_BIGENDIAN, 1) &&
           VerifyField<uint32_t>(verifier, VT_STEP, 4) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  ImageT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ImageT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Image> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ImageT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ImageBuilder {
  typedef Image Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Image::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(Image::VT_HEADER, header);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(Image::VT_HEIGHT, height, 0);
  }
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(Image::VT_WIDTH, width, 0);
  }
  void add_encoding(::flatbuffers::Offset<::flatbuffers::String> encoding) {
    fbb_.AddOffset(Image::VT_ENCODING, encoding);
  }
  void add_is_bigendian(uint8_t is_bigendian) {
    fbb_.AddElement<uint8_t>(Image::VT_IS_BIGENDIAN, is_bigendian, 0);
  }
  void add_step(uint32_t step) {
    fbb_.AddElement<uint32_t>(Image::VT_STEP, step, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Image::VT_DATA, data);
  }
  explicit ImageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Image> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Image>(end);
    fbb_.Required(o, Image::VT_HEADER);
    fbb_.Required(o, Image::VT_ENCODING);
    fbb_.Required(o, Image::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<Image> CreateImage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    uint32_t height = 0,
    uint32_t width = 0,
    ::flatbuffers::Offset<::flatbuffers::String> encoding = 0,
    uint8_t is_bigendian = 0,
    uint32_t step = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  ImageBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_step(step);
  builder_.add_encoding(encoding);
  builder_.add_width(width);
  builder_.add_height(height);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  builder_.add_is_bigendian(is_bigendian);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Image> CreateImageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    uint32_t height = 0,
    uint32_t width = 0,
    const char *encoding = nullptr,
    uint8_t is_bigendian = 0,
    uint32_t step = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto encoding__ = encoding ? _fbb.CreateString(encoding) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return fb::sensor_msgs::CreateImage(
      _fbb,
      __metadata,
      header,
      height,
      width,
      encoding__,
      is_bigendian,
      step,
      data__);
}

::flatbuffers::Offset<Image> CreateImage(::flatbuffers::FlatBufferBuilder &_fbb, const ImageT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ChannelFloat32T : public ::flatbuffers::NativeTable {
  typedef ChannelFloat32 TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string name{};
  std::vector<float> values{};
  ChannelFloat32T() = default;
  ChannelFloat32T(const ChannelFloat32T &o);
  ChannelFloat32T(ChannelFloat32T&&) FLATBUFFERS_NOEXCEPT = default;
  ChannelFloat32T &operator=(ChannelFloat32T o) FLATBUFFERS_NOEXCEPT;
};

struct ChannelFloat32 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChannelFloat32T NativeTableType;
  typedef ChannelFloat32Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_NAME = 6,
    VT_VALUES = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<float> *values() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.EndTable();
  }
  ChannelFloat32T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ChannelFloat32T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ChannelFloat32> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ChannelFloat32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ChannelFloat32Builder {
  typedef ChannelFloat32 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ChannelFloat32::VT___METADATA, __metadata);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ChannelFloat32::VT_NAME, name);
  }
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<float>> values) {
    fbb_.AddOffset(ChannelFloat32::VT_VALUES, values);
  }
  explicit ChannelFloat32Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChannelFloat32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChannelFloat32>(end);
    fbb_.Required(o, ChannelFloat32::VT_NAME);
    fbb_.Required(o, ChannelFloat32::VT_VALUES);
    return o;
  }
};

inline ::flatbuffers::Offset<ChannelFloat32> CreateChannelFloat32(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> values = 0) {
  ChannelFloat32Builder builder_(_fbb);
  builder_.add_values(values);
  builder_.add_name(name);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ChannelFloat32> CreateChannelFloat32Direct(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *name = nullptr,
    const std::vector<float> *values = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto values__ = values ? _fbb.CreateVector<float>(*values) : 0;
  return fb::sensor_msgs::CreateChannelFloat32(
      _fbb,
      __metadata,
      name__,
      values__);
}

::flatbuffers::Offset<ChannelFloat32> CreateChannelFloat32(::flatbuffers::FlatBufferBuilder &_fbb, const ChannelFloat32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TemperatureT : public ::flatbuffers::NativeTable {
  typedef Temperature TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  double temperature = 0.0;
  double variance = 0.0;
  TemperatureT() = default;
  TemperatureT(const TemperatureT &o);
  TemperatureT(TemperatureT&&) FLATBUFFERS_NOEXCEPT = default;
  TemperatureT &operator=(TemperatureT o) FLATBUFFERS_NOEXCEPT;
};

struct Temperature FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TemperatureT NativeTableType;
  typedef TemperatureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_TEMPERATURE = 8,
    VT_VARIANCE = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  double temperature() const {
    return GetField<double>(VT_TEMPERATURE, 0.0);
  }
  double variance() const {
    return GetField<double>(VT_VARIANCE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<double>(verifier, VT_TEMPERATURE, 8) &&
           VerifyField<double>(verifier, VT_VARIANCE, 8) &&
           verifier.EndTable();
  }
  TemperatureT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TemperatureT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Temperature> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TemperatureT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TemperatureBuilder {
  typedef Temperature Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Temperature::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(Temperature::VT_HEADER, header);
  }
  void add_temperature(double temperature) {
    fbb_.AddElement<double>(Temperature::VT_TEMPERATURE, temperature, 0.0);
  }
  void add_variance(double variance) {
    fbb_.AddElement<double>(Temperature::VT_VARIANCE, variance, 0.0);
  }
  explicit TemperatureBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Temperature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Temperature>(end);
    fbb_.Required(o, Temperature::VT_HEADER);
    return o;
  }
};

inline ::flatbuffers::Offset<Temperature> CreateTemperature(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    double temperature = 0.0,
    double variance = 0.0) {
  TemperatureBuilder builder_(_fbb);
  builder_.add_variance(variance);
  builder_.add_temperature(temperature);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<Temperature> CreateTemperature(::flatbuffers::FlatBufferBuilder &_fbb, const TemperatureT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RegionOfInterestT : public ::flatbuffers::NativeTable {
  typedef RegionOfInterest TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  uint32_t x_offset = 0;
  uint32_t y_offset = 0;
  uint32_t height = 0;
  uint32_t width = 0;
  bool do_rectify = false;
  RegionOfInterestT() = default;
  RegionOfInterestT(const RegionOfInterestT &o);
  RegionOfInterestT(RegionOfInterestT&&) FLATBUFFERS_NOEXCEPT = default;
  RegionOfInterestT &operator=(RegionOfInterestT o) FLATBUFFERS_NOEXCEPT;
};

struct RegionOfInterest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RegionOfInterestT NativeTableType;
  typedef RegionOfInterestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_X_OFFSET = 6,
    VT_Y_OFFSET = 8,
    VT_HEIGHT = 10,
    VT_WIDTH = 12,
    VT_DO_RECTIFY = 14
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  uint32_t x_offset() const {
    return GetField<uint32_t>(VT_X_OFFSET, 0);
  }
  uint32_t y_offset() const {
    return GetField<uint32_t>(VT_Y_OFFSET, 0);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  uint32_t width() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  bool do_rectify() const {
    return GetField<uint8_t>(VT_DO_RECTIFY, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint32_t>(verifier, VT_X_OFFSET, 4) &&
           VerifyField<uint32_t>(verifier, VT_Y_OFFSET, 4) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT, 4) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH, 4) &&
           VerifyField<uint8_t>(verifier, VT_DO_RECTIFY, 1) &&
           verifier.EndTable();
  }
  RegionOfInterestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RegionOfInterestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RegionOfInterest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RegionOfInterestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RegionOfInterestBuilder {
  typedef RegionOfInterest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(RegionOfInterest::VT___METADATA, __metadata);
  }
  void add_x_offset(uint32_t x_offset) {
    fbb_.AddElement<uint32_t>(RegionOfInterest::VT_X_OFFSET, x_offset, 0);
  }
  void add_y_offset(uint32_t y_offset) {
    fbb_.AddElement<uint32_t>(RegionOfInterest::VT_Y_OFFSET, y_offset, 0);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(RegionOfInterest::VT_HEIGHT, height, 0);
  }
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(RegionOfInterest::VT_WIDTH, width, 0);
  }
  void add_do_rectify(bool do_rectify) {
    fbb_.AddElement<uint8_t>(RegionOfInterest::VT_DO_RECTIFY, static_cast<uint8_t>(do_rectify), 0);
  }
  explicit RegionOfInterestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RegionOfInterest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RegionOfInterest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RegionOfInterest> CreateRegionOfInterest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint32_t x_offset = 0,
    uint32_t y_offset = 0,
    uint32_t height = 0,
    uint32_t width = 0,
    bool do_rectify = false) {
  RegionOfInterestBuilder builder_(_fbb);
  builder_.add_width(width);
  builder_.add_height(height);
  builder_.add_y_offset(y_offset);
  builder_.add_x_offset(x_offset);
  builder_.add___metadata(__metadata);
  builder_.add_do_rectify(do_rectify);
  return builder_.Finish();
}

::flatbuffers::Offset<RegionOfInterest> CreateRegionOfInterest(::flatbuffers::FlatBufferBuilder &_fbb, const RegionOfInterestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct JoyFeedbackT : public ::flatbuffers::NativeTable {
  typedef JoyFeedback TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  uint8_t type = 0;
  uint8_t id = 0;
  float intensity = 0.0f;
  JoyFeedbackT() = default;
  JoyFeedbackT(const JoyFeedbackT &o);
  JoyFeedbackT(JoyFeedbackT&&) FLATBUFFERS_NOEXCEPT = default;
  JoyFeedbackT &operator=(JoyFeedbackT o) FLATBUFFERS_NOEXCEPT;
};

struct JoyFeedback FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JoyFeedbackT NativeTableType;
  typedef JoyFeedbackBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_TYPE = 6,
    VT_ID = 8,
    VT_INTENSITY = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  uint8_t type() const {
    return GetField<uint8_t>(VT_TYPE, 0);
  }
  uint8_t id() const {
    return GetField<uint8_t>(VT_ID, 0);
  }
  float intensity() const {
    return GetField<float>(VT_INTENSITY, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ID, 1) &&
           VerifyField<float>(verifier, VT_INTENSITY, 4) &&
           verifier.EndTable();
  }
  JoyFeedbackT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(JoyFeedbackT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<JoyFeedback> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const JoyFeedbackT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct JoyFeedbackBuilder {
  typedef JoyFeedback Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(JoyFeedback::VT___METADATA, __metadata);
  }
  void add_type(uint8_t type) {
    fbb_.AddElement<uint8_t>(JoyFeedback::VT_TYPE, type, 0);
  }
  void add_id(uint8_t id) {
    fbb_.AddElement<uint8_t>(JoyFeedback::VT_ID, id, 0);
  }
  void add_intensity(float intensity) {
    fbb_.AddElement<float>(JoyFeedback::VT_INTENSITY, intensity, 0.0f);
  }
  explicit JoyFeedbackBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JoyFeedback> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JoyFeedback>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JoyFeedback> CreateJoyFeedback(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint8_t type = 0,
    uint8_t id = 0,
    float intensity = 0.0f) {
  JoyFeedbackBuilder builder_(_fbb);
  builder_.add_intensity(intensity);
  builder_.add___metadata(__metadata);
  builder_.add_id(id);
  builder_.add_type(type);
  return builder_.Finish();
}

::flatbuffers::Offset<JoyFeedback> CreateJoyFeedback(::flatbuffers::FlatBufferBuilder &_fbb, const JoyFeedbackT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SetCameraInfoRequestT : public ::flatbuffers::NativeTable {
  typedef SetCameraInfoRequest TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::sensor_msgs::CameraInfoT> camera_info{};
  SetCameraInfoRequestT() = default;
  SetCameraInfoRequestT(const SetCameraInfoRequestT &o);
  SetCameraInfoRequestT(SetCameraInfoRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  SetCameraInfoRequestT &operator=(SetCameraInfoRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct SetCameraInfoRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetCameraInfoRequestT NativeTableType;
  typedef SetCameraInfoRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_CAMERA_INFO = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::sensor_msgs::CameraInfo *camera_info() const {
    return GetPointer<const fb::sensor_msgs::CameraInfo *>(VT_CAMERA_INFO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_CAMERA_INFO) &&
           verifier.VerifyTable(camera_info()) &&
           verifier.EndTable();
  }
  SetCameraInfoRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SetCameraInfoRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SetCameraInfoRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetCameraInfoRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SetCameraInfoRequestBuilder {
  typedef SetCameraInfoRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(SetCameraInfoRequest::VT___METADATA, __metadata);
  }
  void add_camera_info(::flatbuffers::Offset<fb::sensor_msgs::CameraInfo> camera_info) {
    fbb_.AddOffset(SetCameraInfoRequest::VT_CAMERA_INFO, camera_info);
  }
  explicit SetCameraInfoRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetCameraInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetCameraInfoRequest>(end);
    fbb_.Required(o, SetCameraInfoRequest::VT_CAMERA_INFO);
    return o;
  }
};

inline ::flatbuffers::Offset<SetCameraInfoRequest> CreateSetCameraInfoRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::sensor_msgs::CameraInfo> camera_info = 0) {
  SetCameraInfoRequestBuilder builder_(_fbb);
  builder_.add_camera_info(camera_info);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<SetCameraInfoRequest> CreateSetCameraInfoRequest(::flatbuffers::FlatBufferBuilder &_fbb, const SetCameraInfoRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SetCameraInfoResponseT : public ::flatbuffers::NativeTable {
  typedef SetCameraInfoResponse TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  bool success = false;
  std::string status_message{};
  SetCameraInfoResponseT() = default;
  SetCameraInfoResponseT(const SetCameraInfoResponseT &o);
  SetCameraInfoResponseT(SetCameraInfoResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  SetCameraInfoResponseT &operator=(SetCameraInfoResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct SetCameraInfoResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetCameraInfoResponseT NativeTableType;
  typedef SetCameraInfoResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_SUCCESS = 6,
    VT_STATUS_MESSAGE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  const ::flatbuffers::String *status_message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATUS_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           VerifyOffsetRequired(verifier, VT_STATUS_MESSAGE) &&
           verifier.VerifyString(status_message()) &&
           verifier.EndTable();
  }
  SetCameraInfoResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SetCameraInfoResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SetCameraInfoResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetCameraInfoResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SetCameraInfoResponseBuilder {
  typedef SetCameraInfoResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(SetCameraInfoResponse::VT___METADATA, __metadata);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(SetCameraInfoResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_status_message(::flatbuffers::Offset<::flatbuffers::String> status_message) {
    fbb_.AddOffset(SetCameraInfoResponse::VT_STATUS_MESSAGE, status_message);
  }
  explicit SetCameraInfoResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetCameraInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetCameraInfoResponse>(end);
    fbb_.Required(o, SetCameraInfoResponse::VT_STATUS_MESSAGE);
    return o;
  }
};

inline ::flatbuffers::Offset<SetCameraInfoResponse> CreateSetCameraInfoResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    bool success = false,
    ::flatbuffers::Offset<::flatbuffers::String> status_message = 0) {
  SetCameraInfoResponseBuilder builder_(_fbb);
  builder_.add_status_message(status_message);
  builder_.add___metadata(__metadata);
  builder_.add_success(success);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SetCameraInfoResponse> CreateSetCameraInfoResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    bool success = false,
    const char *status_message = nullptr) {
  auto status_message__ = status_message ? _fbb.CreateString(status_message) : 0;
  return fb::sensor_msgs::CreateSetCameraInfoResponse(
      _fbb,
      __metadata,
      success,
      status_message__);
}

::flatbuffers::Offset<SetCameraInfoResponse> CreateSetCameraInfoResponse(::flatbuffers::FlatBufferBuilder &_fbb, const SetCameraInfoResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NavSatFixT : public ::flatbuffers::NativeTable {
  typedef NavSatFix TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::sensor_msgs::NavSatStatusT> status{};
  double latitude = 0.0;
  double longitude = 0.0;
  double altitude = 0.0;
  std::vector<double> position_covariance{};
  uint8_t position_covariance_type = 0;
  NavSatFixT() = default;
  NavSatFixT(const NavSatFixT &o);
  NavSatFixT(NavSatFixT&&) FLATBUFFERS_NOEXCEPT = default;
  NavSatFixT &operator=(NavSatFixT o) FLATBUFFERS_NOEXCEPT;
};

struct NavSatFix FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NavSatFixT NativeTableType;
  typedef NavSatFixBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_STATUS = 8,
    VT_LATITUDE = 10,
    VT_LONGITUDE = 12,
    VT_ALTITUDE = 14,
    VT_POSITION_COVARIANCE = 16,
    VT_POSITION_COVARIANCE_TYPE = 18
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::sensor_msgs::NavSatStatus *status() const {
    return GetPointer<const fb::sensor_msgs::NavSatStatus *>(VT_STATUS);
  }
  double latitude() const {
    return GetField<double>(VT_LATITUDE, 0.0);
  }
  double longitude() const {
    return GetField<double>(VT_LONGITUDE, 0.0);
  }
  double altitude() const {
    return GetField<double>(VT_ALTITUDE, 0.0);
  }
  const ::flatbuffers::Vector<double> *position_covariance() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_POSITION_COVARIANCE);
  }
  uint8_t position_covariance_type() const {
    return GetField<uint8_t>(VT_POSITION_COVARIANCE_TYPE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_STATUS) &&
           verifier.VerifyTable(status()) &&
           VerifyField<double>(verifier, VT_LATITUDE, 8) &&
           VerifyField<double>(verifier, VT_LONGITUDE, 8) &&
           VerifyField<double>(verifier, VT_ALTITUDE, 8) &&
           VerifyOffsetRequired(verifier, VT_POSITION_COVARIANCE) &&
           verifier.VerifyVector(position_covariance()) &&
           VerifyField<uint8_t>(verifier, VT_POSITION_COVARIANCE_TYPE, 1) &&
           verifier.EndTable();
  }
  NavSatFixT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NavSatFixT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<NavSatFix> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NavSatFixT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NavSatFixBuilder {
  typedef NavSatFix Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(NavSatFix::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(NavSatFix::VT_HEADER, header);
  }
  void add_status(::flatbuffers::Offset<fb::sensor_msgs::NavSatStatus> status) {
    fbb_.AddOffset(NavSatFix::VT_STATUS, status);
  }
  void add_latitude(double latitude) {
    fbb_.AddElement<double>(NavSatFix::VT_LATITUDE, latitude, 0.0);
  }
  void add_longitude(double longitude) {
    fbb_.AddElement<double>(NavSatFix::VT_LONGITUDE, longitude, 0.0);
  }
  void add_altitude(double altitude) {
    fbb_.AddElement<double>(NavSatFix::VT_ALTITUDE, altitude, 0.0);
  }
  void add_position_covariance(::flatbuffers::Offset<::flatbuffers::Vector<double>> position_covariance) {
    fbb_.AddOffset(NavSatFix::VT_POSITION_COVARIANCE, position_covariance);
  }
  void add_position_covariance_type(uint8_t position_covariance_type) {
    fbb_.AddElement<uint8_t>(NavSatFix::VT_POSITION_COVARIANCE_TYPE, position_covariance_type, 0);
  }
  explicit NavSatFixBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NavSatFix> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NavSatFix>(end);
    fbb_.Required(o, NavSatFix::VT_HEADER);
    fbb_.Required(o, NavSatFix::VT_STATUS);
    fbb_.Required(o, NavSatFix::VT_POSITION_COVARIANCE);
    return o;
  }
};

inline ::flatbuffers::Offset<NavSatFix> CreateNavSatFix(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::sensor_msgs::NavSatStatus> status = 0,
    double latitude = 0.0,
    double longitude = 0.0,
    double altitude = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> position_covariance = 0,
    uint8_t position_covariance_type = 0) {
  NavSatFixBuilder builder_(_fbb);
  builder_.add_altitude(altitude);
  builder_.add_longitude(longitude);
  builder_.add_latitude(latitude);
  builder_.add_position_covariance(position_covariance);
  builder_.add_status(status);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  builder_.add_position_covariance_type(position_covariance_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NavSatFix> CreateNavSatFixDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::sensor_msgs::NavSatStatus> status = 0,
    double latitude = 0.0,
    double longitude = 0.0,
    double altitude = 0.0,
    const std::vector<double> *position_covariance = nullptr,
    uint8_t position_covariance_type = 0) {
  auto position_covariance__ = position_covariance ? _fbb.CreateVector<double>(*position_covariance) : 0;
  return fb::sensor_msgs::CreateNavSatFix(
      _fbb,
      __metadata,
      header,
      status,
      latitude,
      longitude,
      altitude,
      position_covariance__,
      position_covariance_type);
}

::flatbuffers::Offset<NavSatFix> CreateNavSatFix(::flatbuffers::FlatBufferBuilder &_fbb, const NavSatFixT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ImuT : public ::flatbuffers::NativeTable {
  typedef Imu TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::geometry_msgs::QuaternionT> orientation{};
  std::vector<double> orientation_covariance{};
  std::unique_ptr<fb::geometry_msgs::Vector3T> angular_velocity{};
  std::vector<double> angular_velocity_covariance{};
  std::unique_ptr<fb::geometry_msgs::Vector3T> linear_acceleration{};
  std::vector<double> linear_acceleration_covariance{};
  ImuT() = default;
  ImuT(const ImuT &o);
  ImuT(ImuT&&) FLATBUFFERS_NOEXCEPT = default;
  ImuT &operator=(ImuT o) FLATBUFFERS_NOEXCEPT;
};

struct Imu FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ImuT NativeTableType;
  typedef ImuBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_ORIENTATION = 8,
    VT_ORIENTATION_COVARIANCE = 10,
    VT_ANGULAR_VELOCITY = 12,
    VT_ANGULAR_VELOCITY_COVARIANCE = 14,
    VT_LINEAR_ACCELERATION = 16,
    VT_LINEAR_ACCELERATION_COVARIANCE = 18
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geometry_msgs::Quaternion *orientation() const {
    return GetPointer<const fb::geometry_msgs::Quaternion *>(VT_ORIENTATION);
  }
  const ::flatbuffers::Vector<double> *orientation_covariance() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_ORIENTATION_COVARIANCE);
  }
  const fb::geometry_msgs::Vector3 *angular_velocity() const {
    return GetPointer<const fb::geometry_msgs::Vector3 *>(VT_ANGULAR_VELOCITY);
  }
  const ::flatbuffers::Vector<double> *angular_velocity_covariance() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_ANGULAR_VELOCITY_COVARIANCE);
  }
  const fb::geometry_msgs::Vector3 *linear_acceleration() const {
    return GetPointer<const fb::geometry_msgs::Vector3 *>(VT_LINEAR_ACCELERATION);
  }
  const ::flatbuffers::Vector<double> *linear_acceleration_covariance() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_LINEAR_ACCELERATION_COVARIANCE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_ORIENTATION) &&
           verifier.VerifyTable(orientation()) &&
           VerifyOffsetRequired(verifier, VT_ORIENTATION_COVARIANCE) &&
           verifier.VerifyVector(orientation_covariance()) &&
           VerifyOffsetRequired(verifier, VT_ANGULAR_VELOCITY) &&
           verifier.VerifyTable(angular_velocity()) &&
           VerifyOffsetRequired(verifier, VT_ANGULAR_VELOCITY_COVARIANCE) &&
           verifier.VerifyVector(angular_velocity_covariance()) &&
           VerifyOffsetRequired(verifier, VT_LINEAR_ACCELERATION) &&
           verifier.VerifyTable(linear_acceleration()) &&
           VerifyOffsetRequired(verifier, VT_LINEAR_ACCELERATION_COVARIANCE) &&
           verifier.VerifyVector(linear_acceleration_covariance()) &&
           verifier.EndTable();
  }
  ImuT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ImuT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Imu> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ImuT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ImuBuilder {
  typedef Imu Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Imu::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(Imu::VT_HEADER, header);
  }
  void add_orientation(::flatbuffers::Offset<fb::geometry_msgs::Quaternion> orientation) {
    fbb_.AddOffset(Imu::VT_ORIENTATION, orientation);
  }
  void add_orientation_covariance(::flatbuffers::Offset<::flatbuffers::Vector<double>> orientation_covariance) {
    fbb_.AddOffset(Imu::VT_ORIENTATION_COVARIANCE, orientation_covariance);
  }
  void add_angular_velocity(::flatbuffers::Offset<fb::geometry_msgs::Vector3> angular_velocity) {
    fbb_.AddOffset(Imu::VT_ANGULAR_VELOCITY, angular_velocity);
  }
  void add_angular_velocity_covariance(::flatbuffers::Offset<::flatbuffers::Vector<double>> angular_velocity_covariance) {
    fbb_.AddOffset(Imu::VT_ANGULAR_VELOCITY_COVARIANCE, angular_velocity_covariance);
  }
  void add_linear_acceleration(::flatbuffers::Offset<fb::geometry_msgs::Vector3> linear_acceleration) {
    fbb_.AddOffset(Imu::VT_LINEAR_ACCELERATION, linear_acceleration);
  }
  void add_linear_acceleration_covariance(::flatbuffers::Offset<::flatbuffers::Vector<double>> linear_acceleration_covariance) {
    fbb_.AddOffset(Imu::VT_LINEAR_ACCELERATION_COVARIANCE, linear_acceleration_covariance);
  }
  explicit ImuBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Imu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Imu>(end);
    fbb_.Required(o, Imu::VT_HEADER);
    fbb_.Required(o, Imu::VT_ORIENTATION);
    fbb_.Required(o, Imu::VT_ORIENTATION_COVARIANCE);
    fbb_.Required(o, Imu::VT_ANGULAR_VELOCITY);
    fbb_.Required(o, Imu::VT_ANGULAR_VELOCITY_COVARIANCE);
    fbb_.Required(o, Imu::VT_LINEAR_ACCELERATION);
    fbb_.Required(o, Imu::VT_LINEAR_ACCELERATION_COVARIANCE);
    return o;
  }
};

inline ::flatbuffers::Offset<Imu> CreateImu(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Quaternion> orientation = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> orientation_covariance = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Vector3> angular_velocity = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> angular_velocity_covariance = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Vector3> linear_acceleration = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> linear_acceleration_covariance = 0) {
  ImuBuilder builder_(_fbb);
  builder_.add_linear_acceleration_covariance(linear_acceleration_covariance);
  builder_.add_linear_acceleration(linear_acceleration);
  builder_.add_angular_velocity_covariance(angular_velocity_covariance);
  builder_.add_angular_velocity(angular_velocity);
  builder_.add_orientation_covariance(orientation_covariance);
  builder_.add_orientation(orientation);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Imu> CreateImuDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Quaternion> orientation = 0,
    const std::vector<double> *orientation_covariance = nullptr,
    ::flatbuffers::Offset<fb::geometry_msgs::Vector3> angular_velocity = 0,
    const std::vector<double> *angular_velocity_covariance = nullptr,
    ::flatbuffers::Offset<fb::geometry_msgs::Vector3> linear_acceleration = 0,
    const std::vector<double> *linear_acceleration_covariance = nullptr) {
  auto orientation_covariance__ = orientation_covariance ? _fbb.CreateVector<double>(*orientation_covariance) : 0;
  auto angular_velocity_covariance__ = angular_velocity_covariance ? _fbb.CreateVector<double>(*angular_velocity_covariance) : 0;
  auto linear_acceleration_covariance__ = linear_acceleration_covariance ? _fbb.CreateVector<double>(*linear_acceleration_covariance) : 0;
  return fb::sensor_msgs::CreateImu(
      _fbb,
      __metadata,
      header,
      orientation,
      orientation_covariance__,
      angular_velocity,
      angular_velocity_covariance__,
      linear_acceleration,
      linear_acceleration_covariance__);
}

::flatbuffers::Offset<Imu> CreateImu(::flatbuffers::FlatBufferBuilder &_fbb, const ImuT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LaserScanT : public ::flatbuffers::NativeTable {
  typedef LaserScan TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  float angle_min = 0.0f;
  float angle_max = 0.0f;
  float angle_increment = 0.0f;
  float time_increment = 0.0f;
  float scan_time = 0.0f;
  float range_min = 0.0f;
  float range_max = 0.0f;
  std::vector<float> ranges{};
  std::vector<float> intensities{};
  LaserScanT() = default;
  LaserScanT(const LaserScanT &o);
  LaserScanT(LaserScanT&&) FLATBUFFERS_NOEXCEPT = default;
  LaserScanT &operator=(LaserScanT o) FLATBUFFERS_NOEXCEPT;
};

struct LaserScan FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LaserScanT NativeTableType;
  typedef LaserScanBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_ANGLE_MIN = 8,
    VT_ANGLE_MAX = 10,
    VT_ANGLE_INCREMENT = 12,
    VT_TIME_INCREMENT = 14,
    VT_SCAN_TIME = 16,
    VT_RANGE_MIN = 18,
    VT_RANGE_MAX = 20,
    VT_RANGES = 22,
    VT_INTENSITIES = 24
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  float angle_min() const {
    return GetField<float>(VT_ANGLE_MIN, 0.0f);
  }
  float angle_max() const {
    return GetField<float>(VT_ANGLE_MAX, 0.0f);
  }
  float angle_increment() const {
    return GetField<float>(VT_ANGLE_INCREMENT, 0.0f);
  }
  float time_increment() const {
    return GetField<float>(VT_TIME_INCREMENT, 0.0f);
  }
  float scan_time() const {
    return GetField<float>(VT_SCAN_TIME, 0.0f);
  }
  float range_min() const {
    return GetField<float>(VT_RANGE_MIN, 0.0f);
  }
  float range_max() const {
    return GetField<float>(VT_RANGE_MAX, 0.0f);
  }
  const ::flatbuffers::Vector<float> *ranges() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_RANGES);
  }
  const ::flatbuffers::Vector<float> *intensities() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_INTENSITIES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<float>(verifier, VT_ANGLE_MIN, 4) &&
           VerifyField<float>(verifier, VT_ANGLE_MAX, 4) &&
           VerifyField<float>(verifier, VT_ANGLE_INCREMENT, 4) &&
           VerifyField<float>(verifier, VT_TIME_INCREMENT, 4) &&
           VerifyField<float>(verifier, VT_SCAN_TIME, 4) &&
           VerifyField<float>(verifier, VT_RANGE_MIN, 4) &&
           VerifyField<float>(verifier, VT_RANGE_MAX, 4) &&
           VerifyOffsetRequired(verifier, VT_RANGES) &&
           verifier.VerifyVector(ranges()) &&
           VerifyOffsetRequired(verifier, VT_INTENSITIES) &&
           verifier.VerifyVector(intensities()) &&
           verifier.EndTable();
  }
  LaserScanT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LaserScanT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<LaserScan> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LaserScanT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LaserScanBuilder {
  typedef LaserScan Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(LaserScan::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(LaserScan::VT_HEADER, header);
  }
  void add_angle_min(float angle_min) {
    fbb_.AddElement<float>(LaserScan::VT_ANGLE_MIN, angle_min, 0.0f);
  }
  void add_angle_max(float angle_max) {
    fbb_.AddElement<float>(LaserScan::VT_ANGLE_MAX, angle_max, 0.0f);
  }
  void add_angle_increment(float angle_increment) {
    fbb_.AddElement<float>(LaserScan::VT_ANGLE_INCREMENT, angle_increment, 0.0f);
  }
  void add_time_increment(float time_increment) {
    fbb_.AddElement<float>(LaserScan::VT_TIME_INCREMENT, time_increment, 0.0f);
  }
  void add_scan_time(float scan_time) {
    fbb_.AddElement<float>(LaserScan::VT_SCAN_TIME, scan_time, 0.0f);
  }
  void add_range_min(float range_min) {
    fbb_.AddElement<float>(LaserScan::VT_RANGE_MIN, range_min, 0.0f);
  }
  void add_range_max(float range_max) {
    fbb_.AddElement<float>(LaserScan::VT_RANGE_MAX, range_max, 0.0f);
  }
  void add_ranges(::flatbuffers::Offset<::flatbuffers::Vector<float>> ranges) {
    fbb_.AddOffset(LaserScan::VT_RANGES, ranges);
  }
  void add_intensities(::flatbuffers::Offset<::flatbuffers::Vector<float>> intensities) {
    fbb_.AddOffset(LaserScan::VT_INTENSITIES, intensities);
  }
  explicit LaserScanBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LaserScan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LaserScan>(end);
    fbb_.Required(o, LaserScan::VT_HEADER);
    fbb_.Required(o, LaserScan::VT_RANGES);
    fbb_.Required(o, LaserScan::VT_INTENSITIES);
    return o;
  }
};

inline ::flatbuffers::Offset<LaserScan> CreateLaserScan(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    float angle_min = 0.0f,
    float angle_max = 0.0f,
    float angle_increment = 0.0f,
    float time_increment = 0.0f,
    float scan_time = 0.0f,
    float range_min = 0.0f,
    float range_max = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> ranges = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> intensities = 0) {
  LaserScanBuilder builder_(_fbb);
  builder_.add_intensities(intensities);
  builder_.add_ranges(ranges);
  builder_.add_range_max(range_max);
  builder_.add_range_min(range_min);
  builder_.add_scan_time(scan_time);
  builder_.add_time_increment(time_increment);
  builder_.add_angle_increment(angle_increment);
  builder_.add_angle_max(angle_max);
  builder_.add_angle_min(angle_min);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LaserScan> CreateLaserScanDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    float angle_min = 0.0f,
    float angle_max = 0.0f,
    float angle_increment = 0.0f,
    float time_increment = 0.0f,
    float scan_time = 0.0f,
    float range_min = 0.0f,
    float range_max = 0.0f,
    const std::vector<float> *ranges = nullptr,
    const std::vector<float> *intensities = nullptr) {
  auto ranges__ = ranges ? _fbb.CreateVector<float>(*ranges) : 0;
  auto intensities__ = intensities ? _fbb.CreateVector<float>(*intensities) : 0;
  return fb::sensor_msgs::CreateLaserScan(
      _fbb,
      __metadata,
      header,
      angle_min,
      angle_max,
      angle_increment,
      time_increment,
      scan_time,
      range_min,
      range_max,
      ranges__,
      intensities__);
}

::flatbuffers::Offset<LaserScan> CreateLaserScan(::flatbuffers::FlatBufferBuilder &_fbb, const LaserScanT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RelativeHumidityT : public ::flatbuffers::NativeTable {
  typedef RelativeHumidity TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  double relative_humidity = 0.0;
  double variance = 0.0;
  RelativeHumidityT() = default;
  RelativeHumidityT(const RelativeHumidityT &o);
  RelativeHumidityT(RelativeHumidityT&&) FLATBUFFERS_NOEXCEPT = default;
  RelativeHumidityT &operator=(RelativeHumidityT o) FLATBUFFERS_NOEXCEPT;
};

struct RelativeHumidity FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RelativeHumidityT NativeTableType;
  typedef RelativeHumidityBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_RELATIVE_HUMIDITY = 8,
    VT_VARIANCE = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  double relative_humidity() const {
    return GetField<double>(VT_RELATIVE_HUMIDITY, 0.0);
  }
  double variance() const {
    return GetField<double>(VT_VARIANCE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<double>(verifier, VT_RELATIVE_HUMIDITY, 8) &&
           VerifyField<double>(verifier, VT_VARIANCE, 8) &&
           verifier.EndTable();
  }
  RelativeHumidityT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RelativeHumidityT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RelativeHumidity> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RelativeHumidityT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RelativeHumidityBuilder {
  typedef RelativeHumidity Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(RelativeHumidity::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(RelativeHumidity::VT_HEADER, header);
  }
  void add_relative_humidity(double relative_humidity) {
    fbb_.AddElement<double>(RelativeHumidity::VT_RELATIVE_HUMIDITY, relative_humidity, 0.0);
  }
  void add_variance(double variance) {
    fbb_.AddElement<double>(RelativeHumidity::VT_VARIANCE, variance, 0.0);
  }
  explicit RelativeHumidityBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RelativeHumidity> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RelativeHumidity>(end);
    fbb_.Required(o, RelativeHumidity::VT_HEADER);
    return o;
  }
};

inline ::flatbuffers::Offset<RelativeHumidity> CreateRelativeHumidity(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    double relative_humidity = 0.0,
    double variance = 0.0) {
  RelativeHumidityBuilder builder_(_fbb);
  builder_.add_variance(variance);
  builder_.add_relative_humidity(relative_humidity);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<RelativeHumidity> CreateRelativeHumidity(::flatbuffers::FlatBufferBuilder &_fbb, const RelativeHumidityT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RangeT : public ::flatbuffers::NativeTable {
  typedef Range TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  uint8_t radiation_type = 0;
  float field_of_view = 0.0f;
  float min_range = 0.0f;
  float max_range = 0.0f;
  float range = 0.0f;
  RangeT() = default;
  RangeT(const RangeT &o);
  RangeT(RangeT&&) FLATBUFFERS_NOEXCEPT = default;
  RangeT &operator=(RangeT o) FLATBUFFERS_NOEXCEPT;
};

struct Range FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RangeT NativeTableType;
  typedef RangeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_RADIATION_TYPE = 8,
    VT_FIELD_OF_VIEW = 10,
    VT_MIN_RANGE = 12,
    VT_MAX_RANGE = 14,
    VT_RANGE = 16
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  uint8_t radiation_type() const {
    return GetField<uint8_t>(VT_RADIATION_TYPE, 0);
  }
  float field_of_view() const {
    return GetField<float>(VT_FIELD_OF_VIEW, 0.0f);
  }
  float min_range() const {
    return GetField<float>(VT_MIN_RANGE, 0.0f);
  }
  float max_range() const {
    return GetField<float>(VT_MAX_RANGE, 0.0f);
  }
  float range() const {
    return GetField<float>(VT_RANGE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<uint8_t>(verifier, VT_RADIATION_TYPE, 1) &&
           VerifyField<float>(verifier, VT_FIELD_OF_VIEW, 4) &&
           VerifyField<float>(verifier, VT_MIN_RANGE, 4) &&
           VerifyField<float>(verifier, VT_MAX_RANGE, 4) &&
           VerifyField<float>(verifier, VT_RANGE, 4) &&
           verifier.EndTable();
  }
  RangeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RangeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Range> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RangeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RangeBuilder {
  typedef Range Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Range::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(Range::VT_HEADER, header);
  }
  void add_radiation_type(uint8_t radiation_type) {
    fbb_.AddElement<uint8_t>(Range::VT_RADIATION_TYPE, radiation_type, 0);
  }
  void add_field_of_view(float field_of_view) {
    fbb_.AddElement<float>(Range::VT_FIELD_OF_VIEW, field_of_view, 0.0f);
  }
  void add_min_range(float min_range) {
    fbb_.AddElement<float>(Range::VT_MIN_RANGE, min_range, 0.0f);
  }
  void add_max_range(float max_range) {
    fbb_.AddElement<float>(Range::VT_MAX_RANGE, max_range, 0.0f);
  }
  void add_range(float range) {
    fbb_.AddElement<float>(Range::VT_RANGE, range, 0.0f);
  }
  explicit RangeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Range> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Range>(end);
    fbb_.Required(o, Range::VT_HEADER);
    return o;
  }
};

inline ::flatbuffers::Offset<Range> CreateRange(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    uint8_t radiation_type = 0,
    float field_of_view = 0.0f,
    float min_range = 0.0f,
    float max_range = 0.0f,
    float range = 0.0f) {
  RangeBuilder builder_(_fbb);
  builder_.add_range(range);
  builder_.add_max_range(max_range);
  builder_.add_min_range(min_range);
  builder_.add_field_of_view(field_of_view);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  builder_.add_radiation_type(radiation_type);
  return builder_.Finish();
}

::flatbuffers::Offset<Range> CreateRange(::flatbuffers::FlatBufferBuilder &_fbb, const RangeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline JointStateT::JointStateT(const JointStateT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        name(o.name),
        position(o.position),
        velocity(o.velocity),
        effort(o.effort) {
}

inline JointStateT &JointStateT::operator=(JointStateT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(name, o.name);
  std::swap(position, o.position);
  std::swap(velocity, o.velocity);
  std::swap(effort, o.effort);
  return *this;
}

inline JointStateT *JointState::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<JointStateT>(new JointStateT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void JointState::UnPackTo(JointStateT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = name(); if (_e) { _o->name.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->name[_i] = _e->Get(_i)->str(); } } else { _o->name.resize(0); } }
  { auto _e = position(); if (_e) { _o->position.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->position[_i] = _e->Get(_i); } } else { _o->position.resize(0); } }
  { auto _e = velocity(); if (_e) { _o->velocity.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->velocity[_i] = _e->Get(_i); } } else { _o->velocity.resize(0); } }
  { auto _e = effort(); if (_e) { _o->effort.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->effort[_i] = _e->Get(_i); } } else { _o->effort.resize(0); } }
}

inline ::flatbuffers::Offset<JointState> JointState::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const JointStateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateJointState(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<JointState> CreateJointState(::flatbuffers::FlatBufferBuilder &_fbb, const JointStateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const JointStateT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _name = _fbb.CreateVectorOfStrings(_o->name);
  auto _position = _fbb.CreateVector(_o->position);
  auto _velocity = _fbb.CreateVector(_o->velocity);
  auto _effort = _fbb.CreateVector(_o->effort);
  return fb::sensor_msgs::CreateJointState(
      _fbb,
      ___metadata,
      _header,
      _name,
      _position,
      _velocity,
      _effort);
}

inline PointFieldT::PointFieldT(const PointFieldT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        name(o.name),
        offset(o.offset),
        datatype(o.datatype),
        count(o.count) {
}

inline PointFieldT &PointFieldT::operator=(PointFieldT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(name, o.name);
  std::swap(offset, o.offset);
  std::swap(datatype, o.datatype);
  std::swap(count, o.count);
  return *this;
}

inline PointFieldT *PointField::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PointFieldT>(new PointFieldT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PointField::UnPackTo(PointFieldT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = offset(); _o->offset = _e; }
  { auto _e = datatype(); _o->datatype = _e; }
  { auto _e = count(); _o->count = _e; }
}

inline ::flatbuffers::Offset<PointField> PointField::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PointFieldT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePointField(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PointField> CreatePointField(::flatbuffers::FlatBufferBuilder &_fbb, const PointFieldT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PointFieldT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _name = _fbb.CreateString(_o->name);
  auto _offset = _o->offset;
  auto _datatype = _o->datatype;
  auto _count = _o->count;
  return fb::sensor_msgs::CreatePointField(
      _fbb,
      ___metadata,
      _name,
      _offset,
      _datatype,
      _count);
}

inline JoyT::JoyT(const JoyT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        axes(o.axes),
        buttons(o.buttons) {
}

inline JoyT &JoyT::operator=(JoyT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(axes, o.axes);
  std::swap(buttons, o.buttons);
  return *this;
}

inline JoyT *Joy::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<JoyT>(new JoyT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Joy::UnPackTo(JoyT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = axes(); if (_e) { _o->axes.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->axes[_i] = _e->Get(_i); } } else { _o->axes.resize(0); } }
  { auto _e = buttons(); if (_e) { _o->buttons.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->buttons[_i] = _e->Get(_i); } } else { _o->buttons.resize(0); } }
}

inline ::flatbuffers::Offset<Joy> Joy::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const JoyT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateJoy(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Joy> CreateJoy(::flatbuffers::FlatBufferBuilder &_fbb, const JoyT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const JoyT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _axes = _fbb.CreateVector(_o->axes);
  auto _buttons = _fbb.CreateVector(_o->buttons);
  return fb::sensor_msgs::CreateJoy(
      _fbb,
      ___metadata,
      _header,
      _axes,
      _buttons);
}

inline BatteryStateT::BatteryStateT(const BatteryStateT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        voltage(o.voltage),
        temperature(o.temperature),
        current(o.current),
        charge(o.charge),
        capacity(o.capacity),
        design_capacity(o.design_capacity),
        percentage(o.percentage),
        power_supply_status(o.power_supply_status),
        power_supply_health(o.power_supply_health),
        power_supply_technology(o.power_supply_technology),
        present(o.present),
        cell_voltage(o.cell_voltage),
        cell_temperature(o.cell_temperature),
        location(o.location),
        serial_number(o.serial_number) {
}

inline BatteryStateT &BatteryStateT::operator=(BatteryStateT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(voltage, o.voltage);
  std::swap(temperature, o.temperature);
  std::swap(current, o.current);
  std::swap(charge, o.charge);
  std::swap(capacity, o.capacity);
  std::swap(design_capacity, o.design_capacity);
  std::swap(percentage, o.percentage);
  std::swap(power_supply_status, o.power_supply_status);
  std::swap(power_supply_health, o.power_supply_health);
  std::swap(power_supply_technology, o.power_supply_technology);
  std::swap(present, o.present);
  std::swap(cell_voltage, o.cell_voltage);
  std::swap(cell_temperature, o.cell_temperature);
  std::swap(location, o.location);
  std::swap(serial_number, o.serial_number);
  return *this;
}

inline BatteryStateT *BatteryState::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BatteryStateT>(new BatteryStateT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BatteryState::UnPackTo(BatteryStateT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = voltage(); _o->voltage = _e; }
  { auto _e = temperature(); _o->temperature = _e; }
  { auto _e = current(); _o->current = _e; }
  { auto _e = charge(); _o->charge = _e; }
  { auto _e = capacity(); _o->capacity = _e; }
  { auto _e = design_capacity(); _o->design_capacity = _e; }
  { auto _e = percentage(); _o->percentage = _e; }
  { auto _e = power_supply_status(); _o->power_supply_status = _e; }
  { auto _e = power_supply_health(); _o->power_supply_health = _e; }
  { auto _e = power_supply_technology(); _o->power_supply_technology = _e; }
  { auto _e = present(); _o->present = _e; }
  { auto _e = cell_voltage(); if (_e) { _o->cell_voltage.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->cell_voltage[_i] = _e->Get(_i); } } else { _o->cell_voltage.resize(0); } }
  { auto _e = cell_temperature(); if (_e) { _o->cell_temperature.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->cell_temperature[_i] = _e->Get(_i); } } else { _o->cell_temperature.resize(0); } }
  { auto _e = location(); if (_e) _o->location = _e->str(); }
  { auto _e = serial_number(); if (_e) _o->serial_number = _e->str(); }
}

inline ::flatbuffers::Offset<BatteryState> BatteryState::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BatteryStateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBatteryState(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BatteryState> CreateBatteryState(::flatbuffers::FlatBufferBuilder &_fbb, const BatteryStateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BatteryStateT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _voltage = _o->voltage;
  auto _temperature = _o->temperature;
  auto _current = _o->current;
  auto _charge = _o->charge;
  auto _capacity = _o->capacity;
  auto _design_capacity = _o->design_capacity;
  auto _percentage = _o->percentage;
  auto _power_supply_status = _o->power_supply_status;
  auto _power_supply_health = _o->power_supply_health;
  auto _power_supply_technology = _o->power_supply_technology;
  auto _present = _o->present;
  auto _cell_voltage = _fbb.CreateVector(_o->cell_voltage);
  auto _cell_temperature = _fbb.CreateVector(_o->cell_temperature);
  auto _location = _fbb.CreateString(_o->location);
  auto _serial_number = _fbb.CreateString(_o->serial_number);
  return fb::sensor_msgs::CreateBatteryState(
      _fbb,
      ___metadata,
      _header,
      _voltage,
      _temperature,
      _current,
      _charge,
      _capacity,
      _design_capacity,
      _percentage,
      _power_supply_status,
      _power_supply_health,
      _power_supply_technology,
      _present,
      _cell_voltage,
      _cell_temperature,
      _location,
      _serial_number);
}

inline CameraInfoT::CameraInfoT(const CameraInfoT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        height(o.height),
        width(o.width),
        distortion_model(o.distortion_model),
        d(o.d),
        k(o.k),
        r(o.r),
        p(o.p),
        binning_x(o.binning_x),
        binning_y(o.binning_y),
        roi((o.roi) ? new fb::sensor_msgs::RegionOfInterestT(*o.roi) : nullptr) {
}

inline CameraInfoT &CameraInfoT::operator=(CameraInfoT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(height, o.height);
  std::swap(width, o.width);
  std::swap(distortion_model, o.distortion_model);
  std::swap(d, o.d);
  std::swap(k, o.k);
  std::swap(r, o.r);
  std::swap(p, o.p);
  std::swap(binning_x, o.binning_x);
  std::swap(binning_y, o.binning_y);
  std::swap(roi, o.roi);
  return *this;
}

inline CameraInfoT *CameraInfo::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CameraInfoT>(new CameraInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CameraInfo::UnPackTo(CameraInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = height(); _o->height = _e; }
  { auto _e = width(); _o->width = _e; }
  { auto _e = distortion_model(); if (_e) _o->distortion_model = _e->str(); }
  { auto _e = d(); if (_e) { _o->d.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->d[_i] = _e->Get(_i); } } else { _o->d.resize(0); } }
  { auto _e = k(); if (_e) { _o->k.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->k[_i] = _e->Get(_i); } } else { _o->k.resize(0); } }
  { auto _e = r(); if (_e) { _o->r.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->r[_i] = _e->Get(_i); } } else { _o->r.resize(0); } }
  { auto _e = p(); if (_e) { _o->p.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->p[_i] = _e->Get(_i); } } else { _o->p.resize(0); } }
  { auto _e = binning_x(); _o->binning_x = _e; }
  { auto _e = binning_y(); _o->binning_y = _e; }
  { auto _e = roi(); if (_e) { if(_o->roi) { _e->UnPackTo(_o->roi.get(), _resolver); } else { _o->roi = std::unique_ptr<fb::sensor_msgs::RegionOfInterestT>(_e->UnPack(_resolver)); } } else if (_o->roi) { _o->roi.reset(); } }
}

inline ::flatbuffers::Offset<CameraInfo> CameraInfo::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CameraInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCameraInfo(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CameraInfo> CreateCameraInfo(::flatbuffers::FlatBufferBuilder &_fbb, const CameraInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CameraInfoT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _height = _o->height;
  auto _width = _o->width;
  auto _distortion_model = _fbb.CreateString(_o->distortion_model);
  auto _d = _fbb.CreateVector(_o->d);
  auto _k = _fbb.CreateVector(_o->k);
  auto _r = _fbb.CreateVector(_o->r);
  auto _p = _fbb.CreateVector(_o->p);
  auto _binning_x = _o->binning_x;
  auto _binning_y = _o->binning_y;
  auto _roi = _o->roi ? CreateRegionOfInterest(_fbb, _o->roi.get(), _rehasher) : 0;
  return fb::sensor_msgs::CreateCameraInfo(
      _fbb,
      ___metadata,
      _header,
      _height,
      _width,
      _distortion_model,
      _d,
      _k,
      _r,
      _p,
      _binning_x,
      _binning_y,
      _roi);
}

inline TimeReferenceT::TimeReferenceT(const TimeReferenceT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        time_ref((o.time_ref) ? new fb::RosTime(*o.time_ref) : nullptr),
        source(o.source) {
}

inline TimeReferenceT &TimeReferenceT::operator=(TimeReferenceT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(time_ref, o.time_ref);
  std::swap(source, o.source);
  return *this;
}

inline TimeReferenceT *TimeReference::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TimeReferenceT>(new TimeReferenceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TimeReference::UnPackTo(TimeReferenceT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = time_ref(); if (_e) _o->time_ref = std::unique_ptr<fb::RosTime>(new fb::RosTime(*_e)); }
  { auto _e = source(); if (_e) _o->source = _e->str(); }
}

inline ::flatbuffers::Offset<TimeReference> TimeReference::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TimeReferenceT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTimeReference(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TimeReference> CreateTimeReference(::flatbuffers::FlatBufferBuilder &_fbb, const TimeReferenceT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TimeReferenceT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _time_ref = _o->time_ref ? _o->time_ref.get() : nullptr;
  auto _source = _fbb.CreateString(_o->source);
  return fb::sensor_msgs::CreateTimeReference(
      _fbb,
      ___metadata,
      _header,
      _time_ref,
      _source);
}

inline LaserEchoT::LaserEchoT(const LaserEchoT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        echoes(o.echoes) {
}

inline LaserEchoT &LaserEchoT::operator=(LaserEchoT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(echoes, o.echoes);
  return *this;
}

inline LaserEchoT *LaserEcho::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LaserEchoT>(new LaserEchoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LaserEcho::UnPackTo(LaserEchoT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = echoes(); if (_e) { _o->echoes.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->echoes[_i] = _e->Get(_i); } } else { _o->echoes.resize(0); } }
}

inline ::flatbuffers::Offset<LaserEcho> LaserEcho::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LaserEchoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLaserEcho(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<LaserEcho> CreateLaserEcho(::flatbuffers::FlatBufferBuilder &_fbb, const LaserEchoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LaserEchoT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _echoes = _fbb.CreateVector(_o->echoes);
  return fb::sensor_msgs::CreateLaserEcho(
      _fbb,
      ___metadata,
      _echoes);
}

inline IlluminanceT::IlluminanceT(const IlluminanceT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        illuminance(o.illuminance),
        variance(o.variance) {
}

inline IlluminanceT &IlluminanceT::operator=(IlluminanceT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(illuminance, o.illuminance);
  std::swap(variance, o.variance);
  return *this;
}

inline IlluminanceT *Illuminance::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<IlluminanceT>(new IlluminanceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Illuminance::UnPackTo(IlluminanceT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = illuminance(); _o->illuminance = _e; }
  { auto _e = variance(); _o->variance = _e; }
}

inline ::flatbuffers::Offset<Illuminance> Illuminance::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const IlluminanceT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIlluminance(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Illuminance> CreateIlluminance(::flatbuffers::FlatBufferBuilder &_fbb, const IlluminanceT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const IlluminanceT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _illuminance = _o->illuminance;
  auto _variance = _o->variance;
  return fb::sensor_msgs::CreateIlluminance(
      _fbb,
      ___metadata,
      _header,
      _illuminance,
      _variance);
}

inline MultiDOFJointStateT::MultiDOFJointStateT(const MultiDOFJointStateT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        joint_names(o.joint_names) {
  transforms.reserve(o.transforms.size());
  for (const auto &transforms_ : o.transforms) { transforms.emplace_back((transforms_) ? new fb::geometry_msgs::TransformT(*transforms_) : nullptr); }
  twist.reserve(o.twist.size());
  for (const auto &twist_ : o.twist) { twist.emplace_back((twist_) ? new fb::geometry_msgs::TwistT(*twist_) : nullptr); }
  wrench.reserve(o.wrench.size());
  for (const auto &wrench_ : o.wrench) { wrench.emplace_back((wrench_) ? new fb::geometry_msgs::WrenchT(*wrench_) : nullptr); }
}

inline MultiDOFJointStateT &MultiDOFJointStateT::operator=(MultiDOFJointStateT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(joint_names, o.joint_names);
  std::swap(transforms, o.transforms);
  std::swap(twist, o.twist);
  std::swap(wrench, o.wrench);
  return *this;
}

inline MultiDOFJointStateT *MultiDOFJointState::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MultiDOFJointStateT>(new MultiDOFJointStateT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MultiDOFJointState::UnPackTo(MultiDOFJointStateT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = joint_names(); if (_e) { _o->joint_names.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->joint_names[_i] = _e->Get(_i)->str(); } } else { _o->joint_names.resize(0); } }
  { auto _e = transforms(); if (_e) { _o->transforms.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->transforms[_i]) { _e->Get(_i)->UnPackTo(_o->transforms[_i].get(), _resolver); } else { _o->transforms[_i] = std::unique_ptr<fb::geometry_msgs::TransformT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->transforms.resize(0); } }
  { auto _e = twist(); if (_e) { _o->twist.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->twist[_i]) { _e->Get(_i)->UnPackTo(_o->twist[_i].get(), _resolver); } else { _o->twist[_i] = std::unique_ptr<fb::geometry_msgs::TwistT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->twist.resize(0); } }
  { auto _e = wrench(); if (_e) { _o->wrench.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->wrench[_i]) { _e->Get(_i)->UnPackTo(_o->wrench[_i].get(), _resolver); } else { _o->wrench[_i] = std::unique_ptr<fb::geometry_msgs::WrenchT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->wrench.resize(0); } }
}

inline ::flatbuffers::Offset<MultiDOFJointState> MultiDOFJointState::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MultiDOFJointStateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMultiDOFJointState(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<MultiDOFJointState> CreateMultiDOFJointState(::flatbuffers::FlatBufferBuilder &_fbb, const MultiDOFJointStateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MultiDOFJointStateT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _joint_names = _fbb.CreateVectorOfStrings(_o->joint_names);
  auto _transforms = _fbb.CreateVector<::flatbuffers::Offset<fb::geometry_msgs::Transform>> (_o->transforms.size(), [](size_t i, _VectorArgs *__va) { return CreateTransform(*__va->__fbb, __va->__o->transforms[i].get(), __va->__rehasher); }, &_va );
  auto _twist = _fbb.CreateVector<::flatbuffers::Offset<fb::geometry_msgs::Twist>> (_o->twist.size(), [](size_t i, _VectorArgs *__va) { return CreateTwist(*__va->__fbb, __va->__o->twist[i].get(), __va->__rehasher); }, &_va );
  auto _wrench = _fbb.CreateVector<::flatbuffers::Offset<fb::geometry_msgs::Wrench>> (_o->wrench.size(), [](size_t i, _VectorArgs *__va) { return CreateWrench(*__va->__fbb, __va->__o->wrench[i].get(), __va->__rehasher); }, &_va );
  return fb::sensor_msgs::CreateMultiDOFJointState(
      _fbb,
      ___metadata,
      _header,
      _joint_names,
      _transforms,
      _twist,
      _wrench);
}

inline MagneticFieldT::MagneticFieldT(const MagneticFieldT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        magnetic_field((o.magnetic_field) ? new fb::geometry_msgs::Vector3T(*o.magnetic_field) : nullptr),
        magnetic_field_covariance(o.magnetic_field_covariance) {
}

inline MagneticFieldT &MagneticFieldT::operator=(MagneticFieldT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(magnetic_field, o.magnetic_field);
  std::swap(magnetic_field_covariance, o.magnetic_field_covariance);
  return *this;
}

inline MagneticFieldT *MagneticField::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MagneticFieldT>(new MagneticFieldT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MagneticField::UnPackTo(MagneticFieldT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = magnetic_field(); if (_e) { if(_o->magnetic_field) { _e->UnPackTo(_o->magnetic_field.get(), _resolver); } else { _o->magnetic_field = std::unique_ptr<fb::geometry_msgs::Vector3T>(_e->UnPack(_resolver)); } } else if (_o->magnetic_field) { _o->magnetic_field.reset(); } }
  { auto _e = magnetic_field_covariance(); if (_e) { _o->magnetic_field_covariance.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->magnetic_field_covariance[_i] = _e->Get(_i); } } else { _o->magnetic_field_covariance.resize(0); } }
}

inline ::flatbuffers::Offset<MagneticField> MagneticField::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MagneticFieldT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMagneticField(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<MagneticField> CreateMagneticField(::flatbuffers::FlatBufferBuilder &_fbb, const MagneticFieldT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MagneticFieldT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _magnetic_field = _o->magnetic_field ? CreateVector3(_fbb, _o->magnetic_field.get(), _rehasher) : 0;
  auto _magnetic_field_covariance = _fbb.CreateVector(_o->magnetic_field_covariance);
  return fb::sensor_msgs::CreateMagneticField(
      _fbb,
      ___metadata,
      _header,
      _magnetic_field,
      _magnetic_field_covariance);
}

inline CompressedImageT::CompressedImageT(const CompressedImageT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        format(o.format),
        data(o.data) {
}

inline CompressedImageT &CompressedImageT::operator=(CompressedImageT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(format, o.format);
  std::swap(data, o.data);
  return *this;
}

inline CompressedImageT *CompressedImage::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CompressedImageT>(new CompressedImageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CompressedImage::UnPackTo(CompressedImageT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = format(); if (_e) _o->format = _e->str(); }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
}

inline ::flatbuffers::Offset<CompressedImage> CompressedImage::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CompressedImageT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCompressedImage(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CompressedImage> CreateCompressedImage(::flatbuffers::FlatBufferBuilder &_fbb, const CompressedImageT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CompressedImageT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _format = _fbb.CreateString(_o->format);
  auto _data = _fbb.CreateVector(_o->data);
  return fb::sensor_msgs::CreateCompressedImage(
      _fbb,
      ___metadata,
      _header,
      _format,
      _data);
}

inline NavSatStatusT::NavSatStatusT(const NavSatStatusT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        status(o.status),
        service(o.service) {
}

inline NavSatStatusT &NavSatStatusT::operator=(NavSatStatusT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(status, o.status);
  std::swap(service, o.service);
  return *this;
}

inline NavSatStatusT *NavSatStatus::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NavSatStatusT>(new NavSatStatusT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NavSatStatus::UnPackTo(NavSatStatusT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = status(); _o->status = _e; }
  { auto _e = service(); _o->service = _e; }
}

inline ::flatbuffers::Offset<NavSatStatus> NavSatStatus::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NavSatStatusT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNavSatStatus(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<NavSatStatus> CreateNavSatStatus(::flatbuffers::FlatBufferBuilder &_fbb, const NavSatStatusT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NavSatStatusT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _status = _o->status;
  auto _service = _o->service;
  return fb::sensor_msgs::CreateNavSatStatus(
      _fbb,
      ___metadata,
      _status,
      _service);
}

inline PointCloud2T::PointCloud2T(const PointCloud2T &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        height(o.height),
        width(o.width),
        is_bigendian(o.is_bigendian),
        point_step(o.point_step),
        row_step(o.row_step),
        data(o.data),
        is_dense(o.is_dense) {
  fields.reserve(o.fields.size());
  for (const auto &fields_ : o.fields) { fields.emplace_back((fields_) ? new fb::sensor_msgs::PointFieldT(*fields_) : nullptr); }
}

inline PointCloud2T &PointCloud2T::operator=(PointCloud2T o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(height, o.height);
  std::swap(width, o.width);
  std::swap(fields, o.fields);
  std::swap(is_bigendian, o.is_bigendian);
  std::swap(point_step, o.point_step);
  std::swap(row_step, o.row_step);
  std::swap(data, o.data);
  std::swap(is_dense, o.is_dense);
  return *this;
}

inline PointCloud2T *PointCloud2::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PointCloud2T>(new PointCloud2T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PointCloud2::UnPackTo(PointCloud2T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = height(); _o->height = _e; }
  { auto _e = width(); _o->width = _e; }
  { auto _e = fields(); if (_e) { _o->fields.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->fields[_i]) { _e->Get(_i)->UnPackTo(_o->fields[_i].get(), _resolver); } else { _o->fields[_i] = std::unique_ptr<fb::sensor_msgs::PointFieldT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->fields.resize(0); } }
  { auto _e = is_bigendian(); _o->is_bigendian = _e; }
  { auto _e = point_step(); _o->point_step = _e; }
  { auto _e = row_step(); _o->row_step = _e; }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
  { auto _e = is_dense(); _o->is_dense = _e; }
}

inline ::flatbuffers::Offset<PointCloud2> PointCloud2::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PointCloud2T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePointCloud2(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PointCloud2> CreatePointCloud2(::flatbuffers::FlatBufferBuilder &_fbb, const PointCloud2T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PointCloud2T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _height = _o->height;
  auto _width = _o->width;
  auto _fields = _fbb.CreateVector<::flatbuffers::Offset<fb::sensor_msgs::PointField>> (_o->fields.size(), [](size_t i, _VectorArgs *__va) { return CreatePointField(*__va->__fbb, __va->__o->fields[i].get(), __va->__rehasher); }, &_va );
  auto _is_bigendian = _o->is_bigendian;
  auto _point_step = _o->point_step;
  auto _row_step = _o->row_step;
  auto _data = _fbb.CreateVector(_o->data);
  auto _is_dense = _o->is_dense;
  return fb::sensor_msgs::CreatePointCloud2(
      _fbb,
      ___metadata,
      _header,
      _height,
      _width,
      _fields,
      _is_bigendian,
      _point_step,
      _row_step,
      _data,
      _is_dense);
}

inline FluidPressureT::FluidPressureT(const FluidPressureT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        fluid_pressure(o.fluid_pressure),
        variance(o.variance) {
}

inline FluidPressureT &FluidPressureT::operator=(FluidPressureT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(fluid_pressure, o.fluid_pressure);
  std::swap(variance, o.variance);
  return *this;
}

inline FluidPressureT *FluidPressure::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FluidPressureT>(new FluidPressureT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FluidPressure::UnPackTo(FluidPressureT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = fluid_pressure(); _o->fluid_pressure = _e; }
  { auto _e = variance(); _o->variance = _e; }
}

inline ::flatbuffers::Offset<FluidPressure> FluidPressure::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FluidPressureT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFluidPressure(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FluidPressure> CreateFluidPressure(::flatbuffers::FlatBufferBuilder &_fbb, const FluidPressureT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FluidPressureT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _fluid_pressure = _o->fluid_pressure;
  auto _variance = _o->variance;
  return fb::sensor_msgs::CreateFluidPressure(
      _fbb,
      ___metadata,
      _header,
      _fluid_pressure,
      _variance);
}

inline JoyFeedbackArrayT::JoyFeedbackArrayT(const JoyFeedbackArrayT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr) {
  array.reserve(o.array.size());
  for (const auto &array_ : o.array) { array.emplace_back((array_) ? new fb::sensor_msgs::JoyFeedbackT(*array_) : nullptr); }
}

inline JoyFeedbackArrayT &JoyFeedbackArrayT::operator=(JoyFeedbackArrayT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(array, o.array);
  return *this;
}

inline JoyFeedbackArrayT *JoyFeedbackArray::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<JoyFeedbackArrayT>(new JoyFeedbackArrayT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void JoyFeedbackArray::UnPackTo(JoyFeedbackArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = array(); if (_e) { _o->array.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->array[_i]) { _e->Get(_i)->UnPackTo(_o->array[_i].get(), _resolver); } else { _o->array[_i] = std::unique_ptr<fb::sensor_msgs::JoyFeedbackT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->array.resize(0); } }
}

inline ::flatbuffers::Offset<JoyFeedbackArray> JoyFeedbackArray::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const JoyFeedbackArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateJoyFeedbackArray(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<JoyFeedbackArray> CreateJoyFeedbackArray(::flatbuffers::FlatBufferBuilder &_fbb, const JoyFeedbackArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const JoyFeedbackArrayT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _array = _fbb.CreateVector<::flatbuffers::Offset<fb::sensor_msgs::JoyFeedback>> (_o->array.size(), [](size_t i, _VectorArgs *__va) { return CreateJoyFeedback(*__va->__fbb, __va->__o->array[i].get(), __va->__rehasher); }, &_va );
  return fb::sensor_msgs::CreateJoyFeedbackArray(
      _fbb,
      ___metadata,
      _array);
}

inline MultiEchoLaserScanT::MultiEchoLaserScanT(const MultiEchoLaserScanT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        angle_min(o.angle_min),
        angle_max(o.angle_max),
        angle_increment(o.angle_increment),
        time_increment(o.time_increment),
        scan_time(o.scan_time),
        range_min(o.range_min),
        range_max(o.range_max) {
  ranges.reserve(o.ranges.size());
  for (const auto &ranges_ : o.ranges) { ranges.emplace_back((ranges_) ? new fb::sensor_msgs::LaserEchoT(*ranges_) : nullptr); }
  intensities.reserve(o.intensities.size());
  for (const auto &intensities_ : o.intensities) { intensities.emplace_back((intensities_) ? new fb::sensor_msgs::LaserEchoT(*intensities_) : nullptr); }
}

inline MultiEchoLaserScanT &MultiEchoLaserScanT::operator=(MultiEchoLaserScanT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(angle_min, o.angle_min);
  std::swap(angle_max, o.angle_max);
  std::swap(angle_increment, o.angle_increment);
  std::swap(time_increment, o.time_increment);
  std::swap(scan_time, o.scan_time);
  std::swap(range_min, o.range_min);
  std::swap(range_max, o.range_max);
  std::swap(ranges, o.ranges);
  std::swap(intensities, o.intensities);
  return *this;
}

inline MultiEchoLaserScanT *MultiEchoLaserScan::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MultiEchoLaserScanT>(new MultiEchoLaserScanT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MultiEchoLaserScan::UnPackTo(MultiEchoLaserScanT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = angle_min(); _o->angle_min = _e; }
  { auto _e = angle_max(); _o->angle_max = _e; }
  { auto _e = angle_increment(); _o->angle_increment = _e; }
  { auto _e = time_increment(); _o->time_increment = _e; }
  { auto _e = scan_time(); _o->scan_time = _e; }
  { auto _e = range_min(); _o->range_min = _e; }
  { auto _e = range_max(); _o->range_max = _e; }
  { auto _e = ranges(); if (_e) { _o->ranges.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->ranges[_i]) { _e->Get(_i)->UnPackTo(_o->ranges[_i].get(), _resolver); } else { _o->ranges[_i] = std::unique_ptr<fb::sensor_msgs::LaserEchoT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->ranges.resize(0); } }
  { auto _e = intensities(); if (_e) { _o->intensities.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->intensities[_i]) { _e->Get(_i)->UnPackTo(_o->intensities[_i].get(), _resolver); } else { _o->intensities[_i] = std::unique_ptr<fb::sensor_msgs::LaserEchoT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->intensities.resize(0); } }
}

inline ::flatbuffers::Offset<MultiEchoLaserScan> MultiEchoLaserScan::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MultiEchoLaserScanT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMultiEchoLaserScan(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<MultiEchoLaserScan> CreateMultiEchoLaserScan(::flatbuffers::FlatBufferBuilder &_fbb, const MultiEchoLaserScanT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MultiEchoLaserScanT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _angle_min = _o->angle_min;
  auto _angle_max = _o->angle_max;
  auto _angle_increment = _o->angle_increment;
  auto _time_increment = _o->time_increment;
  auto _scan_time = _o->scan_time;
  auto _range_min = _o->range_min;
  auto _range_max = _o->range_max;
  auto _ranges = _fbb.CreateVector<::flatbuffers::Offset<fb::sensor_msgs::LaserEcho>> (_o->ranges.size(), [](size_t i, _VectorArgs *__va) { return CreateLaserEcho(*__va->__fbb, __va->__o->ranges[i].get(), __va->__rehasher); }, &_va );
  auto _intensities = _fbb.CreateVector<::flatbuffers::Offset<fb::sensor_msgs::LaserEcho>> (_o->intensities.size(), [](size_t i, _VectorArgs *__va) { return CreateLaserEcho(*__va->__fbb, __va->__o->intensities[i].get(), __va->__rehasher); }, &_va );
  return fb::sensor_msgs::CreateMultiEchoLaserScan(
      _fbb,
      ___metadata,
      _header,
      _angle_min,
      _angle_max,
      _angle_increment,
      _time_increment,
      _scan_time,
      _range_min,
      _range_max,
      _ranges,
      _intensities);
}

inline PointCloudT::PointCloudT(const PointCloudT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr) {
  points.reserve(o.points.size());
  for (const auto &points_ : o.points) { points.emplace_back((points_) ? new fb::geometry_msgs::Point32T(*points_) : nullptr); }
  channels.reserve(o.channels.size());
  for (const auto &channels_ : o.channels) { channels.emplace_back((channels_) ? new fb::sensor_msgs::ChannelFloat32T(*channels_) : nullptr); }
}

inline PointCloudT &PointCloudT::operator=(PointCloudT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(points, o.points);
  std::swap(channels, o.channels);
  return *this;
}

inline PointCloudT *PointCloud::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PointCloudT>(new PointCloudT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PointCloud::UnPackTo(PointCloudT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = points(); if (_e) { _o->points.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->points[_i]) { _e->Get(_i)->UnPackTo(_o->points[_i].get(), _resolver); } else { _o->points[_i] = std::unique_ptr<fb::geometry_msgs::Point32T>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->points.resize(0); } }
  { auto _e = channels(); if (_e) { _o->channels.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->channels[_i]) { _e->Get(_i)->UnPackTo(_o->channels[_i].get(), _resolver); } else { _o->channels[_i] = std::unique_ptr<fb::sensor_msgs::ChannelFloat32T>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->channels.resize(0); } }
}

inline ::flatbuffers::Offset<PointCloud> PointCloud::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PointCloudT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePointCloud(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PointCloud> CreatePointCloud(::flatbuffers::FlatBufferBuilder &_fbb, const PointCloudT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PointCloudT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _points = _fbb.CreateVector<::flatbuffers::Offset<fb::geometry_msgs::Point32>> (_o->points.size(), [](size_t i, _VectorArgs *__va) { return CreatePoint32(*__va->__fbb, __va->__o->points[i].get(), __va->__rehasher); }, &_va );
  auto _channels = _fbb.CreateVector<::flatbuffers::Offset<fb::sensor_msgs::ChannelFloat32>> (_o->channels.size(), [](size_t i, _VectorArgs *__va) { return CreateChannelFloat32(*__va->__fbb, __va->__o->channels[i].get(), __va->__rehasher); }, &_va );
  return fb::sensor_msgs::CreatePointCloud(
      _fbb,
      ___metadata,
      _header,
      _points,
      _channels);
}

inline ImageT::ImageT(const ImageT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        height(o.height),
        width(o.width),
        encoding(o.encoding),
        is_bigendian(o.is_bigendian),
        step(o.step),
        data(o.data) {
}

inline ImageT &ImageT::operator=(ImageT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(height, o.height);
  std::swap(width, o.width);
  std::swap(encoding, o.encoding);
  std::swap(is_bigendian, o.is_bigendian);
  std::swap(step, o.step);
  std::swap(data, o.data);
  return *this;
}

inline ImageT *Image::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ImageT>(new ImageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Image::UnPackTo(ImageT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = height(); _o->height = _e; }
  { auto _e = width(); _o->width = _e; }
  { auto _e = encoding(); if (_e) _o->encoding = _e->str(); }
  { auto _e = is_bigendian(); _o->is_bigendian = _e; }
  { auto _e = step(); _o->step = _e; }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
}

inline ::flatbuffers::Offset<Image> Image::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ImageT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateImage(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Image> CreateImage(::flatbuffers::FlatBufferBuilder &_fbb, const ImageT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ImageT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _height = _o->height;
  auto _width = _o->width;
  auto _encoding = _fbb.CreateString(_o->encoding);
  auto _is_bigendian = _o->is_bigendian;
  auto _step = _o->step;
  auto _data = _fbb.CreateVector(_o->data);
  return fb::sensor_msgs::CreateImage(
      _fbb,
      ___metadata,
      _header,
      _height,
      _width,
      _encoding,
      _is_bigendian,
      _step,
      _data);
}

inline ChannelFloat32T::ChannelFloat32T(const ChannelFloat32T &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        name(o.name),
        values(o.values) {
}

inline ChannelFloat32T &ChannelFloat32T::operator=(ChannelFloat32T o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(name, o.name);
  std::swap(values, o.values);
  return *this;
}

inline ChannelFloat32T *ChannelFloat32::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ChannelFloat32T>(new ChannelFloat32T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ChannelFloat32::UnPackTo(ChannelFloat32T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->values[_i] = _e->Get(_i); } } else { _o->values.resize(0); } }
}

inline ::flatbuffers::Offset<ChannelFloat32> ChannelFloat32::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ChannelFloat32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateChannelFloat32(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ChannelFloat32> CreateChannelFloat32(::flatbuffers::FlatBufferBuilder &_fbb, const ChannelFloat32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ChannelFloat32T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _name = _fbb.CreateString(_o->name);
  auto _values = _fbb.CreateVector(_o->values);
  return fb::sensor_msgs::CreateChannelFloat32(
      _fbb,
      ___metadata,
      _name,
      _values);
}

inline TemperatureT::TemperatureT(const TemperatureT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        temperature(o.temperature),
        variance(o.variance) {
}

inline TemperatureT &TemperatureT::operator=(TemperatureT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(temperature, o.temperature);
  std::swap(variance, o.variance);
  return *this;
}

inline TemperatureT *Temperature::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TemperatureT>(new TemperatureT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Temperature::UnPackTo(TemperatureT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = temperature(); _o->temperature = _e; }
  { auto _e = variance(); _o->variance = _e; }
}

inline ::flatbuffers::Offset<Temperature> Temperature::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TemperatureT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTemperature(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Temperature> CreateTemperature(::flatbuffers::FlatBufferBuilder &_fbb, const TemperatureT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TemperatureT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _temperature = _o->temperature;
  auto _variance = _o->variance;
  return fb::sensor_msgs::CreateTemperature(
      _fbb,
      ___metadata,
      _header,
      _temperature,
      _variance);
}

inline RegionOfInterestT::RegionOfInterestT(const RegionOfInterestT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        x_offset(o.x_offset),
        y_offset(o.y_offset),
        height(o.height),
        width(o.width),
        do_rectify(o.do_rectify) {
}

inline RegionOfInterestT &RegionOfInterestT::operator=(RegionOfInterestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(x_offset, o.x_offset);
  std::swap(y_offset, o.y_offset);
  std::swap(height, o.height);
  std::swap(width, o.width);
  std::swap(do_rectify, o.do_rectify);
  return *this;
}

inline RegionOfInterestT *RegionOfInterest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RegionOfInterestT>(new RegionOfInterestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RegionOfInterest::UnPackTo(RegionOfInterestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = x_offset(); _o->x_offset = _e; }
  { auto _e = y_offset(); _o->y_offset = _e; }
  { auto _e = height(); _o->height = _e; }
  { auto _e = width(); _o->width = _e; }
  { auto _e = do_rectify(); _o->do_rectify = _e; }
}

inline ::flatbuffers::Offset<RegionOfInterest> RegionOfInterest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RegionOfInterestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRegionOfInterest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RegionOfInterest> CreateRegionOfInterest(::flatbuffers::FlatBufferBuilder &_fbb, const RegionOfInterestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RegionOfInterestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _x_offset = _o->x_offset;
  auto _y_offset = _o->y_offset;
  auto _height = _o->height;
  auto _width = _o->width;
  auto _do_rectify = _o->do_rectify;
  return fb::sensor_msgs::CreateRegionOfInterest(
      _fbb,
      ___metadata,
      _x_offset,
      _y_offset,
      _height,
      _width,
      _do_rectify);
}

inline JoyFeedbackT::JoyFeedbackT(const JoyFeedbackT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        type(o.type),
        id(o.id),
        intensity(o.intensity) {
}

inline JoyFeedbackT &JoyFeedbackT::operator=(JoyFeedbackT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(type, o.type);
  std::swap(id, o.id);
  std::swap(intensity, o.intensity);
  return *this;
}

inline JoyFeedbackT *JoyFeedback::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<JoyFeedbackT>(new JoyFeedbackT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void JoyFeedback::UnPackTo(JoyFeedbackT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = type(); _o->type = _e; }
  { auto _e = id(); _o->id = _e; }
  { auto _e = intensity(); _o->intensity = _e; }
}

inline ::flatbuffers::Offset<JoyFeedback> JoyFeedback::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const JoyFeedbackT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateJoyFeedback(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<JoyFeedback> CreateJoyFeedback(::flatbuffers::FlatBufferBuilder &_fbb, const JoyFeedbackT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const JoyFeedbackT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _type = _o->type;
  auto _id = _o->id;
  auto _intensity = _o->intensity;
  return fb::sensor_msgs::CreateJoyFeedback(
      _fbb,
      ___metadata,
      _type,
      _id,
      _intensity);
}

inline SetCameraInfoRequestT::SetCameraInfoRequestT(const SetCameraInfoRequestT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        camera_info((o.camera_info) ? new fb::sensor_msgs::CameraInfoT(*o.camera_info) : nullptr) {
}

inline SetCameraInfoRequestT &SetCameraInfoRequestT::operator=(SetCameraInfoRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(camera_info, o.camera_info);
  return *this;
}

inline SetCameraInfoRequestT *SetCameraInfoRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SetCameraInfoRequestT>(new SetCameraInfoRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SetCameraInfoRequest::UnPackTo(SetCameraInfoRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = camera_info(); if (_e) { if(_o->camera_info) { _e->UnPackTo(_o->camera_info.get(), _resolver); } else { _o->camera_info = std::unique_ptr<fb::sensor_msgs::CameraInfoT>(_e->UnPack(_resolver)); } } else if (_o->camera_info) { _o->camera_info.reset(); } }
}

inline ::flatbuffers::Offset<SetCameraInfoRequest> SetCameraInfoRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetCameraInfoRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSetCameraInfoRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SetCameraInfoRequest> CreateSetCameraInfoRequest(::flatbuffers::FlatBufferBuilder &_fbb, const SetCameraInfoRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SetCameraInfoRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _camera_info = _o->camera_info ? CreateCameraInfo(_fbb, _o->camera_info.get(), _rehasher) : 0;
  return fb::sensor_msgs::CreateSetCameraInfoRequest(
      _fbb,
      ___metadata,
      _camera_info);
}

inline SetCameraInfoResponseT::SetCameraInfoResponseT(const SetCameraInfoResponseT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        success(o.success),
        status_message(o.status_message) {
}

inline SetCameraInfoResponseT &SetCameraInfoResponseT::operator=(SetCameraInfoResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(success, o.success);
  std::swap(status_message, o.status_message);
  return *this;
}

inline SetCameraInfoResponseT *SetCameraInfoResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SetCameraInfoResponseT>(new SetCameraInfoResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SetCameraInfoResponse::UnPackTo(SetCameraInfoResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = success(); _o->success = _e; }
  { auto _e = status_message(); if (_e) _o->status_message = _e->str(); }
}

inline ::flatbuffers::Offset<SetCameraInfoResponse> SetCameraInfoResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetCameraInfoResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSetCameraInfoResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SetCameraInfoResponse> CreateSetCameraInfoResponse(::flatbuffers::FlatBufferBuilder &_fbb, const SetCameraInfoResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SetCameraInfoResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _success = _o->success;
  auto _status_message = _fbb.CreateString(_o->status_message);
  return fb::sensor_msgs::CreateSetCameraInfoResponse(
      _fbb,
      ___metadata,
      _success,
      _status_message);
}

inline NavSatFixT::NavSatFixT(const NavSatFixT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        status((o.status) ? new fb::sensor_msgs::NavSatStatusT(*o.status) : nullptr),
        latitude(o.latitude),
        longitude(o.longitude),
        altitude(o.altitude),
        position_covariance(o.position_covariance),
        position_covariance_type(o.position_covariance_type) {
}

inline NavSatFixT &NavSatFixT::operator=(NavSatFixT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(status, o.status);
  std::swap(latitude, o.latitude);
  std::swap(longitude, o.longitude);
  std::swap(altitude, o.altitude);
  std::swap(position_covariance, o.position_covariance);
  std::swap(position_covariance_type, o.position_covariance_type);
  return *this;
}

inline NavSatFixT *NavSatFix::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NavSatFixT>(new NavSatFixT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NavSatFix::UnPackTo(NavSatFixT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = status(); if (_e) { if(_o->status) { _e->UnPackTo(_o->status.get(), _resolver); } else { _o->status = std::unique_ptr<fb::sensor_msgs::NavSatStatusT>(_e->UnPack(_resolver)); } } else if (_o->status) { _o->status.reset(); } }
  { auto _e = latitude(); _o->latitude = _e; }
  { auto _e = longitude(); _o->longitude = _e; }
  { auto _e = altitude(); _o->altitude = _e; }
  { auto _e = position_covariance(); if (_e) { _o->position_covariance.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->position_covariance[_i] = _e->Get(_i); } } else { _o->position_covariance.resize(0); } }
  { auto _e = position_covariance_type(); _o->position_covariance_type = _e; }
}

inline ::flatbuffers::Offset<NavSatFix> NavSatFix::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NavSatFixT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNavSatFix(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<NavSatFix> CreateNavSatFix(::flatbuffers::FlatBufferBuilder &_fbb, const NavSatFixT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NavSatFixT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _status = _o->status ? CreateNavSatStatus(_fbb, _o->status.get(), _rehasher) : 0;
  auto _latitude = _o->latitude;
  auto _longitude = _o->longitude;
  auto _altitude = _o->altitude;
  auto _position_covariance = _fbb.CreateVector(_o->position_covariance);
  auto _position_covariance_type = _o->position_covariance_type;
  return fb::sensor_msgs::CreateNavSatFix(
      _fbb,
      ___metadata,
      _header,
      _status,
      _latitude,
      _longitude,
      _altitude,
      _position_covariance,
      _position_covariance_type);
}

inline ImuT::ImuT(const ImuT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        orientation((o.orientation) ? new fb::geometry_msgs::QuaternionT(*o.orientation) : nullptr),
        orientation_covariance(o.orientation_covariance),
        angular_velocity((o.angular_velocity) ? new fb::geometry_msgs::Vector3T(*o.angular_velocity) : nullptr),
        angular_velocity_covariance(o.angular_velocity_covariance),
        linear_acceleration((o.linear_acceleration) ? new fb::geometry_msgs::Vector3T(*o.linear_acceleration) : nullptr),
        linear_acceleration_covariance(o.linear_acceleration_covariance) {
}

inline ImuT &ImuT::operator=(ImuT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(orientation, o.orientation);
  std::swap(orientation_covariance, o.orientation_covariance);
  std::swap(angular_velocity, o.angular_velocity);
  std::swap(angular_velocity_covariance, o.angular_velocity_covariance);
  std::swap(linear_acceleration, o.linear_acceleration);
  std::swap(linear_acceleration_covariance, o.linear_acceleration_covariance);
  return *this;
}

inline ImuT *Imu::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ImuT>(new ImuT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Imu::UnPackTo(ImuT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = orientation(); if (_e) { if(_o->orientation) { _e->UnPackTo(_o->orientation.get(), _resolver); } else { _o->orientation = std::unique_ptr<fb::geometry_msgs::QuaternionT>(_e->UnPack(_resolver)); } } else if (_o->orientation) { _o->orientation.reset(); } }
  { auto _e = orientation_covariance(); if (_e) { _o->orientation_covariance.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->orientation_covariance[_i] = _e->Get(_i); } } else { _o->orientation_covariance.resize(0); } }
  { auto _e = angular_velocity(); if (_e) { if(_o->angular_velocity) { _e->UnPackTo(_o->angular_velocity.get(), _resolver); } else { _o->angular_velocity = std::unique_ptr<fb::geometry_msgs::Vector3T>(_e->UnPack(_resolver)); } } else if (_o->angular_velocity) { _o->angular_velocity.reset(); } }
  { auto _e = angular_velocity_covariance(); if (_e) { _o->angular_velocity_covariance.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->angular_velocity_covariance[_i] = _e->Get(_i); } } else { _o->angular_velocity_covariance.resize(0); } }
  { auto _e = linear_acceleration(); if (_e) { if(_o->linear_acceleration) { _e->UnPackTo(_o->linear_acceleration.get(), _resolver); } else { _o->linear_acceleration = std::unique_ptr<fb::geometry_msgs::Vector3T>(_e->UnPack(_resolver)); } } else if (_o->linear_acceleration) { _o->linear_acceleration.reset(); } }
  { auto _e = linear_acceleration_covariance(); if (_e) { _o->linear_acceleration_covariance.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->linear_acceleration_covariance[_i] = _e->Get(_i); } } else { _o->linear_acceleration_covariance.resize(0); } }
}

inline ::flatbuffers::Offset<Imu> Imu::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ImuT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateImu(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Imu> CreateImu(::flatbuffers::FlatBufferBuilder &_fbb, const ImuT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ImuT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _orientation = _o->orientation ? CreateQuaternion(_fbb, _o->orientation.get(), _rehasher) : 0;
  auto _orientation_covariance = _fbb.CreateVector(_o->orientation_covariance);
  auto _angular_velocity = _o->angular_velocity ? CreateVector3(_fbb, _o->angular_velocity.get(), _rehasher) : 0;
  auto _angular_velocity_covariance = _fbb.CreateVector(_o->angular_velocity_covariance);
  auto _linear_acceleration = _o->linear_acceleration ? CreateVector3(_fbb, _o->linear_acceleration.get(), _rehasher) : 0;
  auto _linear_acceleration_covariance = _fbb.CreateVector(_o->linear_acceleration_covariance);
  return fb::sensor_msgs::CreateImu(
      _fbb,
      ___metadata,
      _header,
      _orientation,
      _orientation_covariance,
      _angular_velocity,
      _angular_velocity_covariance,
      _linear_acceleration,
      _linear_acceleration_covariance);
}

inline LaserScanT::LaserScanT(const LaserScanT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        angle_min(o.angle_min),
        angle_max(o.angle_max),
        angle_increment(o.angle_increment),
        time_increment(o.time_increment),
        scan_time(o.scan_time),
        range_min(o.range_min),
        range_max(o.range_max),
        ranges(o.ranges),
        intensities(o.intensities) {
}

inline LaserScanT &LaserScanT::operator=(LaserScanT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(angle_min, o.angle_min);
  std::swap(angle_max, o.angle_max);
  std::swap(angle_increment, o.angle_increment);
  std::swap(time_increment, o.time_increment);
  std::swap(scan_time, o.scan_time);
  std::swap(range_min, o.range_min);
  std::swap(range_max, o.range_max);
  std::swap(ranges, o.ranges);
  std::swap(intensities, o.intensities);
  return *this;
}

inline LaserScanT *LaserScan::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LaserScanT>(new LaserScanT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LaserScan::UnPackTo(LaserScanT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = angle_min(); _o->angle_min = _e; }
  { auto _e = angle_max(); _o->angle_max = _e; }
  { auto _e = angle_increment(); _o->angle_increment = _e; }
  { auto _e = time_increment(); _o->time_increment = _e; }
  { auto _e = scan_time(); _o->scan_time = _e; }
  { auto _e = range_min(); _o->range_min = _e; }
  { auto _e = range_max(); _o->range_max = _e; }
  { auto _e = ranges(); if (_e) { _o->ranges.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ranges[_i] = _e->Get(_i); } } else { _o->ranges.resize(0); } }
  { auto _e = intensities(); if (_e) { _o->intensities.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->intensities[_i] = _e->Get(_i); } } else { _o->intensities.resize(0); } }
}

inline ::flatbuffers::Offset<LaserScan> LaserScan::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LaserScanT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLaserScan(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<LaserScan> CreateLaserScan(::flatbuffers::FlatBufferBuilder &_fbb, const LaserScanT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LaserScanT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _angle_min = _o->angle_min;
  auto _angle_max = _o->angle_max;
  auto _angle_increment = _o->angle_increment;
  auto _time_increment = _o->time_increment;
  auto _scan_time = _o->scan_time;
  auto _range_min = _o->range_min;
  auto _range_max = _o->range_max;
  auto _ranges = _fbb.CreateVector(_o->ranges);
  auto _intensities = _fbb.CreateVector(_o->intensities);
  return fb::sensor_msgs::CreateLaserScan(
      _fbb,
      ___metadata,
      _header,
      _angle_min,
      _angle_max,
      _angle_increment,
      _time_increment,
      _scan_time,
      _range_min,
      _range_max,
      _ranges,
      _intensities);
}

inline RelativeHumidityT::RelativeHumidityT(const RelativeHumidityT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        relative_humidity(o.relative_humidity),
        variance(o.variance) {
}

inline RelativeHumidityT &RelativeHumidityT::operator=(RelativeHumidityT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(relative_humidity, o.relative_humidity);
  std::swap(variance, o.variance);
  return *this;
}

inline RelativeHumidityT *RelativeHumidity::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RelativeHumidityT>(new RelativeHumidityT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RelativeHumidity::UnPackTo(RelativeHumidityT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = relative_humidity(); _o->relative_humidity = _e; }
  { auto _e = variance(); _o->variance = _e; }
}

inline ::flatbuffers::Offset<RelativeHumidity> RelativeHumidity::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RelativeHumidityT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRelativeHumidity(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RelativeHumidity> CreateRelativeHumidity(::flatbuffers::FlatBufferBuilder &_fbb, const RelativeHumidityT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RelativeHumidityT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _relative_humidity = _o->relative_humidity;
  auto _variance = _o->variance;
  return fb::sensor_msgs::CreateRelativeHumidity(
      _fbb,
      ___metadata,
      _header,
      _relative_humidity,
      _variance);
}

inline RangeT::RangeT(const RangeT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        radiation_type(o.radiation_type),
        field_of_view(o.field_of_view),
        min_range(o.min_range),
        max_range(o.max_range),
        range(o.range) {
}

inline RangeT &RangeT::operator=(RangeT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(radiation_type, o.radiation_type);
  std::swap(field_of_view, o.field_of_view);
  std::swap(min_range, o.min_range);
  std::swap(max_range, o.max_range);
  std::swap(range, o.range);
  return *this;
}

inline RangeT *Range::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RangeT>(new RangeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Range::UnPackTo(RangeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = radiation_type(); _o->radiation_type = _e; }
  { auto _e = field_of_view(); _o->field_of_view = _e; }
  { auto _e = min_range(); _o->min_range = _e; }
  { auto _e = max_range(); _o->max_range = _e; }
  { auto _e = range(); _o->range = _e; }
}

inline ::flatbuffers::Offset<Range> Range::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RangeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRange(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Range> CreateRange(::flatbuffers::FlatBufferBuilder &_fbb, const RangeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RangeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _radiation_type = _o->radiation_type;
  auto _field_of_view = _o->field_of_view;
  auto _min_range = _o->min_range;
  auto _max_range = _o->max_range;
  auto _range = _o->range;
  return fb::sensor_msgs::CreateRange(
      _fbb,
      ___metadata,
      _header,
      _radiation_type,
      _field_of_view,
      _min_range,
      _max_range,
      _range);
}

}  // namespace sensor_msgs
}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_SENSORMSGS_FB_SENSOR_MSGS_H_
