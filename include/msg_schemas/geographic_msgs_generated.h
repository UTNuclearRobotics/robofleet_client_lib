// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GEOGRAPHICMSGS_FB_GEOGRAPHIC_MSGS_H_
#define FLATBUFFERS_GENERATED_GEOGRAPHICMSGS_FB_GEOGRAPHIC_MSGS_H_

#include "./flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 21,
             "Non-compatible flatbuffers version included");

#include "msg_schemas/geometry_msgs_generated.h"
#include "msg_schemas/std_msgs_generated.h"
#include "msg_schemas/uuid_msgs_generated.h"

namespace fb {
namespace geographic_msgs {

struct GeoPoseWithCovarianceStamped;
struct GeoPoseWithCovarianceStampedBuilder;
struct GeoPoseWithCovarianceStampedT;

struct GeographicMapChanges;
struct GeographicMapChangesBuilder;
struct GeographicMapChangesT;

struct GeoPoseStamped;
struct GeoPoseStampedBuilder;
struct GeoPoseStampedT;

struct UpdateGeographicMapRequest;
struct UpdateGeographicMapRequestBuilder;
struct UpdateGeographicMapRequestT;

struct UpdateGeographicMapResponse;
struct UpdateGeographicMapResponseBuilder;
struct UpdateGeographicMapResponseT;

struct GeographicMap;
struct GeographicMapBuilder;
struct GeographicMapT;

struct KeyValue;
struct KeyValueBuilder;
struct KeyValueT;

struct RoutePath;
struct RoutePathBuilder;
struct RoutePathT;

struct GetRoutePlanRequest;
struct GetRoutePlanRequestBuilder;
struct GetRoutePlanRequestT;

struct GetRoutePlanResponse;
struct GetRoutePlanResponseBuilder;
struct GetRoutePlanResponseT;

struct RouteSegment;
struct RouteSegmentBuilder;
struct RouteSegmentT;

struct GeoPath;
struct GeoPathBuilder;
struct GeoPathT;

struct GetGeoPathRequest;
struct GetGeoPathRequestBuilder;
struct GetGeoPathRequestT;

struct GetGeoPathResponse;
struct GetGeoPathResponseBuilder;
struct GetGeoPathResponseT;

struct GeoPoint;
struct GeoPointBuilder;
struct GeoPointT;

struct WayPoint;
struct WayPointBuilder;
struct WayPointT;

struct GeoPoseWithCovariance;
struct GeoPoseWithCovarianceBuilder;
struct GeoPoseWithCovarianceT;

struct GeoPose;
struct GeoPoseBuilder;
struct GeoPoseT;

struct BoundingBox;
struct BoundingBoxBuilder;
struct BoundingBoxT;

struct GeoPointStamped;
struct GeoPointStampedBuilder;
struct GeoPointStampedT;

struct RouteNetwork;
struct RouteNetworkBuilder;
struct RouteNetworkT;

struct MapFeature;
struct MapFeatureBuilder;
struct MapFeatureT;

struct GetGeographicMapRequest;
struct GetGeographicMapRequestBuilder;
struct GetGeographicMapRequestT;

struct GetGeographicMapResponse;
struct GetGeographicMapResponseBuilder;
struct GetGeographicMapResponseT;

struct GeoPoseWithCovarianceStampedT : public ::flatbuffers::NativeTable {
  typedef GeoPoseWithCovarianceStamped TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::geographic_msgs::GeoPoseWithCovarianceT> pose{};
  GeoPoseWithCovarianceStampedT() = default;
  GeoPoseWithCovarianceStampedT(const GeoPoseWithCovarianceStampedT &o);
  GeoPoseWithCovarianceStampedT(GeoPoseWithCovarianceStampedT&&) FLATBUFFERS_NOEXCEPT = default;
  GeoPoseWithCovarianceStampedT &operator=(GeoPoseWithCovarianceStampedT o) FLATBUFFERS_NOEXCEPT;
};

struct GeoPoseWithCovarianceStamped FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GeoPoseWithCovarianceStampedT NativeTableType;
  typedef GeoPoseWithCovarianceStampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_POSE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geographic_msgs::GeoPoseWithCovariance *pose() const {
    return GetPointer<const fb::geographic_msgs::GeoPoseWithCovariance *>(VT_POSE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           verifier.EndTable();
  }
  GeoPoseWithCovarianceStampedT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GeoPoseWithCovarianceStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GeoPoseWithCovarianceStamped> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseWithCovarianceStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GeoPoseWithCovarianceStampedBuilder {
  typedef GeoPoseWithCovarianceStamped Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GeoPoseWithCovarianceStamped::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(GeoPoseWithCovarianceStamped::VT_HEADER, header);
  }
  void add_pose(::flatbuffers::Offset<fb::geographic_msgs::GeoPoseWithCovariance> pose) {
    fbb_.AddOffset(GeoPoseWithCovarianceStamped::VT_POSE, pose);
  }
  explicit GeoPoseWithCovarianceStampedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GeoPoseWithCovarianceStamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GeoPoseWithCovarianceStamped>(end);
    fbb_.Required(o, GeoPoseWithCovarianceStamped::VT_HEADER);
    fbb_.Required(o, GeoPoseWithCovarianceStamped::VT_POSE);
    return o;
  }
};

inline ::flatbuffers::Offset<GeoPoseWithCovarianceStamped> CreateGeoPoseWithCovarianceStamped(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::geographic_msgs::GeoPoseWithCovariance> pose = 0) {
  GeoPoseWithCovarianceStampedBuilder builder_(_fbb);
  builder_.add_pose(pose);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<GeoPoseWithCovarianceStamped> CreateGeoPoseWithCovarianceStamped(::flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseWithCovarianceStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GeographicMapChangesT : public ::flatbuffers::NativeTable {
  typedef GeographicMapChanges TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::geographic_msgs::GeographicMapT> diffs{};
  std::vector<std::unique_ptr<fb::uuid_msgs::UniqueIDT>> deletes{};
  GeographicMapChangesT() = default;
  GeographicMapChangesT(const GeographicMapChangesT &o);
  GeographicMapChangesT(GeographicMapChangesT&&) FLATBUFFERS_NOEXCEPT = default;
  GeographicMapChangesT &operator=(GeographicMapChangesT o) FLATBUFFERS_NOEXCEPT;
};

struct GeographicMapChanges FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GeographicMapChangesT NativeTableType;
  typedef GeographicMapChangesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_DIFFS = 8,
    VT_DELETES = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geographic_msgs::GeographicMap *diffs() const {
    return GetPointer<const fb::geographic_msgs::GeographicMap *>(VT_DIFFS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::uuid_msgs::UniqueID>> *deletes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::uuid_msgs::UniqueID>> *>(VT_DELETES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_DIFFS) &&
           verifier.VerifyTable(diffs()) &&
           VerifyOffsetRequired(verifier, VT_DELETES) &&
           verifier.VerifyVector(deletes()) &&
           verifier.VerifyVectorOfTables(deletes()) &&
           verifier.EndTable();
  }
  GeographicMapChangesT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GeographicMapChangesT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GeographicMapChanges> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GeographicMapChangesT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GeographicMapChangesBuilder {
  typedef GeographicMapChanges Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GeographicMapChanges::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(GeographicMapChanges::VT_HEADER, header);
  }
  void add_diffs(::flatbuffers::Offset<fb::geographic_msgs::GeographicMap> diffs) {
    fbb_.AddOffset(GeographicMapChanges::VT_DIFFS, diffs);
  }
  void add_deletes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::uuid_msgs::UniqueID>>> deletes) {
    fbb_.AddOffset(GeographicMapChanges::VT_DELETES, deletes);
  }
  explicit GeographicMapChangesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GeographicMapChanges> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GeographicMapChanges>(end);
    fbb_.Required(o, GeographicMapChanges::VT_HEADER);
    fbb_.Required(o, GeographicMapChanges::VT_DIFFS);
    fbb_.Required(o, GeographicMapChanges::VT_DELETES);
    return o;
  }
};

inline ::flatbuffers::Offset<GeographicMapChanges> CreateGeographicMapChanges(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::geographic_msgs::GeographicMap> diffs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::uuid_msgs::UniqueID>>> deletes = 0) {
  GeographicMapChangesBuilder builder_(_fbb);
  builder_.add_deletes(deletes);
  builder_.add_diffs(diffs);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GeographicMapChanges> CreateGeographicMapChangesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::geographic_msgs::GeographicMap> diffs = 0,
    const std::vector<::flatbuffers::Offset<fb::uuid_msgs::UniqueID>> *deletes = nullptr) {
  auto deletes__ = deletes ? _fbb.CreateVector<::flatbuffers::Offset<fb::uuid_msgs::UniqueID>>(*deletes) : 0;
  return fb::geographic_msgs::CreateGeographicMapChanges(
      _fbb,
      __metadata,
      header,
      diffs,
      deletes__);
}

::flatbuffers::Offset<GeographicMapChanges> CreateGeographicMapChanges(::flatbuffers::FlatBufferBuilder &_fbb, const GeographicMapChangesT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GeoPoseStampedT : public ::flatbuffers::NativeTable {
  typedef GeoPoseStamped TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::geographic_msgs::GeoPoseT> pose{};
  GeoPoseStampedT() = default;
  GeoPoseStampedT(const GeoPoseStampedT &o);
  GeoPoseStampedT(GeoPoseStampedT&&) FLATBUFFERS_NOEXCEPT = default;
  GeoPoseStampedT &operator=(GeoPoseStampedT o) FLATBUFFERS_NOEXCEPT;
};

struct GeoPoseStamped FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GeoPoseStampedT NativeTableType;
  typedef GeoPoseStampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_POSE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geographic_msgs::GeoPose *pose() const {
    return GetPointer<const fb::geographic_msgs::GeoPose *>(VT_POSE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           verifier.EndTable();
  }
  GeoPoseStampedT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GeoPoseStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GeoPoseStamped> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GeoPoseStampedBuilder {
  typedef GeoPoseStamped Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GeoPoseStamped::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(GeoPoseStamped::VT_HEADER, header);
  }
  void add_pose(::flatbuffers::Offset<fb::geographic_msgs::GeoPose> pose) {
    fbb_.AddOffset(GeoPoseStamped::VT_POSE, pose);
  }
  explicit GeoPoseStampedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GeoPoseStamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GeoPoseStamped>(end);
    fbb_.Required(o, GeoPoseStamped::VT_HEADER);
    fbb_.Required(o, GeoPoseStamped::VT_POSE);
    return o;
  }
};

inline ::flatbuffers::Offset<GeoPoseStamped> CreateGeoPoseStamped(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::geographic_msgs::GeoPose> pose = 0) {
  GeoPoseStampedBuilder builder_(_fbb);
  builder_.add_pose(pose);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<GeoPoseStamped> CreateGeoPoseStamped(::flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UpdateGeographicMapRequestT : public ::flatbuffers::NativeTable {
  typedef UpdateGeographicMapRequest TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::geographic_msgs::GeographicMapChangesT> updates{};
  UpdateGeographicMapRequestT() = default;
  UpdateGeographicMapRequestT(const UpdateGeographicMapRequestT &o);
  UpdateGeographicMapRequestT(UpdateGeographicMapRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  UpdateGeographicMapRequestT &operator=(UpdateGeographicMapRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct UpdateGeographicMapRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UpdateGeographicMapRequestT NativeTableType;
  typedef UpdateGeographicMapRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_UPDATES = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geographic_msgs::GeographicMapChanges *updates() const {
    return GetPointer<const fb::geographic_msgs::GeographicMapChanges *>(VT_UPDATES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_UPDATES) &&
           verifier.VerifyTable(updates()) &&
           verifier.EndTable();
  }
  UpdateGeographicMapRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UpdateGeographicMapRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UpdateGeographicMapRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UpdateGeographicMapRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UpdateGeographicMapRequestBuilder {
  typedef UpdateGeographicMapRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(UpdateGeographicMapRequest::VT___METADATA, __metadata);
  }
  void add_updates(::flatbuffers::Offset<fb::geographic_msgs::GeographicMapChanges> updates) {
    fbb_.AddOffset(UpdateGeographicMapRequest::VT_UPDATES, updates);
  }
  explicit UpdateGeographicMapRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UpdateGeographicMapRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UpdateGeographicMapRequest>(end);
    fbb_.Required(o, UpdateGeographicMapRequest::VT_UPDATES);
    return o;
  }
};

inline ::flatbuffers::Offset<UpdateGeographicMapRequest> CreateUpdateGeographicMapRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geographic_msgs::GeographicMapChanges> updates = 0) {
  UpdateGeographicMapRequestBuilder builder_(_fbb);
  builder_.add_updates(updates);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<UpdateGeographicMapRequest> CreateUpdateGeographicMapRequest(::flatbuffers::FlatBufferBuilder &_fbb, const UpdateGeographicMapRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UpdateGeographicMapResponseT : public ::flatbuffers::NativeTable {
  typedef UpdateGeographicMapResponse TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  bool success = false;
  std::string status{};
  UpdateGeographicMapResponseT() = default;
  UpdateGeographicMapResponseT(const UpdateGeographicMapResponseT &o);
  UpdateGeographicMapResponseT(UpdateGeographicMapResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  UpdateGeographicMapResponseT &operator=(UpdateGeographicMapResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct UpdateGeographicMapResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UpdateGeographicMapResponseT NativeTableType;
  typedef UpdateGeographicMapResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_SUCCESS = 6,
    VT_STATUS = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  const ::flatbuffers::String *status() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATUS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           VerifyOffsetRequired(verifier, VT_STATUS) &&
           verifier.VerifyString(status()) &&
           verifier.EndTable();
  }
  UpdateGeographicMapResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UpdateGeographicMapResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UpdateGeographicMapResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UpdateGeographicMapResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UpdateGeographicMapResponseBuilder {
  typedef UpdateGeographicMapResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(UpdateGeographicMapResponse::VT___METADATA, __metadata);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(UpdateGeographicMapResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_status(::flatbuffers::Offset<::flatbuffers::String> status) {
    fbb_.AddOffset(UpdateGeographicMapResponse::VT_STATUS, status);
  }
  explicit UpdateGeographicMapResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UpdateGeographicMapResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UpdateGeographicMapResponse>(end);
    fbb_.Required(o, UpdateGeographicMapResponse::VT_STATUS);
    return o;
  }
};

inline ::flatbuffers::Offset<UpdateGeographicMapResponse> CreateUpdateGeographicMapResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    bool success = false,
    ::flatbuffers::Offset<::flatbuffers::String> status = 0) {
  UpdateGeographicMapResponseBuilder builder_(_fbb);
  builder_.add_status(status);
  builder_.add___metadata(__metadata);
  builder_.add_success(success);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UpdateGeographicMapResponse> CreateUpdateGeographicMapResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    bool success = false,
    const char *status = nullptr) {
  auto status__ = status ? _fbb.CreateString(status) : 0;
  return fb::geographic_msgs::CreateUpdateGeographicMapResponse(
      _fbb,
      __metadata,
      success,
      status__);
}

::flatbuffers::Offset<UpdateGeographicMapResponse> CreateUpdateGeographicMapResponse(::flatbuffers::FlatBufferBuilder &_fbb, const UpdateGeographicMapResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GeographicMapT : public ::flatbuffers::NativeTable {
  typedef GeographicMap TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::uuid_msgs::UniqueIDT> id{};
  std::unique_ptr<fb::geographic_msgs::BoundingBoxT> bounds{};
  std::vector<std::unique_ptr<fb::geographic_msgs::WayPointT>> points{};
  std::vector<std::unique_ptr<fb::geographic_msgs::MapFeatureT>> features{};
  std::vector<std::unique_ptr<fb::geographic_msgs::KeyValueT>> props{};
  GeographicMapT() = default;
  GeographicMapT(const GeographicMapT &o);
  GeographicMapT(GeographicMapT&&) FLATBUFFERS_NOEXCEPT = default;
  GeographicMapT &operator=(GeographicMapT o) FLATBUFFERS_NOEXCEPT;
};

struct GeographicMap FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GeographicMapT NativeTableType;
  typedef GeographicMapBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_ID = 8,
    VT_BOUNDS = 10,
    VT_POINTS = 12,
    VT_FEATURES = 14,
    VT_PROPS = 16
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::uuid_msgs::UniqueID *id() const {
    return GetPointer<const fb::uuid_msgs::UniqueID *>(VT_ID);
  }
  const fb::geographic_msgs::BoundingBox *bounds() const {
    return GetPointer<const fb::geographic_msgs::BoundingBox *>(VT_BOUNDS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::WayPoint>> *points() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::WayPoint>> *>(VT_POINTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::MapFeature>> *features() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::MapFeature>> *>(VT_FEATURES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>> *props() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>> *>(VT_PROPS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffsetRequired(verifier, VT_BOUNDS) &&
           verifier.VerifyTable(bounds()) &&
           VerifyOffsetRequired(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.VerifyVectorOfTables(points()) &&
           VerifyOffsetRequired(verifier, VT_FEATURES) &&
           verifier.VerifyVector(features()) &&
           verifier.VerifyVectorOfTables(features()) &&
           VerifyOffsetRequired(verifier, VT_PROPS) &&
           verifier.VerifyVector(props()) &&
           verifier.VerifyVectorOfTables(props()) &&
           verifier.EndTable();
  }
  GeographicMapT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GeographicMapT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GeographicMap> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GeographicMapT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GeographicMapBuilder {
  typedef GeographicMap Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GeographicMap::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(GeographicMap::VT_HEADER, header);
  }
  void add_id(::flatbuffers::Offset<fb::uuid_msgs::UniqueID> id) {
    fbb_.AddOffset(GeographicMap::VT_ID, id);
  }
  void add_bounds(::flatbuffers::Offset<fb::geographic_msgs::BoundingBox> bounds) {
    fbb_.AddOffset(GeographicMap::VT_BOUNDS, bounds);
  }
  void add_points(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::WayPoint>>> points) {
    fbb_.AddOffset(GeographicMap::VT_POINTS, points);
  }
  void add_features(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::MapFeature>>> features) {
    fbb_.AddOffset(GeographicMap::VT_FEATURES, features);
  }
  void add_props(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>>> props) {
    fbb_.AddOffset(GeographicMap::VT_PROPS, props);
  }
  explicit GeographicMapBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GeographicMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GeographicMap>(end);
    fbb_.Required(o, GeographicMap::VT_HEADER);
    fbb_.Required(o, GeographicMap::VT_ID);
    fbb_.Required(o, GeographicMap::VT_BOUNDS);
    fbb_.Required(o, GeographicMap::VT_POINTS);
    fbb_.Required(o, GeographicMap::VT_FEATURES);
    fbb_.Required(o, GeographicMap::VT_PROPS);
    return o;
  }
};

inline ::flatbuffers::Offset<GeographicMap> CreateGeographicMap(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::uuid_msgs::UniqueID> id = 0,
    ::flatbuffers::Offset<fb::geographic_msgs::BoundingBox> bounds = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::WayPoint>>> points = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::MapFeature>>> features = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>>> props = 0) {
  GeographicMapBuilder builder_(_fbb);
  builder_.add_props(props);
  builder_.add_features(features);
  builder_.add_points(points);
  builder_.add_bounds(bounds);
  builder_.add_id(id);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GeographicMap> CreateGeographicMapDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::uuid_msgs::UniqueID> id = 0,
    ::flatbuffers::Offset<fb::geographic_msgs::BoundingBox> bounds = 0,
    const std::vector<::flatbuffers::Offset<fb::geographic_msgs::WayPoint>> *points = nullptr,
    const std::vector<::flatbuffers::Offset<fb::geographic_msgs::MapFeature>> *features = nullptr,
    const std::vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>> *props = nullptr) {
  auto points__ = points ? _fbb.CreateVector<::flatbuffers::Offset<fb::geographic_msgs::WayPoint>>(*points) : 0;
  auto features__ = features ? _fbb.CreateVector<::flatbuffers::Offset<fb::geographic_msgs::MapFeature>>(*features) : 0;
  auto props__ = props ? _fbb.CreateVector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>>(*props) : 0;
  return fb::geographic_msgs::CreateGeographicMap(
      _fbb,
      __metadata,
      header,
      id,
      bounds,
      points__,
      features__,
      props__);
}

::flatbuffers::Offset<GeographicMap> CreateGeographicMap(::flatbuffers::FlatBufferBuilder &_fbb, const GeographicMapT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct KeyValueT : public ::flatbuffers::NativeTable {
  typedef KeyValue TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string key{};
  std::string value{};
  KeyValueT() = default;
  KeyValueT(const KeyValueT &o);
  KeyValueT(KeyValueT&&) FLATBUFFERS_NOEXCEPT = default;
  KeyValueT &operator=(KeyValueT o) FLATBUFFERS_NOEXCEPT;
};

struct KeyValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KeyValueT NativeTableType;
  typedef KeyValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_KEY = 6,
    VT_VALUE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
  KeyValueT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(KeyValueT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<KeyValue> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const KeyValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct KeyValueBuilder {
  typedef KeyValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(KeyValue::VT___METADATA, __metadata);
  }
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(KeyValue::VT_KEY, key);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(KeyValue::VT_VALUE, value);
  }
  explicit KeyValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KeyValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KeyValue>(end);
    fbb_.Required(o, KeyValue::VT_KEY);
    fbb_.Required(o, KeyValue::VT_VALUE);
    return o;
  }
};

inline ::flatbuffers::Offset<KeyValue> CreateKeyValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  KeyValueBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KeyValue> CreateKeyValueDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *key = nullptr,
    const char *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return fb::geographic_msgs::CreateKeyValue(
      _fbb,
      __metadata,
      key__,
      value__);
}

::flatbuffers::Offset<KeyValue> CreateKeyValue(::flatbuffers::FlatBufferBuilder &_fbb, const KeyValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RoutePathT : public ::flatbuffers::NativeTable {
  typedef RoutePath TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::uuid_msgs::UniqueIDT> network{};
  std::vector<std::unique_ptr<fb::uuid_msgs::UniqueIDT>> segments{};
  std::vector<std::unique_ptr<fb::geographic_msgs::KeyValueT>> props{};
  RoutePathT() = default;
  RoutePathT(const RoutePathT &o);
  RoutePathT(RoutePathT&&) FLATBUFFERS_NOEXCEPT = default;
  RoutePathT &operator=(RoutePathT o) FLATBUFFERS_NOEXCEPT;
};

struct RoutePath FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RoutePathT NativeTableType;
  typedef RoutePathBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_NETWORK = 8,
    VT_SEGMENTS = 10,
    VT_PROPS = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::uuid_msgs::UniqueID *network() const {
    return GetPointer<const fb::uuid_msgs::UniqueID *>(VT_NETWORK);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::uuid_msgs::UniqueID>> *segments() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::uuid_msgs::UniqueID>> *>(VT_SEGMENTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>> *props() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>> *>(VT_PROPS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_NETWORK) &&
           verifier.VerifyTable(network()) &&
           VerifyOffsetRequired(verifier, VT_SEGMENTS) &&
           verifier.VerifyVector(segments()) &&
           verifier.VerifyVectorOfTables(segments()) &&
           VerifyOffsetRequired(verifier, VT_PROPS) &&
           verifier.VerifyVector(props()) &&
           verifier.VerifyVectorOfTables(props()) &&
           verifier.EndTable();
  }
  RoutePathT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RoutePathT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RoutePath> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RoutePathT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RoutePathBuilder {
  typedef RoutePath Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(RoutePath::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(RoutePath::VT_HEADER, header);
  }
  void add_network(::flatbuffers::Offset<fb::uuid_msgs::UniqueID> network) {
    fbb_.AddOffset(RoutePath::VT_NETWORK, network);
  }
  void add_segments(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::uuid_msgs::UniqueID>>> segments) {
    fbb_.AddOffset(RoutePath::VT_SEGMENTS, segments);
  }
  void add_props(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>>> props) {
    fbb_.AddOffset(RoutePath::VT_PROPS, props);
  }
  explicit RoutePathBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RoutePath> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RoutePath>(end);
    fbb_.Required(o, RoutePath::VT_HEADER);
    fbb_.Required(o, RoutePath::VT_NETWORK);
    fbb_.Required(o, RoutePath::VT_SEGMENTS);
    fbb_.Required(o, RoutePath::VT_PROPS);
    return o;
  }
};

inline ::flatbuffers::Offset<RoutePath> CreateRoutePath(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::uuid_msgs::UniqueID> network = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::uuid_msgs::UniqueID>>> segments = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>>> props = 0) {
  RoutePathBuilder builder_(_fbb);
  builder_.add_props(props);
  builder_.add_segments(segments);
  builder_.add_network(network);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RoutePath> CreateRoutePathDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::uuid_msgs::UniqueID> network = 0,
    const std::vector<::flatbuffers::Offset<fb::uuid_msgs::UniqueID>> *segments = nullptr,
    const std::vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>> *props = nullptr) {
  auto segments__ = segments ? _fbb.CreateVector<::flatbuffers::Offset<fb::uuid_msgs::UniqueID>>(*segments) : 0;
  auto props__ = props ? _fbb.CreateVector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>>(*props) : 0;
  return fb::geographic_msgs::CreateRoutePath(
      _fbb,
      __metadata,
      header,
      network,
      segments__,
      props__);
}

::flatbuffers::Offset<RoutePath> CreateRoutePath(::flatbuffers::FlatBufferBuilder &_fbb, const RoutePathT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetRoutePlanRequestT : public ::flatbuffers::NativeTable {
  typedef GetRoutePlanRequest TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::uuid_msgs::UniqueIDT> network{};
  std::unique_ptr<fb::uuid_msgs::UniqueIDT> start{};
  std::unique_ptr<fb::uuid_msgs::UniqueIDT> goal{};
  GetRoutePlanRequestT() = default;
  GetRoutePlanRequestT(const GetRoutePlanRequestT &o);
  GetRoutePlanRequestT(GetRoutePlanRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  GetRoutePlanRequestT &operator=(GetRoutePlanRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct GetRoutePlanRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetRoutePlanRequestT NativeTableType;
  typedef GetRoutePlanRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_NETWORK = 6,
    VT_START = 8,
    VT_GOAL = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::uuid_msgs::UniqueID *network() const {
    return GetPointer<const fb::uuid_msgs::UniqueID *>(VT_NETWORK);
  }
  const fb::uuid_msgs::UniqueID *start() const {
    return GetPointer<const fb::uuid_msgs::UniqueID *>(VT_START);
  }
  const fb::uuid_msgs::UniqueID *goal() const {
    return GetPointer<const fb::uuid_msgs::UniqueID *>(VT_GOAL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_NETWORK) &&
           verifier.VerifyTable(network()) &&
           VerifyOffsetRequired(verifier, VT_START) &&
           verifier.VerifyTable(start()) &&
           VerifyOffsetRequired(verifier, VT_GOAL) &&
           verifier.VerifyTable(goal()) &&
           verifier.EndTable();
  }
  GetRoutePlanRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetRoutePlanRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GetRoutePlanRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetRoutePlanRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetRoutePlanRequestBuilder {
  typedef GetRoutePlanRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GetRoutePlanRequest::VT___METADATA, __metadata);
  }
  void add_network(::flatbuffers::Offset<fb::uuid_msgs::UniqueID> network) {
    fbb_.AddOffset(GetRoutePlanRequest::VT_NETWORK, network);
  }
  void add_start(::flatbuffers::Offset<fb::uuid_msgs::UniqueID> start) {
    fbb_.AddOffset(GetRoutePlanRequest::VT_START, start);
  }
  void add_goal(::flatbuffers::Offset<fb::uuid_msgs::UniqueID> goal) {
    fbb_.AddOffset(GetRoutePlanRequest::VT_GOAL, goal);
  }
  explicit GetRoutePlanRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetRoutePlanRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetRoutePlanRequest>(end);
    fbb_.Required(o, GetRoutePlanRequest::VT_NETWORK);
    fbb_.Required(o, GetRoutePlanRequest::VT_START);
    fbb_.Required(o, GetRoutePlanRequest::VT_GOAL);
    return o;
  }
};

inline ::flatbuffers::Offset<GetRoutePlanRequest> CreateGetRoutePlanRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::uuid_msgs::UniqueID> network = 0,
    ::flatbuffers::Offset<fb::uuid_msgs::UniqueID> start = 0,
    ::flatbuffers::Offset<fb::uuid_msgs::UniqueID> goal = 0) {
  GetRoutePlanRequestBuilder builder_(_fbb);
  builder_.add_goal(goal);
  builder_.add_start(start);
  builder_.add_network(network);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<GetRoutePlanRequest> CreateGetRoutePlanRequest(::flatbuffers::FlatBufferBuilder &_fbb, const GetRoutePlanRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetRoutePlanResponseT : public ::flatbuffers::NativeTable {
  typedef GetRoutePlanResponse TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  bool success = false;
  std::string status{};
  std::unique_ptr<fb::geographic_msgs::RoutePathT> plan{};
  GetRoutePlanResponseT() = default;
  GetRoutePlanResponseT(const GetRoutePlanResponseT &o);
  GetRoutePlanResponseT(GetRoutePlanResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  GetRoutePlanResponseT &operator=(GetRoutePlanResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct GetRoutePlanResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetRoutePlanResponseT NativeTableType;
  typedef GetRoutePlanResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_SUCCESS = 6,
    VT_STATUS = 8,
    VT_PLAN = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  const ::flatbuffers::String *status() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATUS);
  }
  const fb::geographic_msgs::RoutePath *plan() const {
    return GetPointer<const fb::geographic_msgs::RoutePath *>(VT_PLAN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           VerifyOffsetRequired(verifier, VT_STATUS) &&
           verifier.VerifyString(status()) &&
           VerifyOffsetRequired(verifier, VT_PLAN) &&
           verifier.VerifyTable(plan()) &&
           verifier.EndTable();
  }
  GetRoutePlanResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetRoutePlanResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GetRoutePlanResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetRoutePlanResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetRoutePlanResponseBuilder {
  typedef GetRoutePlanResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GetRoutePlanResponse::VT___METADATA, __metadata);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(GetRoutePlanResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_status(::flatbuffers::Offset<::flatbuffers::String> status) {
    fbb_.AddOffset(GetRoutePlanResponse::VT_STATUS, status);
  }
  void add_plan(::flatbuffers::Offset<fb::geographic_msgs::RoutePath> plan) {
    fbb_.AddOffset(GetRoutePlanResponse::VT_PLAN, plan);
  }
  explicit GetRoutePlanResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetRoutePlanResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetRoutePlanResponse>(end);
    fbb_.Required(o, GetRoutePlanResponse::VT_STATUS);
    fbb_.Required(o, GetRoutePlanResponse::VT_PLAN);
    return o;
  }
};

inline ::flatbuffers::Offset<GetRoutePlanResponse> CreateGetRoutePlanResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    bool success = false,
    ::flatbuffers::Offset<::flatbuffers::String> status = 0,
    ::flatbuffers::Offset<fb::geographic_msgs::RoutePath> plan = 0) {
  GetRoutePlanResponseBuilder builder_(_fbb);
  builder_.add_plan(plan);
  builder_.add_status(status);
  builder_.add___metadata(__metadata);
  builder_.add_success(success);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GetRoutePlanResponse> CreateGetRoutePlanResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    bool success = false,
    const char *status = nullptr,
    ::flatbuffers::Offset<fb::geographic_msgs::RoutePath> plan = 0) {
  auto status__ = status ? _fbb.CreateString(status) : 0;
  return fb::geographic_msgs::CreateGetRoutePlanResponse(
      _fbb,
      __metadata,
      success,
      status__,
      plan);
}

::flatbuffers::Offset<GetRoutePlanResponse> CreateGetRoutePlanResponse(::flatbuffers::FlatBufferBuilder &_fbb, const GetRoutePlanResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RouteSegmentT : public ::flatbuffers::NativeTable {
  typedef RouteSegment TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::uuid_msgs::UniqueIDT> id{};
  std::unique_ptr<fb::uuid_msgs::UniqueIDT> start{};
  std::unique_ptr<fb::uuid_msgs::UniqueIDT> end{};
  std::vector<std::unique_ptr<fb::geographic_msgs::KeyValueT>> props{};
  RouteSegmentT() = default;
  RouteSegmentT(const RouteSegmentT &o);
  RouteSegmentT(RouteSegmentT&&) FLATBUFFERS_NOEXCEPT = default;
  RouteSegmentT &operator=(RouteSegmentT o) FLATBUFFERS_NOEXCEPT;
};

struct RouteSegment FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RouteSegmentT NativeTableType;
  typedef RouteSegmentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_ID = 6,
    VT_START = 8,
    VT_END = 10,
    VT_PROPS = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::uuid_msgs::UniqueID *id() const {
    return GetPointer<const fb::uuid_msgs::UniqueID *>(VT_ID);
  }
  const fb::uuid_msgs::UniqueID *start() const {
    return GetPointer<const fb::uuid_msgs::UniqueID *>(VT_START);
  }
  const fb::uuid_msgs::UniqueID *end() const {
    return GetPointer<const fb::uuid_msgs::UniqueID *>(VT_END);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>> *props() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>> *>(VT_PROPS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffsetRequired(verifier, VT_START) &&
           verifier.VerifyTable(start()) &&
           VerifyOffsetRequired(verifier, VT_END) &&
           verifier.VerifyTable(end()) &&
           VerifyOffsetRequired(verifier, VT_PROPS) &&
           verifier.VerifyVector(props()) &&
           verifier.VerifyVectorOfTables(props()) &&
           verifier.EndTable();
  }
  RouteSegmentT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RouteSegmentT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RouteSegment> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RouteSegmentT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RouteSegmentBuilder {
  typedef RouteSegment Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(RouteSegment::VT___METADATA, __metadata);
  }
  void add_id(::flatbuffers::Offset<fb::uuid_msgs::UniqueID> id) {
    fbb_.AddOffset(RouteSegment::VT_ID, id);
  }
  void add_start(::flatbuffers::Offset<fb::uuid_msgs::UniqueID> start) {
    fbb_.AddOffset(RouteSegment::VT_START, start);
  }
  void add_end(::flatbuffers::Offset<fb::uuid_msgs::UniqueID> end) {
    fbb_.AddOffset(RouteSegment::VT_END, end);
  }
  void add_props(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>>> props) {
    fbb_.AddOffset(RouteSegment::VT_PROPS, props);
  }
  explicit RouteSegmentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RouteSegment> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RouteSegment>(end);
    fbb_.Required(o, RouteSegment::VT_ID);
    fbb_.Required(o, RouteSegment::VT_START);
    fbb_.Required(o, RouteSegment::VT_END);
    fbb_.Required(o, RouteSegment::VT_PROPS);
    return o;
  }
};

inline ::flatbuffers::Offset<RouteSegment> CreateRouteSegment(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::uuid_msgs::UniqueID> id = 0,
    ::flatbuffers::Offset<fb::uuid_msgs::UniqueID> start = 0,
    ::flatbuffers::Offset<fb::uuid_msgs::UniqueID> end = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>>> props = 0) {
  RouteSegmentBuilder builder_(_fbb);
  builder_.add_props(props);
  builder_.add_end(end);
  builder_.add_start(start);
  builder_.add_id(id);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RouteSegment> CreateRouteSegmentDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::uuid_msgs::UniqueID> id = 0,
    ::flatbuffers::Offset<fb::uuid_msgs::UniqueID> start = 0,
    ::flatbuffers::Offset<fb::uuid_msgs::UniqueID> end = 0,
    const std::vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>> *props = nullptr) {
  auto props__ = props ? _fbb.CreateVector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>>(*props) : 0;
  return fb::geographic_msgs::CreateRouteSegment(
      _fbb,
      __metadata,
      id,
      start,
      end,
      props__);
}

::flatbuffers::Offset<RouteSegment> CreateRouteSegment(::flatbuffers::FlatBufferBuilder &_fbb, const RouteSegmentT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GeoPathT : public ::flatbuffers::NativeTable {
  typedef GeoPath TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::vector<std::unique_ptr<fb::geographic_msgs::GeoPoseStampedT>> poses{};
  GeoPathT() = default;
  GeoPathT(const GeoPathT &o);
  GeoPathT(GeoPathT&&) FLATBUFFERS_NOEXCEPT = default;
  GeoPathT &operator=(GeoPathT o) FLATBUFFERS_NOEXCEPT;
};

struct GeoPath FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GeoPathT NativeTableType;
  typedef GeoPathBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_POSES = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::GeoPoseStamped>> *poses() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::GeoPoseStamped>> *>(VT_POSES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_POSES) &&
           verifier.VerifyVector(poses()) &&
           verifier.VerifyVectorOfTables(poses()) &&
           verifier.EndTable();
  }
  GeoPathT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GeoPathT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GeoPath> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GeoPathT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GeoPathBuilder {
  typedef GeoPath Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GeoPath::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(GeoPath::VT_HEADER, header);
  }
  void add_poses(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::GeoPoseStamped>>> poses) {
    fbb_.AddOffset(GeoPath::VT_POSES, poses);
  }
  explicit GeoPathBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GeoPath> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GeoPath>(end);
    fbb_.Required(o, GeoPath::VT_HEADER);
    fbb_.Required(o, GeoPath::VT_POSES);
    return o;
  }
};

inline ::flatbuffers::Offset<GeoPath> CreateGeoPath(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::GeoPoseStamped>>> poses = 0) {
  GeoPathBuilder builder_(_fbb);
  builder_.add_poses(poses);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GeoPath> CreateGeoPathDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const std::vector<::flatbuffers::Offset<fb::geographic_msgs::GeoPoseStamped>> *poses = nullptr) {
  auto poses__ = poses ? _fbb.CreateVector<::flatbuffers::Offset<fb::geographic_msgs::GeoPoseStamped>>(*poses) : 0;
  return fb::geographic_msgs::CreateGeoPath(
      _fbb,
      __metadata,
      header,
      poses__);
}

::flatbuffers::Offset<GeoPath> CreateGeoPath(::flatbuffers::FlatBufferBuilder &_fbb, const GeoPathT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetGeoPathRequestT : public ::flatbuffers::NativeTable {
  typedef GetGeoPathRequest TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::geographic_msgs::GeoPointT> start{};
  std::unique_ptr<fb::geographic_msgs::GeoPointT> goal{};
  GetGeoPathRequestT() = default;
  GetGeoPathRequestT(const GetGeoPathRequestT &o);
  GetGeoPathRequestT(GetGeoPathRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  GetGeoPathRequestT &operator=(GetGeoPathRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct GetGeoPathRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetGeoPathRequestT NativeTableType;
  typedef GetGeoPathRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_START = 6,
    VT_GOAL = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geographic_msgs::GeoPoint *start() const {
    return GetPointer<const fb::geographic_msgs::GeoPoint *>(VT_START);
  }
  const fb::geographic_msgs::GeoPoint *goal() const {
    return GetPointer<const fb::geographic_msgs::GeoPoint *>(VT_GOAL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_START) &&
           verifier.VerifyTable(start()) &&
           VerifyOffsetRequired(verifier, VT_GOAL) &&
           verifier.VerifyTable(goal()) &&
           verifier.EndTable();
  }
  GetGeoPathRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetGeoPathRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GetGeoPathRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetGeoPathRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetGeoPathRequestBuilder {
  typedef GetGeoPathRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GetGeoPathRequest::VT___METADATA, __metadata);
  }
  void add_start(::flatbuffers::Offset<fb::geographic_msgs::GeoPoint> start) {
    fbb_.AddOffset(GetGeoPathRequest::VT_START, start);
  }
  void add_goal(::flatbuffers::Offset<fb::geographic_msgs::GeoPoint> goal) {
    fbb_.AddOffset(GetGeoPathRequest::VT_GOAL, goal);
  }
  explicit GetGeoPathRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetGeoPathRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetGeoPathRequest>(end);
    fbb_.Required(o, GetGeoPathRequest::VT_START);
    fbb_.Required(o, GetGeoPathRequest::VT_GOAL);
    return o;
  }
};

inline ::flatbuffers::Offset<GetGeoPathRequest> CreateGetGeoPathRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geographic_msgs::GeoPoint> start = 0,
    ::flatbuffers::Offset<fb::geographic_msgs::GeoPoint> goal = 0) {
  GetGeoPathRequestBuilder builder_(_fbb);
  builder_.add_goal(goal);
  builder_.add_start(start);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<GetGeoPathRequest> CreateGetGeoPathRequest(::flatbuffers::FlatBufferBuilder &_fbb, const GetGeoPathRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetGeoPathResponseT : public ::flatbuffers::NativeTable {
  typedef GetGeoPathResponse TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  bool success = false;
  std::string status{};
  std::unique_ptr<fb::geographic_msgs::GeoPathT> plan{};
  std::unique_ptr<fb::uuid_msgs::UniqueIDT> network{};
  std::unique_ptr<fb::uuid_msgs::UniqueIDT> start_seg{};
  std::unique_ptr<fb::uuid_msgs::UniqueIDT> goal_seg{};
  double distance = 0.0;
  GetGeoPathResponseT() = default;
  GetGeoPathResponseT(const GetGeoPathResponseT &o);
  GetGeoPathResponseT(GetGeoPathResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  GetGeoPathResponseT &operator=(GetGeoPathResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct GetGeoPathResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetGeoPathResponseT NativeTableType;
  typedef GetGeoPathResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_SUCCESS = 6,
    VT_STATUS = 8,
    VT_PLAN = 10,
    VT_NETWORK = 12,
    VT_START_SEG = 14,
    VT_GOAL_SEG = 16,
    VT_DISTANCE = 18
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  const ::flatbuffers::String *status() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATUS);
  }
  const fb::geographic_msgs::GeoPath *plan() const {
    return GetPointer<const fb::geographic_msgs::GeoPath *>(VT_PLAN);
  }
  const fb::uuid_msgs::UniqueID *network() const {
    return GetPointer<const fb::uuid_msgs::UniqueID *>(VT_NETWORK);
  }
  const fb::uuid_msgs::UniqueID *start_seg() const {
    return GetPointer<const fb::uuid_msgs::UniqueID *>(VT_START_SEG);
  }
  const fb::uuid_msgs::UniqueID *goal_seg() const {
    return GetPointer<const fb::uuid_msgs::UniqueID *>(VT_GOAL_SEG);
  }
  double distance() const {
    return GetField<double>(VT_DISTANCE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           VerifyOffsetRequired(verifier, VT_STATUS) &&
           verifier.VerifyString(status()) &&
           VerifyOffsetRequired(verifier, VT_PLAN) &&
           verifier.VerifyTable(plan()) &&
           VerifyOffsetRequired(verifier, VT_NETWORK) &&
           verifier.VerifyTable(network()) &&
           VerifyOffsetRequired(verifier, VT_START_SEG) &&
           verifier.VerifyTable(start_seg()) &&
           VerifyOffsetRequired(verifier, VT_GOAL_SEG) &&
           verifier.VerifyTable(goal_seg()) &&
           VerifyField<double>(verifier, VT_DISTANCE, 8) &&
           verifier.EndTable();
  }
  GetGeoPathResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetGeoPathResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GetGeoPathResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetGeoPathResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetGeoPathResponseBuilder {
  typedef GetGeoPathResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GetGeoPathResponse::VT___METADATA, __metadata);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(GetGeoPathResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_status(::flatbuffers::Offset<::flatbuffers::String> status) {
    fbb_.AddOffset(GetGeoPathResponse::VT_STATUS, status);
  }
  void add_plan(::flatbuffers::Offset<fb::geographic_msgs::GeoPath> plan) {
    fbb_.AddOffset(GetGeoPathResponse::VT_PLAN, plan);
  }
  void add_network(::flatbuffers::Offset<fb::uuid_msgs::UniqueID> network) {
    fbb_.AddOffset(GetGeoPathResponse::VT_NETWORK, network);
  }
  void add_start_seg(::flatbuffers::Offset<fb::uuid_msgs::UniqueID> start_seg) {
    fbb_.AddOffset(GetGeoPathResponse::VT_START_SEG, start_seg);
  }
  void add_goal_seg(::flatbuffers::Offset<fb::uuid_msgs::UniqueID> goal_seg) {
    fbb_.AddOffset(GetGeoPathResponse::VT_GOAL_SEG, goal_seg);
  }
  void add_distance(double distance) {
    fbb_.AddElement<double>(GetGeoPathResponse::VT_DISTANCE, distance, 0.0);
  }
  explicit GetGeoPathResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetGeoPathResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetGeoPathResponse>(end);
    fbb_.Required(o, GetGeoPathResponse::VT_STATUS);
    fbb_.Required(o, GetGeoPathResponse::VT_PLAN);
    fbb_.Required(o, GetGeoPathResponse::VT_NETWORK);
    fbb_.Required(o, GetGeoPathResponse::VT_START_SEG);
    fbb_.Required(o, GetGeoPathResponse::VT_GOAL_SEG);
    return o;
  }
};

inline ::flatbuffers::Offset<GetGeoPathResponse> CreateGetGeoPathResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    bool success = false,
    ::flatbuffers::Offset<::flatbuffers::String> status = 0,
    ::flatbuffers::Offset<fb::geographic_msgs::GeoPath> plan = 0,
    ::flatbuffers::Offset<fb::uuid_msgs::UniqueID> network = 0,
    ::flatbuffers::Offset<fb::uuid_msgs::UniqueID> start_seg = 0,
    ::flatbuffers::Offset<fb::uuid_msgs::UniqueID> goal_seg = 0,
    double distance = 0.0) {
  GetGeoPathResponseBuilder builder_(_fbb);
  builder_.add_distance(distance);
  builder_.add_goal_seg(goal_seg);
  builder_.add_start_seg(start_seg);
  builder_.add_network(network);
  builder_.add_plan(plan);
  builder_.add_status(status);
  builder_.add___metadata(__metadata);
  builder_.add_success(success);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GetGeoPathResponse> CreateGetGeoPathResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    bool success = false,
    const char *status = nullptr,
    ::flatbuffers::Offset<fb::geographic_msgs::GeoPath> plan = 0,
    ::flatbuffers::Offset<fb::uuid_msgs::UniqueID> network = 0,
    ::flatbuffers::Offset<fb::uuid_msgs::UniqueID> start_seg = 0,
    ::flatbuffers::Offset<fb::uuid_msgs::UniqueID> goal_seg = 0,
    double distance = 0.0) {
  auto status__ = status ? _fbb.CreateString(status) : 0;
  return fb::geographic_msgs::CreateGetGeoPathResponse(
      _fbb,
      __metadata,
      success,
      status__,
      plan,
      network,
      start_seg,
      goal_seg,
      distance);
}

::flatbuffers::Offset<GetGeoPathResponse> CreateGetGeoPathResponse(::flatbuffers::FlatBufferBuilder &_fbb, const GetGeoPathResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GeoPointT : public ::flatbuffers::NativeTable {
  typedef GeoPoint TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  double latitude = 0.0;
  double longitude = 0.0;
  double altitude = 0.0;
  GeoPointT() = default;
  GeoPointT(const GeoPointT &o);
  GeoPointT(GeoPointT&&) FLATBUFFERS_NOEXCEPT = default;
  GeoPointT &operator=(GeoPointT o) FLATBUFFERS_NOEXCEPT;
};

struct GeoPoint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GeoPointT NativeTableType;
  typedef GeoPointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_LATITUDE = 6,
    VT_LONGITUDE = 8,
    VT_ALTITUDE = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  double latitude() const {
    return GetField<double>(VT_LATITUDE, 0.0);
  }
  double longitude() const {
    return GetField<double>(VT_LONGITUDE, 0.0);
  }
  double altitude() const {
    return GetField<double>(VT_ALTITUDE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<double>(verifier, VT_LATITUDE, 8) &&
           VerifyField<double>(verifier, VT_LONGITUDE, 8) &&
           VerifyField<double>(verifier, VT_ALTITUDE, 8) &&
           verifier.EndTable();
  }
  GeoPointT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GeoPointT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GeoPoint> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GeoPointT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GeoPointBuilder {
  typedef GeoPoint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GeoPoint::VT___METADATA, __metadata);
  }
  void add_latitude(double latitude) {
    fbb_.AddElement<double>(GeoPoint::VT_LATITUDE, latitude, 0.0);
  }
  void add_longitude(double longitude) {
    fbb_.AddElement<double>(GeoPoint::VT_LONGITUDE, longitude, 0.0);
  }
  void add_altitude(double altitude) {
    fbb_.AddElement<double>(GeoPoint::VT_ALTITUDE, altitude, 0.0);
  }
  explicit GeoPointBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GeoPoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GeoPoint>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GeoPoint> CreateGeoPoint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    double latitude = 0.0,
    double longitude = 0.0,
    double altitude = 0.0) {
  GeoPointBuilder builder_(_fbb);
  builder_.add_altitude(altitude);
  builder_.add_longitude(longitude);
  builder_.add_latitude(latitude);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<GeoPoint> CreateGeoPoint(::flatbuffers::FlatBufferBuilder &_fbb, const GeoPointT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WayPointT : public ::flatbuffers::NativeTable {
  typedef WayPoint TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::uuid_msgs::UniqueIDT> id{};
  std::unique_ptr<fb::geographic_msgs::GeoPointT> position{};
  std::vector<std::unique_ptr<fb::geographic_msgs::KeyValueT>> props{};
  WayPointT() = default;
  WayPointT(const WayPointT &o);
  WayPointT(WayPointT&&) FLATBUFFERS_NOEXCEPT = default;
  WayPointT &operator=(WayPointT o) FLATBUFFERS_NOEXCEPT;
};

struct WayPoint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WayPointT NativeTableType;
  typedef WayPointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_ID = 6,
    VT_POSITION = 8,
    VT_PROPS = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::uuid_msgs::UniqueID *id() const {
    return GetPointer<const fb::uuid_msgs::UniqueID *>(VT_ID);
  }
  const fb::geographic_msgs::GeoPoint *position() const {
    return GetPointer<const fb::geographic_msgs::GeoPoint *>(VT_POSITION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>> *props() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>> *>(VT_PROPS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffsetRequired(verifier, VT_POSITION) &&
           verifier.VerifyTable(position()) &&
           VerifyOffsetRequired(verifier, VT_PROPS) &&
           verifier.VerifyVector(props()) &&
           verifier.VerifyVectorOfTables(props()) &&
           verifier.EndTable();
  }
  WayPointT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WayPointT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<WayPoint> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WayPointT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WayPointBuilder {
  typedef WayPoint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(WayPoint::VT___METADATA, __metadata);
  }
  void add_id(::flatbuffers::Offset<fb::uuid_msgs::UniqueID> id) {
    fbb_.AddOffset(WayPoint::VT_ID, id);
  }
  void add_position(::flatbuffers::Offset<fb::geographic_msgs::GeoPoint> position) {
    fbb_.AddOffset(WayPoint::VT_POSITION, position);
  }
  void add_props(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>>> props) {
    fbb_.AddOffset(WayPoint::VT_PROPS, props);
  }
  explicit WayPointBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WayPoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WayPoint>(end);
    fbb_.Required(o, WayPoint::VT_ID);
    fbb_.Required(o, WayPoint::VT_POSITION);
    fbb_.Required(o, WayPoint::VT_PROPS);
    return o;
  }
};

inline ::flatbuffers::Offset<WayPoint> CreateWayPoint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::uuid_msgs::UniqueID> id = 0,
    ::flatbuffers::Offset<fb::geographic_msgs::GeoPoint> position = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>>> props = 0) {
  WayPointBuilder builder_(_fbb);
  builder_.add_props(props);
  builder_.add_position(position);
  builder_.add_id(id);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<WayPoint> CreateWayPointDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::uuid_msgs::UniqueID> id = 0,
    ::flatbuffers::Offset<fb::geographic_msgs::GeoPoint> position = 0,
    const std::vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>> *props = nullptr) {
  auto props__ = props ? _fbb.CreateVector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>>(*props) : 0;
  return fb::geographic_msgs::CreateWayPoint(
      _fbb,
      __metadata,
      id,
      position,
      props__);
}

::flatbuffers::Offset<WayPoint> CreateWayPoint(::flatbuffers::FlatBufferBuilder &_fbb, const WayPointT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GeoPoseWithCovarianceT : public ::flatbuffers::NativeTable {
  typedef GeoPoseWithCovariance TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::geographic_msgs::GeoPoseT> pose{};
  std::vector<double> covariance{};
  GeoPoseWithCovarianceT() = default;
  GeoPoseWithCovarianceT(const GeoPoseWithCovarianceT &o);
  GeoPoseWithCovarianceT(GeoPoseWithCovarianceT&&) FLATBUFFERS_NOEXCEPT = default;
  GeoPoseWithCovarianceT &operator=(GeoPoseWithCovarianceT o) FLATBUFFERS_NOEXCEPT;
};

struct GeoPoseWithCovariance FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GeoPoseWithCovarianceT NativeTableType;
  typedef GeoPoseWithCovarianceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_POSE = 6,
    VT_COVARIANCE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geographic_msgs::GeoPose *pose() const {
    return GetPointer<const fb::geographic_msgs::GeoPose *>(VT_POSE);
  }
  const ::flatbuffers::Vector<double> *covariance() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_COVARIANCE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           VerifyOffsetRequired(verifier, VT_COVARIANCE) &&
           verifier.VerifyVector(covariance()) &&
           verifier.EndTable();
  }
  GeoPoseWithCovarianceT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GeoPoseWithCovarianceT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GeoPoseWithCovariance> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseWithCovarianceT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GeoPoseWithCovarianceBuilder {
  typedef GeoPoseWithCovariance Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GeoPoseWithCovariance::VT___METADATA, __metadata);
  }
  void add_pose(::flatbuffers::Offset<fb::geographic_msgs::GeoPose> pose) {
    fbb_.AddOffset(GeoPoseWithCovariance::VT_POSE, pose);
  }
  void add_covariance(::flatbuffers::Offset<::flatbuffers::Vector<double>> covariance) {
    fbb_.AddOffset(GeoPoseWithCovariance::VT_COVARIANCE, covariance);
  }
  explicit GeoPoseWithCovarianceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GeoPoseWithCovariance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GeoPoseWithCovariance>(end);
    fbb_.Required(o, GeoPoseWithCovariance::VT_POSE);
    fbb_.Required(o, GeoPoseWithCovariance::VT_COVARIANCE);
    return o;
  }
};

inline ::flatbuffers::Offset<GeoPoseWithCovariance> CreateGeoPoseWithCovariance(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geographic_msgs::GeoPose> pose = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> covariance = 0) {
  GeoPoseWithCovarianceBuilder builder_(_fbb);
  builder_.add_covariance(covariance);
  builder_.add_pose(pose);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GeoPoseWithCovariance> CreateGeoPoseWithCovarianceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geographic_msgs::GeoPose> pose = 0,
    const std::vector<double> *covariance = nullptr) {
  auto covariance__ = covariance ? _fbb.CreateVector<double>(*covariance) : 0;
  return fb::geographic_msgs::CreateGeoPoseWithCovariance(
      _fbb,
      __metadata,
      pose,
      covariance__);
}

::flatbuffers::Offset<GeoPoseWithCovariance> CreateGeoPoseWithCovariance(::flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseWithCovarianceT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GeoPoseT : public ::flatbuffers::NativeTable {
  typedef GeoPose TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::geographic_msgs::GeoPointT> position{};
  std::unique_ptr<fb::geometry_msgs::QuaternionT> orientation{};
  GeoPoseT() = default;
  GeoPoseT(const GeoPoseT &o);
  GeoPoseT(GeoPoseT&&) FLATBUFFERS_NOEXCEPT = default;
  GeoPoseT &operator=(GeoPoseT o) FLATBUFFERS_NOEXCEPT;
};

struct GeoPose FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GeoPoseT NativeTableType;
  typedef GeoPoseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_POSITION = 6,
    VT_ORIENTATION = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geographic_msgs::GeoPoint *position() const {
    return GetPointer<const fb::geographic_msgs::GeoPoint *>(VT_POSITION);
  }
  const fb::geometry_msgs::Quaternion *orientation() const {
    return GetPointer<const fb::geometry_msgs::Quaternion *>(VT_ORIENTATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_POSITION) &&
           verifier.VerifyTable(position()) &&
           VerifyOffsetRequired(verifier, VT_ORIENTATION) &&
           verifier.VerifyTable(orientation()) &&
           verifier.EndTable();
  }
  GeoPoseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GeoPoseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GeoPose> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GeoPoseBuilder {
  typedef GeoPose Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GeoPose::VT___METADATA, __metadata);
  }
  void add_position(::flatbuffers::Offset<fb::geographic_msgs::GeoPoint> position) {
    fbb_.AddOffset(GeoPose::VT_POSITION, position);
  }
  void add_orientation(::flatbuffers::Offset<fb::geometry_msgs::Quaternion> orientation) {
    fbb_.AddOffset(GeoPose::VT_ORIENTATION, orientation);
  }
  explicit GeoPoseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GeoPose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GeoPose>(end);
    fbb_.Required(o, GeoPose::VT_POSITION);
    fbb_.Required(o, GeoPose::VT_ORIENTATION);
    return o;
  }
};

inline ::flatbuffers::Offset<GeoPose> CreateGeoPose(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geographic_msgs::GeoPoint> position = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Quaternion> orientation = 0) {
  GeoPoseBuilder builder_(_fbb);
  builder_.add_orientation(orientation);
  builder_.add_position(position);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<GeoPose> CreateGeoPose(::flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BoundingBoxT : public ::flatbuffers::NativeTable {
  typedef BoundingBox TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::geographic_msgs::GeoPointT> min_pt{};
  std::unique_ptr<fb::geographic_msgs::GeoPointT> max_pt{};
  BoundingBoxT() = default;
  BoundingBoxT(const BoundingBoxT &o);
  BoundingBoxT(BoundingBoxT&&) FLATBUFFERS_NOEXCEPT = default;
  BoundingBoxT &operator=(BoundingBoxT o) FLATBUFFERS_NOEXCEPT;
};

struct BoundingBox FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BoundingBoxT NativeTableType;
  typedef BoundingBoxBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_MIN_PT = 6,
    VT_MAX_PT = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geographic_msgs::GeoPoint *min_pt() const {
    return GetPointer<const fb::geographic_msgs::GeoPoint *>(VT_MIN_PT);
  }
  const fb::geographic_msgs::GeoPoint *max_pt() const {
    return GetPointer<const fb::geographic_msgs::GeoPoint *>(VT_MAX_PT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_MIN_PT) &&
           verifier.VerifyTable(min_pt()) &&
           VerifyOffsetRequired(verifier, VT_MAX_PT) &&
           verifier.VerifyTable(max_pt()) &&
           verifier.EndTable();
  }
  BoundingBoxT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BoundingBoxT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BoundingBox> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BoundingBoxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BoundingBoxBuilder {
  typedef BoundingBox Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(BoundingBox::VT___METADATA, __metadata);
  }
  void add_min_pt(::flatbuffers::Offset<fb::geographic_msgs::GeoPoint> min_pt) {
    fbb_.AddOffset(BoundingBox::VT_MIN_PT, min_pt);
  }
  void add_max_pt(::flatbuffers::Offset<fb::geographic_msgs::GeoPoint> max_pt) {
    fbb_.AddOffset(BoundingBox::VT_MAX_PT, max_pt);
  }
  explicit BoundingBoxBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BoundingBox> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BoundingBox>(end);
    fbb_.Required(o, BoundingBox::VT_MIN_PT);
    fbb_.Required(o, BoundingBox::VT_MAX_PT);
    return o;
  }
};

inline ::flatbuffers::Offset<BoundingBox> CreateBoundingBox(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geographic_msgs::GeoPoint> min_pt = 0,
    ::flatbuffers::Offset<fb::geographic_msgs::GeoPoint> max_pt = 0) {
  BoundingBoxBuilder builder_(_fbb);
  builder_.add_max_pt(max_pt);
  builder_.add_min_pt(min_pt);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<BoundingBox> CreateBoundingBox(::flatbuffers::FlatBufferBuilder &_fbb, const BoundingBoxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GeoPointStampedT : public ::flatbuffers::NativeTable {
  typedef GeoPointStamped TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::geographic_msgs::GeoPointT> position{};
  GeoPointStampedT() = default;
  GeoPointStampedT(const GeoPointStampedT &o);
  GeoPointStampedT(GeoPointStampedT&&) FLATBUFFERS_NOEXCEPT = default;
  GeoPointStampedT &operator=(GeoPointStampedT o) FLATBUFFERS_NOEXCEPT;
};

struct GeoPointStamped FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GeoPointStampedT NativeTableType;
  typedef GeoPointStampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_POSITION = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geographic_msgs::GeoPoint *position() const {
    return GetPointer<const fb::geographic_msgs::GeoPoint *>(VT_POSITION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_POSITION) &&
           verifier.VerifyTable(position()) &&
           verifier.EndTable();
  }
  GeoPointStampedT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GeoPointStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GeoPointStamped> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GeoPointStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GeoPointStampedBuilder {
  typedef GeoPointStamped Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GeoPointStamped::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(GeoPointStamped::VT_HEADER, header);
  }
  void add_position(::flatbuffers::Offset<fb::geographic_msgs::GeoPoint> position) {
    fbb_.AddOffset(GeoPointStamped::VT_POSITION, position);
  }
  explicit GeoPointStampedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GeoPointStamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GeoPointStamped>(end);
    fbb_.Required(o, GeoPointStamped::VT_HEADER);
    fbb_.Required(o, GeoPointStamped::VT_POSITION);
    return o;
  }
};

inline ::flatbuffers::Offset<GeoPointStamped> CreateGeoPointStamped(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::geographic_msgs::GeoPoint> position = 0) {
  GeoPointStampedBuilder builder_(_fbb);
  builder_.add_position(position);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<GeoPointStamped> CreateGeoPointStamped(::flatbuffers::FlatBufferBuilder &_fbb, const GeoPointStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RouteNetworkT : public ::flatbuffers::NativeTable {
  typedef RouteNetwork TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::uuid_msgs::UniqueIDT> id{};
  std::unique_ptr<fb::geographic_msgs::BoundingBoxT> bounds{};
  std::vector<std::unique_ptr<fb::geographic_msgs::WayPointT>> points{};
  std::vector<std::unique_ptr<fb::geographic_msgs::RouteSegmentT>> segments{};
  std::vector<std::unique_ptr<fb::geographic_msgs::KeyValueT>> props{};
  RouteNetworkT() = default;
  RouteNetworkT(const RouteNetworkT &o);
  RouteNetworkT(RouteNetworkT&&) FLATBUFFERS_NOEXCEPT = default;
  RouteNetworkT &operator=(RouteNetworkT o) FLATBUFFERS_NOEXCEPT;
};

struct RouteNetwork FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RouteNetworkT NativeTableType;
  typedef RouteNetworkBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_ID = 8,
    VT_BOUNDS = 10,
    VT_POINTS = 12,
    VT_SEGMENTS = 14,
    VT_PROPS = 16
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::uuid_msgs::UniqueID *id() const {
    return GetPointer<const fb::uuid_msgs::UniqueID *>(VT_ID);
  }
  const fb::geographic_msgs::BoundingBox *bounds() const {
    return GetPointer<const fb::geographic_msgs::BoundingBox *>(VT_BOUNDS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::WayPoint>> *points() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::WayPoint>> *>(VT_POINTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::RouteSegment>> *segments() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::RouteSegment>> *>(VT_SEGMENTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>> *props() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>> *>(VT_PROPS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffsetRequired(verifier, VT_BOUNDS) &&
           verifier.VerifyTable(bounds()) &&
           VerifyOffsetRequired(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.VerifyVectorOfTables(points()) &&
           VerifyOffsetRequired(verifier, VT_SEGMENTS) &&
           verifier.VerifyVector(segments()) &&
           verifier.VerifyVectorOfTables(segments()) &&
           VerifyOffsetRequired(verifier, VT_PROPS) &&
           verifier.VerifyVector(props()) &&
           verifier.VerifyVectorOfTables(props()) &&
           verifier.EndTable();
  }
  RouteNetworkT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RouteNetworkT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RouteNetwork> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RouteNetworkT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RouteNetworkBuilder {
  typedef RouteNetwork Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(RouteNetwork::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(RouteNetwork::VT_HEADER, header);
  }
  void add_id(::flatbuffers::Offset<fb::uuid_msgs::UniqueID> id) {
    fbb_.AddOffset(RouteNetwork::VT_ID, id);
  }
  void add_bounds(::flatbuffers::Offset<fb::geographic_msgs::BoundingBox> bounds) {
    fbb_.AddOffset(RouteNetwork::VT_BOUNDS, bounds);
  }
  void add_points(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::WayPoint>>> points) {
    fbb_.AddOffset(RouteNetwork::VT_POINTS, points);
  }
  void add_segments(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::RouteSegment>>> segments) {
    fbb_.AddOffset(RouteNetwork::VT_SEGMENTS, segments);
  }
  void add_props(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>>> props) {
    fbb_.AddOffset(RouteNetwork::VT_PROPS, props);
  }
  explicit RouteNetworkBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RouteNetwork> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RouteNetwork>(end);
    fbb_.Required(o, RouteNetwork::VT_HEADER);
    fbb_.Required(o, RouteNetwork::VT_ID);
    fbb_.Required(o, RouteNetwork::VT_BOUNDS);
    fbb_.Required(o, RouteNetwork::VT_POINTS);
    fbb_.Required(o, RouteNetwork::VT_SEGMENTS);
    fbb_.Required(o, RouteNetwork::VT_PROPS);
    return o;
  }
};

inline ::flatbuffers::Offset<RouteNetwork> CreateRouteNetwork(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::uuid_msgs::UniqueID> id = 0,
    ::flatbuffers::Offset<fb::geographic_msgs::BoundingBox> bounds = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::WayPoint>>> points = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::RouteSegment>>> segments = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>>> props = 0) {
  RouteNetworkBuilder builder_(_fbb);
  builder_.add_props(props);
  builder_.add_segments(segments);
  builder_.add_points(points);
  builder_.add_bounds(bounds);
  builder_.add_id(id);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RouteNetwork> CreateRouteNetworkDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::uuid_msgs::UniqueID> id = 0,
    ::flatbuffers::Offset<fb::geographic_msgs::BoundingBox> bounds = 0,
    const std::vector<::flatbuffers::Offset<fb::geographic_msgs::WayPoint>> *points = nullptr,
    const std::vector<::flatbuffers::Offset<fb::geographic_msgs::RouteSegment>> *segments = nullptr,
    const std::vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>> *props = nullptr) {
  auto points__ = points ? _fbb.CreateVector<::flatbuffers::Offset<fb::geographic_msgs::WayPoint>>(*points) : 0;
  auto segments__ = segments ? _fbb.CreateVector<::flatbuffers::Offset<fb::geographic_msgs::RouteSegment>>(*segments) : 0;
  auto props__ = props ? _fbb.CreateVector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>>(*props) : 0;
  return fb::geographic_msgs::CreateRouteNetwork(
      _fbb,
      __metadata,
      header,
      id,
      bounds,
      points__,
      segments__,
      props__);
}

::flatbuffers::Offset<RouteNetwork> CreateRouteNetwork(::flatbuffers::FlatBufferBuilder &_fbb, const RouteNetworkT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MapFeatureT : public ::flatbuffers::NativeTable {
  typedef MapFeature TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::uuid_msgs::UniqueIDT> id{};
  std::vector<std::unique_ptr<fb::uuid_msgs::UniqueIDT>> components{};
  std::vector<std::unique_ptr<fb::geographic_msgs::KeyValueT>> props{};
  MapFeatureT() = default;
  MapFeatureT(const MapFeatureT &o);
  MapFeatureT(MapFeatureT&&) FLATBUFFERS_NOEXCEPT = default;
  MapFeatureT &operator=(MapFeatureT o) FLATBUFFERS_NOEXCEPT;
};

struct MapFeature FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MapFeatureT NativeTableType;
  typedef MapFeatureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_ID = 6,
    VT_COMPONENTS = 8,
    VT_PROPS = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::uuid_msgs::UniqueID *id() const {
    return GetPointer<const fb::uuid_msgs::UniqueID *>(VT_ID);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::uuid_msgs::UniqueID>> *components() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::uuid_msgs::UniqueID>> *>(VT_COMPONENTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>> *props() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>> *>(VT_PROPS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffsetRequired(verifier, VT_COMPONENTS) &&
           verifier.VerifyVector(components()) &&
           verifier.VerifyVectorOfTables(components()) &&
           VerifyOffsetRequired(verifier, VT_PROPS) &&
           verifier.VerifyVector(props()) &&
           verifier.VerifyVectorOfTables(props()) &&
           verifier.EndTable();
  }
  MapFeatureT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MapFeatureT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<MapFeature> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MapFeatureT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MapFeatureBuilder {
  typedef MapFeature Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(MapFeature::VT___METADATA, __metadata);
  }
  void add_id(::flatbuffers::Offset<fb::uuid_msgs::UniqueID> id) {
    fbb_.AddOffset(MapFeature::VT_ID, id);
  }
  void add_components(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::uuid_msgs::UniqueID>>> components) {
    fbb_.AddOffset(MapFeature::VT_COMPONENTS, components);
  }
  void add_props(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>>> props) {
    fbb_.AddOffset(MapFeature::VT_PROPS, props);
  }
  explicit MapFeatureBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MapFeature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MapFeature>(end);
    fbb_.Required(o, MapFeature::VT_ID);
    fbb_.Required(o, MapFeature::VT_COMPONENTS);
    fbb_.Required(o, MapFeature::VT_PROPS);
    return o;
  }
};

inline ::flatbuffers::Offset<MapFeature> CreateMapFeature(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::uuid_msgs::UniqueID> id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::uuid_msgs::UniqueID>>> components = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>>> props = 0) {
  MapFeatureBuilder builder_(_fbb);
  builder_.add_props(props);
  builder_.add_components(components);
  builder_.add_id(id);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MapFeature> CreateMapFeatureDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::uuid_msgs::UniqueID> id = 0,
    const std::vector<::flatbuffers::Offset<fb::uuid_msgs::UniqueID>> *components = nullptr,
    const std::vector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>> *props = nullptr) {
  auto components__ = components ? _fbb.CreateVector<::flatbuffers::Offset<fb::uuid_msgs::UniqueID>>(*components) : 0;
  auto props__ = props ? _fbb.CreateVector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>>(*props) : 0;
  return fb::geographic_msgs::CreateMapFeature(
      _fbb,
      __metadata,
      id,
      components__,
      props__);
}

::flatbuffers::Offset<MapFeature> CreateMapFeature(::flatbuffers::FlatBufferBuilder &_fbb, const MapFeatureT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetGeographicMapRequestT : public ::flatbuffers::NativeTable {
  typedef GetGeographicMapRequest TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string url{};
  std::unique_ptr<fb::geographic_msgs::BoundingBoxT> bounds{};
  GetGeographicMapRequestT() = default;
  GetGeographicMapRequestT(const GetGeographicMapRequestT &o);
  GetGeographicMapRequestT(GetGeographicMapRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  GetGeographicMapRequestT &operator=(GetGeographicMapRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct GetGeographicMapRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetGeographicMapRequestT NativeTableType;
  typedef GetGeographicMapRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_URL = 6,
    VT_BOUNDS = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *url() const {
    return GetPointer<const ::flatbuffers::String *>(VT_URL);
  }
  const fb::geographic_msgs::BoundingBox *bounds() const {
    return GetPointer<const fb::geographic_msgs::BoundingBox *>(VT_BOUNDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_URL) &&
           verifier.VerifyString(url()) &&
           VerifyOffsetRequired(verifier, VT_BOUNDS) &&
           verifier.VerifyTable(bounds()) &&
           verifier.EndTable();
  }
  GetGeographicMapRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetGeographicMapRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GetGeographicMapRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetGeographicMapRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetGeographicMapRequestBuilder {
  typedef GetGeographicMapRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GetGeographicMapRequest::VT___METADATA, __metadata);
  }
  void add_url(::flatbuffers::Offset<::flatbuffers::String> url) {
    fbb_.AddOffset(GetGeographicMapRequest::VT_URL, url);
  }
  void add_bounds(::flatbuffers::Offset<fb::geographic_msgs::BoundingBox> bounds) {
    fbb_.AddOffset(GetGeographicMapRequest::VT_BOUNDS, bounds);
  }
  explicit GetGeographicMapRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetGeographicMapRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetGeographicMapRequest>(end);
    fbb_.Required(o, GetGeographicMapRequest::VT_URL);
    fbb_.Required(o, GetGeographicMapRequest::VT_BOUNDS);
    return o;
  }
};

inline ::flatbuffers::Offset<GetGeographicMapRequest> CreateGetGeographicMapRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> url = 0,
    ::flatbuffers::Offset<fb::geographic_msgs::BoundingBox> bounds = 0) {
  GetGeographicMapRequestBuilder builder_(_fbb);
  builder_.add_bounds(bounds);
  builder_.add_url(url);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GetGeographicMapRequest> CreateGetGeographicMapRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *url = nullptr,
    ::flatbuffers::Offset<fb::geographic_msgs::BoundingBox> bounds = 0) {
  auto url__ = url ? _fbb.CreateString(url) : 0;
  return fb::geographic_msgs::CreateGetGeographicMapRequest(
      _fbb,
      __metadata,
      url__,
      bounds);
}

::flatbuffers::Offset<GetGeographicMapRequest> CreateGetGeographicMapRequest(::flatbuffers::FlatBufferBuilder &_fbb, const GetGeographicMapRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetGeographicMapResponseT : public ::flatbuffers::NativeTable {
  typedef GetGeographicMapResponse TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  bool success = false;
  std::string status{};
  std::unique_ptr<fb::geographic_msgs::GeographicMapT> map{};
  GetGeographicMapResponseT() = default;
  GetGeographicMapResponseT(const GetGeographicMapResponseT &o);
  GetGeographicMapResponseT(GetGeographicMapResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  GetGeographicMapResponseT &operator=(GetGeographicMapResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct GetGeographicMapResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetGeographicMapResponseT NativeTableType;
  typedef GetGeographicMapResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_SUCCESS = 6,
    VT_STATUS = 8,
    VT_MAP = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  const ::flatbuffers::String *status() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATUS);
  }
  const fb::geographic_msgs::GeographicMap *map() const {
    return GetPointer<const fb::geographic_msgs::GeographicMap *>(VT_MAP);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           VerifyOffsetRequired(verifier, VT_STATUS) &&
           verifier.VerifyString(status()) &&
           VerifyOffsetRequired(verifier, VT_MAP) &&
           verifier.VerifyTable(map()) &&
           verifier.EndTable();
  }
  GetGeographicMapResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetGeographicMapResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GetGeographicMapResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetGeographicMapResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetGeographicMapResponseBuilder {
  typedef GetGeographicMapResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GetGeographicMapResponse::VT___METADATA, __metadata);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(GetGeographicMapResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_status(::flatbuffers::Offset<::flatbuffers::String> status) {
    fbb_.AddOffset(GetGeographicMapResponse::VT_STATUS, status);
  }
  void add_map(::flatbuffers::Offset<fb::geographic_msgs::GeographicMap> map) {
    fbb_.AddOffset(GetGeographicMapResponse::VT_MAP, map);
  }
  explicit GetGeographicMapResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetGeographicMapResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetGeographicMapResponse>(end);
    fbb_.Required(o, GetGeographicMapResponse::VT_STATUS);
    fbb_.Required(o, GetGeographicMapResponse::VT_MAP);
    return o;
  }
};

inline ::flatbuffers::Offset<GetGeographicMapResponse> CreateGetGeographicMapResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    bool success = false,
    ::flatbuffers::Offset<::flatbuffers::String> status = 0,
    ::flatbuffers::Offset<fb::geographic_msgs::GeographicMap> map = 0) {
  GetGeographicMapResponseBuilder builder_(_fbb);
  builder_.add_map(map);
  builder_.add_status(status);
  builder_.add___metadata(__metadata);
  builder_.add_success(success);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GetGeographicMapResponse> CreateGetGeographicMapResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    bool success = false,
    const char *status = nullptr,
    ::flatbuffers::Offset<fb::geographic_msgs::GeographicMap> map = 0) {
  auto status__ = status ? _fbb.CreateString(status) : 0;
  return fb::geographic_msgs::CreateGetGeographicMapResponse(
      _fbb,
      __metadata,
      success,
      status__,
      map);
}

::flatbuffers::Offset<GetGeographicMapResponse> CreateGetGeographicMapResponse(::flatbuffers::FlatBufferBuilder &_fbb, const GetGeographicMapResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline GeoPoseWithCovarianceStampedT::GeoPoseWithCovarianceStampedT(const GeoPoseWithCovarianceStampedT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        pose((o.pose) ? new fb::geographic_msgs::GeoPoseWithCovarianceT(*o.pose) : nullptr) {
}

inline GeoPoseWithCovarianceStampedT &GeoPoseWithCovarianceStampedT::operator=(GeoPoseWithCovarianceStampedT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(pose, o.pose);
  return *this;
}

inline GeoPoseWithCovarianceStampedT *GeoPoseWithCovarianceStamped::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GeoPoseWithCovarianceStampedT>(new GeoPoseWithCovarianceStampedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GeoPoseWithCovarianceStamped::UnPackTo(GeoPoseWithCovarianceStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = pose(); if (_e) { if(_o->pose) { _e->UnPackTo(_o->pose.get(), _resolver); } else { _o->pose = std::unique_ptr<fb::geographic_msgs::GeoPoseWithCovarianceT>(_e->UnPack(_resolver)); } } else if (_o->pose) { _o->pose.reset(); } }
}

inline ::flatbuffers::Offset<GeoPoseWithCovarianceStamped> GeoPoseWithCovarianceStamped::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseWithCovarianceStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGeoPoseWithCovarianceStamped(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GeoPoseWithCovarianceStamped> CreateGeoPoseWithCovarianceStamped(::flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseWithCovarianceStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GeoPoseWithCovarianceStampedT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _pose = _o->pose ? CreateGeoPoseWithCovariance(_fbb, _o->pose.get(), _rehasher) : 0;
  return fb::geographic_msgs::CreateGeoPoseWithCovarianceStamped(
      _fbb,
      ___metadata,
      _header,
      _pose);
}

inline GeographicMapChangesT::GeographicMapChangesT(const GeographicMapChangesT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        diffs((o.diffs) ? new fb::geographic_msgs::GeographicMapT(*o.diffs) : nullptr) {
  deletes.reserve(o.deletes.size());
  for (const auto &deletes_ : o.deletes) { deletes.emplace_back((deletes_) ? new fb::uuid_msgs::UniqueIDT(*deletes_) : nullptr); }
}

inline GeographicMapChangesT &GeographicMapChangesT::operator=(GeographicMapChangesT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(diffs, o.diffs);
  std::swap(deletes, o.deletes);
  return *this;
}

inline GeographicMapChangesT *GeographicMapChanges::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GeographicMapChangesT>(new GeographicMapChangesT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GeographicMapChanges::UnPackTo(GeographicMapChangesT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = diffs(); if (_e) { if(_o->diffs) { _e->UnPackTo(_o->diffs.get(), _resolver); } else { _o->diffs = std::unique_ptr<fb::geographic_msgs::GeographicMapT>(_e->UnPack(_resolver)); } } else if (_o->diffs) { _o->diffs.reset(); } }
  { auto _e = deletes(); if (_e) { _o->deletes.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->deletes[_i]) { _e->Get(_i)->UnPackTo(_o->deletes[_i].get(), _resolver); } else { _o->deletes[_i] = std::unique_ptr<fb::uuid_msgs::UniqueIDT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->deletes.resize(0); } }
}

inline ::flatbuffers::Offset<GeographicMapChanges> GeographicMapChanges::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GeographicMapChangesT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGeographicMapChanges(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GeographicMapChanges> CreateGeographicMapChanges(::flatbuffers::FlatBufferBuilder &_fbb, const GeographicMapChangesT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GeographicMapChangesT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _diffs = _o->diffs ? CreateGeographicMap(_fbb, _o->diffs.get(), _rehasher) : 0;
  auto _deletes = _fbb.CreateVector<::flatbuffers::Offset<fb::uuid_msgs::UniqueID>> (_o->deletes.size(), [](size_t i, _VectorArgs *__va) { return CreateUniqueID(*__va->__fbb, __va->__o->deletes[i].get(), __va->__rehasher); }, &_va );
  return fb::geographic_msgs::CreateGeographicMapChanges(
      _fbb,
      ___metadata,
      _header,
      _diffs,
      _deletes);
}

inline GeoPoseStampedT::GeoPoseStampedT(const GeoPoseStampedT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        pose((o.pose) ? new fb::geographic_msgs::GeoPoseT(*o.pose) : nullptr) {
}

inline GeoPoseStampedT &GeoPoseStampedT::operator=(GeoPoseStampedT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(pose, o.pose);
  return *this;
}

inline GeoPoseStampedT *GeoPoseStamped::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GeoPoseStampedT>(new GeoPoseStampedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GeoPoseStamped::UnPackTo(GeoPoseStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = pose(); if (_e) { if(_o->pose) { _e->UnPackTo(_o->pose.get(), _resolver); } else { _o->pose = std::unique_ptr<fb::geographic_msgs::GeoPoseT>(_e->UnPack(_resolver)); } } else if (_o->pose) { _o->pose.reset(); } }
}

inline ::flatbuffers::Offset<GeoPoseStamped> GeoPoseStamped::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGeoPoseStamped(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GeoPoseStamped> CreateGeoPoseStamped(::flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GeoPoseStampedT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _pose = _o->pose ? CreateGeoPose(_fbb, _o->pose.get(), _rehasher) : 0;
  return fb::geographic_msgs::CreateGeoPoseStamped(
      _fbb,
      ___metadata,
      _header,
      _pose);
}

inline UpdateGeographicMapRequestT::UpdateGeographicMapRequestT(const UpdateGeographicMapRequestT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        updates((o.updates) ? new fb::geographic_msgs::GeographicMapChangesT(*o.updates) : nullptr) {
}

inline UpdateGeographicMapRequestT &UpdateGeographicMapRequestT::operator=(UpdateGeographicMapRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(updates, o.updates);
  return *this;
}

inline UpdateGeographicMapRequestT *UpdateGeographicMapRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UpdateGeographicMapRequestT>(new UpdateGeographicMapRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UpdateGeographicMapRequest::UnPackTo(UpdateGeographicMapRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = updates(); if (_e) { if(_o->updates) { _e->UnPackTo(_o->updates.get(), _resolver); } else { _o->updates = std::unique_ptr<fb::geographic_msgs::GeographicMapChangesT>(_e->UnPack(_resolver)); } } else if (_o->updates) { _o->updates.reset(); } }
}

inline ::flatbuffers::Offset<UpdateGeographicMapRequest> UpdateGeographicMapRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UpdateGeographicMapRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUpdateGeographicMapRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UpdateGeographicMapRequest> CreateUpdateGeographicMapRequest(::flatbuffers::FlatBufferBuilder &_fbb, const UpdateGeographicMapRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UpdateGeographicMapRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _updates = _o->updates ? CreateGeographicMapChanges(_fbb, _o->updates.get(), _rehasher) : 0;
  return fb::geographic_msgs::CreateUpdateGeographicMapRequest(
      _fbb,
      ___metadata,
      _updates);
}

inline UpdateGeographicMapResponseT::UpdateGeographicMapResponseT(const UpdateGeographicMapResponseT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        success(o.success),
        status(o.status) {
}

inline UpdateGeographicMapResponseT &UpdateGeographicMapResponseT::operator=(UpdateGeographicMapResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(success, o.success);
  std::swap(status, o.status);
  return *this;
}

inline UpdateGeographicMapResponseT *UpdateGeographicMapResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UpdateGeographicMapResponseT>(new UpdateGeographicMapResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UpdateGeographicMapResponse::UnPackTo(UpdateGeographicMapResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = success(); _o->success = _e; }
  { auto _e = status(); if (_e) _o->status = _e->str(); }
}

inline ::flatbuffers::Offset<UpdateGeographicMapResponse> UpdateGeographicMapResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UpdateGeographicMapResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUpdateGeographicMapResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UpdateGeographicMapResponse> CreateUpdateGeographicMapResponse(::flatbuffers::FlatBufferBuilder &_fbb, const UpdateGeographicMapResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UpdateGeographicMapResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _success = _o->success;
  auto _status = _fbb.CreateString(_o->status);
  return fb::geographic_msgs::CreateUpdateGeographicMapResponse(
      _fbb,
      ___metadata,
      _success,
      _status);
}

inline GeographicMapT::GeographicMapT(const GeographicMapT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        id((o.id) ? new fb::uuid_msgs::UniqueIDT(*o.id) : nullptr),
        bounds((o.bounds) ? new fb::geographic_msgs::BoundingBoxT(*o.bounds) : nullptr) {
  points.reserve(o.points.size());
  for (const auto &points_ : o.points) { points.emplace_back((points_) ? new fb::geographic_msgs::WayPointT(*points_) : nullptr); }
  features.reserve(o.features.size());
  for (const auto &features_ : o.features) { features.emplace_back((features_) ? new fb::geographic_msgs::MapFeatureT(*features_) : nullptr); }
  props.reserve(o.props.size());
  for (const auto &props_ : o.props) { props.emplace_back((props_) ? new fb::geographic_msgs::KeyValueT(*props_) : nullptr); }
}

inline GeographicMapT &GeographicMapT::operator=(GeographicMapT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(id, o.id);
  std::swap(bounds, o.bounds);
  std::swap(points, o.points);
  std::swap(features, o.features);
  std::swap(props, o.props);
  return *this;
}

inline GeographicMapT *GeographicMap::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GeographicMapT>(new GeographicMapT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GeographicMap::UnPackTo(GeographicMapT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = id(); if (_e) { if(_o->id) { _e->UnPackTo(_o->id.get(), _resolver); } else { _o->id = std::unique_ptr<fb::uuid_msgs::UniqueIDT>(_e->UnPack(_resolver)); } } else if (_o->id) { _o->id.reset(); } }
  { auto _e = bounds(); if (_e) { if(_o->bounds) { _e->UnPackTo(_o->bounds.get(), _resolver); } else { _o->bounds = std::unique_ptr<fb::geographic_msgs::BoundingBoxT>(_e->UnPack(_resolver)); } } else if (_o->bounds) { _o->bounds.reset(); } }
  { auto _e = points(); if (_e) { _o->points.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->points[_i]) { _e->Get(_i)->UnPackTo(_o->points[_i].get(), _resolver); } else { _o->points[_i] = std::unique_ptr<fb::geographic_msgs::WayPointT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->points.resize(0); } }
  { auto _e = features(); if (_e) { _o->features.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->features[_i]) { _e->Get(_i)->UnPackTo(_o->features[_i].get(), _resolver); } else { _o->features[_i] = std::unique_ptr<fb::geographic_msgs::MapFeatureT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->features.resize(0); } }
  { auto _e = props(); if (_e) { _o->props.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->props[_i]) { _e->Get(_i)->UnPackTo(_o->props[_i].get(), _resolver); } else { _o->props[_i] = std::unique_ptr<fb::geographic_msgs::KeyValueT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->props.resize(0); } }
}

inline ::flatbuffers::Offset<GeographicMap> GeographicMap::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GeographicMapT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGeographicMap(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GeographicMap> CreateGeographicMap(::flatbuffers::FlatBufferBuilder &_fbb, const GeographicMapT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GeographicMapT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _id = _o->id ? CreateUniqueID(_fbb, _o->id.get(), _rehasher) : 0;
  auto _bounds = _o->bounds ? CreateBoundingBox(_fbb, _o->bounds.get(), _rehasher) : 0;
  auto _points = _fbb.CreateVector<::flatbuffers::Offset<fb::geographic_msgs::WayPoint>> (_o->points.size(), [](size_t i, _VectorArgs *__va) { return CreateWayPoint(*__va->__fbb, __va->__o->points[i].get(), __va->__rehasher); }, &_va );
  auto _features = _fbb.CreateVector<::flatbuffers::Offset<fb::geographic_msgs::MapFeature>> (_o->features.size(), [](size_t i, _VectorArgs *__va) { return CreateMapFeature(*__va->__fbb, __va->__o->features[i].get(), __va->__rehasher); }, &_va );
  auto _props = _fbb.CreateVector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>> (_o->props.size(), [](size_t i, _VectorArgs *__va) { return CreateKeyValue(*__va->__fbb, __va->__o->props[i].get(), __va->__rehasher); }, &_va );
  return fb::geographic_msgs::CreateGeographicMap(
      _fbb,
      ___metadata,
      _header,
      _id,
      _bounds,
      _points,
      _features,
      _props);
}

inline KeyValueT::KeyValueT(const KeyValueT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        key(o.key),
        value(o.value) {
}

inline KeyValueT &KeyValueT::operator=(KeyValueT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(key, o.key);
  std::swap(value, o.value);
  return *this;
}

inline KeyValueT *KeyValue::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<KeyValueT>(new KeyValueT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void KeyValue::UnPackTo(KeyValueT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = key(); if (_e) _o->key = _e->str(); }
  { auto _e = value(); if (_e) _o->value = _e->str(); }
}

inline ::flatbuffers::Offset<KeyValue> KeyValue::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const KeyValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateKeyValue(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<KeyValue> CreateKeyValue(::flatbuffers::FlatBufferBuilder &_fbb, const KeyValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const KeyValueT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _key = _fbb.CreateString(_o->key);
  auto _value = _fbb.CreateString(_o->value);
  return fb::geographic_msgs::CreateKeyValue(
      _fbb,
      ___metadata,
      _key,
      _value);
}

inline RoutePathT::RoutePathT(const RoutePathT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        network((o.network) ? new fb::uuid_msgs::UniqueIDT(*o.network) : nullptr) {
  segments.reserve(o.segments.size());
  for (const auto &segments_ : o.segments) { segments.emplace_back((segments_) ? new fb::uuid_msgs::UniqueIDT(*segments_) : nullptr); }
  props.reserve(o.props.size());
  for (const auto &props_ : o.props) { props.emplace_back((props_) ? new fb::geographic_msgs::KeyValueT(*props_) : nullptr); }
}

inline RoutePathT &RoutePathT::operator=(RoutePathT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(network, o.network);
  std::swap(segments, o.segments);
  std::swap(props, o.props);
  return *this;
}

inline RoutePathT *RoutePath::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RoutePathT>(new RoutePathT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RoutePath::UnPackTo(RoutePathT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = network(); if (_e) { if(_o->network) { _e->UnPackTo(_o->network.get(), _resolver); } else { _o->network = std::unique_ptr<fb::uuid_msgs::UniqueIDT>(_e->UnPack(_resolver)); } } else if (_o->network) { _o->network.reset(); } }
  { auto _e = segments(); if (_e) { _o->segments.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->segments[_i]) { _e->Get(_i)->UnPackTo(_o->segments[_i].get(), _resolver); } else { _o->segments[_i] = std::unique_ptr<fb::uuid_msgs::UniqueIDT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->segments.resize(0); } }
  { auto _e = props(); if (_e) { _o->props.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->props[_i]) { _e->Get(_i)->UnPackTo(_o->props[_i].get(), _resolver); } else { _o->props[_i] = std::unique_ptr<fb::geographic_msgs::KeyValueT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->props.resize(0); } }
}

inline ::flatbuffers::Offset<RoutePath> RoutePath::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RoutePathT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRoutePath(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RoutePath> CreateRoutePath(::flatbuffers::FlatBufferBuilder &_fbb, const RoutePathT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RoutePathT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _network = _o->network ? CreateUniqueID(_fbb, _o->network.get(), _rehasher) : 0;
  auto _segments = _fbb.CreateVector<::flatbuffers::Offset<fb::uuid_msgs::UniqueID>> (_o->segments.size(), [](size_t i, _VectorArgs *__va) { return CreateUniqueID(*__va->__fbb, __va->__o->segments[i].get(), __va->__rehasher); }, &_va );
  auto _props = _fbb.CreateVector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>> (_o->props.size(), [](size_t i, _VectorArgs *__va) { return CreateKeyValue(*__va->__fbb, __va->__o->props[i].get(), __va->__rehasher); }, &_va );
  return fb::geographic_msgs::CreateRoutePath(
      _fbb,
      ___metadata,
      _header,
      _network,
      _segments,
      _props);
}

inline GetRoutePlanRequestT::GetRoutePlanRequestT(const GetRoutePlanRequestT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        network((o.network) ? new fb::uuid_msgs::UniqueIDT(*o.network) : nullptr),
        start((o.start) ? new fb::uuid_msgs::UniqueIDT(*o.start) : nullptr),
        goal((o.goal) ? new fb::uuid_msgs::UniqueIDT(*o.goal) : nullptr) {
}

inline GetRoutePlanRequestT &GetRoutePlanRequestT::operator=(GetRoutePlanRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(network, o.network);
  std::swap(start, o.start);
  std::swap(goal, o.goal);
  return *this;
}

inline GetRoutePlanRequestT *GetRoutePlanRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetRoutePlanRequestT>(new GetRoutePlanRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetRoutePlanRequest::UnPackTo(GetRoutePlanRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = network(); if (_e) { if(_o->network) { _e->UnPackTo(_o->network.get(), _resolver); } else { _o->network = std::unique_ptr<fb::uuid_msgs::UniqueIDT>(_e->UnPack(_resolver)); } } else if (_o->network) { _o->network.reset(); } }
  { auto _e = start(); if (_e) { if(_o->start) { _e->UnPackTo(_o->start.get(), _resolver); } else { _o->start = std::unique_ptr<fb::uuid_msgs::UniqueIDT>(_e->UnPack(_resolver)); } } else if (_o->start) { _o->start.reset(); } }
  { auto _e = goal(); if (_e) { if(_o->goal) { _e->UnPackTo(_o->goal.get(), _resolver); } else { _o->goal = std::unique_ptr<fb::uuid_msgs::UniqueIDT>(_e->UnPack(_resolver)); } } else if (_o->goal) { _o->goal.reset(); } }
}

inline ::flatbuffers::Offset<GetRoutePlanRequest> GetRoutePlanRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetRoutePlanRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetRoutePlanRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GetRoutePlanRequest> CreateGetRoutePlanRequest(::flatbuffers::FlatBufferBuilder &_fbb, const GetRoutePlanRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GetRoutePlanRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _network = _o->network ? CreateUniqueID(_fbb, _o->network.get(), _rehasher) : 0;
  auto _start = _o->start ? CreateUniqueID(_fbb, _o->start.get(), _rehasher) : 0;
  auto _goal = _o->goal ? CreateUniqueID(_fbb, _o->goal.get(), _rehasher) : 0;
  return fb::geographic_msgs::CreateGetRoutePlanRequest(
      _fbb,
      ___metadata,
      _network,
      _start,
      _goal);
}

inline GetRoutePlanResponseT::GetRoutePlanResponseT(const GetRoutePlanResponseT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        success(o.success),
        status(o.status),
        plan((o.plan) ? new fb::geographic_msgs::RoutePathT(*o.plan) : nullptr) {
}

inline GetRoutePlanResponseT &GetRoutePlanResponseT::operator=(GetRoutePlanResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(success, o.success);
  std::swap(status, o.status);
  std::swap(plan, o.plan);
  return *this;
}

inline GetRoutePlanResponseT *GetRoutePlanResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetRoutePlanResponseT>(new GetRoutePlanResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetRoutePlanResponse::UnPackTo(GetRoutePlanResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = success(); _o->success = _e; }
  { auto _e = status(); if (_e) _o->status = _e->str(); }
  { auto _e = plan(); if (_e) { if(_o->plan) { _e->UnPackTo(_o->plan.get(), _resolver); } else { _o->plan = std::unique_ptr<fb::geographic_msgs::RoutePathT>(_e->UnPack(_resolver)); } } else if (_o->plan) { _o->plan.reset(); } }
}

inline ::flatbuffers::Offset<GetRoutePlanResponse> GetRoutePlanResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetRoutePlanResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetRoutePlanResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GetRoutePlanResponse> CreateGetRoutePlanResponse(::flatbuffers::FlatBufferBuilder &_fbb, const GetRoutePlanResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GetRoutePlanResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _success = _o->success;
  auto _status = _fbb.CreateString(_o->status);
  auto _plan = _o->plan ? CreateRoutePath(_fbb, _o->plan.get(), _rehasher) : 0;
  return fb::geographic_msgs::CreateGetRoutePlanResponse(
      _fbb,
      ___metadata,
      _success,
      _status,
      _plan);
}

inline RouteSegmentT::RouteSegmentT(const RouteSegmentT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        id((o.id) ? new fb::uuid_msgs::UniqueIDT(*o.id) : nullptr),
        start((o.start) ? new fb::uuid_msgs::UniqueIDT(*o.start) : nullptr),
        end((o.end) ? new fb::uuid_msgs::UniqueIDT(*o.end) : nullptr) {
  props.reserve(o.props.size());
  for (const auto &props_ : o.props) { props.emplace_back((props_) ? new fb::geographic_msgs::KeyValueT(*props_) : nullptr); }
}

inline RouteSegmentT &RouteSegmentT::operator=(RouteSegmentT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(id, o.id);
  std::swap(start, o.start);
  std::swap(end, o.end);
  std::swap(props, o.props);
  return *this;
}

inline RouteSegmentT *RouteSegment::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RouteSegmentT>(new RouteSegmentT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RouteSegment::UnPackTo(RouteSegmentT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = id(); if (_e) { if(_o->id) { _e->UnPackTo(_o->id.get(), _resolver); } else { _o->id = std::unique_ptr<fb::uuid_msgs::UniqueIDT>(_e->UnPack(_resolver)); } } else if (_o->id) { _o->id.reset(); } }
  { auto _e = start(); if (_e) { if(_o->start) { _e->UnPackTo(_o->start.get(), _resolver); } else { _o->start = std::unique_ptr<fb::uuid_msgs::UniqueIDT>(_e->UnPack(_resolver)); } } else if (_o->start) { _o->start.reset(); } }
  { auto _e = end(); if (_e) { if(_o->end) { _e->UnPackTo(_o->end.get(), _resolver); } else { _o->end = std::unique_ptr<fb::uuid_msgs::UniqueIDT>(_e->UnPack(_resolver)); } } else if (_o->end) { _o->end.reset(); } }
  { auto _e = props(); if (_e) { _o->props.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->props[_i]) { _e->Get(_i)->UnPackTo(_o->props[_i].get(), _resolver); } else { _o->props[_i] = std::unique_ptr<fb::geographic_msgs::KeyValueT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->props.resize(0); } }
}

inline ::flatbuffers::Offset<RouteSegment> RouteSegment::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RouteSegmentT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRouteSegment(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RouteSegment> CreateRouteSegment(::flatbuffers::FlatBufferBuilder &_fbb, const RouteSegmentT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RouteSegmentT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _id = _o->id ? CreateUniqueID(_fbb, _o->id.get(), _rehasher) : 0;
  auto _start = _o->start ? CreateUniqueID(_fbb, _o->start.get(), _rehasher) : 0;
  auto _end = _o->end ? CreateUniqueID(_fbb, _o->end.get(), _rehasher) : 0;
  auto _props = _fbb.CreateVector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>> (_o->props.size(), [](size_t i, _VectorArgs *__va) { return CreateKeyValue(*__va->__fbb, __va->__o->props[i].get(), __va->__rehasher); }, &_va );
  return fb::geographic_msgs::CreateRouteSegment(
      _fbb,
      ___metadata,
      _id,
      _start,
      _end,
      _props);
}

inline GeoPathT::GeoPathT(const GeoPathT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr) {
  poses.reserve(o.poses.size());
  for (const auto &poses_ : o.poses) { poses.emplace_back((poses_) ? new fb::geographic_msgs::GeoPoseStampedT(*poses_) : nullptr); }
}

inline GeoPathT &GeoPathT::operator=(GeoPathT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(poses, o.poses);
  return *this;
}

inline GeoPathT *GeoPath::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GeoPathT>(new GeoPathT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GeoPath::UnPackTo(GeoPathT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = poses(); if (_e) { _o->poses.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->poses[_i]) { _e->Get(_i)->UnPackTo(_o->poses[_i].get(), _resolver); } else { _o->poses[_i] = std::unique_ptr<fb::geographic_msgs::GeoPoseStampedT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->poses.resize(0); } }
}

inline ::flatbuffers::Offset<GeoPath> GeoPath::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GeoPathT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGeoPath(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GeoPath> CreateGeoPath(::flatbuffers::FlatBufferBuilder &_fbb, const GeoPathT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GeoPathT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _poses = _fbb.CreateVector<::flatbuffers::Offset<fb::geographic_msgs::GeoPoseStamped>> (_o->poses.size(), [](size_t i, _VectorArgs *__va) { return CreateGeoPoseStamped(*__va->__fbb, __va->__o->poses[i].get(), __va->__rehasher); }, &_va );
  return fb::geographic_msgs::CreateGeoPath(
      _fbb,
      ___metadata,
      _header,
      _poses);
}

inline GetGeoPathRequestT::GetGeoPathRequestT(const GetGeoPathRequestT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        start((o.start) ? new fb::geographic_msgs::GeoPointT(*o.start) : nullptr),
        goal((o.goal) ? new fb::geographic_msgs::GeoPointT(*o.goal) : nullptr) {
}

inline GetGeoPathRequestT &GetGeoPathRequestT::operator=(GetGeoPathRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(start, o.start);
  std::swap(goal, o.goal);
  return *this;
}

inline GetGeoPathRequestT *GetGeoPathRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetGeoPathRequestT>(new GetGeoPathRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetGeoPathRequest::UnPackTo(GetGeoPathRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = start(); if (_e) { if(_o->start) { _e->UnPackTo(_o->start.get(), _resolver); } else { _o->start = std::unique_ptr<fb::geographic_msgs::GeoPointT>(_e->UnPack(_resolver)); } } else if (_o->start) { _o->start.reset(); } }
  { auto _e = goal(); if (_e) { if(_o->goal) { _e->UnPackTo(_o->goal.get(), _resolver); } else { _o->goal = std::unique_ptr<fb::geographic_msgs::GeoPointT>(_e->UnPack(_resolver)); } } else if (_o->goal) { _o->goal.reset(); } }
}

inline ::flatbuffers::Offset<GetGeoPathRequest> GetGeoPathRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetGeoPathRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetGeoPathRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GetGeoPathRequest> CreateGetGeoPathRequest(::flatbuffers::FlatBufferBuilder &_fbb, const GetGeoPathRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GetGeoPathRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _start = _o->start ? CreateGeoPoint(_fbb, _o->start.get(), _rehasher) : 0;
  auto _goal = _o->goal ? CreateGeoPoint(_fbb, _o->goal.get(), _rehasher) : 0;
  return fb::geographic_msgs::CreateGetGeoPathRequest(
      _fbb,
      ___metadata,
      _start,
      _goal);
}

inline GetGeoPathResponseT::GetGeoPathResponseT(const GetGeoPathResponseT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        success(o.success),
        status(o.status),
        plan((o.plan) ? new fb::geographic_msgs::GeoPathT(*o.plan) : nullptr),
        network((o.network) ? new fb::uuid_msgs::UniqueIDT(*o.network) : nullptr),
        start_seg((o.start_seg) ? new fb::uuid_msgs::UniqueIDT(*o.start_seg) : nullptr),
        goal_seg((o.goal_seg) ? new fb::uuid_msgs::UniqueIDT(*o.goal_seg) : nullptr),
        distance(o.distance) {
}

inline GetGeoPathResponseT &GetGeoPathResponseT::operator=(GetGeoPathResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(success, o.success);
  std::swap(status, o.status);
  std::swap(plan, o.plan);
  std::swap(network, o.network);
  std::swap(start_seg, o.start_seg);
  std::swap(goal_seg, o.goal_seg);
  std::swap(distance, o.distance);
  return *this;
}

inline GetGeoPathResponseT *GetGeoPathResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetGeoPathResponseT>(new GetGeoPathResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetGeoPathResponse::UnPackTo(GetGeoPathResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = success(); _o->success = _e; }
  { auto _e = status(); if (_e) _o->status = _e->str(); }
  { auto _e = plan(); if (_e) { if(_o->plan) { _e->UnPackTo(_o->plan.get(), _resolver); } else { _o->plan = std::unique_ptr<fb::geographic_msgs::GeoPathT>(_e->UnPack(_resolver)); } } else if (_o->plan) { _o->plan.reset(); } }
  { auto _e = network(); if (_e) { if(_o->network) { _e->UnPackTo(_o->network.get(), _resolver); } else { _o->network = std::unique_ptr<fb::uuid_msgs::UniqueIDT>(_e->UnPack(_resolver)); } } else if (_o->network) { _o->network.reset(); } }
  { auto _e = start_seg(); if (_e) { if(_o->start_seg) { _e->UnPackTo(_o->start_seg.get(), _resolver); } else { _o->start_seg = std::unique_ptr<fb::uuid_msgs::UniqueIDT>(_e->UnPack(_resolver)); } } else if (_o->start_seg) { _o->start_seg.reset(); } }
  { auto _e = goal_seg(); if (_e) { if(_o->goal_seg) { _e->UnPackTo(_o->goal_seg.get(), _resolver); } else { _o->goal_seg = std::unique_ptr<fb::uuid_msgs::UniqueIDT>(_e->UnPack(_resolver)); } } else if (_o->goal_seg) { _o->goal_seg.reset(); } }
  { auto _e = distance(); _o->distance = _e; }
}

inline ::flatbuffers::Offset<GetGeoPathResponse> GetGeoPathResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetGeoPathResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetGeoPathResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GetGeoPathResponse> CreateGetGeoPathResponse(::flatbuffers::FlatBufferBuilder &_fbb, const GetGeoPathResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GetGeoPathResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _success = _o->success;
  auto _status = _fbb.CreateString(_o->status);
  auto _plan = _o->plan ? CreateGeoPath(_fbb, _o->plan.get(), _rehasher) : 0;
  auto _network = _o->network ? CreateUniqueID(_fbb, _o->network.get(), _rehasher) : 0;
  auto _start_seg = _o->start_seg ? CreateUniqueID(_fbb, _o->start_seg.get(), _rehasher) : 0;
  auto _goal_seg = _o->goal_seg ? CreateUniqueID(_fbb, _o->goal_seg.get(), _rehasher) : 0;
  auto _distance = _o->distance;
  return fb::geographic_msgs::CreateGetGeoPathResponse(
      _fbb,
      ___metadata,
      _success,
      _status,
      _plan,
      _network,
      _start_seg,
      _goal_seg,
      _distance);
}

inline GeoPointT::GeoPointT(const GeoPointT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        latitude(o.latitude),
        longitude(o.longitude),
        altitude(o.altitude) {
}

inline GeoPointT &GeoPointT::operator=(GeoPointT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(latitude, o.latitude);
  std::swap(longitude, o.longitude);
  std::swap(altitude, o.altitude);
  return *this;
}

inline GeoPointT *GeoPoint::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GeoPointT>(new GeoPointT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GeoPoint::UnPackTo(GeoPointT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = latitude(); _o->latitude = _e; }
  { auto _e = longitude(); _o->longitude = _e; }
  { auto _e = altitude(); _o->altitude = _e; }
}

inline ::flatbuffers::Offset<GeoPoint> GeoPoint::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GeoPointT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGeoPoint(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GeoPoint> CreateGeoPoint(::flatbuffers::FlatBufferBuilder &_fbb, const GeoPointT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GeoPointT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _latitude = _o->latitude;
  auto _longitude = _o->longitude;
  auto _altitude = _o->altitude;
  return fb::geographic_msgs::CreateGeoPoint(
      _fbb,
      ___metadata,
      _latitude,
      _longitude,
      _altitude);
}

inline WayPointT::WayPointT(const WayPointT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        id((o.id) ? new fb::uuid_msgs::UniqueIDT(*o.id) : nullptr),
        position((o.position) ? new fb::geographic_msgs::GeoPointT(*o.position) : nullptr) {
  props.reserve(o.props.size());
  for (const auto &props_ : o.props) { props.emplace_back((props_) ? new fb::geographic_msgs::KeyValueT(*props_) : nullptr); }
}

inline WayPointT &WayPointT::operator=(WayPointT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(id, o.id);
  std::swap(position, o.position);
  std::swap(props, o.props);
  return *this;
}

inline WayPointT *WayPoint::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<WayPointT>(new WayPointT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void WayPoint::UnPackTo(WayPointT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = id(); if (_e) { if(_o->id) { _e->UnPackTo(_o->id.get(), _resolver); } else { _o->id = std::unique_ptr<fb::uuid_msgs::UniqueIDT>(_e->UnPack(_resolver)); } } else if (_o->id) { _o->id.reset(); } }
  { auto _e = position(); if (_e) { if(_o->position) { _e->UnPackTo(_o->position.get(), _resolver); } else { _o->position = std::unique_ptr<fb::geographic_msgs::GeoPointT>(_e->UnPack(_resolver)); } } else if (_o->position) { _o->position.reset(); } }
  { auto _e = props(); if (_e) { _o->props.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->props[_i]) { _e->Get(_i)->UnPackTo(_o->props[_i].get(), _resolver); } else { _o->props[_i] = std::unique_ptr<fb::geographic_msgs::KeyValueT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->props.resize(0); } }
}

inline ::flatbuffers::Offset<WayPoint> WayPoint::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WayPointT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWayPoint(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<WayPoint> CreateWayPoint(::flatbuffers::FlatBufferBuilder &_fbb, const WayPointT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const WayPointT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _id = _o->id ? CreateUniqueID(_fbb, _o->id.get(), _rehasher) : 0;
  auto _position = _o->position ? CreateGeoPoint(_fbb, _o->position.get(), _rehasher) : 0;
  auto _props = _fbb.CreateVector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>> (_o->props.size(), [](size_t i, _VectorArgs *__va) { return CreateKeyValue(*__va->__fbb, __va->__o->props[i].get(), __va->__rehasher); }, &_va );
  return fb::geographic_msgs::CreateWayPoint(
      _fbb,
      ___metadata,
      _id,
      _position,
      _props);
}

inline GeoPoseWithCovarianceT::GeoPoseWithCovarianceT(const GeoPoseWithCovarianceT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        pose((o.pose) ? new fb::geographic_msgs::GeoPoseT(*o.pose) : nullptr),
        covariance(o.covariance) {
}

inline GeoPoseWithCovarianceT &GeoPoseWithCovarianceT::operator=(GeoPoseWithCovarianceT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(pose, o.pose);
  std::swap(covariance, o.covariance);
  return *this;
}

inline GeoPoseWithCovarianceT *GeoPoseWithCovariance::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GeoPoseWithCovarianceT>(new GeoPoseWithCovarianceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GeoPoseWithCovariance::UnPackTo(GeoPoseWithCovarianceT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = pose(); if (_e) { if(_o->pose) { _e->UnPackTo(_o->pose.get(), _resolver); } else { _o->pose = std::unique_ptr<fb::geographic_msgs::GeoPoseT>(_e->UnPack(_resolver)); } } else if (_o->pose) { _o->pose.reset(); } }
  { auto _e = covariance(); if (_e) { _o->covariance.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->covariance[_i] = _e->Get(_i); } } else { _o->covariance.resize(0); } }
}

inline ::flatbuffers::Offset<GeoPoseWithCovariance> GeoPoseWithCovariance::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseWithCovarianceT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGeoPoseWithCovariance(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GeoPoseWithCovariance> CreateGeoPoseWithCovariance(::flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseWithCovarianceT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GeoPoseWithCovarianceT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _pose = _o->pose ? CreateGeoPose(_fbb, _o->pose.get(), _rehasher) : 0;
  auto _covariance = _fbb.CreateVector(_o->covariance);
  return fb::geographic_msgs::CreateGeoPoseWithCovariance(
      _fbb,
      ___metadata,
      _pose,
      _covariance);
}

inline GeoPoseT::GeoPoseT(const GeoPoseT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        position((o.position) ? new fb::geographic_msgs::GeoPointT(*o.position) : nullptr),
        orientation((o.orientation) ? new fb::geometry_msgs::QuaternionT(*o.orientation) : nullptr) {
}

inline GeoPoseT &GeoPoseT::operator=(GeoPoseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(position, o.position);
  std::swap(orientation, o.orientation);
  return *this;
}

inline GeoPoseT *GeoPose::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GeoPoseT>(new GeoPoseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GeoPose::UnPackTo(GeoPoseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = position(); if (_e) { if(_o->position) { _e->UnPackTo(_o->position.get(), _resolver); } else { _o->position = std::unique_ptr<fb::geographic_msgs::GeoPointT>(_e->UnPack(_resolver)); } } else if (_o->position) { _o->position.reset(); } }
  { auto _e = orientation(); if (_e) { if(_o->orientation) { _e->UnPackTo(_o->orientation.get(), _resolver); } else { _o->orientation = std::unique_ptr<fb::geometry_msgs::QuaternionT>(_e->UnPack(_resolver)); } } else if (_o->orientation) { _o->orientation.reset(); } }
}

inline ::flatbuffers::Offset<GeoPose> GeoPose::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGeoPose(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GeoPose> CreateGeoPose(::flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GeoPoseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _position = _o->position ? CreateGeoPoint(_fbb, _o->position.get(), _rehasher) : 0;
  auto _orientation = _o->orientation ? CreateQuaternion(_fbb, _o->orientation.get(), _rehasher) : 0;
  return fb::geographic_msgs::CreateGeoPose(
      _fbb,
      ___metadata,
      _position,
      _orientation);
}

inline BoundingBoxT::BoundingBoxT(const BoundingBoxT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        min_pt((o.min_pt) ? new fb::geographic_msgs::GeoPointT(*o.min_pt) : nullptr),
        max_pt((o.max_pt) ? new fb::geographic_msgs::GeoPointT(*o.max_pt) : nullptr) {
}

inline BoundingBoxT &BoundingBoxT::operator=(BoundingBoxT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(min_pt, o.min_pt);
  std::swap(max_pt, o.max_pt);
  return *this;
}

inline BoundingBoxT *BoundingBox::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BoundingBoxT>(new BoundingBoxT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BoundingBox::UnPackTo(BoundingBoxT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = min_pt(); if (_e) { if(_o->min_pt) { _e->UnPackTo(_o->min_pt.get(), _resolver); } else { _o->min_pt = std::unique_ptr<fb::geographic_msgs::GeoPointT>(_e->UnPack(_resolver)); } } else if (_o->min_pt) { _o->min_pt.reset(); } }
  { auto _e = max_pt(); if (_e) { if(_o->max_pt) { _e->UnPackTo(_o->max_pt.get(), _resolver); } else { _o->max_pt = std::unique_ptr<fb::geographic_msgs::GeoPointT>(_e->UnPack(_resolver)); } } else if (_o->max_pt) { _o->max_pt.reset(); } }
}

inline ::flatbuffers::Offset<BoundingBox> BoundingBox::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BoundingBoxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBoundingBox(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BoundingBox> CreateBoundingBox(::flatbuffers::FlatBufferBuilder &_fbb, const BoundingBoxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BoundingBoxT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _min_pt = _o->min_pt ? CreateGeoPoint(_fbb, _o->min_pt.get(), _rehasher) : 0;
  auto _max_pt = _o->max_pt ? CreateGeoPoint(_fbb, _o->max_pt.get(), _rehasher) : 0;
  return fb::geographic_msgs::CreateBoundingBox(
      _fbb,
      ___metadata,
      _min_pt,
      _max_pt);
}

inline GeoPointStampedT::GeoPointStampedT(const GeoPointStampedT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        position((o.position) ? new fb::geographic_msgs::GeoPointT(*o.position) : nullptr) {
}

inline GeoPointStampedT &GeoPointStampedT::operator=(GeoPointStampedT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(position, o.position);
  return *this;
}

inline GeoPointStampedT *GeoPointStamped::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GeoPointStampedT>(new GeoPointStampedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GeoPointStamped::UnPackTo(GeoPointStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = position(); if (_e) { if(_o->position) { _e->UnPackTo(_o->position.get(), _resolver); } else { _o->position = std::unique_ptr<fb::geographic_msgs::GeoPointT>(_e->UnPack(_resolver)); } } else if (_o->position) { _o->position.reset(); } }
}

inline ::flatbuffers::Offset<GeoPointStamped> GeoPointStamped::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GeoPointStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGeoPointStamped(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GeoPointStamped> CreateGeoPointStamped(::flatbuffers::FlatBufferBuilder &_fbb, const GeoPointStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GeoPointStampedT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _position = _o->position ? CreateGeoPoint(_fbb, _o->position.get(), _rehasher) : 0;
  return fb::geographic_msgs::CreateGeoPointStamped(
      _fbb,
      ___metadata,
      _header,
      _position);
}

inline RouteNetworkT::RouteNetworkT(const RouteNetworkT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        id((o.id) ? new fb::uuid_msgs::UniqueIDT(*o.id) : nullptr),
        bounds((o.bounds) ? new fb::geographic_msgs::BoundingBoxT(*o.bounds) : nullptr) {
  points.reserve(o.points.size());
  for (const auto &points_ : o.points) { points.emplace_back((points_) ? new fb::geographic_msgs::WayPointT(*points_) : nullptr); }
  segments.reserve(o.segments.size());
  for (const auto &segments_ : o.segments) { segments.emplace_back((segments_) ? new fb::geographic_msgs::RouteSegmentT(*segments_) : nullptr); }
  props.reserve(o.props.size());
  for (const auto &props_ : o.props) { props.emplace_back((props_) ? new fb::geographic_msgs::KeyValueT(*props_) : nullptr); }
}

inline RouteNetworkT &RouteNetworkT::operator=(RouteNetworkT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(id, o.id);
  std::swap(bounds, o.bounds);
  std::swap(points, o.points);
  std::swap(segments, o.segments);
  std::swap(props, o.props);
  return *this;
}

inline RouteNetworkT *RouteNetwork::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RouteNetworkT>(new RouteNetworkT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RouteNetwork::UnPackTo(RouteNetworkT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = id(); if (_e) { if(_o->id) { _e->UnPackTo(_o->id.get(), _resolver); } else { _o->id = std::unique_ptr<fb::uuid_msgs::UniqueIDT>(_e->UnPack(_resolver)); } } else if (_o->id) { _o->id.reset(); } }
  { auto _e = bounds(); if (_e) { if(_o->bounds) { _e->UnPackTo(_o->bounds.get(), _resolver); } else { _o->bounds = std::unique_ptr<fb::geographic_msgs::BoundingBoxT>(_e->UnPack(_resolver)); } } else if (_o->bounds) { _o->bounds.reset(); } }
  { auto _e = points(); if (_e) { _o->points.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->points[_i]) { _e->Get(_i)->UnPackTo(_o->points[_i].get(), _resolver); } else { _o->points[_i] = std::unique_ptr<fb::geographic_msgs::WayPointT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->points.resize(0); } }
  { auto _e = segments(); if (_e) { _o->segments.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->segments[_i]) { _e->Get(_i)->UnPackTo(_o->segments[_i].get(), _resolver); } else { _o->segments[_i] = std::unique_ptr<fb::geographic_msgs::RouteSegmentT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->segments.resize(0); } }
  { auto _e = props(); if (_e) { _o->props.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->props[_i]) { _e->Get(_i)->UnPackTo(_o->props[_i].get(), _resolver); } else { _o->props[_i] = std::unique_ptr<fb::geographic_msgs::KeyValueT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->props.resize(0); } }
}

inline ::flatbuffers::Offset<RouteNetwork> RouteNetwork::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RouteNetworkT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRouteNetwork(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RouteNetwork> CreateRouteNetwork(::flatbuffers::FlatBufferBuilder &_fbb, const RouteNetworkT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RouteNetworkT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _id = _o->id ? CreateUniqueID(_fbb, _o->id.get(), _rehasher) : 0;
  auto _bounds = _o->bounds ? CreateBoundingBox(_fbb, _o->bounds.get(), _rehasher) : 0;
  auto _points = _fbb.CreateVector<::flatbuffers::Offset<fb::geographic_msgs::WayPoint>> (_o->points.size(), [](size_t i, _VectorArgs *__va) { return CreateWayPoint(*__va->__fbb, __va->__o->points[i].get(), __va->__rehasher); }, &_va );
  auto _segments = _fbb.CreateVector<::flatbuffers::Offset<fb::geographic_msgs::RouteSegment>> (_o->segments.size(), [](size_t i, _VectorArgs *__va) { return CreateRouteSegment(*__va->__fbb, __va->__o->segments[i].get(), __va->__rehasher); }, &_va );
  auto _props = _fbb.CreateVector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>> (_o->props.size(), [](size_t i, _VectorArgs *__va) { return CreateKeyValue(*__va->__fbb, __va->__o->props[i].get(), __va->__rehasher); }, &_va );
  return fb::geographic_msgs::CreateRouteNetwork(
      _fbb,
      ___metadata,
      _header,
      _id,
      _bounds,
      _points,
      _segments,
      _props);
}

inline MapFeatureT::MapFeatureT(const MapFeatureT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        id((o.id) ? new fb::uuid_msgs::UniqueIDT(*o.id) : nullptr) {
  components.reserve(o.components.size());
  for (const auto &components_ : o.components) { components.emplace_back((components_) ? new fb::uuid_msgs::UniqueIDT(*components_) : nullptr); }
  props.reserve(o.props.size());
  for (const auto &props_ : o.props) { props.emplace_back((props_) ? new fb::geographic_msgs::KeyValueT(*props_) : nullptr); }
}

inline MapFeatureT &MapFeatureT::operator=(MapFeatureT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(id, o.id);
  std::swap(components, o.components);
  std::swap(props, o.props);
  return *this;
}

inline MapFeatureT *MapFeature::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MapFeatureT>(new MapFeatureT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MapFeature::UnPackTo(MapFeatureT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = id(); if (_e) { if(_o->id) { _e->UnPackTo(_o->id.get(), _resolver); } else { _o->id = std::unique_ptr<fb::uuid_msgs::UniqueIDT>(_e->UnPack(_resolver)); } } else if (_o->id) { _o->id.reset(); } }
  { auto _e = components(); if (_e) { _o->components.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->components[_i]) { _e->Get(_i)->UnPackTo(_o->components[_i].get(), _resolver); } else { _o->components[_i] = std::unique_ptr<fb::uuid_msgs::UniqueIDT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->components.resize(0); } }
  { auto _e = props(); if (_e) { _o->props.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->props[_i]) { _e->Get(_i)->UnPackTo(_o->props[_i].get(), _resolver); } else { _o->props[_i] = std::unique_ptr<fb::geographic_msgs::KeyValueT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->props.resize(0); } }
}

inline ::flatbuffers::Offset<MapFeature> MapFeature::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MapFeatureT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMapFeature(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<MapFeature> CreateMapFeature(::flatbuffers::FlatBufferBuilder &_fbb, const MapFeatureT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MapFeatureT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _id = _o->id ? CreateUniqueID(_fbb, _o->id.get(), _rehasher) : 0;
  auto _components = _fbb.CreateVector<::flatbuffers::Offset<fb::uuid_msgs::UniqueID>> (_o->components.size(), [](size_t i, _VectorArgs *__va) { return CreateUniqueID(*__va->__fbb, __va->__o->components[i].get(), __va->__rehasher); }, &_va );
  auto _props = _fbb.CreateVector<::flatbuffers::Offset<fb::geographic_msgs::KeyValue>> (_o->props.size(), [](size_t i, _VectorArgs *__va) { return CreateKeyValue(*__va->__fbb, __va->__o->props[i].get(), __va->__rehasher); }, &_va );
  return fb::geographic_msgs::CreateMapFeature(
      _fbb,
      ___metadata,
      _id,
      _components,
      _props);
}

inline GetGeographicMapRequestT::GetGeographicMapRequestT(const GetGeographicMapRequestT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        url(o.url),
        bounds((o.bounds) ? new fb::geographic_msgs::BoundingBoxT(*o.bounds) : nullptr) {
}

inline GetGeographicMapRequestT &GetGeographicMapRequestT::operator=(GetGeographicMapRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(url, o.url);
  std::swap(bounds, o.bounds);
  return *this;
}

inline GetGeographicMapRequestT *GetGeographicMapRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetGeographicMapRequestT>(new GetGeographicMapRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetGeographicMapRequest::UnPackTo(GetGeographicMapRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = url(); if (_e) _o->url = _e->str(); }
  { auto _e = bounds(); if (_e) { if(_o->bounds) { _e->UnPackTo(_o->bounds.get(), _resolver); } else { _o->bounds = std::unique_ptr<fb::geographic_msgs::BoundingBoxT>(_e->UnPack(_resolver)); } } else if (_o->bounds) { _o->bounds.reset(); } }
}

inline ::flatbuffers::Offset<GetGeographicMapRequest> GetGeographicMapRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetGeographicMapRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetGeographicMapRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GetGeographicMapRequest> CreateGetGeographicMapRequest(::flatbuffers::FlatBufferBuilder &_fbb, const GetGeographicMapRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GetGeographicMapRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _url = _fbb.CreateString(_o->url);
  auto _bounds = _o->bounds ? CreateBoundingBox(_fbb, _o->bounds.get(), _rehasher) : 0;
  return fb::geographic_msgs::CreateGetGeographicMapRequest(
      _fbb,
      ___metadata,
      _url,
      _bounds);
}

inline GetGeographicMapResponseT::GetGeographicMapResponseT(const GetGeographicMapResponseT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        success(o.success),
        status(o.status),
        map((o.map) ? new fb::geographic_msgs::GeographicMapT(*o.map) : nullptr) {
}

inline GetGeographicMapResponseT &GetGeographicMapResponseT::operator=(GetGeographicMapResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(success, o.success);
  std::swap(status, o.status);
  std::swap(map, o.map);
  return *this;
}

inline GetGeographicMapResponseT *GetGeographicMapResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetGeographicMapResponseT>(new GetGeographicMapResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetGeographicMapResponse::UnPackTo(GetGeographicMapResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = success(); _o->success = _e; }
  { auto _e = status(); if (_e) _o->status = _e->str(); }
  { auto _e = map(); if (_e) { if(_o->map) { _e->UnPackTo(_o->map.get(), _resolver); } else { _o->map = std::unique_ptr<fb::geographic_msgs::GeographicMapT>(_e->UnPack(_resolver)); } } else if (_o->map) { _o->map.reset(); } }
}

inline ::flatbuffers::Offset<GetGeographicMapResponse> GetGeographicMapResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetGeographicMapResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetGeographicMapResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GetGeographicMapResponse> CreateGetGeographicMapResponse(::flatbuffers::FlatBufferBuilder &_fbb, const GetGeographicMapResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GetGeographicMapResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _success = _o->success;
  auto _status = _fbb.CreateString(_o->status);
  auto _map = _o->map ? CreateGeographicMap(_fbb, _o->map.get(), _rehasher) : 0;
  return fb::geographic_msgs::CreateGetGeographicMapResponse(
      _fbb,
      ___metadata,
      _success,
      _status,
      _map);
}

}  // namespace geographic_msgs
}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_GEOGRAPHICMSGS_FB_GEOGRAPHIC_MSGS_H_
