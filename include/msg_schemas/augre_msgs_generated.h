// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_AUGREMSGS_FB_AUGRE_MSGS_H_
#define FLATBUFFERS_GENERATED_AUGREMSGS_FB_AUGRE_MSGS_H_

#include "./flatbuffers/flatbuffers.h"

#include "geometry_msgs_generated.h"
#include "base_schema_generated.h"
#include "sensor_msgs_generated.h"
#include "std_msgs_generated.h"

namespace fb {
    namespace augre_msgs {

        struct TransformWithCovarianceStamped;
        struct TransformWithCovarianceStampedBuilder;
        struct TransformWithCovarianceStampedT;

        struct BoundingObject3D;
        struct BoundingObject3DBuilder;
        struct BoundingObject3DT;

        struct AgentStatus;
        struct AgentStatusBuilder;
        struct AgentStatusT;

        struct HeaderArrayStamped;
        struct HeaderArrayStampedBuilder;
        struct HeaderArrayStampedT;

        struct BoundingObject3DArray;
        struct BoundingObject3DArrayBuilder;
        struct BoundingObject3DArrayT;

        struct DetectedItem;
        struct DetectedItemBuilder;
        struct DetectedItemT;

        struct TransformWithCovarianceStampedT : public flatbuffers::NativeTable {
            typedef TransformWithCovarianceStamped TableType;
            std::unique_ptr<fb::MsgMetadataT> __metadata{};
            std::unique_ptr<fb::geometry_msgs::TransformStampedT> transform{};
            std::vector<float> covariance{};
            TransformWithCovarianceStampedT() = default;
            TransformWithCovarianceStampedT(const TransformWithCovarianceStampedT& o);
            TransformWithCovarianceStampedT(TransformWithCovarianceStampedT&&) FLATBUFFERS_NOEXCEPT = default;
            TransformWithCovarianceStampedT& operator=(TransformWithCovarianceStampedT o) FLATBUFFERS_NOEXCEPT;
        };

        struct TransformWithCovarianceStamped FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
            typedef TransformWithCovarianceStampedT NativeTableType;
            typedef TransformWithCovarianceStampedBuilder Builder;
            enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
                VT___METADATA = 4,
                VT_TRANSFORM = 6,
                VT_COVARIANCE = 8
            };
            const fb::MsgMetadata* __metadata() const {
                return GetPointer<const fb::MsgMetadata*>(VT___METADATA);
            }
            const fb::geometry_msgs::TransformStamped* transform() const {
                return GetPointer<const fb::geometry_msgs::TransformStamped*>(VT_TRANSFORM);
            }
            const flatbuffers::Vector<float>* covariance() const {
                return GetPointer<const flatbuffers::Vector<float>*>(VT_COVARIANCE);
            }
            bool Verify(flatbuffers::Verifier& verifier) const {
                return VerifyTableStart(verifier) &&
                    VerifyOffset(verifier, VT___METADATA) &&
                    verifier.VerifyTable(__metadata()) &&
                    VerifyOffsetRequired(verifier, VT_TRANSFORM) &&
                    verifier.VerifyTable(transform()) &&
                    VerifyOffsetRequired(verifier, VT_COVARIANCE) &&
                    verifier.VerifyVector(covariance()) &&
                    verifier.EndTable();
            }
            TransformWithCovarianceStampedT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
            void UnPackTo(TransformWithCovarianceStampedT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
            static flatbuffers::Offset<TransformWithCovarianceStamped> Pack(flatbuffers::FlatBufferBuilder& _fbb, const TransformWithCovarianceStampedT* _o, const flatbuffers::rehasher_function_t* _rehasher = nullptr);
        };

        struct TransformWithCovarianceStampedBuilder {
            typedef TransformWithCovarianceStamped Table;
            flatbuffers::FlatBufferBuilder& fbb_;
            flatbuffers::uoffset_t start_;
            void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
                fbb_.AddOffset(TransformWithCovarianceStamped::VT___METADATA, __metadata);
            }
            void add_transform(flatbuffers::Offset<fb::geometry_msgs::TransformStamped> transform) {
                fbb_.AddOffset(TransformWithCovarianceStamped::VT_TRANSFORM, transform);
            }
            void add_covariance(flatbuffers::Offset<flatbuffers::Vector<float>> covariance) {
                fbb_.AddOffset(TransformWithCovarianceStamped::VT_COVARIANCE, covariance);
            }
            explicit TransformWithCovarianceStampedBuilder(flatbuffers::FlatBufferBuilder& _fbb)
                : fbb_(_fbb) {
                start_ = fbb_.StartTable();
            }
            flatbuffers::Offset<TransformWithCovarianceStamped> Finish() {
                const auto end = fbb_.EndTable(start_);
                auto o = flatbuffers::Offset<TransformWithCovarianceStamped>(end);
                fbb_.Required(o, TransformWithCovarianceStamped::VT_TRANSFORM);
                fbb_.Required(o, TransformWithCovarianceStamped::VT_COVARIANCE);
                return o;
            }
        };

        inline flatbuffers::Offset<TransformWithCovarianceStamped> CreateTransformWithCovarianceStamped(
            flatbuffers::FlatBufferBuilder& _fbb,
            flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
            flatbuffers::Offset<fb::geometry_msgs::TransformStamped> transform = 0,
            flatbuffers::Offset<flatbuffers::Vector<float>> covariance = 0) {
            TransformWithCovarianceStampedBuilder builder_(_fbb);
            builder_.add_covariance(covariance);
            builder_.add_transform(transform);
            builder_.add___metadata(__metadata);
            return builder_.Finish();
        }

        inline flatbuffers::Offset<TransformWithCovarianceStamped> CreateTransformWithCovarianceStampedDirect(
            flatbuffers::FlatBufferBuilder& _fbb,
            flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
            flatbuffers::Offset<fb::geometry_msgs::TransformStamped> transform = 0,
            const std::vector<float>* covariance = nullptr) {
            auto covariance__ = covariance ? _fbb.CreateVector<float>(*covariance) : 0;
            return fb::augre_msgs::CreateTransformWithCovarianceStamped(
                _fbb,
                __metadata,
                transform,
                covariance__);
        }

        flatbuffers::Offset<TransformWithCovarianceStamped> CreateTransformWithCovarianceStamped(flatbuffers::FlatBufferBuilder& _fbb, const TransformWithCovarianceStampedT* _o, const flatbuffers::rehasher_function_t* _rehasher = nullptr);

        struct BoundingObject3DT : public flatbuffers::NativeTable {
            typedef BoundingObject3D TableType;
            std::unique_ptr<fb::MsgMetadataT> __metadata{};
            uint8_t action = 0;
            uint8_t shape = 0;
            std::string uid{};
            double size_x = 0.0;
            double size_y = 0.0;
            double size_z = 0.0;
            double radius = 0.0;
            std::unique_ptr<fb::geometry_msgs::PoseStampedT> centroid{};
            BoundingObject3DT() = default;
            BoundingObject3DT(const BoundingObject3DT& o);
            BoundingObject3DT(BoundingObject3DT&&) FLATBUFFERS_NOEXCEPT = default;
            BoundingObject3DT& operator=(BoundingObject3DT o) FLATBUFFERS_NOEXCEPT;
        };

        struct BoundingObject3D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
            typedef BoundingObject3DT NativeTableType;
            typedef BoundingObject3DBuilder Builder;
            enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
                VT___METADATA = 4,
                VT_ACTION = 6,
                VT_SHAPE = 8,
                VT_UID = 10,
                VT_SIZE_X = 12,
                VT_SIZE_Y = 14,
                VT_SIZE_Z = 16,
                VT_RADIUS = 18,
                VT_CENTROID = 20
            };
            const fb::MsgMetadata* __metadata() const {
                return GetPointer<const fb::MsgMetadata*>(VT___METADATA);
            }
            uint8_t action() const {
                return GetField<uint8_t>(VT_ACTION, 0);
            }
            uint8_t shape() const {
                return GetField<uint8_t>(VT_SHAPE, 0);
            }
            const flatbuffers::String* uid() const {
                return GetPointer<const flatbuffers::String*>(VT_UID);
            }
            double size_x() const {
                return GetField<double>(VT_SIZE_X, 0.0);
            }
            double size_y() const {
                return GetField<double>(VT_SIZE_Y, 0.0);
            }
            double size_z() const {
                return GetField<double>(VT_SIZE_Z, 0.0);
            }
            double radius() const {
                return GetField<double>(VT_RADIUS, 0.0);
            }
            const fb::geometry_msgs::PoseStamped* centroid() const {
                return GetPointer<const fb::geometry_msgs::PoseStamped*>(VT_CENTROID);
            }
            bool Verify(flatbuffers::Verifier& verifier) const {
                return VerifyTableStart(verifier) &&
                    VerifyOffset(verifier, VT___METADATA) &&
                    verifier.VerifyTable(__metadata()) &&
                    VerifyField<uint8_t>(verifier, VT_ACTION, 1) &&
                    VerifyField<uint8_t>(verifier, VT_SHAPE, 1) &&
                    VerifyOffsetRequired(verifier, VT_UID) &&
                    verifier.VerifyString(uid()) &&
                    VerifyField<double>(verifier, VT_SIZE_X, 8) &&
                    VerifyField<double>(verifier, VT_SIZE_Y, 8) &&
                    VerifyField<double>(verifier, VT_SIZE_Z, 8) &&
                    VerifyField<double>(verifier, VT_RADIUS, 8) &&
                    VerifyOffsetRequired(verifier, VT_CENTROID) &&
                    verifier.VerifyTable(centroid()) &&
                    verifier.EndTable();
            }
            BoundingObject3DT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
            void UnPackTo(BoundingObject3DT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
            static flatbuffers::Offset<BoundingObject3D> Pack(flatbuffers::FlatBufferBuilder& _fbb, const BoundingObject3DT* _o, const flatbuffers::rehasher_function_t* _rehasher = nullptr);
        };

        struct BoundingObject3DBuilder {
            typedef BoundingObject3D Table;
            flatbuffers::FlatBufferBuilder& fbb_;
            flatbuffers::uoffset_t start_;
            void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
                fbb_.AddOffset(BoundingObject3D::VT___METADATA, __metadata);
            }
            void add_action(uint8_t action) {
                fbb_.AddElement<uint8_t>(BoundingObject3D::VT_ACTION, action, 0);
            }
            void add_shape(uint8_t shape) {
                fbb_.AddElement<uint8_t>(BoundingObject3D::VT_SHAPE, shape, 0);
            }
            void add_uid(flatbuffers::Offset<flatbuffers::String> uid) {
                fbb_.AddOffset(BoundingObject3D::VT_UID, uid);
            }
            void add_size_x(double size_x) {
                fbb_.AddElement<double>(BoundingObject3D::VT_SIZE_X, size_x, 0.0);
            }
            void add_size_y(double size_y) {
                fbb_.AddElement<double>(BoundingObject3D::VT_SIZE_Y, size_y, 0.0);
            }
            void add_size_z(double size_z) {
                fbb_.AddElement<double>(BoundingObject3D::VT_SIZE_Z, size_z, 0.0);
            }
            void add_radius(double radius) {
                fbb_.AddElement<double>(BoundingObject3D::VT_RADIUS, radius, 0.0);
            }
            void add_centroid(flatbuffers::Offset<fb::geometry_msgs::PoseStamped> centroid) {
                fbb_.AddOffset(BoundingObject3D::VT_CENTROID, centroid);
            }
            explicit BoundingObject3DBuilder(flatbuffers::FlatBufferBuilder& _fbb)
                : fbb_(_fbb) {
                start_ = fbb_.StartTable();
            }
            flatbuffers::Offset<BoundingObject3D> Finish() {
                const auto end = fbb_.EndTable(start_);
                auto o = flatbuffers::Offset<BoundingObject3D>(end);
                fbb_.Required(o, BoundingObject3D::VT_UID);
                fbb_.Required(o, BoundingObject3D::VT_CENTROID);
                return o;
            }
        };

        inline flatbuffers::Offset<BoundingObject3D> CreateBoundingObject3D(
            flatbuffers::FlatBufferBuilder& _fbb,
            flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
            uint8_t action = 0,
            uint8_t shape = 0,
            flatbuffers::Offset<flatbuffers::String> uid = 0,
            double size_x = 0.0,
            double size_y = 0.0,
            double size_z = 0.0,
            double radius = 0.0,
            flatbuffers::Offset<fb::geometry_msgs::PoseStamped> centroid = 0) {
            BoundingObject3DBuilder builder_(_fbb);
            builder_.add_radius(radius);
            builder_.add_size_z(size_z);
            builder_.add_size_y(size_y);
            builder_.add_size_x(size_x);
            builder_.add_centroid(centroid);
            builder_.add_uid(uid);
            builder_.add___metadata(__metadata);
            builder_.add_shape(shape);
            builder_.add_action(action);
            return builder_.Finish();
        }

        inline flatbuffers::Offset<BoundingObject3D> CreateBoundingObject3DDirect(
            flatbuffers::FlatBufferBuilder& _fbb,
            flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
            uint8_t action = 0,
            uint8_t shape = 0,
            const char* uid = nullptr,
            double size_x = 0.0,
            double size_y = 0.0,
            double size_z = 0.0,
            double radius = 0.0,
            flatbuffers::Offset<fb::geometry_msgs::PoseStamped> centroid = 0) {
            auto uid__ = uid ? _fbb.CreateString(uid) : 0;
            return fb::augre_msgs::CreateBoundingObject3D(
                _fbb,
                __metadata,
                action,
                shape,
                uid__,
                size_x,
                size_y,
                size_z,
                radius,
                centroid);
        }

        flatbuffers::Offset<BoundingObject3D> CreateBoundingObject3D(flatbuffers::FlatBufferBuilder& _fbb, const BoundingObject3DT* _o, const flatbuffers::rehasher_function_t* _rehasher = nullptr);

        struct AgentStatusT : public flatbuffers::NativeTable {
            typedef AgentStatus TableType;
            std::unique_ptr<fb::MsgMetadataT> __metadata{};
            std::string uid{};
            std::string callsign{};
            std::string agent_type{};
            float battery = 0.0f;
            std::string commander{};
            std::string control_status{};
            AgentStatusT() = default;
            AgentStatusT(const AgentStatusT& o);
            AgentStatusT(AgentStatusT&&) FLATBUFFERS_NOEXCEPT = default;
            AgentStatusT& operator=(AgentStatusT o) FLATBUFFERS_NOEXCEPT;
        };

        struct AgentStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
            typedef AgentStatusT NativeTableType;
            typedef AgentStatusBuilder Builder;
            enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
                VT___METADATA = 4,
                VT_UID = 6,
                VT_CALLSIGN = 8,
                VT_AGENT_TYPE = 10,
                VT_BATTERY = 12,
                VT_COMMANDER = 14,
                VT_CONTROL_STATUS = 16
            };
            const fb::MsgMetadata* __metadata() const {
                return GetPointer<const fb::MsgMetadata*>(VT___METADATA);
            }
            const flatbuffers::String* uid() const {
                return GetPointer<const flatbuffers::String*>(VT_UID);
            }
            const flatbuffers::String* callsign() const {
                return GetPointer<const flatbuffers::String*>(VT_CALLSIGN);
            }
            const flatbuffers::String* agent_type() const {
                return GetPointer<const flatbuffers::String*>(VT_AGENT_TYPE);
            }
            float battery() const {
                return GetField<float>(VT_BATTERY, 0.0f);
            }
            const flatbuffers::String* commander() const {
                return GetPointer<const flatbuffers::String*>(VT_COMMANDER);
            }
            const flatbuffers::String* control_status() const {
                return GetPointer<const flatbuffers::String*>(VT_CONTROL_STATUS);
            }
            bool Verify(flatbuffers::Verifier& verifier) const {
                return VerifyTableStart(verifier) &&
                    VerifyOffset(verifier, VT___METADATA) &&
                    verifier.VerifyTable(__metadata()) &&
                    VerifyOffsetRequired(verifier, VT_UID) &&
                    verifier.VerifyString(uid()) &&
                    VerifyOffsetRequired(verifier, VT_CALLSIGN) &&
                    verifier.VerifyString(callsign()) &&
                    VerifyOffsetRequired(verifier, VT_AGENT_TYPE) &&
                    verifier.VerifyString(agent_type()) &&
                    VerifyField<float>(verifier, VT_BATTERY, 4) &&
                    VerifyOffsetRequired(verifier, VT_COMMANDER) &&
                    verifier.VerifyString(commander()) &&
                    VerifyOffsetRequired(verifier, VT_CONTROL_STATUS) &&
                    verifier.VerifyString(control_status()) &&
                    verifier.EndTable();
            }
            AgentStatusT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
            void UnPackTo(AgentStatusT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
            static flatbuffers::Offset<AgentStatus> Pack(flatbuffers::FlatBufferBuilder& _fbb, const AgentStatusT* _o, const flatbuffers::rehasher_function_t* _rehasher = nullptr);
        };

        struct AgentStatusBuilder {
            typedef AgentStatus Table;
            flatbuffers::FlatBufferBuilder& fbb_;
            flatbuffers::uoffset_t start_;
            void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
                fbb_.AddOffset(AgentStatus::VT___METADATA, __metadata);
            }
            void add_uid(flatbuffers::Offset<flatbuffers::String> uid) {
                fbb_.AddOffset(AgentStatus::VT_UID, uid);
            }
            void add_callsign(flatbuffers::Offset<flatbuffers::String> callsign) {
                fbb_.AddOffset(AgentStatus::VT_CALLSIGN, callsign);
            }
            void add_agent_type(flatbuffers::Offset<flatbuffers::String> agent_type) {
                fbb_.AddOffset(AgentStatus::VT_AGENT_TYPE, agent_type);
            }
            void add_battery(float battery) {
                fbb_.AddElement<float>(AgentStatus::VT_BATTERY, battery, 0.0f);
            }
            void add_commander(flatbuffers::Offset<flatbuffers::String> commander) {
                fbb_.AddOffset(AgentStatus::VT_COMMANDER, commander);
            }
            void add_control_status(flatbuffers::Offset<flatbuffers::String> control_status) {
                fbb_.AddOffset(AgentStatus::VT_CONTROL_STATUS, control_status);
            }
            explicit AgentStatusBuilder(flatbuffers::FlatBufferBuilder& _fbb)
                : fbb_(_fbb) {
                start_ = fbb_.StartTable();
            }
            flatbuffers::Offset<AgentStatus> Finish() {
                const auto end = fbb_.EndTable(start_);
                auto o = flatbuffers::Offset<AgentStatus>(end);
                fbb_.Required(o, AgentStatus::VT_UID);
                fbb_.Required(o, AgentStatus::VT_CALLSIGN);
                fbb_.Required(o, AgentStatus::VT_AGENT_TYPE);
                fbb_.Required(o, AgentStatus::VT_COMMANDER);
                fbb_.Required(o, AgentStatus::VT_CONTROL_STATUS);
                return o;
            }
        };

        inline flatbuffers::Offset<AgentStatus> CreateAgentStatus(
            flatbuffers::FlatBufferBuilder& _fbb,
            flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
            flatbuffers::Offset<flatbuffers::String> uid = 0,
            flatbuffers::Offset<flatbuffers::String> callsign = 0,
            flatbuffers::Offset<flatbuffers::String> agent_type = 0,
            float battery = 0.0f,
            flatbuffers::Offset<flatbuffers::String> commander = 0,
            flatbuffers::Offset<flatbuffers::String> control_status = 0) {
            AgentStatusBuilder builder_(_fbb);
            builder_.add_control_status(control_status);
            builder_.add_commander(commander);
            builder_.add_battery(battery);
            builder_.add_agent_type(agent_type);
            builder_.add_callsign(callsign);
            builder_.add_uid(uid);
            builder_.add___metadata(__metadata);
            return builder_.Finish();
        }

        inline flatbuffers::Offset<AgentStatus> CreateAgentStatusDirect(
            flatbuffers::FlatBufferBuilder& _fbb,
            flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
            const char* uid = nullptr,
            const char* callsign = nullptr,
            const char* agent_type = nullptr,
            float battery = 0.0f,
            const char* commander = nullptr,
            const char* control_status = nullptr) {
            auto uid__ = uid ? _fbb.CreateString(uid) : 0;
            auto callsign__ = callsign ? _fbb.CreateString(callsign) : 0;
            auto agent_type__ = agent_type ? _fbb.CreateString(agent_type) : 0;
            auto commander__ = commander ? _fbb.CreateString(commander) : 0;
            auto control_status__ = control_status ? _fbb.CreateString(control_status) : 0;
            return fb::augre_msgs::CreateAgentStatus(
                _fbb,
                __metadata,
                uid__,
                callsign__,
                agent_type__,
                battery,
                commander__,
                control_status__);
        }

        flatbuffers::Offset<AgentStatus> CreateAgentStatus(flatbuffers::FlatBufferBuilder& _fbb, const AgentStatusT* _o, const flatbuffers::rehasher_function_t* _rehasher = nullptr);

        struct HeaderArrayStampedT : public flatbuffers::NativeTable {
            typedef HeaderArrayStamped TableType;
            std::unique_ptr<fb::MsgMetadataT> __metadata{};
            std::unique_ptr<fb::std_msgs::HeaderT> header{};
            std::vector<std::unique_ptr<fb::std_msgs::HeaderT>> data{};
            HeaderArrayStampedT() = default;
            HeaderArrayStampedT(const HeaderArrayStampedT& o);
            HeaderArrayStampedT(HeaderArrayStampedT&&) FLATBUFFERS_NOEXCEPT = default;
            HeaderArrayStampedT& operator=(HeaderArrayStampedT o) FLATBUFFERS_NOEXCEPT;
        };

        struct HeaderArrayStamped FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
            typedef HeaderArrayStampedT NativeTableType;
            typedef HeaderArrayStampedBuilder Builder;
            enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
                VT___METADATA = 4,
                VT_HEADER = 6,
                VT_DATA = 8
            };
            const fb::MsgMetadata* __metadata() const {
                return GetPointer<const fb::MsgMetadata*>(VT___METADATA);
            }
            const fb::std_msgs::Header* header() const {
                return GetPointer<const fb::std_msgs::Header*>(VT_HEADER);
            }
            const flatbuffers::Vector<flatbuffers::Offset<fb::std_msgs::Header>>* data() const {
                return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::std_msgs::Header>>*>(VT_DATA);
            }
            bool Verify(flatbuffers::Verifier& verifier) const {
                return VerifyTableStart(verifier) &&
                    VerifyOffset(verifier, VT___METADATA) &&
                    verifier.VerifyTable(__metadata()) &&
                    VerifyOffsetRequired(verifier, VT_HEADER) &&
                    verifier.VerifyTable(header()) &&
                    VerifyOffsetRequired(verifier, VT_DATA) &&
                    verifier.VerifyVector(data()) &&
                    verifier.VerifyVectorOfTables(data()) &&
                    verifier.EndTable();
            }
            HeaderArrayStampedT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
            void UnPackTo(HeaderArrayStampedT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
            static flatbuffers::Offset<HeaderArrayStamped> Pack(flatbuffers::FlatBufferBuilder& _fbb, const HeaderArrayStampedT* _o, const flatbuffers::rehasher_function_t* _rehasher = nullptr);
        };

        struct HeaderArrayStampedBuilder {
            typedef HeaderArrayStamped Table;
            flatbuffers::FlatBufferBuilder& fbb_;
            flatbuffers::uoffset_t start_;
            void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
                fbb_.AddOffset(HeaderArrayStamped::VT___METADATA, __metadata);
            }
            void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
                fbb_.AddOffset(HeaderArrayStamped::VT_HEADER, header);
            }
            void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::std_msgs::Header>>> data) {
                fbb_.AddOffset(HeaderArrayStamped::VT_DATA, data);
            }
            explicit HeaderArrayStampedBuilder(flatbuffers::FlatBufferBuilder& _fbb)
                : fbb_(_fbb) {
                start_ = fbb_.StartTable();
            }
            flatbuffers::Offset<HeaderArrayStamped> Finish() {
                const auto end = fbb_.EndTable(start_);
                auto o = flatbuffers::Offset<HeaderArrayStamped>(end);
                fbb_.Required(o, HeaderArrayStamped::VT_HEADER);
                fbb_.Required(o, HeaderArrayStamped::VT_DATA);
                return o;
            }
        };

        inline flatbuffers::Offset<HeaderArrayStamped> CreateHeaderArrayStamped(
            flatbuffers::FlatBufferBuilder& _fbb,
            flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
            flatbuffers::Offset<fb::std_msgs::Header> header = 0,
            flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::std_msgs::Header>>> data = 0) {
            HeaderArrayStampedBuilder builder_(_fbb);
            builder_.add_data(data);
            builder_.add_header(header);
            builder_.add___metadata(__metadata);
            return builder_.Finish();
        }

        inline flatbuffers::Offset<HeaderArrayStamped> CreateHeaderArrayStampedDirect(
            flatbuffers::FlatBufferBuilder& _fbb,
            flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
            flatbuffers::Offset<fb::std_msgs::Header> header = 0,
            const std::vector<flatbuffers::Offset<fb::std_msgs::Header>>* data = nullptr) {
            auto data__ = data ? _fbb.CreateVector<flatbuffers::Offset<fb::std_msgs::Header>>(*data) : 0;
            return fb::augre_msgs::CreateHeaderArrayStamped(
                _fbb,
                __metadata,
                header,
                data__);
        }

        flatbuffers::Offset<HeaderArrayStamped> CreateHeaderArrayStamped(flatbuffers::FlatBufferBuilder& _fbb, const HeaderArrayStampedT* _o, const flatbuffers::rehasher_function_t* _rehasher = nullptr);

        struct BoundingObject3DArrayT : public flatbuffers::NativeTable {
            typedef BoundingObject3DArray TableType;
            std::unique_ptr<fb::MsgMetadataT> __metadata{};
            std::vector<std::unique_ptr<fb::augre_msgs::BoundingObject3DT>> objects{};
            BoundingObject3DArrayT() = default;
            BoundingObject3DArrayT(const BoundingObject3DArrayT& o);
            BoundingObject3DArrayT(BoundingObject3DArrayT&&) FLATBUFFERS_NOEXCEPT = default;
            BoundingObject3DArrayT& operator=(BoundingObject3DArrayT o) FLATBUFFERS_NOEXCEPT;
        };

        struct BoundingObject3DArray FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
            typedef BoundingObject3DArrayT NativeTableType;
            typedef BoundingObject3DArrayBuilder Builder;
            enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
                VT___METADATA = 4,
                VT_OBJECTS = 6
            };
            const fb::MsgMetadata* __metadata() const {
                return GetPointer<const fb::MsgMetadata*>(VT___METADATA);
            }
            const flatbuffers::Vector<flatbuffers::Offset<fb::augre_msgs::BoundingObject3D>>* objects() const {
                return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::augre_msgs::BoundingObject3D>>*>(VT_OBJECTS);
            }
            bool Verify(flatbuffers::Verifier& verifier) const {
                return VerifyTableStart(verifier) &&
                    VerifyOffset(verifier, VT___METADATA) &&
                    verifier.VerifyTable(__metadata()) &&
                    VerifyOffsetRequired(verifier, VT_OBJECTS) &&
                    verifier.VerifyVector(objects()) &&
                    verifier.VerifyVectorOfTables(objects()) &&
                    verifier.EndTable();
            }
            BoundingObject3DArrayT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
            void UnPackTo(BoundingObject3DArrayT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
            static flatbuffers::Offset<BoundingObject3DArray> Pack(flatbuffers::FlatBufferBuilder& _fbb, const BoundingObject3DArrayT* _o, const flatbuffers::rehasher_function_t* _rehasher = nullptr);
        };

        struct BoundingObject3DArrayBuilder {
            typedef BoundingObject3DArray Table;
            flatbuffers::FlatBufferBuilder& fbb_;
            flatbuffers::uoffset_t start_;
            void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
                fbb_.AddOffset(BoundingObject3DArray::VT___METADATA, __metadata);
            }
            void add_objects(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::augre_msgs::BoundingObject3D>>> objects) {
                fbb_.AddOffset(BoundingObject3DArray::VT_OBJECTS, objects);
            }
            explicit BoundingObject3DArrayBuilder(flatbuffers::FlatBufferBuilder& _fbb)
                : fbb_(_fbb) {
                start_ = fbb_.StartTable();
            }
            flatbuffers::Offset<BoundingObject3DArray> Finish() {
                const auto end = fbb_.EndTable(start_);
                auto o = flatbuffers::Offset<BoundingObject3DArray>(end);
                fbb_.Required(o, BoundingObject3DArray::VT_OBJECTS);
                return o;
            }
        };

        inline flatbuffers::Offset<BoundingObject3DArray> CreateBoundingObject3DArray(
            flatbuffers::FlatBufferBuilder& _fbb,
            flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
            flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::augre_msgs::BoundingObject3D>>> objects = 0) {
            BoundingObject3DArrayBuilder builder_(_fbb);
            builder_.add_objects(objects);
            builder_.add___metadata(__metadata);
            return builder_.Finish();
        }

        inline flatbuffers::Offset<BoundingObject3DArray> CreateBoundingObject3DArrayDirect(
            flatbuffers::FlatBufferBuilder& _fbb,
            flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
            const std::vector<flatbuffers::Offset<fb::augre_msgs::BoundingObject3D>>* objects = nullptr) {
            auto objects__ = objects ? _fbb.CreateVector<flatbuffers::Offset<fb::augre_msgs::BoundingObject3D>>(*objects) : 0;
            return fb::augre_msgs::CreateBoundingObject3DArray(
                _fbb,
                __metadata,
                objects__);
        }

        flatbuffers::Offset<BoundingObject3DArray> CreateBoundingObject3DArray(flatbuffers::FlatBufferBuilder& _fbb, const BoundingObject3DArrayT* _o, const flatbuffers::rehasher_function_t* _rehasher = nullptr);

        struct DetectedItemT : public flatbuffers::NativeTable {
            typedef DetectedItem TableType;
            std::unique_ptr<fb::MsgMetadataT> __metadata{};
            std::string uid{};
            std::string callsign{};
            std::string type{};
            std::string type_label{};
            std::string how{};
            std::string how_label{};
            std::unique_ptr<fb::geometry_msgs::PoseStampedT> pose{};
            std::unique_ptr<fb::sensor_msgs::CompressedImageT> cmpr_image{};
            std::string url{};
            DetectedItemT() = default;
            DetectedItemT(const DetectedItemT& o);
            DetectedItemT(DetectedItemT&&) FLATBUFFERS_NOEXCEPT = default;
            DetectedItemT& operator=(DetectedItemT o) FLATBUFFERS_NOEXCEPT;
        };

        struct DetectedItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
            typedef DetectedItemT NativeTableType;
            typedef DetectedItemBuilder Builder;
            enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
                VT___METADATA = 4,
                VT_UID = 6,
                VT_CALLSIGN = 8,
                VT_TYPE = 10,
                VT_TYPE_LABEL = 12,
                VT_HOW = 14,
                VT_HOW_LABEL = 16,
                VT_POSE = 18,
                VT_CMPR_IMAGE = 20,
                VT_URL = 22
            };
            const fb::MsgMetadata* __metadata() const {
                return GetPointer<const fb::MsgMetadata*>(VT___METADATA);
            }
            const flatbuffers::String* uid() const {
                return GetPointer<const flatbuffers::String*>(VT_UID);
            }
            const flatbuffers::String* callsign() const {
                return GetPointer<const flatbuffers::String*>(VT_CALLSIGN);
            }
            const flatbuffers::String* type() const {
                return GetPointer<const flatbuffers::String*>(VT_TYPE);
            }
            const flatbuffers::String* type_label() const {
                return GetPointer<const flatbuffers::String*>(VT_TYPE_LABEL);
            }
            const flatbuffers::String* how() const {
                return GetPointer<const flatbuffers::String*>(VT_HOW);
            }
            const flatbuffers::String* how_label() const {
                return GetPointer<const flatbuffers::String*>(VT_HOW_LABEL);
            }
            const fb::geometry_msgs::PoseStamped* pose() const {
                return GetPointer<const fb::geometry_msgs::PoseStamped*>(VT_POSE);
            }
            const fb::sensor_msgs::CompressedImage* cmpr_image() const {
                return GetPointer<const fb::sensor_msgs::CompressedImage*>(VT_CMPR_IMAGE);
            }
            const flatbuffers::String* url() const {
                return GetPointer<const flatbuffers::String*>(VT_URL);
            }
            bool Verify(flatbuffers::Verifier& verifier) const {
                return VerifyTableStart(verifier) &&
                    VerifyOffset(verifier, VT___METADATA) &&
                    verifier.VerifyTable(__metadata()) &&
                    VerifyOffsetRequired(verifier, VT_UID) &&
                    verifier.VerifyString(uid()) &&
                    VerifyOffsetRequired(verifier, VT_CALLSIGN) &&
                    verifier.VerifyString(callsign()) &&
                    VerifyOffsetRequired(verifier, VT_TYPE) &&
                    verifier.VerifyString(type()) &&
                    VerifyOffsetRequired(verifier, VT_TYPE_LABEL) &&
                    verifier.VerifyString(type_label()) &&
                    VerifyOffsetRequired(verifier, VT_HOW) &&
                    verifier.VerifyString(how()) &&
                    VerifyOffsetRequired(verifier, VT_HOW_LABEL) &&
                    verifier.VerifyString(how_label()) &&
                    VerifyOffsetRequired(verifier, VT_POSE) &&
                    verifier.VerifyTable(pose()) &&
                    VerifyOffsetRequired(verifier, VT_CMPR_IMAGE) &&
                    verifier.VerifyTable(cmpr_image()) &&
                    VerifyOffsetRequired(verifier, VT_URL) &&
                    verifier.VerifyString(url()) &&
                    verifier.EndTable();
            }
            DetectedItemT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
            void UnPackTo(DetectedItemT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
            static flatbuffers::Offset<DetectedItem> Pack(flatbuffers::FlatBufferBuilder& _fbb, const DetectedItemT* _o, const flatbuffers::rehasher_function_t* _rehasher = nullptr);
        };

        struct DetectedItemBuilder {
            typedef DetectedItem Table;
            flatbuffers::FlatBufferBuilder& fbb_;
            flatbuffers::uoffset_t start_;
            void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
                fbb_.AddOffset(DetectedItem::VT___METADATA, __metadata);
            }
            void add_uid(flatbuffers::Offset<flatbuffers::String> uid) {
                fbb_.AddOffset(DetectedItem::VT_UID, uid);
            }
            void add_callsign(flatbuffers::Offset<flatbuffers::String> callsign) {
                fbb_.AddOffset(DetectedItem::VT_CALLSIGN, callsign);
            }
            void add_type(flatbuffers::Offset<flatbuffers::String> type) {
                fbb_.AddOffset(DetectedItem::VT_TYPE, type);
            }
            void add_type_label(flatbuffers::Offset<flatbuffers::String> type_label) {
                fbb_.AddOffset(DetectedItem::VT_TYPE_LABEL, type_label);
            }
            void add_how(flatbuffers::Offset<flatbuffers::String> how) {
                fbb_.AddOffset(DetectedItem::VT_HOW, how);
            }
            void add_how_label(flatbuffers::Offset<flatbuffers::String> how_label) {
                fbb_.AddOffset(DetectedItem::VT_HOW_LABEL, how_label);
            }
            void add_pose(flatbuffers::Offset<fb::geometry_msgs::PoseStamped> pose) {
                fbb_.AddOffset(DetectedItem::VT_POSE, pose);
            }
            void add_cmpr_image(flatbuffers::Offset<fb::sensor_msgs::CompressedImage> cmpr_image) {
                fbb_.AddOffset(DetectedItem::VT_CMPR_IMAGE, cmpr_image);
            }
            void add_url(flatbuffers::Offset<flatbuffers::String> url) {
                fbb_.AddOffset(DetectedItem::VT_URL, url);
            }
            explicit DetectedItemBuilder(flatbuffers::FlatBufferBuilder& _fbb)
                : fbb_(_fbb) {
                start_ = fbb_.StartTable();
            }
            flatbuffers::Offset<DetectedItem> Finish() {
                const auto end = fbb_.EndTable(start_);
                auto o = flatbuffers::Offset<DetectedItem>(end);
                fbb_.Required(o, DetectedItem::VT_UID);
                fbb_.Required(o, DetectedItem::VT_CALLSIGN);
                fbb_.Required(o, DetectedItem::VT_TYPE);
                fbb_.Required(o, DetectedItem::VT_TYPE_LABEL);
                fbb_.Required(o, DetectedItem::VT_HOW);
                fbb_.Required(o, DetectedItem::VT_HOW_LABEL);
                fbb_.Required(o, DetectedItem::VT_POSE);
                fbb_.Required(o, DetectedItem::VT_CMPR_IMAGE);
                fbb_.Required(o, DetectedItem::VT_URL);
                return o;
            }
        };

        inline flatbuffers::Offset<DetectedItem> CreateDetectedItem(
            flatbuffers::FlatBufferBuilder& _fbb,
            flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
            flatbuffers::Offset<flatbuffers::String> uid = 0,
            flatbuffers::Offset<flatbuffers::String> callsign = 0,
            flatbuffers::Offset<flatbuffers::String> type = 0,
            flatbuffers::Offset<flatbuffers::String> type_label = 0,
            flatbuffers::Offset<flatbuffers::String> how = 0,
            flatbuffers::Offset<flatbuffers::String> how_label = 0,
            flatbuffers::Offset<fb::geometry_msgs::PoseStamped> pose = 0,
            flatbuffers::Offset<fb::sensor_msgs::CompressedImage> cmpr_image = 0,
            flatbuffers::Offset<flatbuffers::String> url = 0) {
            DetectedItemBuilder builder_(_fbb);
            builder_.add_url(url);
            builder_.add_cmpr_image(cmpr_image);
            builder_.add_pose(pose);
            builder_.add_how_label(how_label);
            builder_.add_how(how);
            builder_.add_type_label(type_label);
            builder_.add_type(type);
            builder_.add_callsign(callsign);
            builder_.add_uid(uid);
            builder_.add___metadata(__metadata);
            return builder_.Finish();
        }

        inline flatbuffers::Offset<DetectedItem> CreateDetectedItemDirect(
            flatbuffers::FlatBufferBuilder& _fbb,
            flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
            const char* uid = nullptr,
            const char* callsign = nullptr,
            const char* type = nullptr,
            const char* type_label = nullptr,
            const char* how = nullptr,
            const char* how_label = nullptr,
            flatbuffers::Offset<fb::geometry_msgs::PoseStamped> pose = 0,
            flatbuffers::Offset<fb::sensor_msgs::CompressedImage> cmpr_image = 0,
            const char* url = nullptr) {
            auto uid__ = uid ? _fbb.CreateString(uid) : 0;
            auto callsign__ = callsign ? _fbb.CreateString(callsign) : 0;
            auto type__ = type ? _fbb.CreateString(type) : 0;
            auto type_label__ = type_label ? _fbb.CreateString(type_label) : 0;
            auto how__ = how ? _fbb.CreateString(how) : 0;
            auto how_label__ = how_label ? _fbb.CreateString(how_label) : 0;
            auto url__ = url ? _fbb.CreateString(url) : 0;
            return fb::augre_msgs::CreateDetectedItem(
                _fbb,
                __metadata,
                uid__,
                callsign__,
                type__,
                type_label__,
                how__,
                how_label__,
                pose,
                cmpr_image,
                url__);
        }

        flatbuffers::Offset<DetectedItem> CreateDetectedItem(flatbuffers::FlatBufferBuilder& _fbb, const DetectedItemT* _o, const flatbuffers::rehasher_function_t* _rehasher = nullptr);

        inline TransformWithCovarianceStampedT::TransformWithCovarianceStampedT(const TransformWithCovarianceStampedT& o)
            : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
            transform((o.transform) ? new fb::geometry_msgs::TransformStampedT(*o.transform) : nullptr),
            covariance(o.covariance) {
        }

        inline TransformWithCovarianceStampedT& TransformWithCovarianceStampedT::operator=(TransformWithCovarianceStampedT o) FLATBUFFERS_NOEXCEPT {
            std::swap(__metadata, o.__metadata);
            std::swap(transform, o.transform);
            std::swap(covariance, o.covariance);
            return *this;
        }

        inline TransformWithCovarianceStampedT* TransformWithCovarianceStamped::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
            auto _o = std::unique_ptr<TransformWithCovarianceStampedT>(new TransformWithCovarianceStampedT());
            UnPackTo(_o.get(), _resolver);
            return _o.release();
        }

        inline void TransformWithCovarianceStamped::UnPackTo(TransformWithCovarianceStampedT* _o, const flatbuffers::resolver_function_t* _resolver) const {
            (void)_o;
            (void)_resolver;
            { auto _e = __metadata(); if (_e) { if (_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
            { auto _e = transform(); if (_e) { if (_o->transform) { _e->UnPackTo(_o->transform.get(), _resolver); } else { _o->transform = std::unique_ptr<fb::geometry_msgs::TransformStampedT>(_e->UnPack(_resolver)); } } }
            { auto _e = covariance(); if (_e) { _o->covariance.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->covariance[_i] = _e->Get(_i); } } }
        }

        inline flatbuffers::Offset<TransformWithCovarianceStamped> TransformWithCovarianceStamped::Pack(flatbuffers::FlatBufferBuilder& _fbb, const TransformWithCovarianceStampedT* _o, const flatbuffers::rehasher_function_t* _rehasher) {
            return CreateTransformWithCovarianceStamped(_fbb, _o, _rehasher);
        }

        inline flatbuffers::Offset<TransformWithCovarianceStamped> CreateTransformWithCovarianceStamped(flatbuffers::FlatBufferBuilder& _fbb, const TransformWithCovarianceStampedT* _o, const flatbuffers::rehasher_function_t* _rehasher) {
            (void)_rehasher;
            (void)_o;
            struct _VectorArgs { flatbuffers::FlatBufferBuilder* __fbb; const TransformWithCovarianceStampedT* __o; const flatbuffers::rehasher_function_t* __rehasher; } _va = { &_fbb, _o, _rehasher }; (void)_va;
            auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
            auto _transform = _o->transform ? CreateTransformStamped(_fbb, _o->transform.get(), _rehasher) : 0;
            auto _covariance = _fbb.CreateVector(_o->covariance);
            return fb::augre_msgs::CreateTransformWithCovarianceStamped(
                _fbb,
                ___metadata,
                _transform,
                _covariance);
        }

        inline BoundingObject3DT::BoundingObject3DT(const BoundingObject3DT& o)
            : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
            action(o.action),
            shape(o.shape),
            uid(o.uid),
            size_x(o.size_x),
            size_y(o.size_y),
            size_z(o.size_z),
            radius(o.radius),
            centroid((o.centroid) ? new fb::geometry_msgs::PoseStampedT(*o.centroid) : nullptr) {
        }

        inline BoundingObject3DT& BoundingObject3DT::operator=(BoundingObject3DT o) FLATBUFFERS_NOEXCEPT {
            std::swap(__metadata, o.__metadata);
            std::swap(action, o.action);
            std::swap(shape, o.shape);
            std::swap(uid, o.uid);
            std::swap(size_x, o.size_x);
            std::swap(size_y, o.size_y);
            std::swap(size_z, o.size_z);
            std::swap(radius, o.radius);
            std::swap(centroid, o.centroid);
            return *this;
        }

        inline BoundingObject3DT* BoundingObject3D::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
            auto _o = std::unique_ptr<BoundingObject3DT>(new BoundingObject3DT());
            UnPackTo(_o.get(), _resolver);
            return _o.release();
        }

        inline void BoundingObject3D::UnPackTo(BoundingObject3DT* _o, const flatbuffers::resolver_function_t* _resolver) const {
            (void)_o;
            (void)_resolver;
            { auto _e = __metadata(); if (_e) { if (_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
            { auto _e = action(); _o->action = _e; }
            { auto _e = shape(); _o->shape = _e; }
            { auto _e = uid(); if (_e) _o->uid = _e->str(); }
            { auto _e = size_x(); _o->size_x = _e; }
            { auto _e = size_y(); _o->size_y = _e; }
            { auto _e = size_z(); _o->size_z = _e; }
            { auto _e = radius(); _o->radius = _e; }
            { auto _e = centroid(); if (_e) { if (_o->centroid) { _e->UnPackTo(_o->centroid.get(), _resolver); } else { _o->centroid = std::unique_ptr<fb::geometry_msgs::PoseStampedT>(_e->UnPack(_resolver)); } } }
        }

        inline flatbuffers::Offset<BoundingObject3D> BoundingObject3D::Pack(flatbuffers::FlatBufferBuilder& _fbb, const BoundingObject3DT* _o, const flatbuffers::rehasher_function_t* _rehasher) {
            return CreateBoundingObject3D(_fbb, _o, _rehasher);
        }

        inline flatbuffers::Offset<BoundingObject3D> CreateBoundingObject3D(flatbuffers::FlatBufferBuilder& _fbb, const BoundingObject3DT* _o, const flatbuffers::rehasher_function_t* _rehasher) {
            (void)_rehasher;
            (void)_o;
            struct _VectorArgs { flatbuffers::FlatBufferBuilder* __fbb; const BoundingObject3DT* __o; const flatbuffers::rehasher_function_t* __rehasher; } _va = { &_fbb, _o, _rehasher }; (void)_va;
            auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
            auto _action = _o->action;
            auto _shape = _o->shape;
            auto _uid = _fbb.CreateString(_o->uid);
            auto _size_x = _o->size_x;
            auto _size_y = _o->size_y;
            auto _size_z = _o->size_z;
            auto _radius = _o->radius;
            auto _centroid = _o->centroid ? CreatePoseStamped(_fbb, _o->centroid.get(), _rehasher) : 0;
            return fb::augre_msgs::CreateBoundingObject3D(
                _fbb,
                ___metadata,
                _action,
                _shape,
                _uid,
                _size_x,
                _size_y,
                _size_z,
                _radius,
                _centroid);
        }

        inline AgentStatusT::AgentStatusT(const AgentStatusT& o)
            : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
            uid(o.uid),
            callsign(o.callsign),
            agent_type(o.agent_type),
            battery(o.battery),
            commander(o.commander),
            control_status(o.control_status) {
        }

        inline AgentStatusT& AgentStatusT::operator=(AgentStatusT o) FLATBUFFERS_NOEXCEPT {
            std::swap(__metadata, o.__metadata);
            std::swap(uid, o.uid);
            std::swap(callsign, o.callsign);
            std::swap(agent_type, o.agent_type);
            std::swap(battery, o.battery);
            std::swap(commander, o.commander);
            std::swap(control_status, o.control_status);
            return *this;
        }

        inline AgentStatusT* AgentStatus::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
            auto _o = std::unique_ptr<AgentStatusT>(new AgentStatusT());
            UnPackTo(_o.get(), _resolver);
            return _o.release();
        }

        inline void AgentStatus::UnPackTo(AgentStatusT* _o, const flatbuffers::resolver_function_t* _resolver) const {
            (void)_o;
            (void)_resolver;
            { auto _e = __metadata(); if (_e) { if (_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
            { auto _e = uid(); if (_e) _o->uid = _e->str(); }
            { auto _e = callsign(); if (_e) _o->callsign = _e->str(); }
            { auto _e = agent_type(); if (_e) _o->agent_type = _e->str(); }
            { auto _e = battery(); _o->battery = _e; }
            { auto _e = commander(); if (_e) _o->commander = _e->str(); }
            { auto _e = control_status(); if (_e) _o->control_status = _e->str(); }
        }

        inline flatbuffers::Offset<AgentStatus> AgentStatus::Pack(flatbuffers::FlatBufferBuilder& _fbb, const AgentStatusT* _o, const flatbuffers::rehasher_function_t* _rehasher) {
            return CreateAgentStatus(_fbb, _o, _rehasher);
        }

        inline flatbuffers::Offset<AgentStatus> CreateAgentStatus(flatbuffers::FlatBufferBuilder& _fbb, const AgentStatusT* _o, const flatbuffers::rehasher_function_t* _rehasher) {
            (void)_rehasher;
            (void)_o;
            struct _VectorArgs { flatbuffers::FlatBufferBuilder* __fbb; const AgentStatusT* __o; const flatbuffers::rehasher_function_t* __rehasher; } _va = { &_fbb, _o, _rehasher }; (void)_va;
            auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
            auto _uid = _fbb.CreateString(_o->uid);
            auto _callsign = _fbb.CreateString(_o->callsign);
            auto _agent_type = _fbb.CreateString(_o->agent_type);
            auto _battery = _o->battery;
            auto _commander = _fbb.CreateString(_o->commander);
            auto _control_status = _fbb.CreateString(_o->control_status);
            return fb::augre_msgs::CreateAgentStatus(
                _fbb,
                ___metadata,
                _uid,
                _callsign,
                _agent_type,
                _battery,
                _commander,
                _control_status);
        }

        inline HeaderArrayStampedT::HeaderArrayStampedT(const HeaderArrayStampedT& o)
            : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
            header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr) {
            data.reserve(o.data.size());
            for (const auto& v : o.data) { data.emplace_back((v) ? new fb::std_msgs::HeaderT(*v) : nullptr); }
        }

        inline HeaderArrayStampedT& HeaderArrayStampedT::operator=(HeaderArrayStampedT o) FLATBUFFERS_NOEXCEPT {
            std::swap(__metadata, o.__metadata);
            std::swap(header, o.header);
            std::swap(data, o.data);
            return *this;
        }

        inline HeaderArrayStampedT* HeaderArrayStamped::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
            auto _o = std::unique_ptr<HeaderArrayStampedT>(new HeaderArrayStampedT());
            UnPackTo(_o.get(), _resolver);
            return _o.release();
        }

        inline void HeaderArrayStamped::UnPackTo(HeaderArrayStampedT* _o, const flatbuffers::resolver_function_t* _resolver) const {
            (void)_o;
            (void)_resolver;
            { auto _e = __metadata(); if (_e) { if (_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
            { auto _e = header(); if (_e) { if (_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } }
            { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if (_o->data[_i]) { _e->Get(_i)->UnPackTo(_o->data[_i].get(), _resolver); } else { _o->data[_i] = std::unique_ptr<fb::std_msgs::HeaderT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
        }

        inline flatbuffers::Offset<HeaderArrayStamped> HeaderArrayStamped::Pack(flatbuffers::FlatBufferBuilder& _fbb, const HeaderArrayStampedT* _o, const flatbuffers::rehasher_function_t* _rehasher) {
            return CreateHeaderArrayStamped(_fbb, _o, _rehasher);
        }

        inline flatbuffers::Offset<HeaderArrayStamped> CreateHeaderArrayStamped(flatbuffers::FlatBufferBuilder& _fbb, const HeaderArrayStampedT* _o, const flatbuffers::rehasher_function_t* _rehasher) {
            (void)_rehasher;
            (void)_o;
            struct _VectorArgs { flatbuffers::FlatBufferBuilder* __fbb; const HeaderArrayStampedT* __o; const flatbuffers::rehasher_function_t* __rehasher; } _va = { &_fbb, _o, _rehasher }; (void)_va;
            auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
            auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
            auto _data = _fbb.CreateVector<flatbuffers::Offset<fb::std_msgs::Header>>(_o->data.size(), [](size_t i, _VectorArgs* __va) { return CreateHeader(*__va->__fbb, __va->__o->data[i].get(), __va->__rehasher); }, &_va);
            return fb::augre_msgs::CreateHeaderArrayStamped(
                _fbb,
                ___metadata,
                _header,
                _data);
        }

        inline BoundingObject3DArrayT::BoundingObject3DArrayT(const BoundingObject3DArrayT& o)
            : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr) {
            objects.reserve(o.objects.size());
            for (const auto& v : o.objects) { objects.emplace_back((v) ? new fb::augre_msgs::BoundingObject3DT(*v) : nullptr); }
        }

        inline BoundingObject3DArrayT& BoundingObject3DArrayT::operator=(BoundingObject3DArrayT o) FLATBUFFERS_NOEXCEPT {
            std::swap(__metadata, o.__metadata);
            std::swap(objects, o.objects);
            return *this;
        }

        inline BoundingObject3DArrayT* BoundingObject3DArray::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
            auto _o = std::unique_ptr<BoundingObject3DArrayT>(new BoundingObject3DArrayT());
            UnPackTo(_o.get(), _resolver);
            return _o.release();
        }

        inline void BoundingObject3DArray::UnPackTo(BoundingObject3DArrayT* _o, const flatbuffers::resolver_function_t* _resolver) const {
            (void)_o;
            (void)_resolver;
            { auto _e = __metadata(); if (_e) { if (_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
            { auto _e = objects(); if (_e) { _o->objects.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if (_o->objects[_i]) { _e->Get(_i)->UnPackTo(_o->objects[_i].get(), _resolver); } else { _o->objects[_i] = std::unique_ptr<fb::augre_msgs::BoundingObject3DT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
        }

        inline flatbuffers::Offset<BoundingObject3DArray> BoundingObject3DArray::Pack(flatbuffers::FlatBufferBuilder& _fbb, const BoundingObject3DArrayT* _o, const flatbuffers::rehasher_function_t* _rehasher) {
            return CreateBoundingObject3DArray(_fbb, _o, _rehasher);
        }

        inline flatbuffers::Offset<BoundingObject3DArray> CreateBoundingObject3DArray(flatbuffers::FlatBufferBuilder& _fbb, const BoundingObject3DArrayT* _o, const flatbuffers::rehasher_function_t* _rehasher) {
            (void)_rehasher;
            (void)_o;
            struct _VectorArgs { flatbuffers::FlatBufferBuilder* __fbb; const BoundingObject3DArrayT* __o; const flatbuffers::rehasher_function_t* __rehasher; } _va = { &_fbb, _o, _rehasher }; (void)_va;
            auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
            auto _objects = _fbb.CreateVector<flatbuffers::Offset<fb::augre_msgs::BoundingObject3D>>(_o->objects.size(), [](size_t i, _VectorArgs* __va) { return CreateBoundingObject3D(*__va->__fbb, __va->__o->objects[i].get(), __va->__rehasher); }, &_va);
            return fb::augre_msgs::CreateBoundingObject3DArray(
                _fbb,
                ___metadata,
                _objects);
        }

        inline DetectedItemT::DetectedItemT(const DetectedItemT& o)
            : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
            uid(o.uid),
            callsign(o.callsign),
            type(o.type),
            type_label(o.type_label),
            how(o.how),
            how_label(o.how_label),
            pose((o.pose) ? new fb::geometry_msgs::PoseStampedT(*o.pose) : nullptr),
            cmpr_image((o.cmpr_image) ? new fb::sensor_msgs::CompressedImageT(*o.cmpr_image) : nullptr),
            url(o.url) {
        }

        inline DetectedItemT& DetectedItemT::operator=(DetectedItemT o) FLATBUFFERS_NOEXCEPT {
            std::swap(__metadata, o.__metadata);
            std::swap(uid, o.uid);
            std::swap(callsign, o.callsign);
            std::swap(type, o.type);
            std::swap(type_label, o.type_label);
            std::swap(how, o.how);
            std::swap(how_label, o.how_label);
            std::swap(pose, o.pose);
            std::swap(cmpr_image, o.cmpr_image);
            std::swap(url, o.url);
            return *this;
        }

        inline DetectedItemT* DetectedItem::UnPack(const flatbuffers::resolver_function_t* _resolver) const {
            auto _o = std::unique_ptr<DetectedItemT>(new DetectedItemT());
            UnPackTo(_o.get(), _resolver);
            return _o.release();
        }

        inline void DetectedItem::UnPackTo(DetectedItemT* _o, const flatbuffers::resolver_function_t* _resolver) const {
            (void)_o;
            (void)_resolver;
            { auto _e = __metadata(); if (_e) { if (_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } }
            { auto _e = uid(); if (_e) _o->uid = _e->str(); }
            { auto _e = callsign(); if (_e) _o->callsign = _e->str(); }
            { auto _e = type(); if (_e) _o->type = _e->str(); }
            { auto _e = type_label(); if (_e) _o->type_label = _e->str(); }
            { auto _e = how(); if (_e) _o->how = _e->str(); }
            { auto _e = how_label(); if (_e) _o->how_label = _e->str(); }
            { auto _e = pose(); if (_e) { if (_o->pose) { _e->UnPackTo(_o->pose.get(), _resolver); } else { _o->pose = std::unique_ptr<fb::geometry_msgs::PoseStampedT>(_e->UnPack(_resolver)); } } }
            { auto _e = cmpr_image(); if (_e) { if (_o->cmpr_image) { _e->UnPackTo(_o->cmpr_image.get(), _resolver); } else { _o->cmpr_image = std::unique_ptr<fb::sensor_msgs::CompressedImageT>(_e->UnPack(_resolver)); } } }
            { auto _e = url(); if (_e) _o->url = _e->str(); }
        }

        inline flatbuffers::Offset<DetectedItem> DetectedItem::Pack(flatbuffers::FlatBufferBuilder& _fbb, const DetectedItemT* _o, const flatbuffers::rehasher_function_t* _rehasher) {
            return CreateDetectedItem(_fbb, _o, _rehasher);
        }

        inline flatbuffers::Offset<DetectedItem> CreateDetectedItem(flatbuffers::FlatBufferBuilder& _fbb, const DetectedItemT* _o, const flatbuffers::rehasher_function_t* _rehasher) {
            (void)_rehasher;
            (void)_o;
            struct _VectorArgs { flatbuffers::FlatBufferBuilder* __fbb; const DetectedItemT* __o; const flatbuffers::rehasher_function_t* __rehasher; } _va = { &_fbb, _o, _rehasher }; (void)_va;
            auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
            auto _uid = _fbb.CreateString(_o->uid);
            auto _callsign = _fbb.CreateString(_o->callsign);
            auto _type = _fbb.CreateString(_o->type);
            auto _type_label = _fbb.CreateString(_o->type_label);
            auto _how = _fbb.CreateString(_o->how);
            auto _how_label = _fbb.CreateString(_o->how_label);
            auto _pose = _o->pose ? CreatePoseStamped(_fbb, _o->pose.get(), _rehasher) : 0;
            auto _cmpr_image = _o->cmpr_image ? CreateCompressedImage(_fbb, _o->cmpr_image.get(), _rehasher) : 0;
            auto _url = _fbb.CreateString(_o->url);
            return fb::augre_msgs::CreateDetectedItem(
                _fbb,
                ___metadata,
                _uid,
                _callsign,
                _type,
                _type_label,
                _how,
                _how_label,
                _pose,
                _cmpr_image,
                _url);
        }

    }  // namespace augre_msgs
}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_AUGREMSGS_FB_AUGRE_MSGS_H_
