// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_AUGREMSGS_FB_AUGRE_MSGS_H_
#define FLATBUFFERS_GENERATED_AUGREMSGS_FB_AUGRE_MSGS_H_

#include "./flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 21,
             "Non-compatible flatbuffers version included");

#include "msg_schemas/geometry_msgs_generated.h"
#include "msg_schemas/sensor_msgs_generated.h"

namespace fb {
namespace augre_msgs {

struct TransformWithCovarianceStamped;
struct TransformWithCovarianceStampedBuilder;
struct TransformWithCovarianceStampedT;

struct AgentStatus;
struct AgentStatusBuilder;
struct AgentStatusT;

struct DetectedItem;
struct DetectedItemBuilder;
struct DetectedItemT;

struct TransformWithCovarianceStampedT : public ::flatbuffers::NativeTable {
  typedef TransformWithCovarianceStamped TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::geometry_msgs::TransformStampedT> transform{};
  std::vector<float> covariance{};
  TransformWithCovarianceStampedT() = default;
  TransformWithCovarianceStampedT(const TransformWithCovarianceStampedT &o);
  TransformWithCovarianceStampedT(TransformWithCovarianceStampedT&&) FLATBUFFERS_NOEXCEPT = default;
  TransformWithCovarianceStampedT &operator=(TransformWithCovarianceStampedT o) FLATBUFFERS_NOEXCEPT;
};

struct TransformWithCovarianceStamped FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TransformWithCovarianceStampedT NativeTableType;
  typedef TransformWithCovarianceStampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_TRANSFORM = 6,
    VT_COVARIANCE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::TransformStamped *transform() const {
    return GetPointer<const fb::geometry_msgs::TransformStamped *>(VT_TRANSFORM);
  }
  const ::flatbuffers::Vector<float> *covariance() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_COVARIANCE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_TRANSFORM) &&
           verifier.VerifyTable(transform()) &&
           VerifyOffsetRequired(verifier, VT_COVARIANCE) &&
           verifier.VerifyVector(covariance()) &&
           verifier.EndTable();
  }
  TransformWithCovarianceStampedT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransformWithCovarianceStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TransformWithCovarianceStamped> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TransformWithCovarianceStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransformWithCovarianceStampedBuilder {
  typedef TransformWithCovarianceStamped Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(TransformWithCovarianceStamped::VT___METADATA, __metadata);
  }
  void add_transform(::flatbuffers::Offset<fb::geometry_msgs::TransformStamped> transform) {
    fbb_.AddOffset(TransformWithCovarianceStamped::VT_TRANSFORM, transform);
  }
  void add_covariance(::flatbuffers::Offset<::flatbuffers::Vector<float>> covariance) {
    fbb_.AddOffset(TransformWithCovarianceStamped::VT_COVARIANCE, covariance);
  }
  explicit TransformWithCovarianceStampedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TransformWithCovarianceStamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TransformWithCovarianceStamped>(end);
    fbb_.Required(o, TransformWithCovarianceStamped::VT_TRANSFORM);
    fbb_.Required(o, TransformWithCovarianceStamped::VT_COVARIANCE);
    return o;
  }
};

inline ::flatbuffers::Offset<TransformWithCovarianceStamped> CreateTransformWithCovarianceStamped(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::TransformStamped> transform = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> covariance = 0) {
  TransformWithCovarianceStampedBuilder builder_(_fbb);
  builder_.add_covariance(covariance);
  builder_.add_transform(transform);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TransformWithCovarianceStamped> CreateTransformWithCovarianceStampedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::TransformStamped> transform = 0,
    const std::vector<float> *covariance = nullptr) {
  auto covariance__ = covariance ? _fbb.CreateVector<float>(*covariance) : 0;
  return fb::augre_msgs::CreateTransformWithCovarianceStamped(
      _fbb,
      __metadata,
      transform,
      covariance__);
}

::flatbuffers::Offset<TransformWithCovarianceStamped> CreateTransformWithCovarianceStamped(::flatbuffers::FlatBufferBuilder &_fbb, const TransformWithCovarianceStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AgentStatusT : public ::flatbuffers::NativeTable {
  typedef AgentStatus TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string uid{};
  std::string callsign{};
  std::string agent_type{};
  float battery = 0.0f;
  std::string commander{};
  std::string control_status{};
  AgentStatusT() = default;
  AgentStatusT(const AgentStatusT &o);
  AgentStatusT(AgentStatusT&&) FLATBUFFERS_NOEXCEPT = default;
  AgentStatusT &operator=(AgentStatusT o) FLATBUFFERS_NOEXCEPT;
};

struct AgentStatus FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AgentStatusT NativeTableType;
  typedef AgentStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_UID = 6,
    VT_CALLSIGN = 8,
    VT_AGENT_TYPE = 10,
    VT_BATTERY = 12,
    VT_COMMANDER = 14,
    VT_CONTROL_STATUS = 16
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *uid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UID);
  }
  const ::flatbuffers::String *callsign() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CALLSIGN);
  }
  const ::flatbuffers::String *agent_type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AGENT_TYPE);
  }
  float battery() const {
    return GetField<float>(VT_BATTERY, 0.0f);
  }
  const ::flatbuffers::String *commander() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMMANDER);
  }
  const ::flatbuffers::String *control_status() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONTROL_STATUS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_UID) &&
           verifier.VerifyString(uid()) &&
           VerifyOffsetRequired(verifier, VT_CALLSIGN) &&
           verifier.VerifyString(callsign()) &&
           VerifyOffsetRequired(verifier, VT_AGENT_TYPE) &&
           verifier.VerifyString(agent_type()) &&
           VerifyField<float>(verifier, VT_BATTERY, 4) &&
           VerifyOffsetRequired(verifier, VT_COMMANDER) &&
           verifier.VerifyString(commander()) &&
           VerifyOffsetRequired(verifier, VT_CONTROL_STATUS) &&
           verifier.VerifyString(control_status()) &&
           verifier.EndTable();
  }
  AgentStatusT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AgentStatusT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AgentStatus> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AgentStatusT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AgentStatusBuilder {
  typedef AgentStatus Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(AgentStatus::VT___METADATA, __metadata);
  }
  void add_uid(::flatbuffers::Offset<::flatbuffers::String> uid) {
    fbb_.AddOffset(AgentStatus::VT_UID, uid);
  }
  void add_callsign(::flatbuffers::Offset<::flatbuffers::String> callsign) {
    fbb_.AddOffset(AgentStatus::VT_CALLSIGN, callsign);
  }
  void add_agent_type(::flatbuffers::Offset<::flatbuffers::String> agent_type) {
    fbb_.AddOffset(AgentStatus::VT_AGENT_TYPE, agent_type);
  }
  void add_battery(float battery) {
    fbb_.AddElement<float>(AgentStatus::VT_BATTERY, battery, 0.0f);
  }
  void add_commander(::flatbuffers::Offset<::flatbuffers::String> commander) {
    fbb_.AddOffset(AgentStatus::VT_COMMANDER, commander);
  }
  void add_control_status(::flatbuffers::Offset<::flatbuffers::String> control_status) {
    fbb_.AddOffset(AgentStatus::VT_CONTROL_STATUS, control_status);
  }
  explicit AgentStatusBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AgentStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AgentStatus>(end);
    fbb_.Required(o, AgentStatus::VT_UID);
    fbb_.Required(o, AgentStatus::VT_CALLSIGN);
    fbb_.Required(o, AgentStatus::VT_AGENT_TYPE);
    fbb_.Required(o, AgentStatus::VT_COMMANDER);
    fbb_.Required(o, AgentStatus::VT_CONTROL_STATUS);
    return o;
  }
};

inline ::flatbuffers::Offset<AgentStatus> CreateAgentStatus(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> uid = 0,
    ::flatbuffers::Offset<::flatbuffers::String> callsign = 0,
    ::flatbuffers::Offset<::flatbuffers::String> agent_type = 0,
    float battery = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> commander = 0,
    ::flatbuffers::Offset<::flatbuffers::String> control_status = 0) {
  AgentStatusBuilder builder_(_fbb);
  builder_.add_control_status(control_status);
  builder_.add_commander(commander);
  builder_.add_battery(battery);
  builder_.add_agent_type(agent_type);
  builder_.add_callsign(callsign);
  builder_.add_uid(uid);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AgentStatus> CreateAgentStatusDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *uid = nullptr,
    const char *callsign = nullptr,
    const char *agent_type = nullptr,
    float battery = 0.0f,
    const char *commander = nullptr,
    const char *control_status = nullptr) {
  auto uid__ = uid ? _fbb.CreateString(uid) : 0;
  auto callsign__ = callsign ? _fbb.CreateString(callsign) : 0;
  auto agent_type__ = agent_type ? _fbb.CreateString(agent_type) : 0;
  auto commander__ = commander ? _fbb.CreateString(commander) : 0;
  auto control_status__ = control_status ? _fbb.CreateString(control_status) : 0;
  return fb::augre_msgs::CreateAgentStatus(
      _fbb,
      __metadata,
      uid__,
      callsign__,
      agent_type__,
      battery,
      commander__,
      control_status__);
}

::flatbuffers::Offset<AgentStatus> CreateAgentStatus(::flatbuffers::FlatBufferBuilder &_fbb, const AgentStatusT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DetectedItemT : public ::flatbuffers::NativeTable {
  typedef DetectedItem TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::string uid{};
  std::string callsign{};
  std::string type{};
  std::string type_label{};
  std::string how{};
  std::string how_label{};
  std::unique_ptr<fb::geometry_msgs::PoseStampedT> pose{};
  std::unique_ptr<fb::sensor_msgs::CompressedImageT> cmpr_image{};
  std::string url{};
  DetectedItemT() = default;
  DetectedItemT(const DetectedItemT &o);
  DetectedItemT(DetectedItemT&&) FLATBUFFERS_NOEXCEPT = default;
  DetectedItemT &operator=(DetectedItemT o) FLATBUFFERS_NOEXCEPT;
};

struct DetectedItem FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DetectedItemT NativeTableType;
  typedef DetectedItemBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_UID = 6,
    VT_CALLSIGN = 8,
    VT_TYPE = 10,
    VT_TYPE_LABEL = 12,
    VT_HOW = 14,
    VT_HOW_LABEL = 16,
    VT_POSE = 18,
    VT_CMPR_IMAGE = 20,
    VT_URL = 22
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::String *uid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UID);
  }
  const ::flatbuffers::String *callsign() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CALLSIGN);
  }
  const ::flatbuffers::String *type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  const ::flatbuffers::String *type_label() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE_LABEL);
  }
  const ::flatbuffers::String *how() const {
    return GetPointer<const ::flatbuffers::String *>(VT_HOW);
  }
  const ::flatbuffers::String *how_label() const {
    return GetPointer<const ::flatbuffers::String *>(VT_HOW_LABEL);
  }
  const fb::geometry_msgs::PoseStamped *pose() const {
    return GetPointer<const fb::geometry_msgs::PoseStamped *>(VT_POSE);
  }
  const fb::sensor_msgs::CompressedImage *cmpr_image() const {
    return GetPointer<const fb::sensor_msgs::CompressedImage *>(VT_CMPR_IMAGE);
  }
  const ::flatbuffers::String *url() const {
    return GetPointer<const ::flatbuffers::String *>(VT_URL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_UID) &&
           verifier.VerifyString(uid()) &&
           VerifyOffsetRequired(verifier, VT_CALLSIGN) &&
           verifier.VerifyString(callsign()) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffsetRequired(verifier, VT_TYPE_LABEL) &&
           verifier.VerifyString(type_label()) &&
           VerifyOffsetRequired(verifier, VT_HOW) &&
           verifier.VerifyString(how()) &&
           VerifyOffsetRequired(verifier, VT_HOW_LABEL) &&
           verifier.VerifyString(how_label()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           VerifyOffsetRequired(verifier, VT_CMPR_IMAGE) &&
           verifier.VerifyTable(cmpr_image()) &&
           VerifyOffsetRequired(verifier, VT_URL) &&
           verifier.VerifyString(url()) &&
           verifier.EndTable();
  }
  DetectedItemT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DetectedItemT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DetectedItem> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DetectedItemT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DetectedItemBuilder {
  typedef DetectedItem Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(DetectedItem::VT___METADATA, __metadata);
  }
  void add_uid(::flatbuffers::Offset<::flatbuffers::String> uid) {
    fbb_.AddOffset(DetectedItem::VT_UID, uid);
  }
  void add_callsign(::flatbuffers::Offset<::flatbuffers::String> callsign) {
    fbb_.AddOffset(DetectedItem::VT_CALLSIGN, callsign);
  }
  void add_type(::flatbuffers::Offset<::flatbuffers::String> type) {
    fbb_.AddOffset(DetectedItem::VT_TYPE, type);
  }
  void add_type_label(::flatbuffers::Offset<::flatbuffers::String> type_label) {
    fbb_.AddOffset(DetectedItem::VT_TYPE_LABEL, type_label);
  }
  void add_how(::flatbuffers::Offset<::flatbuffers::String> how) {
    fbb_.AddOffset(DetectedItem::VT_HOW, how);
  }
  void add_how_label(::flatbuffers::Offset<::flatbuffers::String> how_label) {
    fbb_.AddOffset(DetectedItem::VT_HOW_LABEL, how_label);
  }
  void add_pose(::flatbuffers::Offset<fb::geometry_msgs::PoseStamped> pose) {
    fbb_.AddOffset(DetectedItem::VT_POSE, pose);
  }
  void add_cmpr_image(::flatbuffers::Offset<fb::sensor_msgs::CompressedImage> cmpr_image) {
    fbb_.AddOffset(DetectedItem::VT_CMPR_IMAGE, cmpr_image);
  }
  void add_url(::flatbuffers::Offset<::flatbuffers::String> url) {
    fbb_.AddOffset(DetectedItem::VT_URL, url);
  }
  explicit DetectedItemBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DetectedItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DetectedItem>(end);
    fbb_.Required(o, DetectedItem::VT_UID);
    fbb_.Required(o, DetectedItem::VT_CALLSIGN);
    fbb_.Required(o, DetectedItem::VT_TYPE);
    fbb_.Required(o, DetectedItem::VT_TYPE_LABEL);
    fbb_.Required(o, DetectedItem::VT_HOW);
    fbb_.Required(o, DetectedItem::VT_HOW_LABEL);
    fbb_.Required(o, DetectedItem::VT_POSE);
    fbb_.Required(o, DetectedItem::VT_CMPR_IMAGE);
    fbb_.Required(o, DetectedItem::VT_URL);
    return o;
  }
};

inline ::flatbuffers::Offset<DetectedItem> CreateDetectedItem(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::String> uid = 0,
    ::flatbuffers::Offset<::flatbuffers::String> callsign = 0,
    ::flatbuffers::Offset<::flatbuffers::String> type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> type_label = 0,
    ::flatbuffers::Offset<::flatbuffers::String> how = 0,
    ::flatbuffers::Offset<::flatbuffers::String> how_label = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::PoseStamped> pose = 0,
    ::flatbuffers::Offset<fb::sensor_msgs::CompressedImage> cmpr_image = 0,
    ::flatbuffers::Offset<::flatbuffers::String> url = 0) {
  DetectedItemBuilder builder_(_fbb);
  builder_.add_url(url);
  builder_.add_cmpr_image(cmpr_image);
  builder_.add_pose(pose);
  builder_.add_how_label(how_label);
  builder_.add_how(how);
  builder_.add_type_label(type_label);
  builder_.add_type(type);
  builder_.add_callsign(callsign);
  builder_.add_uid(uid);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DetectedItem> CreateDetectedItemDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *uid = nullptr,
    const char *callsign = nullptr,
    const char *type = nullptr,
    const char *type_label = nullptr,
    const char *how = nullptr,
    const char *how_label = nullptr,
    ::flatbuffers::Offset<fb::geometry_msgs::PoseStamped> pose = 0,
    ::flatbuffers::Offset<fb::sensor_msgs::CompressedImage> cmpr_image = 0,
    const char *url = nullptr) {
  auto uid__ = uid ? _fbb.CreateString(uid) : 0;
  auto callsign__ = callsign ? _fbb.CreateString(callsign) : 0;
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto type_label__ = type_label ? _fbb.CreateString(type_label) : 0;
  auto how__ = how ? _fbb.CreateString(how) : 0;
  auto how_label__ = how_label ? _fbb.CreateString(how_label) : 0;
  auto url__ = url ? _fbb.CreateString(url) : 0;
  return fb::augre_msgs::CreateDetectedItem(
      _fbb,
      __metadata,
      uid__,
      callsign__,
      type__,
      type_label__,
      how__,
      how_label__,
      pose,
      cmpr_image,
      url__);
}

::flatbuffers::Offset<DetectedItem> CreateDetectedItem(::flatbuffers::FlatBufferBuilder &_fbb, const DetectedItemT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TransformWithCovarianceStampedT::TransformWithCovarianceStampedT(const TransformWithCovarianceStampedT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        transform((o.transform) ? new fb::geometry_msgs::TransformStampedT(*o.transform) : nullptr),
        covariance(o.covariance) {
}

inline TransformWithCovarianceStampedT &TransformWithCovarianceStampedT::operator=(TransformWithCovarianceStampedT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(transform, o.transform);
  std::swap(covariance, o.covariance);
  return *this;
}

inline TransformWithCovarianceStampedT *TransformWithCovarianceStamped::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TransformWithCovarianceStampedT>(new TransformWithCovarianceStampedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TransformWithCovarianceStamped::UnPackTo(TransformWithCovarianceStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = transform(); if (_e) { if(_o->transform) { _e->UnPackTo(_o->transform.get(), _resolver); } else { _o->transform = std::unique_ptr<fb::geometry_msgs::TransformStampedT>(_e->UnPack(_resolver)); } } else if (_o->transform) { _o->transform.reset(); } }
  { auto _e = covariance(); if (_e) { _o->covariance.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->covariance[_i] = _e->Get(_i); } } else { _o->covariance.resize(0); } }
}

inline ::flatbuffers::Offset<TransformWithCovarianceStamped> TransformWithCovarianceStamped::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TransformWithCovarianceStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTransformWithCovarianceStamped(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TransformWithCovarianceStamped> CreateTransformWithCovarianceStamped(::flatbuffers::FlatBufferBuilder &_fbb, const TransformWithCovarianceStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TransformWithCovarianceStampedT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _transform = _o->transform ? CreateTransformStamped(_fbb, _o->transform.get(), _rehasher) : 0;
  auto _covariance = _fbb.CreateVector(_o->covariance);
  return fb::augre_msgs::CreateTransformWithCovarianceStamped(
      _fbb,
      ___metadata,
      _transform,
      _covariance);
}

inline AgentStatusT::AgentStatusT(const AgentStatusT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        uid(o.uid),
        callsign(o.callsign),
        agent_type(o.agent_type),
        battery(o.battery),
        commander(o.commander),
        control_status(o.control_status) {
}

inline AgentStatusT &AgentStatusT::operator=(AgentStatusT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(uid, o.uid);
  std::swap(callsign, o.callsign);
  std::swap(agent_type, o.agent_type);
  std::swap(battery, o.battery);
  std::swap(commander, o.commander);
  std::swap(control_status, o.control_status);
  return *this;
}

inline AgentStatusT *AgentStatus::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AgentStatusT>(new AgentStatusT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AgentStatus::UnPackTo(AgentStatusT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = uid(); if (_e) _o->uid = _e->str(); }
  { auto _e = callsign(); if (_e) _o->callsign = _e->str(); }
  { auto _e = agent_type(); if (_e) _o->agent_type = _e->str(); }
  { auto _e = battery(); _o->battery = _e; }
  { auto _e = commander(); if (_e) _o->commander = _e->str(); }
  { auto _e = control_status(); if (_e) _o->control_status = _e->str(); }
}

inline ::flatbuffers::Offset<AgentStatus> AgentStatus::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AgentStatusT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAgentStatus(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AgentStatus> CreateAgentStatus(::flatbuffers::FlatBufferBuilder &_fbb, const AgentStatusT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AgentStatusT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _uid = _fbb.CreateString(_o->uid);
  auto _callsign = _fbb.CreateString(_o->callsign);
  auto _agent_type = _fbb.CreateString(_o->agent_type);
  auto _battery = _o->battery;
  auto _commander = _fbb.CreateString(_o->commander);
  auto _control_status = _fbb.CreateString(_o->control_status);
  return fb::augre_msgs::CreateAgentStatus(
      _fbb,
      ___metadata,
      _uid,
      _callsign,
      _agent_type,
      _battery,
      _commander,
      _control_status);
}

inline DetectedItemT::DetectedItemT(const DetectedItemT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        uid(o.uid),
        callsign(o.callsign),
        type(o.type),
        type_label(o.type_label),
        how(o.how),
        how_label(o.how_label),
        pose((o.pose) ? new fb::geometry_msgs::PoseStampedT(*o.pose) : nullptr),
        cmpr_image((o.cmpr_image) ? new fb::sensor_msgs::CompressedImageT(*o.cmpr_image) : nullptr),
        url(o.url) {
}

inline DetectedItemT &DetectedItemT::operator=(DetectedItemT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(uid, o.uid);
  std::swap(callsign, o.callsign);
  std::swap(type, o.type);
  std::swap(type_label, o.type_label);
  std::swap(how, o.how);
  std::swap(how_label, o.how_label);
  std::swap(pose, o.pose);
  std::swap(cmpr_image, o.cmpr_image);
  std::swap(url, o.url);
  return *this;
}

inline DetectedItemT *DetectedItem::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DetectedItemT>(new DetectedItemT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DetectedItem::UnPackTo(DetectedItemT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = uid(); if (_e) _o->uid = _e->str(); }
  { auto _e = callsign(); if (_e) _o->callsign = _e->str(); }
  { auto _e = type(); if (_e) _o->type = _e->str(); }
  { auto _e = type_label(); if (_e) _o->type_label = _e->str(); }
  { auto _e = how(); if (_e) _o->how = _e->str(); }
  { auto _e = how_label(); if (_e) _o->how_label = _e->str(); }
  { auto _e = pose(); if (_e) { if(_o->pose) { _e->UnPackTo(_o->pose.get(), _resolver); } else { _o->pose = std::unique_ptr<fb::geometry_msgs::PoseStampedT>(_e->UnPack(_resolver)); } } else if (_o->pose) { _o->pose.reset(); } }
  { auto _e = cmpr_image(); if (_e) { if(_o->cmpr_image) { _e->UnPackTo(_o->cmpr_image.get(), _resolver); } else { _o->cmpr_image = std::unique_ptr<fb::sensor_msgs::CompressedImageT>(_e->UnPack(_resolver)); } } else if (_o->cmpr_image) { _o->cmpr_image.reset(); } }
  { auto _e = url(); if (_e) _o->url = _e->str(); }
}

inline ::flatbuffers::Offset<DetectedItem> DetectedItem::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DetectedItemT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDetectedItem(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DetectedItem> CreateDetectedItem(::flatbuffers::FlatBufferBuilder &_fbb, const DetectedItemT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DetectedItemT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _uid = _fbb.CreateString(_o->uid);
  auto _callsign = _fbb.CreateString(_o->callsign);
  auto _type = _fbb.CreateString(_o->type);
  auto _type_label = _fbb.CreateString(_o->type_label);
  auto _how = _fbb.CreateString(_o->how);
  auto _how_label = _fbb.CreateString(_o->how_label);
  auto _pose = _o->pose ? CreatePoseStamped(_fbb, _o->pose.get(), _rehasher) : 0;
  auto _cmpr_image = _o->cmpr_image ? CreateCompressedImage(_fbb, _o->cmpr_image.get(), _rehasher) : 0;
  auto _url = _fbb.CreateString(_o->url);
  return fb::augre_msgs::CreateDetectedItem(
      _fbb,
      ___metadata,
      _uid,
      _callsign,
      _type,
      _type_label,
      _how,
      _how_label,
      _pose,
      _cmpr_image,
      _url);
}

}  // namespace augre_msgs
}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_AUGREMSGS_FB_AUGRE_MSGS_H_
