// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GEOMETRYMSGS_FB_GEOMETRY_MSGS_H_
#define FLATBUFFERS_GENERATED_GEOMETRYMSGS_FB_GEOMETRY_MSGS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 21,
             "Non-compatible flatbuffers version included");

#include "msg_schemas/std_msgs_generated.h"

namespace fb {
namespace geometry_msgs {

struct Polygon;
struct PolygonBuilder;
struct PolygonT;

struct Twist;
struct TwistBuilder;
struct TwistT;

struct PoseStamped;
struct PoseStampedBuilder;
struct PoseStampedT;

struct Vector3Stamped;
struct Vector3StampedBuilder;
struct Vector3StampedT;

struct TwistWithCovarianceStamped;
struct TwistWithCovarianceStampedBuilder;
struct TwistWithCovarianceStampedT;

struct Vector3;
struct Vector3Builder;
struct Vector3T;

struct Quaternion;
struct QuaternionBuilder;
struct QuaternionT;

struct PoseWithCovariance;
struct PoseWithCovarianceBuilder;
struct PoseWithCovarianceT;

struct Transform;
struct TransformBuilder;
struct TransformT;

struct WrenchStamped;
struct WrenchStampedBuilder;
struct WrenchStampedT;

struct Wrench;
struct WrenchBuilder;
struct WrenchT;

struct AccelWithCovariance;
struct AccelWithCovarianceBuilder;
struct AccelWithCovarianceT;

struct Pose;
struct PoseBuilder;
struct PoseT;

struct PointStamped;
struct PointStampedBuilder;
struct PointStampedT;

struct PoseWithCovarianceStamped;
struct PoseWithCovarianceStampedBuilder;
struct PoseWithCovarianceStampedT;

struct Accel;
struct AccelBuilder;
struct AccelT;

struct PoseArray;
struct PoseArrayBuilder;
struct PoseArrayT;

struct InertiaStamped;
struct InertiaStampedBuilder;
struct InertiaStampedT;

struct PolygonStamped;
struct PolygonStampedBuilder;
struct PolygonStampedT;

struct QuaternionStamped;
struct QuaternionStampedBuilder;
struct QuaternionStampedT;

struct AccelWithCovarianceStamped;
struct AccelWithCovarianceStampedBuilder;
struct AccelWithCovarianceStampedT;

struct Pose2D;
struct Pose2DBuilder;
struct Pose2DT;

struct Point32;
struct Point32Builder;
struct Point32T;

struct AccelStamped;
struct AccelStampedBuilder;
struct AccelStampedT;

struct TwistStamped;
struct TwistStampedBuilder;
struct TwistStampedT;

struct Inertia;
struct InertiaBuilder;
struct InertiaT;

struct TwistWithCovariance;
struct TwistWithCovarianceBuilder;
struct TwistWithCovarianceT;

struct TransformStamped;
struct TransformStampedBuilder;
struct TransformStampedT;

struct Point;
struct PointBuilder;
struct PointT;

struct PolygonT : public ::flatbuffers::NativeTable {
  typedef Polygon TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::vector<std::unique_ptr<fb::geometry_msgs::Point32T>> points{};
  PolygonT() = default;
  PolygonT(const PolygonT &o);
  PolygonT(PolygonT&&) FLATBUFFERS_NOEXCEPT = default;
  PolygonT &operator=(PolygonT o) FLATBUFFERS_NOEXCEPT;
};

struct Polygon FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PolygonT NativeTableType;
  typedef PolygonBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_POINTS = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::Point32>> *points() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::Point32>> *>(VT_POINTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.VerifyVectorOfTables(points()) &&
           verifier.EndTable();
  }
  PolygonT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PolygonT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Polygon> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PolygonT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PolygonBuilder {
  typedef Polygon Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Polygon::VT___METADATA, __metadata);
  }
  void add_points(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::Point32>>> points) {
    fbb_.AddOffset(Polygon::VT_POINTS, points);
  }
  explicit PolygonBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Polygon> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Polygon>(end);
    fbb_.Required(o, Polygon::VT_POINTS);
    return o;
  }
};

inline ::flatbuffers::Offset<Polygon> CreatePolygon(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::Point32>>> points = 0) {
  PolygonBuilder builder_(_fbb);
  builder_.add_points(points);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Polygon> CreatePolygonDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const std::vector<::flatbuffers::Offset<fb::geometry_msgs::Point32>> *points = nullptr) {
  auto points__ = points ? _fbb.CreateVector<::flatbuffers::Offset<fb::geometry_msgs::Point32>>(*points) : 0;
  return fb::geometry_msgs::CreatePolygon(
      _fbb,
      __metadata,
      points__);
}

::flatbuffers::Offset<Polygon> CreatePolygon(::flatbuffers::FlatBufferBuilder &_fbb, const PolygonT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TwistT : public ::flatbuffers::NativeTable {
  typedef Twist TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::geometry_msgs::Vector3T> linear{};
  std::unique_ptr<fb::geometry_msgs::Vector3T> angular{};
  TwistT() = default;
  TwistT(const TwistT &o);
  TwistT(TwistT&&) FLATBUFFERS_NOEXCEPT = default;
  TwistT &operator=(TwistT o) FLATBUFFERS_NOEXCEPT;
};

struct Twist FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TwistT NativeTableType;
  typedef TwistBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_LINEAR = 6,
    VT_ANGULAR = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Vector3 *linear() const {
    return GetPointer<const fb::geometry_msgs::Vector3 *>(VT_LINEAR);
  }
  const fb::geometry_msgs::Vector3 *angular() const {
    return GetPointer<const fb::geometry_msgs::Vector3 *>(VT_ANGULAR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_LINEAR) &&
           verifier.VerifyTable(linear()) &&
           VerifyOffsetRequired(verifier, VT_ANGULAR) &&
           verifier.VerifyTable(angular()) &&
           verifier.EndTable();
  }
  TwistT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TwistT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Twist> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TwistT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TwistBuilder {
  typedef Twist Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Twist::VT___METADATA, __metadata);
  }
  void add_linear(::flatbuffers::Offset<fb::geometry_msgs::Vector3> linear) {
    fbb_.AddOffset(Twist::VT_LINEAR, linear);
  }
  void add_angular(::flatbuffers::Offset<fb::geometry_msgs::Vector3> angular) {
    fbb_.AddOffset(Twist::VT_ANGULAR, angular);
  }
  explicit TwistBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Twist> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Twist>(end);
    fbb_.Required(o, Twist::VT_LINEAR);
    fbb_.Required(o, Twist::VT_ANGULAR);
    return o;
  }
};

inline ::flatbuffers::Offset<Twist> CreateTwist(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Vector3> linear = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Vector3> angular = 0) {
  TwistBuilder builder_(_fbb);
  builder_.add_angular(angular);
  builder_.add_linear(linear);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<Twist> CreateTwist(::flatbuffers::FlatBufferBuilder &_fbb, const TwistT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PoseStampedT : public ::flatbuffers::NativeTable {
  typedef PoseStamped TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::geometry_msgs::PoseT> pose{};
  PoseStampedT() = default;
  PoseStampedT(const PoseStampedT &o);
  PoseStampedT(PoseStampedT&&) FLATBUFFERS_NOEXCEPT = default;
  PoseStampedT &operator=(PoseStampedT o) FLATBUFFERS_NOEXCEPT;
};

struct PoseStamped FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PoseStampedT NativeTableType;
  typedef PoseStampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_POSE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geometry_msgs::Pose *pose() const {
    return GetPointer<const fb::geometry_msgs::Pose *>(VT_POSE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           verifier.EndTable();
  }
  PoseStampedT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PoseStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PoseStamped> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PoseStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PoseStampedBuilder {
  typedef PoseStamped Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PoseStamped::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(PoseStamped::VT_HEADER, header);
  }
  void add_pose(::flatbuffers::Offset<fb::geometry_msgs::Pose> pose) {
    fbb_.AddOffset(PoseStamped::VT_POSE, pose);
  }
  explicit PoseStampedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PoseStamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PoseStamped>(end);
    fbb_.Required(o, PoseStamped::VT_HEADER);
    fbb_.Required(o, PoseStamped::VT_POSE);
    return o;
  }
};

inline ::flatbuffers::Offset<PoseStamped> CreatePoseStamped(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Pose> pose = 0) {
  PoseStampedBuilder builder_(_fbb);
  builder_.add_pose(pose);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<PoseStamped> CreatePoseStamped(::flatbuffers::FlatBufferBuilder &_fbb, const PoseStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Vector3StampedT : public ::flatbuffers::NativeTable {
  typedef Vector3Stamped TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::geometry_msgs::Vector3T> vector{};
  Vector3StampedT() = default;
  Vector3StampedT(const Vector3StampedT &o);
  Vector3StampedT(Vector3StampedT&&) FLATBUFFERS_NOEXCEPT = default;
  Vector3StampedT &operator=(Vector3StampedT o) FLATBUFFERS_NOEXCEPT;
};

struct Vector3Stamped FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Vector3StampedT NativeTableType;
  typedef Vector3StampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_VECTOR = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geometry_msgs::Vector3 *vector() const {
    return GetPointer<const fb::geometry_msgs::Vector3 *>(VT_VECTOR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_VECTOR) &&
           verifier.VerifyTable(vector()) &&
           verifier.EndTable();
  }
  Vector3StampedT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Vector3StampedT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Vector3Stamped> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Vector3StampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Vector3StampedBuilder {
  typedef Vector3Stamped Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Vector3Stamped::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(Vector3Stamped::VT_HEADER, header);
  }
  void add_vector(::flatbuffers::Offset<fb::geometry_msgs::Vector3> vector) {
    fbb_.AddOffset(Vector3Stamped::VT_VECTOR, vector);
  }
  explicit Vector3StampedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Vector3Stamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Vector3Stamped>(end);
    fbb_.Required(o, Vector3Stamped::VT_HEADER);
    fbb_.Required(o, Vector3Stamped::VT_VECTOR);
    return o;
  }
};

inline ::flatbuffers::Offset<Vector3Stamped> CreateVector3Stamped(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Vector3> vector = 0) {
  Vector3StampedBuilder builder_(_fbb);
  builder_.add_vector(vector);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<Vector3Stamped> CreateVector3Stamped(::flatbuffers::FlatBufferBuilder &_fbb, const Vector3StampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TwistWithCovarianceStampedT : public ::flatbuffers::NativeTable {
  typedef TwistWithCovarianceStamped TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::geometry_msgs::TwistWithCovarianceT> twist{};
  TwistWithCovarianceStampedT() = default;
  TwistWithCovarianceStampedT(const TwistWithCovarianceStampedT &o);
  TwistWithCovarianceStampedT(TwistWithCovarianceStampedT&&) FLATBUFFERS_NOEXCEPT = default;
  TwistWithCovarianceStampedT &operator=(TwistWithCovarianceStampedT o) FLATBUFFERS_NOEXCEPT;
};

struct TwistWithCovarianceStamped FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TwistWithCovarianceStampedT NativeTableType;
  typedef TwistWithCovarianceStampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_TWIST = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geometry_msgs::TwistWithCovariance *twist() const {
    return GetPointer<const fb::geometry_msgs::TwistWithCovariance *>(VT_TWIST);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_TWIST) &&
           verifier.VerifyTable(twist()) &&
           verifier.EndTable();
  }
  TwistWithCovarianceStampedT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TwistWithCovarianceStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TwistWithCovarianceStamped> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TwistWithCovarianceStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TwistWithCovarianceStampedBuilder {
  typedef TwistWithCovarianceStamped Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(TwistWithCovarianceStamped::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(TwistWithCovarianceStamped::VT_HEADER, header);
  }
  void add_twist(::flatbuffers::Offset<fb::geometry_msgs::TwistWithCovariance> twist) {
    fbb_.AddOffset(TwistWithCovarianceStamped::VT_TWIST, twist);
  }
  explicit TwistWithCovarianceStampedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TwistWithCovarianceStamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TwistWithCovarianceStamped>(end);
    fbb_.Required(o, TwistWithCovarianceStamped::VT_HEADER);
    fbb_.Required(o, TwistWithCovarianceStamped::VT_TWIST);
    return o;
  }
};

inline ::flatbuffers::Offset<TwistWithCovarianceStamped> CreateTwistWithCovarianceStamped(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::TwistWithCovariance> twist = 0) {
  TwistWithCovarianceStampedBuilder builder_(_fbb);
  builder_.add_twist(twist);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<TwistWithCovarianceStamped> CreateTwistWithCovarianceStamped(::flatbuffers::FlatBufferBuilder &_fbb, const TwistWithCovarianceStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Vector3T : public ::flatbuffers::NativeTable {
  typedef Vector3 TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  double x = 0.0;
  double y = 0.0;
  double z = 0.0;
  Vector3T() = default;
  Vector3T(const Vector3T &o);
  Vector3T(Vector3T&&) FLATBUFFERS_NOEXCEPT = default;
  Vector3T &operator=(Vector3T o) FLATBUFFERS_NOEXCEPT;
};

struct Vector3 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Vector3T NativeTableType;
  typedef Vector3Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<double>(verifier, VT_X, 8) &&
           VerifyField<double>(verifier, VT_Y, 8) &&
           VerifyField<double>(verifier, VT_Z, 8) &&
           verifier.EndTable();
  }
  Vector3T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Vector3T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Vector3> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Vector3T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Vector3Builder {
  typedef Vector3 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Vector3::VT___METADATA, __metadata);
  }
  void add_x(double x) {
    fbb_.AddElement<double>(Vector3::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Vector3::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(Vector3::VT_Z, z, 0.0);
  }
  explicit Vector3Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Vector3> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Vector3>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Vector3> CreateVector3(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0) {
  Vector3Builder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<Vector3> CreateVector3(::flatbuffers::FlatBufferBuilder &_fbb, const Vector3T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QuaternionT : public ::flatbuffers::NativeTable {
  typedef Quaternion TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  double x = 0.0;
  double y = 0.0;
  double z = 0.0;
  double w = 0.0;
  QuaternionT() = default;
  QuaternionT(const QuaternionT &o);
  QuaternionT(QuaternionT&&) FLATBUFFERS_NOEXCEPT = default;
  QuaternionT &operator=(QuaternionT o) FLATBUFFERS_NOEXCEPT;
};

struct Quaternion FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef QuaternionT NativeTableType;
  typedef QuaternionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10,
    VT_W = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  double w() const {
    return GetField<double>(VT_W, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<double>(verifier, VT_X, 8) &&
           VerifyField<double>(verifier, VT_Y, 8) &&
           VerifyField<double>(verifier, VT_Z, 8) &&
           VerifyField<double>(verifier, VT_W, 8) &&
           verifier.EndTable();
  }
  QuaternionT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QuaternionT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Quaternion> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const QuaternionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QuaternionBuilder {
  typedef Quaternion Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Quaternion::VT___METADATA, __metadata);
  }
  void add_x(double x) {
    fbb_.AddElement<double>(Quaternion::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Quaternion::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(Quaternion::VT_Z, z, 0.0);
  }
  void add_w(double w) {
    fbb_.AddElement<double>(Quaternion::VT_W, w, 0.0);
  }
  explicit QuaternionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Quaternion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Quaternion>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Quaternion> CreateQuaternion(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0,
    double w = 0.0) {
  QuaternionBuilder builder_(_fbb);
  builder_.add_w(w);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<Quaternion> CreateQuaternion(::flatbuffers::FlatBufferBuilder &_fbb, const QuaternionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PoseWithCovarianceT : public ::flatbuffers::NativeTable {
  typedef PoseWithCovariance TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::geometry_msgs::PoseT> pose{};
  std::vector<double> covariance{};
  PoseWithCovarianceT() = default;
  PoseWithCovarianceT(const PoseWithCovarianceT &o);
  PoseWithCovarianceT(PoseWithCovarianceT&&) FLATBUFFERS_NOEXCEPT = default;
  PoseWithCovarianceT &operator=(PoseWithCovarianceT o) FLATBUFFERS_NOEXCEPT;
};

struct PoseWithCovariance FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PoseWithCovarianceT NativeTableType;
  typedef PoseWithCovarianceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_POSE = 6,
    VT_COVARIANCE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Pose *pose() const {
    return GetPointer<const fb::geometry_msgs::Pose *>(VT_POSE);
  }
  const ::flatbuffers::Vector<double> *covariance() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_COVARIANCE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           VerifyOffsetRequired(verifier, VT_COVARIANCE) &&
           verifier.VerifyVector(covariance()) &&
           verifier.EndTable();
  }
  PoseWithCovarianceT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PoseWithCovarianceT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PoseWithCovariance> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PoseWithCovarianceT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PoseWithCovarianceBuilder {
  typedef PoseWithCovariance Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PoseWithCovariance::VT___METADATA, __metadata);
  }
  void add_pose(::flatbuffers::Offset<fb::geometry_msgs::Pose> pose) {
    fbb_.AddOffset(PoseWithCovariance::VT_POSE, pose);
  }
  void add_covariance(::flatbuffers::Offset<::flatbuffers::Vector<double>> covariance) {
    fbb_.AddOffset(PoseWithCovariance::VT_COVARIANCE, covariance);
  }
  explicit PoseWithCovarianceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PoseWithCovariance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PoseWithCovariance>(end);
    fbb_.Required(o, PoseWithCovariance::VT_POSE);
    fbb_.Required(o, PoseWithCovariance::VT_COVARIANCE);
    return o;
  }
};

inline ::flatbuffers::Offset<PoseWithCovariance> CreatePoseWithCovariance(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Pose> pose = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> covariance = 0) {
  PoseWithCovarianceBuilder builder_(_fbb);
  builder_.add_covariance(covariance);
  builder_.add_pose(pose);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PoseWithCovariance> CreatePoseWithCovarianceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Pose> pose = 0,
    const std::vector<double> *covariance = nullptr) {
  auto covariance__ = covariance ? _fbb.CreateVector<double>(*covariance) : 0;
  return fb::geometry_msgs::CreatePoseWithCovariance(
      _fbb,
      __metadata,
      pose,
      covariance__);
}

::flatbuffers::Offset<PoseWithCovariance> CreatePoseWithCovariance(::flatbuffers::FlatBufferBuilder &_fbb, const PoseWithCovarianceT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransformT : public ::flatbuffers::NativeTable {
  typedef Transform TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::geometry_msgs::Vector3T> translation{};
  std::unique_ptr<fb::geometry_msgs::QuaternionT> rotation{};
  TransformT() = default;
  TransformT(const TransformT &o);
  TransformT(TransformT&&) FLATBUFFERS_NOEXCEPT = default;
  TransformT &operator=(TransformT o) FLATBUFFERS_NOEXCEPT;
};

struct Transform FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TransformT NativeTableType;
  typedef TransformBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_TRANSLATION = 6,
    VT_ROTATION = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Vector3 *translation() const {
    return GetPointer<const fb::geometry_msgs::Vector3 *>(VT_TRANSLATION);
  }
  const fb::geometry_msgs::Quaternion *rotation() const {
    return GetPointer<const fb::geometry_msgs::Quaternion *>(VT_ROTATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_TRANSLATION) &&
           verifier.VerifyTable(translation()) &&
           VerifyOffsetRequired(verifier, VT_ROTATION) &&
           verifier.VerifyTable(rotation()) &&
           verifier.EndTable();
  }
  TransformT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransformT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Transform> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TransformT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransformBuilder {
  typedef Transform Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Transform::VT___METADATA, __metadata);
  }
  void add_translation(::flatbuffers::Offset<fb::geometry_msgs::Vector3> translation) {
    fbb_.AddOffset(Transform::VT_TRANSLATION, translation);
  }
  void add_rotation(::flatbuffers::Offset<fb::geometry_msgs::Quaternion> rotation) {
    fbb_.AddOffset(Transform::VT_ROTATION, rotation);
  }
  explicit TransformBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Transform> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Transform>(end);
    fbb_.Required(o, Transform::VT_TRANSLATION);
    fbb_.Required(o, Transform::VT_ROTATION);
    return o;
  }
};

inline ::flatbuffers::Offset<Transform> CreateTransform(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Vector3> translation = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Quaternion> rotation = 0) {
  TransformBuilder builder_(_fbb);
  builder_.add_rotation(rotation);
  builder_.add_translation(translation);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<Transform> CreateTransform(::flatbuffers::FlatBufferBuilder &_fbb, const TransformT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WrenchStampedT : public ::flatbuffers::NativeTable {
  typedef WrenchStamped TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::geometry_msgs::WrenchT> wrench{};
  WrenchStampedT() = default;
  WrenchStampedT(const WrenchStampedT &o);
  WrenchStampedT(WrenchStampedT&&) FLATBUFFERS_NOEXCEPT = default;
  WrenchStampedT &operator=(WrenchStampedT o) FLATBUFFERS_NOEXCEPT;
};

struct WrenchStamped FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WrenchStampedT NativeTableType;
  typedef WrenchStampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_WRENCH = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geometry_msgs::Wrench *wrench() const {
    return GetPointer<const fb::geometry_msgs::Wrench *>(VT_WRENCH);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_WRENCH) &&
           verifier.VerifyTable(wrench()) &&
           verifier.EndTable();
  }
  WrenchStampedT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WrenchStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<WrenchStamped> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WrenchStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WrenchStampedBuilder {
  typedef WrenchStamped Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(WrenchStamped::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(WrenchStamped::VT_HEADER, header);
  }
  void add_wrench(::flatbuffers::Offset<fb::geometry_msgs::Wrench> wrench) {
    fbb_.AddOffset(WrenchStamped::VT_WRENCH, wrench);
  }
  explicit WrenchStampedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WrenchStamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WrenchStamped>(end);
    fbb_.Required(o, WrenchStamped::VT_HEADER);
    fbb_.Required(o, WrenchStamped::VT_WRENCH);
    return o;
  }
};

inline ::flatbuffers::Offset<WrenchStamped> CreateWrenchStamped(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Wrench> wrench = 0) {
  WrenchStampedBuilder builder_(_fbb);
  builder_.add_wrench(wrench);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<WrenchStamped> CreateWrenchStamped(::flatbuffers::FlatBufferBuilder &_fbb, const WrenchStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WrenchT : public ::flatbuffers::NativeTable {
  typedef Wrench TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::geometry_msgs::Vector3T> force{};
  std::unique_ptr<fb::geometry_msgs::Vector3T> torque{};
  WrenchT() = default;
  WrenchT(const WrenchT &o);
  WrenchT(WrenchT&&) FLATBUFFERS_NOEXCEPT = default;
  WrenchT &operator=(WrenchT o) FLATBUFFERS_NOEXCEPT;
};

struct Wrench FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WrenchT NativeTableType;
  typedef WrenchBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_FORCE = 6,
    VT_TORQUE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Vector3 *force() const {
    return GetPointer<const fb::geometry_msgs::Vector3 *>(VT_FORCE);
  }
  const fb::geometry_msgs::Vector3 *torque() const {
    return GetPointer<const fb::geometry_msgs::Vector3 *>(VT_TORQUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_FORCE) &&
           verifier.VerifyTable(force()) &&
           VerifyOffsetRequired(verifier, VT_TORQUE) &&
           verifier.VerifyTable(torque()) &&
           verifier.EndTable();
  }
  WrenchT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WrenchT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Wrench> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WrenchT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WrenchBuilder {
  typedef Wrench Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Wrench::VT___METADATA, __metadata);
  }
  void add_force(::flatbuffers::Offset<fb::geometry_msgs::Vector3> force) {
    fbb_.AddOffset(Wrench::VT_FORCE, force);
  }
  void add_torque(::flatbuffers::Offset<fb::geometry_msgs::Vector3> torque) {
    fbb_.AddOffset(Wrench::VT_TORQUE, torque);
  }
  explicit WrenchBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Wrench> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Wrench>(end);
    fbb_.Required(o, Wrench::VT_FORCE);
    fbb_.Required(o, Wrench::VT_TORQUE);
    return o;
  }
};

inline ::flatbuffers::Offset<Wrench> CreateWrench(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Vector3> force = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Vector3> torque = 0) {
  WrenchBuilder builder_(_fbb);
  builder_.add_torque(torque);
  builder_.add_force(force);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<Wrench> CreateWrench(::flatbuffers::FlatBufferBuilder &_fbb, const WrenchT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AccelWithCovarianceT : public ::flatbuffers::NativeTable {
  typedef AccelWithCovariance TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::geometry_msgs::AccelT> accel{};
  std::vector<double> covariance{};
  AccelWithCovarianceT() = default;
  AccelWithCovarianceT(const AccelWithCovarianceT &o);
  AccelWithCovarianceT(AccelWithCovarianceT&&) FLATBUFFERS_NOEXCEPT = default;
  AccelWithCovarianceT &operator=(AccelWithCovarianceT o) FLATBUFFERS_NOEXCEPT;
};

struct AccelWithCovariance FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AccelWithCovarianceT NativeTableType;
  typedef AccelWithCovarianceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_ACCEL = 6,
    VT_COVARIANCE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Accel *accel() const {
    return GetPointer<const fb::geometry_msgs::Accel *>(VT_ACCEL);
  }
  const ::flatbuffers::Vector<double> *covariance() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_COVARIANCE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_ACCEL) &&
           verifier.VerifyTable(accel()) &&
           VerifyOffsetRequired(verifier, VT_COVARIANCE) &&
           verifier.VerifyVector(covariance()) &&
           verifier.EndTable();
  }
  AccelWithCovarianceT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AccelWithCovarianceT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AccelWithCovariance> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AccelWithCovarianceT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AccelWithCovarianceBuilder {
  typedef AccelWithCovariance Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(AccelWithCovariance::VT___METADATA, __metadata);
  }
  void add_accel(::flatbuffers::Offset<fb::geometry_msgs::Accel> accel) {
    fbb_.AddOffset(AccelWithCovariance::VT_ACCEL, accel);
  }
  void add_covariance(::flatbuffers::Offset<::flatbuffers::Vector<double>> covariance) {
    fbb_.AddOffset(AccelWithCovariance::VT_COVARIANCE, covariance);
  }
  explicit AccelWithCovarianceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AccelWithCovariance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AccelWithCovariance>(end);
    fbb_.Required(o, AccelWithCovariance::VT_ACCEL);
    fbb_.Required(o, AccelWithCovariance::VT_COVARIANCE);
    return o;
  }
};

inline ::flatbuffers::Offset<AccelWithCovariance> CreateAccelWithCovariance(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Accel> accel = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> covariance = 0) {
  AccelWithCovarianceBuilder builder_(_fbb);
  builder_.add_covariance(covariance);
  builder_.add_accel(accel);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AccelWithCovariance> CreateAccelWithCovarianceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Accel> accel = 0,
    const std::vector<double> *covariance = nullptr) {
  auto covariance__ = covariance ? _fbb.CreateVector<double>(*covariance) : 0;
  return fb::geometry_msgs::CreateAccelWithCovariance(
      _fbb,
      __metadata,
      accel,
      covariance__);
}

::flatbuffers::Offset<AccelWithCovariance> CreateAccelWithCovariance(::flatbuffers::FlatBufferBuilder &_fbb, const AccelWithCovarianceT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PoseT : public ::flatbuffers::NativeTable {
  typedef Pose TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::geometry_msgs::PointT> position{};
  std::unique_ptr<fb::geometry_msgs::QuaternionT> orientation{};
  PoseT() = default;
  PoseT(const PoseT &o);
  PoseT(PoseT&&) FLATBUFFERS_NOEXCEPT = default;
  PoseT &operator=(PoseT o) FLATBUFFERS_NOEXCEPT;
};

struct Pose FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PoseT NativeTableType;
  typedef PoseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_POSITION = 6,
    VT_ORIENTATION = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Point *position() const {
    return GetPointer<const fb::geometry_msgs::Point *>(VT_POSITION);
  }
  const fb::geometry_msgs::Quaternion *orientation() const {
    return GetPointer<const fb::geometry_msgs::Quaternion *>(VT_ORIENTATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_POSITION) &&
           verifier.VerifyTable(position()) &&
           VerifyOffsetRequired(verifier, VT_ORIENTATION) &&
           verifier.VerifyTable(orientation()) &&
           verifier.EndTable();
  }
  PoseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PoseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Pose> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PoseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PoseBuilder {
  typedef Pose Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Pose::VT___METADATA, __metadata);
  }
  void add_position(::flatbuffers::Offset<fb::geometry_msgs::Point> position) {
    fbb_.AddOffset(Pose::VT_POSITION, position);
  }
  void add_orientation(::flatbuffers::Offset<fb::geometry_msgs::Quaternion> orientation) {
    fbb_.AddOffset(Pose::VT_ORIENTATION, orientation);
  }
  explicit PoseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Pose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Pose>(end);
    fbb_.Required(o, Pose::VT_POSITION);
    fbb_.Required(o, Pose::VT_ORIENTATION);
    return o;
  }
};

inline ::flatbuffers::Offset<Pose> CreatePose(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Point> position = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Quaternion> orientation = 0) {
  PoseBuilder builder_(_fbb);
  builder_.add_orientation(orientation);
  builder_.add_position(position);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<Pose> CreatePose(::flatbuffers::FlatBufferBuilder &_fbb, const PoseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PointStampedT : public ::flatbuffers::NativeTable {
  typedef PointStamped TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::geometry_msgs::PointT> point{};
  PointStampedT() = default;
  PointStampedT(const PointStampedT &o);
  PointStampedT(PointStampedT&&) FLATBUFFERS_NOEXCEPT = default;
  PointStampedT &operator=(PointStampedT o) FLATBUFFERS_NOEXCEPT;
};

struct PointStamped FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PointStampedT NativeTableType;
  typedef PointStampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_POINT = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geometry_msgs::Point *point() const {
    return GetPointer<const fb::geometry_msgs::Point *>(VT_POINT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_POINT) &&
           verifier.VerifyTable(point()) &&
           verifier.EndTable();
  }
  PointStampedT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PointStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PointStamped> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PointStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PointStampedBuilder {
  typedef PointStamped Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PointStamped::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(PointStamped::VT_HEADER, header);
  }
  void add_point(::flatbuffers::Offset<fb::geometry_msgs::Point> point) {
    fbb_.AddOffset(PointStamped::VT_POINT, point);
  }
  explicit PointStampedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PointStamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PointStamped>(end);
    fbb_.Required(o, PointStamped::VT_HEADER);
    fbb_.Required(o, PointStamped::VT_POINT);
    return o;
  }
};

inline ::flatbuffers::Offset<PointStamped> CreatePointStamped(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Point> point = 0) {
  PointStampedBuilder builder_(_fbb);
  builder_.add_point(point);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<PointStamped> CreatePointStamped(::flatbuffers::FlatBufferBuilder &_fbb, const PointStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PoseWithCovarianceStampedT : public ::flatbuffers::NativeTable {
  typedef PoseWithCovarianceStamped TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::geometry_msgs::PoseWithCovarianceT> pose{};
  PoseWithCovarianceStampedT() = default;
  PoseWithCovarianceStampedT(const PoseWithCovarianceStampedT &o);
  PoseWithCovarianceStampedT(PoseWithCovarianceStampedT&&) FLATBUFFERS_NOEXCEPT = default;
  PoseWithCovarianceStampedT &operator=(PoseWithCovarianceStampedT o) FLATBUFFERS_NOEXCEPT;
};

struct PoseWithCovarianceStamped FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PoseWithCovarianceStampedT NativeTableType;
  typedef PoseWithCovarianceStampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_POSE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geometry_msgs::PoseWithCovariance *pose() const {
    return GetPointer<const fb::geometry_msgs::PoseWithCovariance *>(VT_POSE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           verifier.EndTable();
  }
  PoseWithCovarianceStampedT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PoseWithCovarianceStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PoseWithCovarianceStamped> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PoseWithCovarianceStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PoseWithCovarianceStampedBuilder {
  typedef PoseWithCovarianceStamped Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PoseWithCovarianceStamped::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(PoseWithCovarianceStamped::VT_HEADER, header);
  }
  void add_pose(::flatbuffers::Offset<fb::geometry_msgs::PoseWithCovariance> pose) {
    fbb_.AddOffset(PoseWithCovarianceStamped::VT_POSE, pose);
  }
  explicit PoseWithCovarianceStampedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PoseWithCovarianceStamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PoseWithCovarianceStamped>(end);
    fbb_.Required(o, PoseWithCovarianceStamped::VT_HEADER);
    fbb_.Required(o, PoseWithCovarianceStamped::VT_POSE);
    return o;
  }
};

inline ::flatbuffers::Offset<PoseWithCovarianceStamped> CreatePoseWithCovarianceStamped(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::PoseWithCovariance> pose = 0) {
  PoseWithCovarianceStampedBuilder builder_(_fbb);
  builder_.add_pose(pose);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<PoseWithCovarianceStamped> CreatePoseWithCovarianceStamped(::flatbuffers::FlatBufferBuilder &_fbb, const PoseWithCovarianceStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AccelT : public ::flatbuffers::NativeTable {
  typedef Accel TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::geometry_msgs::Vector3T> linear{};
  std::unique_ptr<fb::geometry_msgs::Vector3T> angular{};
  AccelT() = default;
  AccelT(const AccelT &o);
  AccelT(AccelT&&) FLATBUFFERS_NOEXCEPT = default;
  AccelT &operator=(AccelT o) FLATBUFFERS_NOEXCEPT;
};

struct Accel FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AccelT NativeTableType;
  typedef AccelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_LINEAR = 6,
    VT_ANGULAR = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Vector3 *linear() const {
    return GetPointer<const fb::geometry_msgs::Vector3 *>(VT_LINEAR);
  }
  const fb::geometry_msgs::Vector3 *angular() const {
    return GetPointer<const fb::geometry_msgs::Vector3 *>(VT_ANGULAR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_LINEAR) &&
           verifier.VerifyTable(linear()) &&
           VerifyOffsetRequired(verifier, VT_ANGULAR) &&
           verifier.VerifyTable(angular()) &&
           verifier.EndTable();
  }
  AccelT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AccelT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Accel> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AccelT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AccelBuilder {
  typedef Accel Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Accel::VT___METADATA, __metadata);
  }
  void add_linear(::flatbuffers::Offset<fb::geometry_msgs::Vector3> linear) {
    fbb_.AddOffset(Accel::VT_LINEAR, linear);
  }
  void add_angular(::flatbuffers::Offset<fb::geometry_msgs::Vector3> angular) {
    fbb_.AddOffset(Accel::VT_ANGULAR, angular);
  }
  explicit AccelBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Accel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Accel>(end);
    fbb_.Required(o, Accel::VT_LINEAR);
    fbb_.Required(o, Accel::VT_ANGULAR);
    return o;
  }
};

inline ::flatbuffers::Offset<Accel> CreateAccel(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Vector3> linear = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Vector3> angular = 0) {
  AccelBuilder builder_(_fbb);
  builder_.add_angular(angular);
  builder_.add_linear(linear);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<Accel> CreateAccel(::flatbuffers::FlatBufferBuilder &_fbb, const AccelT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PoseArrayT : public ::flatbuffers::NativeTable {
  typedef PoseArray TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::vector<std::unique_ptr<fb::geometry_msgs::PoseT>> poses{};
  PoseArrayT() = default;
  PoseArrayT(const PoseArrayT &o);
  PoseArrayT(PoseArrayT&&) FLATBUFFERS_NOEXCEPT = default;
  PoseArrayT &operator=(PoseArrayT o) FLATBUFFERS_NOEXCEPT;
};

struct PoseArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PoseArrayT NativeTableType;
  typedef PoseArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_POSES = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::Pose>> *poses() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::Pose>> *>(VT_POSES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_POSES) &&
           verifier.VerifyVector(poses()) &&
           verifier.VerifyVectorOfTables(poses()) &&
           verifier.EndTable();
  }
  PoseArrayT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PoseArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PoseArray> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PoseArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PoseArrayBuilder {
  typedef PoseArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PoseArray::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(PoseArray::VT_HEADER, header);
  }
  void add_poses(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::Pose>>> poses) {
    fbb_.AddOffset(PoseArray::VT_POSES, poses);
  }
  explicit PoseArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PoseArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PoseArray>(end);
    fbb_.Required(o, PoseArray::VT_HEADER);
    fbb_.Required(o, PoseArray::VT_POSES);
    return o;
  }
};

inline ::flatbuffers::Offset<PoseArray> CreatePoseArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::geometry_msgs::Pose>>> poses = 0) {
  PoseArrayBuilder builder_(_fbb);
  builder_.add_poses(poses);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PoseArray> CreatePoseArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const std::vector<::flatbuffers::Offset<fb::geometry_msgs::Pose>> *poses = nullptr) {
  auto poses__ = poses ? _fbb.CreateVector<::flatbuffers::Offset<fb::geometry_msgs::Pose>>(*poses) : 0;
  return fb::geometry_msgs::CreatePoseArray(
      _fbb,
      __metadata,
      header,
      poses__);
}

::flatbuffers::Offset<PoseArray> CreatePoseArray(::flatbuffers::FlatBufferBuilder &_fbb, const PoseArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InertiaStampedT : public ::flatbuffers::NativeTable {
  typedef InertiaStamped TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::geometry_msgs::InertiaT> inertia{};
  InertiaStampedT() = default;
  InertiaStampedT(const InertiaStampedT &o);
  InertiaStampedT(InertiaStampedT&&) FLATBUFFERS_NOEXCEPT = default;
  InertiaStampedT &operator=(InertiaStampedT o) FLATBUFFERS_NOEXCEPT;
};

struct InertiaStamped FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InertiaStampedT NativeTableType;
  typedef InertiaStampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_INERTIA = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geometry_msgs::Inertia *inertia() const {
    return GetPointer<const fb::geometry_msgs::Inertia *>(VT_INERTIA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_INERTIA) &&
           verifier.VerifyTable(inertia()) &&
           verifier.EndTable();
  }
  InertiaStampedT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InertiaStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<InertiaStamped> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const InertiaStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InertiaStampedBuilder {
  typedef InertiaStamped Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(InertiaStamped::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(InertiaStamped::VT_HEADER, header);
  }
  void add_inertia(::flatbuffers::Offset<fb::geometry_msgs::Inertia> inertia) {
    fbb_.AddOffset(InertiaStamped::VT_INERTIA, inertia);
  }
  explicit InertiaStampedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InertiaStamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InertiaStamped>(end);
    fbb_.Required(o, InertiaStamped::VT_HEADER);
    fbb_.Required(o, InertiaStamped::VT_INERTIA);
    return o;
  }
};

inline ::flatbuffers::Offset<InertiaStamped> CreateInertiaStamped(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Inertia> inertia = 0) {
  InertiaStampedBuilder builder_(_fbb);
  builder_.add_inertia(inertia);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<InertiaStamped> CreateInertiaStamped(::flatbuffers::FlatBufferBuilder &_fbb, const InertiaStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PolygonStampedT : public ::flatbuffers::NativeTable {
  typedef PolygonStamped TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::geometry_msgs::PolygonT> polygon{};
  PolygonStampedT() = default;
  PolygonStampedT(const PolygonStampedT &o);
  PolygonStampedT(PolygonStampedT&&) FLATBUFFERS_NOEXCEPT = default;
  PolygonStampedT &operator=(PolygonStampedT o) FLATBUFFERS_NOEXCEPT;
};

struct PolygonStamped FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PolygonStampedT NativeTableType;
  typedef PolygonStampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_POLYGON = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geometry_msgs::Polygon *polygon() const {
    return GetPointer<const fb::geometry_msgs::Polygon *>(VT_POLYGON);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_POLYGON) &&
           verifier.VerifyTable(polygon()) &&
           verifier.EndTable();
  }
  PolygonStampedT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PolygonStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PolygonStamped> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PolygonStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PolygonStampedBuilder {
  typedef PolygonStamped Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PolygonStamped::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(PolygonStamped::VT_HEADER, header);
  }
  void add_polygon(::flatbuffers::Offset<fb::geometry_msgs::Polygon> polygon) {
    fbb_.AddOffset(PolygonStamped::VT_POLYGON, polygon);
  }
  explicit PolygonStampedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PolygonStamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PolygonStamped>(end);
    fbb_.Required(o, PolygonStamped::VT_HEADER);
    fbb_.Required(o, PolygonStamped::VT_POLYGON);
    return o;
  }
};

inline ::flatbuffers::Offset<PolygonStamped> CreatePolygonStamped(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Polygon> polygon = 0) {
  PolygonStampedBuilder builder_(_fbb);
  builder_.add_polygon(polygon);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<PolygonStamped> CreatePolygonStamped(::flatbuffers::FlatBufferBuilder &_fbb, const PolygonStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QuaternionStampedT : public ::flatbuffers::NativeTable {
  typedef QuaternionStamped TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::geometry_msgs::QuaternionT> quaternion{};
  QuaternionStampedT() = default;
  QuaternionStampedT(const QuaternionStampedT &o);
  QuaternionStampedT(QuaternionStampedT&&) FLATBUFFERS_NOEXCEPT = default;
  QuaternionStampedT &operator=(QuaternionStampedT o) FLATBUFFERS_NOEXCEPT;
};

struct QuaternionStamped FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef QuaternionStampedT NativeTableType;
  typedef QuaternionStampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_QUATERNION = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geometry_msgs::Quaternion *quaternion() const {
    return GetPointer<const fb::geometry_msgs::Quaternion *>(VT_QUATERNION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_QUATERNION) &&
           verifier.VerifyTable(quaternion()) &&
           verifier.EndTable();
  }
  QuaternionStampedT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QuaternionStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<QuaternionStamped> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const QuaternionStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QuaternionStampedBuilder {
  typedef QuaternionStamped Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(QuaternionStamped::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(QuaternionStamped::VT_HEADER, header);
  }
  void add_quaternion(::flatbuffers::Offset<fb::geometry_msgs::Quaternion> quaternion) {
    fbb_.AddOffset(QuaternionStamped::VT_QUATERNION, quaternion);
  }
  explicit QuaternionStampedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<QuaternionStamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<QuaternionStamped>(end);
    fbb_.Required(o, QuaternionStamped::VT_HEADER);
    fbb_.Required(o, QuaternionStamped::VT_QUATERNION);
    return o;
  }
};

inline ::flatbuffers::Offset<QuaternionStamped> CreateQuaternionStamped(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Quaternion> quaternion = 0) {
  QuaternionStampedBuilder builder_(_fbb);
  builder_.add_quaternion(quaternion);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<QuaternionStamped> CreateQuaternionStamped(::flatbuffers::FlatBufferBuilder &_fbb, const QuaternionStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AccelWithCovarianceStampedT : public ::flatbuffers::NativeTable {
  typedef AccelWithCovarianceStamped TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::geometry_msgs::AccelWithCovarianceT> accel{};
  AccelWithCovarianceStampedT() = default;
  AccelWithCovarianceStampedT(const AccelWithCovarianceStampedT &o);
  AccelWithCovarianceStampedT(AccelWithCovarianceStampedT&&) FLATBUFFERS_NOEXCEPT = default;
  AccelWithCovarianceStampedT &operator=(AccelWithCovarianceStampedT o) FLATBUFFERS_NOEXCEPT;
};

struct AccelWithCovarianceStamped FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AccelWithCovarianceStampedT NativeTableType;
  typedef AccelWithCovarianceStampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_ACCEL = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geometry_msgs::AccelWithCovariance *accel() const {
    return GetPointer<const fb::geometry_msgs::AccelWithCovariance *>(VT_ACCEL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_ACCEL) &&
           verifier.VerifyTable(accel()) &&
           verifier.EndTable();
  }
  AccelWithCovarianceStampedT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AccelWithCovarianceStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AccelWithCovarianceStamped> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AccelWithCovarianceStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AccelWithCovarianceStampedBuilder {
  typedef AccelWithCovarianceStamped Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(AccelWithCovarianceStamped::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(AccelWithCovarianceStamped::VT_HEADER, header);
  }
  void add_accel(::flatbuffers::Offset<fb::geometry_msgs::AccelWithCovariance> accel) {
    fbb_.AddOffset(AccelWithCovarianceStamped::VT_ACCEL, accel);
  }
  explicit AccelWithCovarianceStampedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AccelWithCovarianceStamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AccelWithCovarianceStamped>(end);
    fbb_.Required(o, AccelWithCovarianceStamped::VT_HEADER);
    fbb_.Required(o, AccelWithCovarianceStamped::VT_ACCEL);
    return o;
  }
};

inline ::flatbuffers::Offset<AccelWithCovarianceStamped> CreateAccelWithCovarianceStamped(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::AccelWithCovariance> accel = 0) {
  AccelWithCovarianceStampedBuilder builder_(_fbb);
  builder_.add_accel(accel);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<AccelWithCovarianceStamped> CreateAccelWithCovarianceStamped(::flatbuffers::FlatBufferBuilder &_fbb, const AccelWithCovarianceStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Pose2DT : public ::flatbuffers::NativeTable {
  typedef Pose2D TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  double x = 0.0;
  double y = 0.0;
  double theta = 0.0;
  Pose2DT() = default;
  Pose2DT(const Pose2DT &o);
  Pose2DT(Pose2DT&&) FLATBUFFERS_NOEXCEPT = default;
  Pose2DT &operator=(Pose2DT o) FLATBUFFERS_NOEXCEPT;
};

struct Pose2D FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Pose2DT NativeTableType;
  typedef Pose2DBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_THETA = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double theta() const {
    return GetField<double>(VT_THETA, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<double>(verifier, VT_X, 8) &&
           VerifyField<double>(verifier, VT_Y, 8) &&
           VerifyField<double>(verifier, VT_THETA, 8) &&
           verifier.EndTable();
  }
  Pose2DT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Pose2DT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Pose2D> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Pose2DT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Pose2DBuilder {
  typedef Pose2D Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Pose2D::VT___METADATA, __metadata);
  }
  void add_x(double x) {
    fbb_.AddElement<double>(Pose2D::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Pose2D::VT_Y, y, 0.0);
  }
  void add_theta(double theta) {
    fbb_.AddElement<double>(Pose2D::VT_THETA, theta, 0.0);
  }
  explicit Pose2DBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Pose2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Pose2D>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Pose2D> CreatePose2D(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    double x = 0.0,
    double y = 0.0,
    double theta = 0.0) {
  Pose2DBuilder builder_(_fbb);
  builder_.add_theta(theta);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<Pose2D> CreatePose2D(::flatbuffers::FlatBufferBuilder &_fbb, const Pose2DT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Point32T : public ::flatbuffers::NativeTable {
  typedef Point32 TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  float x = 0.0f;
  float y = 0.0f;
  float z = 0.0f;
  Point32T() = default;
  Point32T(const Point32T &o);
  Point32T(Point32T&&) FLATBUFFERS_NOEXCEPT = default;
  Point32T &operator=(Point32T o) FLATBUFFERS_NOEXCEPT;
};

struct Point32 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Point32T NativeTableType;
  typedef Point32Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float z() const {
    return GetField<float>(VT_Z, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           VerifyField<float>(verifier, VT_Z, 4) &&
           verifier.EndTable();
  }
  Point32T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Point32T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Point32> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Point32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Point32Builder {
  typedef Point32 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Point32::VT___METADATA, __metadata);
  }
  void add_x(float x) {
    fbb_.AddElement<float>(Point32::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Point32::VT_Y, y, 0.0f);
  }
  void add_z(float z) {
    fbb_.AddElement<float>(Point32::VT_Z, z, 0.0f);
  }
  explicit Point32Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Point32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Point32>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Point32> CreatePoint32(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f) {
  Point32Builder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<Point32> CreatePoint32(::flatbuffers::FlatBufferBuilder &_fbb, const Point32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AccelStampedT : public ::flatbuffers::NativeTable {
  typedef AccelStamped TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::geometry_msgs::AccelT> accel{};
  AccelStampedT() = default;
  AccelStampedT(const AccelStampedT &o);
  AccelStampedT(AccelStampedT&&) FLATBUFFERS_NOEXCEPT = default;
  AccelStampedT &operator=(AccelStampedT o) FLATBUFFERS_NOEXCEPT;
};

struct AccelStamped FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AccelStampedT NativeTableType;
  typedef AccelStampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_ACCEL = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geometry_msgs::Accel *accel() const {
    return GetPointer<const fb::geometry_msgs::Accel *>(VT_ACCEL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_ACCEL) &&
           verifier.VerifyTable(accel()) &&
           verifier.EndTable();
  }
  AccelStampedT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AccelStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AccelStamped> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AccelStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AccelStampedBuilder {
  typedef AccelStamped Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(AccelStamped::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(AccelStamped::VT_HEADER, header);
  }
  void add_accel(::flatbuffers::Offset<fb::geometry_msgs::Accel> accel) {
    fbb_.AddOffset(AccelStamped::VT_ACCEL, accel);
  }
  explicit AccelStampedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AccelStamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AccelStamped>(end);
    fbb_.Required(o, AccelStamped::VT_HEADER);
    fbb_.Required(o, AccelStamped::VT_ACCEL);
    return o;
  }
};

inline ::flatbuffers::Offset<AccelStamped> CreateAccelStamped(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Accel> accel = 0) {
  AccelStampedBuilder builder_(_fbb);
  builder_.add_accel(accel);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<AccelStamped> CreateAccelStamped(::flatbuffers::FlatBufferBuilder &_fbb, const AccelStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TwistStampedT : public ::flatbuffers::NativeTable {
  typedef TwistStamped TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::unique_ptr<fb::geometry_msgs::TwistT> twist{};
  TwistStampedT() = default;
  TwistStampedT(const TwistStampedT &o);
  TwistStampedT(TwistStampedT&&) FLATBUFFERS_NOEXCEPT = default;
  TwistStampedT &operator=(TwistStampedT o) FLATBUFFERS_NOEXCEPT;
};

struct TwistStamped FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TwistStampedT NativeTableType;
  typedef TwistStampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_TWIST = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geometry_msgs::Twist *twist() const {
    return GetPointer<const fb::geometry_msgs::Twist *>(VT_TWIST);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_TWIST) &&
           verifier.VerifyTable(twist()) &&
           verifier.EndTable();
  }
  TwistStampedT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TwistStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TwistStamped> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TwistStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TwistStampedBuilder {
  typedef TwistStamped Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(TwistStamped::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(TwistStamped::VT_HEADER, header);
  }
  void add_twist(::flatbuffers::Offset<fb::geometry_msgs::Twist> twist) {
    fbb_.AddOffset(TwistStamped::VT_TWIST, twist);
  }
  explicit TwistStampedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TwistStamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TwistStamped>(end);
    fbb_.Required(o, TwistStamped::VT_HEADER);
    fbb_.Required(o, TwistStamped::VT_TWIST);
    return o;
  }
};

inline ::flatbuffers::Offset<TwistStamped> CreateTwistStamped(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Twist> twist = 0) {
  TwistStampedBuilder builder_(_fbb);
  builder_.add_twist(twist);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<TwistStamped> CreateTwistStamped(::flatbuffers::FlatBufferBuilder &_fbb, const TwistStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InertiaT : public ::flatbuffers::NativeTable {
  typedef Inertia TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  double m = 0.0;
  std::unique_ptr<fb::geometry_msgs::Vector3T> com{};
  double ixx = 0.0;
  double ixy = 0.0;
  double ixz = 0.0;
  double iyy = 0.0;
  double iyz = 0.0;
  double izz = 0.0;
  InertiaT() = default;
  InertiaT(const InertiaT &o);
  InertiaT(InertiaT&&) FLATBUFFERS_NOEXCEPT = default;
  InertiaT &operator=(InertiaT o) FLATBUFFERS_NOEXCEPT;
};

struct Inertia FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InertiaT NativeTableType;
  typedef InertiaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_M = 6,
    VT_COM = 8,
    VT_IXX = 10,
    VT_IXY = 12,
    VT_IXZ = 14,
    VT_IYY = 16,
    VT_IYZ = 18,
    VT_IZZ = 20
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  double m() const {
    return GetField<double>(VT_M, 0.0);
  }
  const fb::geometry_msgs::Vector3 *com() const {
    return GetPointer<const fb::geometry_msgs::Vector3 *>(VT_COM);
  }
  double ixx() const {
    return GetField<double>(VT_IXX, 0.0);
  }
  double ixy() const {
    return GetField<double>(VT_IXY, 0.0);
  }
  double ixz() const {
    return GetField<double>(VT_IXZ, 0.0);
  }
  double iyy() const {
    return GetField<double>(VT_IYY, 0.0);
  }
  double iyz() const {
    return GetField<double>(VT_IYZ, 0.0);
  }
  double izz() const {
    return GetField<double>(VT_IZZ, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<double>(verifier, VT_M, 8) &&
           VerifyOffsetRequired(verifier, VT_COM) &&
           verifier.VerifyTable(com()) &&
           VerifyField<double>(verifier, VT_IXX, 8) &&
           VerifyField<double>(verifier, VT_IXY, 8) &&
           VerifyField<double>(verifier, VT_IXZ, 8) &&
           VerifyField<double>(verifier, VT_IYY, 8) &&
           VerifyField<double>(verifier, VT_IYZ, 8) &&
           VerifyField<double>(verifier, VT_IZZ, 8) &&
           verifier.EndTable();
  }
  InertiaT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InertiaT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Inertia> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const InertiaT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InertiaBuilder {
  typedef Inertia Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Inertia::VT___METADATA, __metadata);
  }
  void add_m(double m) {
    fbb_.AddElement<double>(Inertia::VT_M, m, 0.0);
  }
  void add_com(::flatbuffers::Offset<fb::geometry_msgs::Vector3> com) {
    fbb_.AddOffset(Inertia::VT_COM, com);
  }
  void add_ixx(double ixx) {
    fbb_.AddElement<double>(Inertia::VT_IXX, ixx, 0.0);
  }
  void add_ixy(double ixy) {
    fbb_.AddElement<double>(Inertia::VT_IXY, ixy, 0.0);
  }
  void add_ixz(double ixz) {
    fbb_.AddElement<double>(Inertia::VT_IXZ, ixz, 0.0);
  }
  void add_iyy(double iyy) {
    fbb_.AddElement<double>(Inertia::VT_IYY, iyy, 0.0);
  }
  void add_iyz(double iyz) {
    fbb_.AddElement<double>(Inertia::VT_IYZ, iyz, 0.0);
  }
  void add_izz(double izz) {
    fbb_.AddElement<double>(Inertia::VT_IZZ, izz, 0.0);
  }
  explicit InertiaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Inertia> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Inertia>(end);
    fbb_.Required(o, Inertia::VT_COM);
    return o;
  }
};

inline ::flatbuffers::Offset<Inertia> CreateInertia(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    double m = 0.0,
    ::flatbuffers::Offset<fb::geometry_msgs::Vector3> com = 0,
    double ixx = 0.0,
    double ixy = 0.0,
    double ixz = 0.0,
    double iyy = 0.0,
    double iyz = 0.0,
    double izz = 0.0) {
  InertiaBuilder builder_(_fbb);
  builder_.add_izz(izz);
  builder_.add_iyz(iyz);
  builder_.add_iyy(iyy);
  builder_.add_ixz(ixz);
  builder_.add_ixy(ixy);
  builder_.add_ixx(ixx);
  builder_.add_m(m);
  builder_.add_com(com);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<Inertia> CreateInertia(::flatbuffers::FlatBufferBuilder &_fbb, const InertiaT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TwistWithCovarianceT : public ::flatbuffers::NativeTable {
  typedef TwistWithCovariance TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::geometry_msgs::TwistT> twist{};
  std::vector<double> covariance{};
  TwistWithCovarianceT() = default;
  TwistWithCovarianceT(const TwistWithCovarianceT &o);
  TwistWithCovarianceT(TwistWithCovarianceT&&) FLATBUFFERS_NOEXCEPT = default;
  TwistWithCovarianceT &operator=(TwistWithCovarianceT o) FLATBUFFERS_NOEXCEPT;
};

struct TwistWithCovariance FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TwistWithCovarianceT NativeTableType;
  typedef TwistWithCovarianceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_TWIST = 6,
    VT_COVARIANCE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Twist *twist() const {
    return GetPointer<const fb::geometry_msgs::Twist *>(VT_TWIST);
  }
  const ::flatbuffers::Vector<double> *covariance() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_COVARIANCE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_TWIST) &&
           verifier.VerifyTable(twist()) &&
           VerifyOffsetRequired(verifier, VT_COVARIANCE) &&
           verifier.VerifyVector(covariance()) &&
           verifier.EndTable();
  }
  TwistWithCovarianceT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TwistWithCovarianceT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TwistWithCovariance> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TwistWithCovarianceT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TwistWithCovarianceBuilder {
  typedef TwistWithCovariance Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(TwistWithCovariance::VT___METADATA, __metadata);
  }
  void add_twist(::flatbuffers::Offset<fb::geometry_msgs::Twist> twist) {
    fbb_.AddOffset(TwistWithCovariance::VT_TWIST, twist);
  }
  void add_covariance(::flatbuffers::Offset<::flatbuffers::Vector<double>> covariance) {
    fbb_.AddOffset(TwistWithCovariance::VT_COVARIANCE, covariance);
  }
  explicit TwistWithCovarianceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TwistWithCovariance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TwistWithCovariance>(end);
    fbb_.Required(o, TwistWithCovariance::VT_TWIST);
    fbb_.Required(o, TwistWithCovariance::VT_COVARIANCE);
    return o;
  }
};

inline ::flatbuffers::Offset<TwistWithCovariance> CreateTwistWithCovariance(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Twist> twist = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> covariance = 0) {
  TwistWithCovarianceBuilder builder_(_fbb);
  builder_.add_covariance(covariance);
  builder_.add_twist(twist);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TwistWithCovariance> CreateTwistWithCovarianceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Twist> twist = 0,
    const std::vector<double> *covariance = nullptr) {
  auto covariance__ = covariance ? _fbb.CreateVector<double>(*covariance) : 0;
  return fb::geometry_msgs::CreateTwistWithCovariance(
      _fbb,
      __metadata,
      twist,
      covariance__);
}

::flatbuffers::Offset<TwistWithCovariance> CreateTwistWithCovariance(::flatbuffers::FlatBufferBuilder &_fbb, const TwistWithCovarianceT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransformStampedT : public ::flatbuffers::NativeTable {
  typedef TransformStamped TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  std::unique_ptr<fb::std_msgs::HeaderT> header{};
  std::string child_frame_id{};
  std::unique_ptr<fb::geometry_msgs::TransformT> transform{};
  TransformStampedT() = default;
  TransformStampedT(const TransformStampedT &o);
  TransformStampedT(TransformStampedT&&) FLATBUFFERS_NOEXCEPT = default;
  TransformStampedT &operator=(TransformStampedT o) FLATBUFFERS_NOEXCEPT;
};

struct TransformStamped FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TransformStampedT NativeTableType;
  typedef TransformStampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_CHILD_FRAME_ID = 8,
    VT_TRANSFORM = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const ::flatbuffers::String *child_frame_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHILD_FRAME_ID);
  }
  const fb::geometry_msgs::Transform *transform() const {
    return GetPointer<const fb::geometry_msgs::Transform *>(VT_TRANSFORM);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_CHILD_FRAME_ID) &&
           verifier.VerifyString(child_frame_id()) &&
           VerifyOffsetRequired(verifier, VT_TRANSFORM) &&
           verifier.VerifyTable(transform()) &&
           verifier.EndTable();
  }
  TransformStampedT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransformStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TransformStamped> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TransformStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransformStampedBuilder {
  typedef TransformStamped Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(TransformStamped::VT___METADATA, __metadata);
  }
  void add_header(::flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(TransformStamped::VT_HEADER, header);
  }
  void add_child_frame_id(::flatbuffers::Offset<::flatbuffers::String> child_frame_id) {
    fbb_.AddOffset(TransformStamped::VT_CHILD_FRAME_ID, child_frame_id);
  }
  void add_transform(::flatbuffers::Offset<fb::geometry_msgs::Transform> transform) {
    fbb_.AddOffset(TransformStamped::VT_TRANSFORM, transform);
  }
  explicit TransformStampedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TransformStamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TransformStamped>(end);
    fbb_.Required(o, TransformStamped::VT_HEADER);
    fbb_.Required(o, TransformStamped::VT_CHILD_FRAME_ID);
    fbb_.Required(o, TransformStamped::VT_TRANSFORM);
    return o;
  }
};

inline ::flatbuffers::Offset<TransformStamped> CreateTransformStamped(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    ::flatbuffers::Offset<::flatbuffers::String> child_frame_id = 0,
    ::flatbuffers::Offset<fb::geometry_msgs::Transform> transform = 0) {
  TransformStampedBuilder builder_(_fbb);
  builder_.add_transform(transform);
  builder_.add_child_frame_id(child_frame_id);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TransformStamped> CreateTransformStampedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    ::flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const char *child_frame_id = nullptr,
    ::flatbuffers::Offset<fb::geometry_msgs::Transform> transform = 0) {
  auto child_frame_id__ = child_frame_id ? _fbb.CreateString(child_frame_id) : 0;
  return fb::geometry_msgs::CreateTransformStamped(
      _fbb,
      __metadata,
      header,
      child_frame_id__,
      transform);
}

::flatbuffers::Offset<TransformStamped> CreateTransformStamped(::flatbuffers::FlatBufferBuilder &_fbb, const TransformStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PointT : public ::flatbuffers::NativeTable {
  typedef Point TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata{};
  double x = 0.0;
  double y = 0.0;
  double z = 0.0;
  PointT() = default;
  PointT(const PointT &o);
  PointT(PointT&&) FLATBUFFERS_NOEXCEPT = default;
  PointT &operator=(PointT o) FLATBUFFERS_NOEXCEPT;
};

struct Point FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PointT NativeTableType;
  typedef PointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<double>(verifier, VT_X, 8) &&
           VerifyField<double>(verifier, VT_Y, 8) &&
           VerifyField<double>(verifier, VT_Z, 8) &&
           verifier.EndTable();
  }
  PointT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PointT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Point> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PointT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PointBuilder {
  typedef Point Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add___metadata(::flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Point::VT___METADATA, __metadata);
  }
  void add_x(double x) {
    fbb_.AddElement<double>(Point::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Point::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(Point::VT_Z, z, 0.0);
  }
  explicit PointBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Point> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Point>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Point> CreatePoint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0) {
  PointBuilder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

::flatbuffers::Offset<Point> CreatePoint(::flatbuffers::FlatBufferBuilder &_fbb, const PointT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline PolygonT::PolygonT(const PolygonT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr) {
  points.reserve(o.points.size());
  for (const auto &points_ : o.points) { points.emplace_back((points_) ? new fb::geometry_msgs::Point32T(*points_) : nullptr); }
}

inline PolygonT &PolygonT::operator=(PolygonT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(points, o.points);
  return *this;
}

inline PolygonT *Polygon::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PolygonT>(new PolygonT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Polygon::UnPackTo(PolygonT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = points(); if (_e) { _o->points.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->points[_i]) { _e->Get(_i)->UnPackTo(_o->points[_i].get(), _resolver); } else { _o->points[_i] = std::unique_ptr<fb::geometry_msgs::Point32T>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->points.resize(0); } }
}

inline ::flatbuffers::Offset<Polygon> Polygon::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PolygonT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePolygon(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Polygon> CreatePolygon(::flatbuffers::FlatBufferBuilder &_fbb, const PolygonT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PolygonT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _points = _fbb.CreateVector<::flatbuffers::Offset<fb::geometry_msgs::Point32>> (_o->points.size(), [](size_t i, _VectorArgs *__va) { return CreatePoint32(*__va->__fbb, __va->__o->points[i].get(), __va->__rehasher); }, &_va );
  return fb::geometry_msgs::CreatePolygon(
      _fbb,
      ___metadata,
      _points);
}

inline TwistT::TwistT(const TwistT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        linear((o.linear) ? new fb::geometry_msgs::Vector3T(*o.linear) : nullptr),
        angular((o.angular) ? new fb::geometry_msgs::Vector3T(*o.angular) : nullptr) {
}

inline TwistT &TwistT::operator=(TwistT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(linear, o.linear);
  std::swap(angular, o.angular);
  return *this;
}

inline TwistT *Twist::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TwistT>(new TwistT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Twist::UnPackTo(TwistT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = linear(); if (_e) { if(_o->linear) { _e->UnPackTo(_o->linear.get(), _resolver); } else { _o->linear = std::unique_ptr<fb::geometry_msgs::Vector3T>(_e->UnPack(_resolver)); } } else if (_o->linear) { _o->linear.reset(); } }
  { auto _e = angular(); if (_e) { if(_o->angular) { _e->UnPackTo(_o->angular.get(), _resolver); } else { _o->angular = std::unique_ptr<fb::geometry_msgs::Vector3T>(_e->UnPack(_resolver)); } } else if (_o->angular) { _o->angular.reset(); } }
}

inline ::flatbuffers::Offset<Twist> Twist::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TwistT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTwist(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Twist> CreateTwist(::flatbuffers::FlatBufferBuilder &_fbb, const TwistT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TwistT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _linear = _o->linear ? CreateVector3(_fbb, _o->linear.get(), _rehasher) : 0;
  auto _angular = _o->angular ? CreateVector3(_fbb, _o->angular.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreateTwist(
      _fbb,
      ___metadata,
      _linear,
      _angular);
}

inline PoseStampedT::PoseStampedT(const PoseStampedT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        pose((o.pose) ? new fb::geometry_msgs::PoseT(*o.pose) : nullptr) {
}

inline PoseStampedT &PoseStampedT::operator=(PoseStampedT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(pose, o.pose);
  return *this;
}

inline PoseStampedT *PoseStamped::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PoseStampedT>(new PoseStampedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PoseStamped::UnPackTo(PoseStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = pose(); if (_e) { if(_o->pose) { _e->UnPackTo(_o->pose.get(), _resolver); } else { _o->pose = std::unique_ptr<fb::geometry_msgs::PoseT>(_e->UnPack(_resolver)); } } else if (_o->pose) { _o->pose.reset(); } }
}

inline ::flatbuffers::Offset<PoseStamped> PoseStamped::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PoseStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePoseStamped(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PoseStamped> CreatePoseStamped(::flatbuffers::FlatBufferBuilder &_fbb, const PoseStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PoseStampedT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _pose = _o->pose ? CreatePose(_fbb, _o->pose.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreatePoseStamped(
      _fbb,
      ___metadata,
      _header,
      _pose);
}

inline Vector3StampedT::Vector3StampedT(const Vector3StampedT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        vector((o.vector) ? new fb::geometry_msgs::Vector3T(*o.vector) : nullptr) {
}

inline Vector3StampedT &Vector3StampedT::operator=(Vector3StampedT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(vector, o.vector);
  return *this;
}

inline Vector3StampedT *Vector3Stamped::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Vector3StampedT>(new Vector3StampedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Vector3Stamped::UnPackTo(Vector3StampedT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = vector(); if (_e) { if(_o->vector) { _e->UnPackTo(_o->vector.get(), _resolver); } else { _o->vector = std::unique_ptr<fb::geometry_msgs::Vector3T>(_e->UnPack(_resolver)); } } else if (_o->vector) { _o->vector.reset(); } }
}

inline ::flatbuffers::Offset<Vector3Stamped> Vector3Stamped::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Vector3StampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVector3Stamped(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Vector3Stamped> CreateVector3Stamped(::flatbuffers::FlatBufferBuilder &_fbb, const Vector3StampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Vector3StampedT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _vector = _o->vector ? CreateVector3(_fbb, _o->vector.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreateVector3Stamped(
      _fbb,
      ___metadata,
      _header,
      _vector);
}

inline TwistWithCovarianceStampedT::TwistWithCovarianceStampedT(const TwistWithCovarianceStampedT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        twist((o.twist) ? new fb::geometry_msgs::TwistWithCovarianceT(*o.twist) : nullptr) {
}

inline TwistWithCovarianceStampedT &TwistWithCovarianceStampedT::operator=(TwistWithCovarianceStampedT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(twist, o.twist);
  return *this;
}

inline TwistWithCovarianceStampedT *TwistWithCovarianceStamped::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TwistWithCovarianceStampedT>(new TwistWithCovarianceStampedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TwistWithCovarianceStamped::UnPackTo(TwistWithCovarianceStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = twist(); if (_e) { if(_o->twist) { _e->UnPackTo(_o->twist.get(), _resolver); } else { _o->twist = std::unique_ptr<fb::geometry_msgs::TwistWithCovarianceT>(_e->UnPack(_resolver)); } } else if (_o->twist) { _o->twist.reset(); } }
}

inline ::flatbuffers::Offset<TwistWithCovarianceStamped> TwistWithCovarianceStamped::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TwistWithCovarianceStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTwistWithCovarianceStamped(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TwistWithCovarianceStamped> CreateTwistWithCovarianceStamped(::flatbuffers::FlatBufferBuilder &_fbb, const TwistWithCovarianceStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TwistWithCovarianceStampedT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _twist = _o->twist ? CreateTwistWithCovariance(_fbb, _o->twist.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreateTwistWithCovarianceStamped(
      _fbb,
      ___metadata,
      _header,
      _twist);
}

inline Vector3T::Vector3T(const Vector3T &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        x(o.x),
        y(o.y),
        z(o.z) {
}

inline Vector3T &Vector3T::operator=(Vector3T o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(x, o.x);
  std::swap(y, o.y);
  std::swap(z, o.z);
  return *this;
}

inline Vector3T *Vector3::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Vector3T>(new Vector3T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Vector3::UnPackTo(Vector3T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
}

inline ::flatbuffers::Offset<Vector3> Vector3::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Vector3T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVector3(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Vector3> CreateVector3(::flatbuffers::FlatBufferBuilder &_fbb, const Vector3T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Vector3T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  return fb::geometry_msgs::CreateVector3(
      _fbb,
      ___metadata,
      _x,
      _y,
      _z);
}

inline QuaternionT::QuaternionT(const QuaternionT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        x(o.x),
        y(o.y),
        z(o.z),
        w(o.w) {
}

inline QuaternionT &QuaternionT::operator=(QuaternionT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(x, o.x);
  std::swap(y, o.y);
  std::swap(z, o.z);
  std::swap(w, o.w);
  return *this;
}

inline QuaternionT *Quaternion::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<QuaternionT>(new QuaternionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Quaternion::UnPackTo(QuaternionT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
  { auto _e = w(); _o->w = _e; }
}

inline ::flatbuffers::Offset<Quaternion> Quaternion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const QuaternionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQuaternion(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Quaternion> CreateQuaternion(::flatbuffers::FlatBufferBuilder &_fbb, const QuaternionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const QuaternionT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  auto _w = _o->w;
  return fb::geometry_msgs::CreateQuaternion(
      _fbb,
      ___metadata,
      _x,
      _y,
      _z,
      _w);
}

inline PoseWithCovarianceT::PoseWithCovarianceT(const PoseWithCovarianceT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        pose((o.pose) ? new fb::geometry_msgs::PoseT(*o.pose) : nullptr),
        covariance(o.covariance) {
}

inline PoseWithCovarianceT &PoseWithCovarianceT::operator=(PoseWithCovarianceT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(pose, o.pose);
  std::swap(covariance, o.covariance);
  return *this;
}

inline PoseWithCovarianceT *PoseWithCovariance::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PoseWithCovarianceT>(new PoseWithCovarianceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PoseWithCovariance::UnPackTo(PoseWithCovarianceT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = pose(); if (_e) { if(_o->pose) { _e->UnPackTo(_o->pose.get(), _resolver); } else { _o->pose = std::unique_ptr<fb::geometry_msgs::PoseT>(_e->UnPack(_resolver)); } } else if (_o->pose) { _o->pose.reset(); } }
  { auto _e = covariance(); if (_e) { _o->covariance.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->covariance[_i] = _e->Get(_i); } } else { _o->covariance.resize(0); } }
}

inline ::flatbuffers::Offset<PoseWithCovariance> PoseWithCovariance::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PoseWithCovarianceT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePoseWithCovariance(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PoseWithCovariance> CreatePoseWithCovariance(::flatbuffers::FlatBufferBuilder &_fbb, const PoseWithCovarianceT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PoseWithCovarianceT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _pose = _o->pose ? CreatePose(_fbb, _o->pose.get(), _rehasher) : 0;
  auto _covariance = _fbb.CreateVector(_o->covariance);
  return fb::geometry_msgs::CreatePoseWithCovariance(
      _fbb,
      ___metadata,
      _pose,
      _covariance);
}

inline TransformT::TransformT(const TransformT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        translation((o.translation) ? new fb::geometry_msgs::Vector3T(*o.translation) : nullptr),
        rotation((o.rotation) ? new fb::geometry_msgs::QuaternionT(*o.rotation) : nullptr) {
}

inline TransformT &TransformT::operator=(TransformT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(translation, o.translation);
  std::swap(rotation, o.rotation);
  return *this;
}

inline TransformT *Transform::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TransformT>(new TransformT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Transform::UnPackTo(TransformT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = translation(); if (_e) { if(_o->translation) { _e->UnPackTo(_o->translation.get(), _resolver); } else { _o->translation = std::unique_ptr<fb::geometry_msgs::Vector3T>(_e->UnPack(_resolver)); } } else if (_o->translation) { _o->translation.reset(); } }
  { auto _e = rotation(); if (_e) { if(_o->rotation) { _e->UnPackTo(_o->rotation.get(), _resolver); } else { _o->rotation = std::unique_ptr<fb::geometry_msgs::QuaternionT>(_e->UnPack(_resolver)); } } else if (_o->rotation) { _o->rotation.reset(); } }
}

inline ::flatbuffers::Offset<Transform> Transform::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TransformT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTransform(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Transform> CreateTransform(::flatbuffers::FlatBufferBuilder &_fbb, const TransformT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TransformT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _translation = _o->translation ? CreateVector3(_fbb, _o->translation.get(), _rehasher) : 0;
  auto _rotation = _o->rotation ? CreateQuaternion(_fbb, _o->rotation.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreateTransform(
      _fbb,
      ___metadata,
      _translation,
      _rotation);
}

inline WrenchStampedT::WrenchStampedT(const WrenchStampedT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        wrench((o.wrench) ? new fb::geometry_msgs::WrenchT(*o.wrench) : nullptr) {
}

inline WrenchStampedT &WrenchStampedT::operator=(WrenchStampedT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(wrench, o.wrench);
  return *this;
}

inline WrenchStampedT *WrenchStamped::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<WrenchStampedT>(new WrenchStampedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void WrenchStamped::UnPackTo(WrenchStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = wrench(); if (_e) { if(_o->wrench) { _e->UnPackTo(_o->wrench.get(), _resolver); } else { _o->wrench = std::unique_ptr<fb::geometry_msgs::WrenchT>(_e->UnPack(_resolver)); } } else if (_o->wrench) { _o->wrench.reset(); } }
}

inline ::flatbuffers::Offset<WrenchStamped> WrenchStamped::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WrenchStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWrenchStamped(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<WrenchStamped> CreateWrenchStamped(::flatbuffers::FlatBufferBuilder &_fbb, const WrenchStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const WrenchStampedT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _wrench = _o->wrench ? CreateWrench(_fbb, _o->wrench.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreateWrenchStamped(
      _fbb,
      ___metadata,
      _header,
      _wrench);
}

inline WrenchT::WrenchT(const WrenchT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        force((o.force) ? new fb::geometry_msgs::Vector3T(*o.force) : nullptr),
        torque((o.torque) ? new fb::geometry_msgs::Vector3T(*o.torque) : nullptr) {
}

inline WrenchT &WrenchT::operator=(WrenchT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(force, o.force);
  std::swap(torque, o.torque);
  return *this;
}

inline WrenchT *Wrench::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<WrenchT>(new WrenchT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Wrench::UnPackTo(WrenchT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = force(); if (_e) { if(_o->force) { _e->UnPackTo(_o->force.get(), _resolver); } else { _o->force = std::unique_ptr<fb::geometry_msgs::Vector3T>(_e->UnPack(_resolver)); } } else if (_o->force) { _o->force.reset(); } }
  { auto _e = torque(); if (_e) { if(_o->torque) { _e->UnPackTo(_o->torque.get(), _resolver); } else { _o->torque = std::unique_ptr<fb::geometry_msgs::Vector3T>(_e->UnPack(_resolver)); } } else if (_o->torque) { _o->torque.reset(); } }
}

inline ::flatbuffers::Offset<Wrench> Wrench::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WrenchT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWrench(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Wrench> CreateWrench(::flatbuffers::FlatBufferBuilder &_fbb, const WrenchT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const WrenchT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _force = _o->force ? CreateVector3(_fbb, _o->force.get(), _rehasher) : 0;
  auto _torque = _o->torque ? CreateVector3(_fbb, _o->torque.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreateWrench(
      _fbb,
      ___metadata,
      _force,
      _torque);
}

inline AccelWithCovarianceT::AccelWithCovarianceT(const AccelWithCovarianceT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        accel((o.accel) ? new fb::geometry_msgs::AccelT(*o.accel) : nullptr),
        covariance(o.covariance) {
}

inline AccelWithCovarianceT &AccelWithCovarianceT::operator=(AccelWithCovarianceT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(accel, o.accel);
  std::swap(covariance, o.covariance);
  return *this;
}

inline AccelWithCovarianceT *AccelWithCovariance::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AccelWithCovarianceT>(new AccelWithCovarianceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AccelWithCovariance::UnPackTo(AccelWithCovarianceT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = accel(); if (_e) { if(_o->accel) { _e->UnPackTo(_o->accel.get(), _resolver); } else { _o->accel = std::unique_ptr<fb::geometry_msgs::AccelT>(_e->UnPack(_resolver)); } } else if (_o->accel) { _o->accel.reset(); } }
  { auto _e = covariance(); if (_e) { _o->covariance.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->covariance[_i] = _e->Get(_i); } } else { _o->covariance.resize(0); } }
}

inline ::flatbuffers::Offset<AccelWithCovariance> AccelWithCovariance::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AccelWithCovarianceT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAccelWithCovariance(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AccelWithCovariance> CreateAccelWithCovariance(::flatbuffers::FlatBufferBuilder &_fbb, const AccelWithCovarianceT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AccelWithCovarianceT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _accel = _o->accel ? CreateAccel(_fbb, _o->accel.get(), _rehasher) : 0;
  auto _covariance = _fbb.CreateVector(_o->covariance);
  return fb::geometry_msgs::CreateAccelWithCovariance(
      _fbb,
      ___metadata,
      _accel,
      _covariance);
}

inline PoseT::PoseT(const PoseT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        position((o.position) ? new fb::geometry_msgs::PointT(*o.position) : nullptr),
        orientation((o.orientation) ? new fb::geometry_msgs::QuaternionT(*o.orientation) : nullptr) {
}

inline PoseT &PoseT::operator=(PoseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(position, o.position);
  std::swap(orientation, o.orientation);
  return *this;
}

inline PoseT *Pose::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PoseT>(new PoseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pose::UnPackTo(PoseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = position(); if (_e) { if(_o->position) { _e->UnPackTo(_o->position.get(), _resolver); } else { _o->position = std::unique_ptr<fb::geometry_msgs::PointT>(_e->UnPack(_resolver)); } } else if (_o->position) { _o->position.reset(); } }
  { auto _e = orientation(); if (_e) { if(_o->orientation) { _e->UnPackTo(_o->orientation.get(), _resolver); } else { _o->orientation = std::unique_ptr<fb::geometry_msgs::QuaternionT>(_e->UnPack(_resolver)); } } else if (_o->orientation) { _o->orientation.reset(); } }
}

inline ::flatbuffers::Offset<Pose> Pose::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PoseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePose(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Pose> CreatePose(::flatbuffers::FlatBufferBuilder &_fbb, const PoseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PoseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _position = _o->position ? CreatePoint(_fbb, _o->position.get(), _rehasher) : 0;
  auto _orientation = _o->orientation ? CreateQuaternion(_fbb, _o->orientation.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreatePose(
      _fbb,
      ___metadata,
      _position,
      _orientation);
}

inline PointStampedT::PointStampedT(const PointStampedT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        point((o.point) ? new fb::geometry_msgs::PointT(*o.point) : nullptr) {
}

inline PointStampedT &PointStampedT::operator=(PointStampedT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(point, o.point);
  return *this;
}

inline PointStampedT *PointStamped::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PointStampedT>(new PointStampedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PointStamped::UnPackTo(PointStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = point(); if (_e) { if(_o->point) { _e->UnPackTo(_o->point.get(), _resolver); } else { _o->point = std::unique_ptr<fb::geometry_msgs::PointT>(_e->UnPack(_resolver)); } } else if (_o->point) { _o->point.reset(); } }
}

inline ::flatbuffers::Offset<PointStamped> PointStamped::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PointStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePointStamped(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PointStamped> CreatePointStamped(::flatbuffers::FlatBufferBuilder &_fbb, const PointStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PointStampedT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _point = _o->point ? CreatePoint(_fbb, _o->point.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreatePointStamped(
      _fbb,
      ___metadata,
      _header,
      _point);
}

inline PoseWithCovarianceStampedT::PoseWithCovarianceStampedT(const PoseWithCovarianceStampedT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        pose((o.pose) ? new fb::geometry_msgs::PoseWithCovarianceT(*o.pose) : nullptr) {
}

inline PoseWithCovarianceStampedT &PoseWithCovarianceStampedT::operator=(PoseWithCovarianceStampedT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(pose, o.pose);
  return *this;
}

inline PoseWithCovarianceStampedT *PoseWithCovarianceStamped::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PoseWithCovarianceStampedT>(new PoseWithCovarianceStampedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PoseWithCovarianceStamped::UnPackTo(PoseWithCovarianceStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = pose(); if (_e) { if(_o->pose) { _e->UnPackTo(_o->pose.get(), _resolver); } else { _o->pose = std::unique_ptr<fb::geometry_msgs::PoseWithCovarianceT>(_e->UnPack(_resolver)); } } else if (_o->pose) { _o->pose.reset(); } }
}

inline ::flatbuffers::Offset<PoseWithCovarianceStamped> PoseWithCovarianceStamped::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PoseWithCovarianceStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePoseWithCovarianceStamped(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PoseWithCovarianceStamped> CreatePoseWithCovarianceStamped(::flatbuffers::FlatBufferBuilder &_fbb, const PoseWithCovarianceStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PoseWithCovarianceStampedT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _pose = _o->pose ? CreatePoseWithCovariance(_fbb, _o->pose.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreatePoseWithCovarianceStamped(
      _fbb,
      ___metadata,
      _header,
      _pose);
}

inline AccelT::AccelT(const AccelT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        linear((o.linear) ? new fb::geometry_msgs::Vector3T(*o.linear) : nullptr),
        angular((o.angular) ? new fb::geometry_msgs::Vector3T(*o.angular) : nullptr) {
}

inline AccelT &AccelT::operator=(AccelT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(linear, o.linear);
  std::swap(angular, o.angular);
  return *this;
}

inline AccelT *Accel::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AccelT>(new AccelT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Accel::UnPackTo(AccelT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = linear(); if (_e) { if(_o->linear) { _e->UnPackTo(_o->linear.get(), _resolver); } else { _o->linear = std::unique_ptr<fb::geometry_msgs::Vector3T>(_e->UnPack(_resolver)); } } else if (_o->linear) { _o->linear.reset(); } }
  { auto _e = angular(); if (_e) { if(_o->angular) { _e->UnPackTo(_o->angular.get(), _resolver); } else { _o->angular = std::unique_ptr<fb::geometry_msgs::Vector3T>(_e->UnPack(_resolver)); } } else if (_o->angular) { _o->angular.reset(); } }
}

inline ::flatbuffers::Offset<Accel> Accel::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AccelT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAccel(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Accel> CreateAccel(::flatbuffers::FlatBufferBuilder &_fbb, const AccelT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AccelT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _linear = _o->linear ? CreateVector3(_fbb, _o->linear.get(), _rehasher) : 0;
  auto _angular = _o->angular ? CreateVector3(_fbb, _o->angular.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreateAccel(
      _fbb,
      ___metadata,
      _linear,
      _angular);
}

inline PoseArrayT::PoseArrayT(const PoseArrayT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr) {
  poses.reserve(o.poses.size());
  for (const auto &poses_ : o.poses) { poses.emplace_back((poses_) ? new fb::geometry_msgs::PoseT(*poses_) : nullptr); }
}

inline PoseArrayT &PoseArrayT::operator=(PoseArrayT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(poses, o.poses);
  return *this;
}

inline PoseArrayT *PoseArray::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PoseArrayT>(new PoseArrayT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PoseArray::UnPackTo(PoseArrayT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = poses(); if (_e) { _o->poses.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->poses[_i]) { _e->Get(_i)->UnPackTo(_o->poses[_i].get(), _resolver); } else { _o->poses[_i] = std::unique_ptr<fb::geometry_msgs::PoseT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->poses.resize(0); } }
}

inline ::flatbuffers::Offset<PoseArray> PoseArray::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PoseArrayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePoseArray(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PoseArray> CreatePoseArray(::flatbuffers::FlatBufferBuilder &_fbb, const PoseArrayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PoseArrayT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _poses = _fbb.CreateVector<::flatbuffers::Offset<fb::geometry_msgs::Pose>> (_o->poses.size(), [](size_t i, _VectorArgs *__va) { return CreatePose(*__va->__fbb, __va->__o->poses[i].get(), __va->__rehasher); }, &_va );
  return fb::geometry_msgs::CreatePoseArray(
      _fbb,
      ___metadata,
      _header,
      _poses);
}

inline InertiaStampedT::InertiaStampedT(const InertiaStampedT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        inertia((o.inertia) ? new fb::geometry_msgs::InertiaT(*o.inertia) : nullptr) {
}

inline InertiaStampedT &InertiaStampedT::operator=(InertiaStampedT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(inertia, o.inertia);
  return *this;
}

inline InertiaStampedT *InertiaStamped::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InertiaStampedT>(new InertiaStampedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InertiaStamped::UnPackTo(InertiaStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = inertia(); if (_e) { if(_o->inertia) { _e->UnPackTo(_o->inertia.get(), _resolver); } else { _o->inertia = std::unique_ptr<fb::geometry_msgs::InertiaT>(_e->UnPack(_resolver)); } } else if (_o->inertia) { _o->inertia.reset(); } }
}

inline ::flatbuffers::Offset<InertiaStamped> InertiaStamped::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const InertiaStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInertiaStamped(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<InertiaStamped> CreateInertiaStamped(::flatbuffers::FlatBufferBuilder &_fbb, const InertiaStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const InertiaStampedT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _inertia = _o->inertia ? CreateInertia(_fbb, _o->inertia.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreateInertiaStamped(
      _fbb,
      ___metadata,
      _header,
      _inertia);
}

inline PolygonStampedT::PolygonStampedT(const PolygonStampedT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        polygon((o.polygon) ? new fb::geometry_msgs::PolygonT(*o.polygon) : nullptr) {
}

inline PolygonStampedT &PolygonStampedT::operator=(PolygonStampedT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(polygon, o.polygon);
  return *this;
}

inline PolygonStampedT *PolygonStamped::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PolygonStampedT>(new PolygonStampedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PolygonStamped::UnPackTo(PolygonStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = polygon(); if (_e) { if(_o->polygon) { _e->UnPackTo(_o->polygon.get(), _resolver); } else { _o->polygon = std::unique_ptr<fb::geometry_msgs::PolygonT>(_e->UnPack(_resolver)); } } else if (_o->polygon) { _o->polygon.reset(); } }
}

inline ::flatbuffers::Offset<PolygonStamped> PolygonStamped::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PolygonStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePolygonStamped(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PolygonStamped> CreatePolygonStamped(::flatbuffers::FlatBufferBuilder &_fbb, const PolygonStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PolygonStampedT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _polygon = _o->polygon ? CreatePolygon(_fbb, _o->polygon.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreatePolygonStamped(
      _fbb,
      ___metadata,
      _header,
      _polygon);
}

inline QuaternionStampedT::QuaternionStampedT(const QuaternionStampedT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        quaternion((o.quaternion) ? new fb::geometry_msgs::QuaternionT(*o.quaternion) : nullptr) {
}

inline QuaternionStampedT &QuaternionStampedT::operator=(QuaternionStampedT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(quaternion, o.quaternion);
  return *this;
}

inline QuaternionStampedT *QuaternionStamped::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<QuaternionStampedT>(new QuaternionStampedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void QuaternionStamped::UnPackTo(QuaternionStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = quaternion(); if (_e) { if(_o->quaternion) { _e->UnPackTo(_o->quaternion.get(), _resolver); } else { _o->quaternion = std::unique_ptr<fb::geometry_msgs::QuaternionT>(_e->UnPack(_resolver)); } } else if (_o->quaternion) { _o->quaternion.reset(); } }
}

inline ::flatbuffers::Offset<QuaternionStamped> QuaternionStamped::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const QuaternionStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQuaternionStamped(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<QuaternionStamped> CreateQuaternionStamped(::flatbuffers::FlatBufferBuilder &_fbb, const QuaternionStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const QuaternionStampedT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _quaternion = _o->quaternion ? CreateQuaternion(_fbb, _o->quaternion.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreateQuaternionStamped(
      _fbb,
      ___metadata,
      _header,
      _quaternion);
}

inline AccelWithCovarianceStampedT::AccelWithCovarianceStampedT(const AccelWithCovarianceStampedT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        accel((o.accel) ? new fb::geometry_msgs::AccelWithCovarianceT(*o.accel) : nullptr) {
}

inline AccelWithCovarianceStampedT &AccelWithCovarianceStampedT::operator=(AccelWithCovarianceStampedT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(accel, o.accel);
  return *this;
}

inline AccelWithCovarianceStampedT *AccelWithCovarianceStamped::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AccelWithCovarianceStampedT>(new AccelWithCovarianceStampedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AccelWithCovarianceStamped::UnPackTo(AccelWithCovarianceStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = accel(); if (_e) { if(_o->accel) { _e->UnPackTo(_o->accel.get(), _resolver); } else { _o->accel = std::unique_ptr<fb::geometry_msgs::AccelWithCovarianceT>(_e->UnPack(_resolver)); } } else if (_o->accel) { _o->accel.reset(); } }
}

inline ::flatbuffers::Offset<AccelWithCovarianceStamped> AccelWithCovarianceStamped::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AccelWithCovarianceStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAccelWithCovarianceStamped(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AccelWithCovarianceStamped> CreateAccelWithCovarianceStamped(::flatbuffers::FlatBufferBuilder &_fbb, const AccelWithCovarianceStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AccelWithCovarianceStampedT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _accel = _o->accel ? CreateAccelWithCovariance(_fbb, _o->accel.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreateAccelWithCovarianceStamped(
      _fbb,
      ___metadata,
      _header,
      _accel);
}

inline Pose2DT::Pose2DT(const Pose2DT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        x(o.x),
        y(o.y),
        theta(o.theta) {
}

inline Pose2DT &Pose2DT::operator=(Pose2DT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(x, o.x);
  std::swap(y, o.y);
  std::swap(theta, o.theta);
  return *this;
}

inline Pose2DT *Pose2D::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Pose2DT>(new Pose2DT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pose2D::UnPackTo(Pose2DT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = theta(); _o->theta = _e; }
}

inline ::flatbuffers::Offset<Pose2D> Pose2D::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Pose2DT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePose2D(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Pose2D> CreatePose2D(::flatbuffers::FlatBufferBuilder &_fbb, const Pose2DT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Pose2DT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _theta = _o->theta;
  return fb::geometry_msgs::CreatePose2D(
      _fbb,
      ___metadata,
      _x,
      _y,
      _theta);
}

inline Point32T::Point32T(const Point32T &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        x(o.x),
        y(o.y),
        z(o.z) {
}

inline Point32T &Point32T::operator=(Point32T o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(x, o.x);
  std::swap(y, o.y);
  std::swap(z, o.z);
  return *this;
}

inline Point32T *Point32::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Point32T>(new Point32T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Point32::UnPackTo(Point32T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
}

inline ::flatbuffers::Offset<Point32> Point32::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const Point32T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePoint32(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Point32> CreatePoint32(::flatbuffers::FlatBufferBuilder &_fbb, const Point32T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const Point32T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  return fb::geometry_msgs::CreatePoint32(
      _fbb,
      ___metadata,
      _x,
      _y,
      _z);
}

inline AccelStampedT::AccelStampedT(const AccelStampedT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        accel((o.accel) ? new fb::geometry_msgs::AccelT(*o.accel) : nullptr) {
}

inline AccelStampedT &AccelStampedT::operator=(AccelStampedT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(accel, o.accel);
  return *this;
}

inline AccelStampedT *AccelStamped::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AccelStampedT>(new AccelStampedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AccelStamped::UnPackTo(AccelStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = accel(); if (_e) { if(_o->accel) { _e->UnPackTo(_o->accel.get(), _resolver); } else { _o->accel = std::unique_ptr<fb::geometry_msgs::AccelT>(_e->UnPack(_resolver)); } } else if (_o->accel) { _o->accel.reset(); } }
}

inline ::flatbuffers::Offset<AccelStamped> AccelStamped::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AccelStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAccelStamped(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AccelStamped> CreateAccelStamped(::flatbuffers::FlatBufferBuilder &_fbb, const AccelStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AccelStampedT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _accel = _o->accel ? CreateAccel(_fbb, _o->accel.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreateAccelStamped(
      _fbb,
      ___metadata,
      _header,
      _accel);
}

inline TwistStampedT::TwistStampedT(const TwistStampedT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        twist((o.twist) ? new fb::geometry_msgs::TwistT(*o.twist) : nullptr) {
}

inline TwistStampedT &TwistStampedT::operator=(TwistStampedT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(twist, o.twist);
  return *this;
}

inline TwistStampedT *TwistStamped::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TwistStampedT>(new TwistStampedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TwistStamped::UnPackTo(TwistStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = twist(); if (_e) { if(_o->twist) { _e->UnPackTo(_o->twist.get(), _resolver); } else { _o->twist = std::unique_ptr<fb::geometry_msgs::TwistT>(_e->UnPack(_resolver)); } } else if (_o->twist) { _o->twist.reset(); } }
}

inline ::flatbuffers::Offset<TwistStamped> TwistStamped::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TwistStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTwistStamped(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TwistStamped> CreateTwistStamped(::flatbuffers::FlatBufferBuilder &_fbb, const TwistStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TwistStampedT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _twist = _o->twist ? CreateTwist(_fbb, _o->twist.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreateTwistStamped(
      _fbb,
      ___metadata,
      _header,
      _twist);
}

inline InertiaT::InertiaT(const InertiaT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        m(o.m),
        com((o.com) ? new fb::geometry_msgs::Vector3T(*o.com) : nullptr),
        ixx(o.ixx),
        ixy(o.ixy),
        ixz(o.ixz),
        iyy(o.iyy),
        iyz(o.iyz),
        izz(o.izz) {
}

inline InertiaT &InertiaT::operator=(InertiaT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(m, o.m);
  std::swap(com, o.com);
  std::swap(ixx, o.ixx);
  std::swap(ixy, o.ixy);
  std::swap(ixz, o.ixz);
  std::swap(iyy, o.iyy);
  std::swap(iyz, o.iyz);
  std::swap(izz, o.izz);
  return *this;
}

inline InertiaT *Inertia::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InertiaT>(new InertiaT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Inertia::UnPackTo(InertiaT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = m(); _o->m = _e; }
  { auto _e = com(); if (_e) { if(_o->com) { _e->UnPackTo(_o->com.get(), _resolver); } else { _o->com = std::unique_ptr<fb::geometry_msgs::Vector3T>(_e->UnPack(_resolver)); } } else if (_o->com) { _o->com.reset(); } }
  { auto _e = ixx(); _o->ixx = _e; }
  { auto _e = ixy(); _o->ixy = _e; }
  { auto _e = ixz(); _o->ixz = _e; }
  { auto _e = iyy(); _o->iyy = _e; }
  { auto _e = iyz(); _o->iyz = _e; }
  { auto _e = izz(); _o->izz = _e; }
}

inline ::flatbuffers::Offset<Inertia> Inertia::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const InertiaT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInertia(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Inertia> CreateInertia(::flatbuffers::FlatBufferBuilder &_fbb, const InertiaT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const InertiaT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _m = _o->m;
  auto _com = _o->com ? CreateVector3(_fbb, _o->com.get(), _rehasher) : 0;
  auto _ixx = _o->ixx;
  auto _ixy = _o->ixy;
  auto _ixz = _o->ixz;
  auto _iyy = _o->iyy;
  auto _iyz = _o->iyz;
  auto _izz = _o->izz;
  return fb::geometry_msgs::CreateInertia(
      _fbb,
      ___metadata,
      _m,
      _com,
      _ixx,
      _ixy,
      _ixz,
      _iyy,
      _iyz,
      _izz);
}

inline TwistWithCovarianceT::TwistWithCovarianceT(const TwistWithCovarianceT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        twist((o.twist) ? new fb::geometry_msgs::TwistT(*o.twist) : nullptr),
        covariance(o.covariance) {
}

inline TwistWithCovarianceT &TwistWithCovarianceT::operator=(TwistWithCovarianceT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(twist, o.twist);
  std::swap(covariance, o.covariance);
  return *this;
}

inline TwistWithCovarianceT *TwistWithCovariance::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TwistWithCovarianceT>(new TwistWithCovarianceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TwistWithCovariance::UnPackTo(TwistWithCovarianceT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = twist(); if (_e) { if(_o->twist) { _e->UnPackTo(_o->twist.get(), _resolver); } else { _o->twist = std::unique_ptr<fb::geometry_msgs::TwistT>(_e->UnPack(_resolver)); } } else if (_o->twist) { _o->twist.reset(); } }
  { auto _e = covariance(); if (_e) { _o->covariance.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->covariance[_i] = _e->Get(_i); } } else { _o->covariance.resize(0); } }
}

inline ::flatbuffers::Offset<TwistWithCovariance> TwistWithCovariance::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TwistWithCovarianceT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTwistWithCovariance(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TwistWithCovariance> CreateTwistWithCovariance(::flatbuffers::FlatBufferBuilder &_fbb, const TwistWithCovarianceT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TwistWithCovarianceT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _twist = _o->twist ? CreateTwist(_fbb, _o->twist.get(), _rehasher) : 0;
  auto _covariance = _fbb.CreateVector(_o->covariance);
  return fb::geometry_msgs::CreateTwistWithCovariance(
      _fbb,
      ___metadata,
      _twist,
      _covariance);
}

inline TransformStampedT::TransformStampedT(const TransformStampedT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        header((o.header) ? new fb::std_msgs::HeaderT(*o.header) : nullptr),
        child_frame_id(o.child_frame_id),
        transform((o.transform) ? new fb::geometry_msgs::TransformT(*o.transform) : nullptr) {
}

inline TransformStampedT &TransformStampedT::operator=(TransformStampedT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(header, o.header);
  std::swap(child_frame_id, o.child_frame_id);
  std::swap(transform, o.transform);
  return *this;
}

inline TransformStampedT *TransformStamped::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TransformStampedT>(new TransformStampedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TransformStamped::UnPackTo(TransformStampedT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = header(); if (_e) { if(_o->header) { _e->UnPackTo(_o->header.get(), _resolver); } else { _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); } } else if (_o->header) { _o->header.reset(); } }
  { auto _e = child_frame_id(); if (_e) _o->child_frame_id = _e->str(); }
  { auto _e = transform(); if (_e) { if(_o->transform) { _e->UnPackTo(_o->transform.get(), _resolver); } else { _o->transform = std::unique_ptr<fb::geometry_msgs::TransformT>(_e->UnPack(_resolver)); } } else if (_o->transform) { _o->transform.reset(); } }
}

inline ::flatbuffers::Offset<TransformStamped> TransformStamped::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TransformStampedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTransformStamped(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TransformStamped> CreateTransformStamped(::flatbuffers::FlatBufferBuilder &_fbb, const TransformStampedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TransformStampedT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _child_frame_id = _fbb.CreateString(_o->child_frame_id);
  auto _transform = _o->transform ? CreateTransform(_fbb, _o->transform.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreateTransformStamped(
      _fbb,
      ___metadata,
      _header,
      _child_frame_id,
      _transform);
}

inline PointT::PointT(const PointT &o)
      : __metadata((o.__metadata) ? new fb::MsgMetadataT(*o.__metadata) : nullptr),
        x(o.x),
        y(o.y),
        z(o.z) {
}

inline PointT &PointT::operator=(PointT o) FLATBUFFERS_NOEXCEPT {
  std::swap(__metadata, o.__metadata);
  std::swap(x, o.x);
  std::swap(y, o.y);
  std::swap(z, o.z);
  return *this;
}

inline PointT *Point::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PointT>(new PointT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Point::UnPackTo(PointT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) { if(_o->__metadata) { _e->UnPackTo(_o->__metadata.get(), _resolver); } else { _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); } } else if (_o->__metadata) { _o->__metadata.reset(); } }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
}

inline ::flatbuffers::Offset<Point> Point::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PointT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePoint(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Point> CreatePoint(::flatbuffers::FlatBufferBuilder &_fbb, const PointT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PointT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  return fb::geometry_msgs::CreatePoint(
      _fbb,
      ___metadata,
      _x,
      _y,
      _z);
}

}  // namespace geometry_msgs
}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_GEOMETRYMSGS_FB_GEOMETRY_MSGS_H_
