// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCHEMA_FB_LEG_TRACKER_H_
#define FLATBUFFERS_GENERATED_SCHEMA_FB_LEG_TRACKER_H_

#include "flatbuffers/flatbuffers.h"

namespace fb {

struct MsgMetadata;
struct MsgMetadataBuilder;
struct MsgMetadataT;

struct MsgWithMetadata;
struct MsgWithMetadataBuilder;
struct MsgWithMetadataT;

struct RosTime;

struct RosDuration;

namespace std_msgs {

struct Header;
struct HeaderBuilder;
struct HeaderT;

}  // namespace std_msgs

namespace sensor_msgs {

struct NavSatStatus;
struct NavSatStatusBuilder;
struct NavSatStatusT;

struct NavSatFix;
struct NavSatFixBuilder;
struct NavSatFixT;

struct LaserScan;
struct LaserScanBuilder;
struct LaserScanT;

struct PointField;
struct PointFieldBuilder;
struct PointFieldT;

struct PointCloud2;
struct PointCloud2Builder;
struct PointCloud2T;

struct CompressedImage;
struct CompressedImageBuilder;
struct CompressedImageT;

}  // namespace sensor_msgs

namespace std_msgs {

struct String;
struct StringBuilder;
struct StringT;

}  // namespace std_msgs

namespace geometry_msgs {

struct Vector3;
struct Vector3Builder;
struct Vector3T;

struct Quaternion;
struct QuaternionBuilder;
struct QuaternionT;

struct Transform;
struct TransformBuilder;
struct TransformT;

struct TransformStamped;
struct TransformStampedBuilder;
struct TransformStampedT;

struct Point;
struct PointBuilder;
struct PointT;

struct Pose;
struct PoseBuilder;
struct PoseT;

struct PoseStamped;
struct PoseStampedBuilder;
struct PoseStampedT;

struct PoseWithCovariance;
struct PoseWithCovarianceBuilder;
struct PoseWithCovarianceT;

struct PoseWithCovarianceStamped;
struct PoseWithCovarianceStampedBuilder;
struct PoseWithCovarianceStampedT;

struct Twist;
struct TwistBuilder;
struct TwistT;

struct TwistStamped;
struct TwistStampedBuilder;
struct TwistStampedT;

}  // namespace geometry_msgs

namespace geographic_msgs {

struct GeoPoint;
struct GeoPointBuilder;
struct GeoPointT;

struct GeoPose;
struct GeoPoseBuilder;
struct GeoPoseT;

struct GeoPoseStamped;
struct GeoPoseStampedBuilder;
struct GeoPoseStampedT;

struct GeoPoseWithCovariance;
struct GeoPoseWithCovarianceBuilder;
struct GeoPoseWithCovarianceT;

struct GeoPoseWithCovarianceStamped;
struct GeoPoseWithCovarianceStampedBuilder;
struct GeoPoseWithCovarianceStampedT;

}  // namespace geographic_msgs

namespace geometry_msgs {

struct TwistWithCovariance;
struct TwistWithCovarianceBuilder;
struct TwistWithCovarianceT;

}  // namespace geometry_msgs

namespace nav_msgs {

struct Odometry;
struct OdometryBuilder;
struct OdometryT;

struct Path;
struct PathBuilder;
struct PathT;

}  // namespace nav_msgs

namespace temoto_action_engine {

struct UmrfGraphDiff;
struct UmrfGraphDiffBuilder;
struct UmrfGraphDiffT;

struct BroadcastStartUmrfGraph;
struct BroadcastStartUmrfGraphBuilder;
struct BroadcastStartUmrfGraphT;

struct BroadcastStopUmrfGraph;
struct BroadcastStopUmrfGraphBuilder;
struct BroadcastStopUmrfGraphT;

}  // namespace temoto_action_engine

namespace augre_msgs {

struct AgentStatus;
struct AgentStatusBuilder;
struct AgentStatusT;

struct DetectedItem;
struct DetectedItemBuilder;
struct DetectedItemT;

struct TransformWithCovarianceStamped;
struct TransformWithCovarianceStampedBuilder;
struct TransformWithCovarianceStampedT;

}  // namespace augre_msgs

namespace asa_db_portal {

struct AzureSpatialAnchor;
struct AzureSpatialAnchorBuilder;
struct AzureSpatialAnchorT;

}  // namespace asa_db_portal

namespace amrl_msgs {

struct RobofleetStatus;
struct RobofleetStatusBuilder;
struct RobofleetStatusT;

struct RobofleetSubscription;
struct RobofleetSubscriptionBuilder;
struct RobofleetSubscriptionT;

struct ElevatorStatus;
struct ElevatorStatusBuilder;
struct ElevatorStatusT;

struct ElevatorCommand;
struct ElevatorCommandBuilder;
struct ElevatorCommandT;

struct Pose2Df;
struct Pose2DfBuilder;
struct Pose2DfT;

struct Localization2DMsg;
struct Localization2DMsgBuilder;
struct Localization2DMsgT;

struct PathVisualization;
struct PathVisualizationBuilder;
struct PathVisualizationT;

struct Point2D;
struct Point2DBuilder;
struct Point2DT;

struct ColoredPoint2D;
struct ColoredPoint2DBuilder;
struct ColoredPoint2DT;

struct ColoredLine2D;
struct ColoredLine2DBuilder;
struct ColoredLine2DT;

struct ColoredArc2D;
struct ColoredArc2DBuilder;
struct ColoredArc2DT;

struct VisualizationMsg;
struct VisualizationMsgBuilder;
struct VisualizationMsgT;

struct DetectedItem;
struct DetectedItemBuilder;
struct DetectedItemT;

}  // namespace amrl_msgs

namespace tf2_msgs {

struct TFMessage;
struct TFMessageBuilder;
struct TFMessageT;

}  // namespace tf2_msgs

namespace leg_tracker {

struct Detection;
struct DetectionBuilder;
struct DetectionT;

struct DetectionArray;
struct DetectionArrayBuilder;
struct DetectionArrayT;

struct Leg;
struct LegBuilder;
struct LegT;

struct LegArray;
struct LegArrayBuilder;
struct LegArrayT;

struct Person;
struct PersonBuilder;
struct PersonT;

struct PersonArray;
struct PersonArrayBuilder;
struct PersonArrayT;

}  // namespace leg_tracker

namespace sensor_msgs {
namespace NavSatStatusConstants {

enum status_no_fix {
  status_no_fix_value = -1,
  status_no_fix_MIN = status_no_fix_value,
  status_no_fix_MAX = status_no_fix_value
};

inline const status_no_fix (&EnumValuesstatus_no_fix())[1] {
  static const status_no_fix values[] = {
    status_no_fix_value
  };
  return values;
}

inline const char * const *EnumNamesstatus_no_fix() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamestatus_no_fix(status_no_fix e) {
  if (flatbuffers::IsOutRange(e, status_no_fix_value, status_no_fix_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(status_no_fix_value);
  return EnumNamesstatus_no_fix()[index];
}

enum status_fix {
  status_fix_value = 0,
  status_fix_MIN = status_fix_value,
  status_fix_MAX = status_fix_value
};

inline const status_fix (&EnumValuesstatus_fix())[1] {
  static const status_fix values[] = {
    status_fix_value
  };
  return values;
}

inline const char * const *EnumNamesstatus_fix() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamestatus_fix(status_fix e) {
  if (flatbuffers::IsOutRange(e, status_fix_value, status_fix_value)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesstatus_fix()[index];
}

enum status_sbas_fix {
  status_sbas_fix_value = 1,
  status_sbas_fix_MIN = status_sbas_fix_value,
  status_sbas_fix_MAX = status_sbas_fix_value
};

inline const status_sbas_fix (&EnumValuesstatus_sbas_fix())[1] {
  static const status_sbas_fix values[] = {
    status_sbas_fix_value
  };
  return values;
}

inline const char * const *EnumNamesstatus_sbas_fix() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamestatus_sbas_fix(status_sbas_fix e) {
  if (flatbuffers::IsOutRange(e, status_sbas_fix_value, status_sbas_fix_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(status_sbas_fix_value);
  return EnumNamesstatus_sbas_fix()[index];
}

enum status_gbas_fix {
  status_gbas_fix_value = 2,
  status_gbas_fix_MIN = status_gbas_fix_value,
  status_gbas_fix_MAX = status_gbas_fix_value
};

inline const status_gbas_fix (&EnumValuesstatus_gbas_fix())[1] {
  static const status_gbas_fix values[] = {
    status_gbas_fix_value
  };
  return values;
}

inline const char * const *EnumNamesstatus_gbas_fix() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamestatus_gbas_fix(status_gbas_fix e) {
  if (flatbuffers::IsOutRange(e, status_gbas_fix_value, status_gbas_fix_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(status_gbas_fix_value);
  return EnumNamesstatus_gbas_fix()[index];
}

enum service_gps {
  service_gps_value = 1,
  service_gps_MIN = service_gps_value,
  service_gps_MAX = service_gps_value
};

inline const service_gps (&EnumValuesservice_gps())[1] {
  static const service_gps values[] = {
    service_gps_value
  };
  return values;
}

inline const char * const *EnumNamesservice_gps() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameservice_gps(service_gps e) {
  if (flatbuffers::IsOutRange(e, service_gps_value, service_gps_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(service_gps_value);
  return EnumNamesservice_gps()[index];
}

enum service_glonass {
  service_glonass_value = 2,
  service_glonass_MIN = service_glonass_value,
  service_glonass_MAX = service_glonass_value
};

inline const service_glonass (&EnumValuesservice_glonass())[1] {
  static const service_glonass values[] = {
    service_glonass_value
  };
  return values;
}

inline const char * const *EnumNamesservice_glonass() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameservice_glonass(service_glonass e) {
  if (flatbuffers::IsOutRange(e, service_glonass_value, service_glonass_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(service_glonass_value);
  return EnumNamesservice_glonass()[index];
}

enum service_compass {
  service_compass_value = 4,
  service_compass_MIN = service_compass_value,
  service_compass_MAX = service_compass_value
};

inline const service_compass (&EnumValuesservice_compass())[1] {
  static const service_compass values[] = {
    service_compass_value
  };
  return values;
}

inline const char * const *EnumNamesservice_compass() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameservice_compass(service_compass e) {
  if (flatbuffers::IsOutRange(e, service_compass_value, service_compass_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(service_compass_value);
  return EnumNamesservice_compass()[index];
}

enum service_galileo {
  service_galileo_value = 8,
  service_galileo_MIN = service_galileo_value,
  service_galileo_MAX = service_galileo_value
};

inline const service_galileo (&EnumValuesservice_galileo())[1] {
  static const service_galileo values[] = {
    service_galileo_value
  };
  return values;
}

inline const char * const *EnumNamesservice_galileo() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameservice_galileo(service_galileo e) {
  if (flatbuffers::IsOutRange(e, service_galileo_value, service_galileo_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(service_galileo_value);
  return EnumNamesservice_galileo()[index];
}

}  // namespace NavSatStatusConstants

namespace NavSatFixConstants {

enum covariance_type_unknown {
  covariance_type_unknown_value = 0,
  covariance_type_unknown_MIN = covariance_type_unknown_value,
  covariance_type_unknown_MAX = covariance_type_unknown_value
};

inline const covariance_type_unknown (&EnumValuescovariance_type_unknown())[1] {
  static const covariance_type_unknown values[] = {
    covariance_type_unknown_value
  };
  return values;
}

inline const char * const *EnumNamescovariance_type_unknown() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamecovariance_type_unknown(covariance_type_unknown e) {
  if (flatbuffers::IsOutRange(e, covariance_type_unknown_value, covariance_type_unknown_value)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamescovariance_type_unknown()[index];
}

enum covariance_type_approximated {
  covariance_type_approximated_value = 1,
  covariance_type_approximated_MIN = covariance_type_approximated_value,
  covariance_type_approximated_MAX = covariance_type_approximated_value
};

inline const covariance_type_approximated (&EnumValuescovariance_type_approximated())[1] {
  static const covariance_type_approximated values[] = {
    covariance_type_approximated_value
  };
  return values;
}

inline const char * const *EnumNamescovariance_type_approximated() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamecovariance_type_approximated(covariance_type_approximated e) {
  if (flatbuffers::IsOutRange(e, covariance_type_approximated_value, covariance_type_approximated_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(covariance_type_approximated_value);
  return EnumNamescovariance_type_approximated()[index];
}

enum covariance_type_diagonal_known {
  covariance_type_diagonal_known_value = 2,
  covariance_type_diagonal_known_MIN = covariance_type_diagonal_known_value,
  covariance_type_diagonal_known_MAX = covariance_type_diagonal_known_value
};

inline const covariance_type_diagonal_known (&EnumValuescovariance_type_diagonal_known())[1] {
  static const covariance_type_diagonal_known values[] = {
    covariance_type_diagonal_known_value
  };
  return values;
}

inline const char * const *EnumNamescovariance_type_diagonal_known() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamecovariance_type_diagonal_known(covariance_type_diagonal_known e) {
  if (flatbuffers::IsOutRange(e, covariance_type_diagonal_known_value, covariance_type_diagonal_known_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(covariance_type_diagonal_known_value);
  return EnumNamescovariance_type_diagonal_known()[index];
}

enum covariance_type_known {
  covariance_type_known_value = 3,
  covariance_type_known_MIN = covariance_type_known_value,
  covariance_type_known_MAX = covariance_type_known_value
};

inline const covariance_type_known (&EnumValuescovariance_type_known())[1] {
  static const covariance_type_known values[] = {
    covariance_type_known_value
  };
  return values;
}

inline const char * const *EnumNamescovariance_type_known() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamecovariance_type_known(covariance_type_known e) {
  if (flatbuffers::IsOutRange(e, covariance_type_known_value, covariance_type_known_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(covariance_type_known_value);
  return EnumNamescovariance_type_known()[index];
}

}  // namespace NavSatFixConstants

namespace PointFieldConstants {

enum int8 {
  int8_value = 1,
  int8_MIN = int8_value,
  int8_MAX = int8_value
};

inline const int8 (&EnumValuesint8())[1] {
  static const int8 values[] = {
    int8_value
  };
  return values;
}

inline const char * const *EnumNamesint8() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameint8(int8 e) {
  if (flatbuffers::IsOutRange(e, int8_value, int8_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(int8_value);
  return EnumNamesint8()[index];
}

enum uint8 {
  uint8_value = 2,
  uint8_MIN = uint8_value,
  uint8_MAX = uint8_value
};

inline const uint8 (&EnumValuesuint8())[1] {
  static const uint8 values[] = {
    uint8_value
  };
  return values;
}

inline const char * const *EnumNamesuint8() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameuint8(uint8 e) {
  if (flatbuffers::IsOutRange(e, uint8_value, uint8_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(uint8_value);
  return EnumNamesuint8()[index];
}

enum int16 {
  int16_value = 3,
  int16_MIN = int16_value,
  int16_MAX = int16_value
};

inline const int16 (&EnumValuesint16())[1] {
  static const int16 values[] = {
    int16_value
  };
  return values;
}

inline const char * const *EnumNamesint16() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameint16(int16 e) {
  if (flatbuffers::IsOutRange(e, int16_value, int16_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(int16_value);
  return EnumNamesint16()[index];
}

enum uint16 {
  uint16_value = 4,
  uint16_MIN = uint16_value,
  uint16_MAX = uint16_value
};

inline const uint16 (&EnumValuesuint16())[1] {
  static const uint16 values[] = {
    uint16_value
  };
  return values;
}

inline const char * const *EnumNamesuint16() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameuint16(uint16 e) {
  if (flatbuffers::IsOutRange(e, uint16_value, uint16_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(uint16_value);
  return EnumNamesuint16()[index];
}

enum int32 {
  int32_value = 5,
  int32_MIN = int32_value,
  int32_MAX = int32_value
};

inline const int32 (&EnumValuesint32())[1] {
  static const int32 values[] = {
    int32_value
  };
  return values;
}

inline const char * const *EnumNamesint32() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameint32(int32 e) {
  if (flatbuffers::IsOutRange(e, int32_value, int32_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(int32_value);
  return EnumNamesint32()[index];
}

enum uint32 {
  uint32_value = 6,
  uint32_MIN = uint32_value,
  uint32_MAX = uint32_value
};

inline const uint32 (&EnumValuesuint32())[1] {
  static const uint32 values[] = {
    uint32_value
  };
  return values;
}

inline const char * const *EnumNamesuint32() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameuint32(uint32 e) {
  if (flatbuffers::IsOutRange(e, uint32_value, uint32_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(uint32_value);
  return EnumNamesuint32()[index];
}

enum float32 {
  float32_value = 7,
  float32_MIN = float32_value,
  float32_MAX = float32_value
};

inline const float32 (&EnumValuesfloat32())[1] {
  static const float32 values[] = {
    float32_value
  };
  return values;
}

inline const char * const *EnumNamesfloat32() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamefloat32(float32 e) {
  if (flatbuffers::IsOutRange(e, float32_value, float32_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(float32_value);
  return EnumNamesfloat32()[index];
}

enum float64 {
  float64_value = 8,
  float64_MIN = float64_value,
  float64_MAX = float64_value
};

inline const float64 (&EnumValuesfloat64())[1] {
  static const float64 values[] = {
    float64_value
  };
  return values;
}

inline const char * const *EnumNamesfloat64() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamefloat64(float64 e) {
  if (flatbuffers::IsOutRange(e, float64_value, float64_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(float64_value);
  return EnumNamesfloat64()[index];
}

}  // namespace PointFieldConstants
}  // namespace sensor_msgs

namespace amrl_msgs {
namespace RobofleetSubscriptionConstants {

enum action_unsubscribe {
  action_unsubscribe_value = 0,
  action_unsubscribe_MIN = action_unsubscribe_value,
  action_unsubscribe_MAX = action_unsubscribe_value
};

inline const action_unsubscribe (&EnumValuesaction_unsubscribe())[1] {
  static const action_unsubscribe values[] = {
    action_unsubscribe_value
  };
  return values;
}

inline const char * const *EnumNamesaction_unsubscribe() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameaction_unsubscribe(action_unsubscribe e) {
  if (flatbuffers::IsOutRange(e, action_unsubscribe_value, action_unsubscribe_value)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesaction_unsubscribe()[index];
}

enum action_subscribe {
  action_subscribe_value = 1,
  action_subscribe_MIN = action_subscribe_value,
  action_subscribe_MAX = action_subscribe_value
};

inline const action_subscribe (&EnumValuesaction_subscribe())[1] {
  static const action_subscribe values[] = {
    action_subscribe_value
  };
  return values;
}

inline const char * const *EnumNamesaction_subscribe() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameaction_subscribe(action_subscribe e) {
  if (flatbuffers::IsOutRange(e, action_subscribe_value, action_subscribe_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(action_subscribe_value);
  return EnumNamesaction_subscribe()[index];
}

}  // namespace RobofleetSubscriptionConstants

namespace ElevatorStatusConstants {

enum door_open {
  door_open_value = 1,
  door_open_MIN = door_open_value,
  door_open_MAX = door_open_value
};

inline const door_open (&EnumValuesdoor_open())[1] {
  static const door_open values[] = {
    door_open_value
  };
  return values;
}

inline const char * const *EnumNamesdoor_open() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamedoor_open(door_open e) {
  if (flatbuffers::IsOutRange(e, door_open_value, door_open_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(door_open_value);
  return EnumNamesdoor_open()[index];
}

enum door_closed {
  door_closed_value = 0,
  door_closed_MIN = door_closed_value,
  door_closed_MAX = door_closed_value
};

inline const door_closed (&EnumValuesdoor_closed())[1] {
  static const door_closed values[] = {
    door_closed_value
  };
  return values;
}

inline const char * const *EnumNamesdoor_closed() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamedoor_closed(door_closed e) {
  if (flatbuffers::IsOutRange(e, door_closed_value, door_closed_value)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesdoor_closed()[index];
}

enum door_transition {
  door_transition_value = 2,
  door_transition_MIN = door_transition_value,
  door_transition_MAX = door_transition_value
};

inline const door_transition (&EnumValuesdoor_transition())[1] {
  static const door_transition values[] = {
    door_transition_value
  };
  return values;
}

inline const char * const *EnumNamesdoor_transition() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamedoor_transition(door_transition e) {
  if (flatbuffers::IsOutRange(e, door_transition_value, door_transition_value)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(door_transition_value);
  return EnumNamesdoor_transition()[index];
}

enum floor_transition {
  floor_transition_value = 0,
  floor_transition_MIN = floor_transition_value,
  floor_transition_MAX = floor_transition_value
};

inline const floor_transition (&EnumValuesfloor_transition())[1] {
  static const floor_transition values[] = {
    floor_transition_value
  };
  return values;
}

inline const char * const *EnumNamesfloor_transition() {
  static const char * const names[2] = {
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNamefloor_transition(floor_transition e) {
  if (flatbuffers::IsOutRange(e, floor_transition_value, floor_transition_value)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesfloor_transition()[index];
}

}  // namespace ElevatorStatusConstants
}  // namespace amrl_msgs

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) RosTime FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t secs_;
  uint32_t nsecs_;

 public:
  RosTime()
      : secs_(0),
        nsecs_(0) {
  }
  RosTime(uint32_t _secs, uint32_t _nsecs)
      : secs_(flatbuffers::EndianScalar(_secs)),
        nsecs_(flatbuffers::EndianScalar(_nsecs)) {
  }
  uint32_t secs() const {
    return flatbuffers::EndianScalar(secs_);
  }
  uint32_t nsecs() const {
    return flatbuffers::EndianScalar(nsecs_);
  }
};
FLATBUFFERS_STRUCT_END(RosTime, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) RosDuration FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t secs_;
  int32_t nsecs_;

 public:
  RosDuration()
      : secs_(0),
        nsecs_(0) {
  }
  RosDuration(int32_t _secs, int32_t _nsecs)
      : secs_(flatbuffers::EndianScalar(_secs)),
        nsecs_(flatbuffers::EndianScalar(_nsecs)) {
  }
  int32_t secs() const {
    return flatbuffers::EndianScalar(secs_);
  }
  int32_t nsecs() const {
    return flatbuffers::EndianScalar(nsecs_);
  }
};
FLATBUFFERS_STRUCT_END(RosDuration, 8);

struct MsgMetadataT : public flatbuffers::NativeTable {
  typedef MsgMetadata TableType;
  std::string type;
  std::string topic;
  MsgMetadataT() {
  }
};

struct MsgMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MsgMetadataT NativeTableType;
  typedef MsgMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_TOPIC = 6
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::String *topic() const {
    return GetPointer<const flatbuffers::String *>(VT_TOPIC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_TOPIC) &&
           verifier.VerifyString(topic()) &&
           verifier.EndTable();
  }
  MsgMetadataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MsgMetadataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MsgMetadata> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgMetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MsgMetadataBuilder {
  typedef MsgMetadata Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(MsgMetadata::VT_TYPE, type);
  }
  void add_topic(flatbuffers::Offset<flatbuffers::String> topic) {
    fbb_.AddOffset(MsgMetadata::VT_TOPIC, topic);
  }
  explicit MsgMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MsgMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MsgMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<MsgMetadata> CreateMsgMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::String> topic = 0) {
  MsgMetadataBuilder builder_(_fbb);
  builder_.add_topic(topic);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<MsgMetadata> CreateMsgMetadataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const char *topic = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto topic__ = topic ? _fbb.CreateString(topic) : 0;
  return fb::CreateMsgMetadata(
      _fbb,
      type__,
      topic__);
}

flatbuffers::Offset<MsgMetadata> CreateMsgMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MsgMetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MsgWithMetadataT : public flatbuffers::NativeTable {
  typedef MsgWithMetadata TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  MsgWithMetadataT() {
  }
};

struct MsgWithMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MsgWithMetadataT NativeTableType;
  typedef MsgWithMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           verifier.EndTable();
  }
  MsgWithMetadataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MsgWithMetadataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MsgWithMetadata> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgWithMetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MsgWithMetadataBuilder {
  typedef MsgWithMetadata Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(MsgWithMetadata::VT___METADATA, __metadata);
  }
  explicit MsgWithMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MsgWithMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MsgWithMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<MsgWithMetadata> CreateMsgWithMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0) {
  MsgWithMetadataBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<MsgWithMetadata> CreateMsgWithMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MsgWithMetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace std_msgs {

struct HeaderT : public flatbuffers::NativeTable {
  typedef Header TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  uint32_t seq;
  std::unique_ptr<fb::RosTime> stamp;
  std::string frame_id;
  HeaderT()
      : seq(0) {
  }
};

struct Header FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HeaderT NativeTableType;
  typedef HeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_SEQ = 6,
    VT_STAMP = 8,
    VT_FRAME_ID = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  uint32_t seq() const {
    return GetField<uint32_t>(VT_SEQ, 0);
  }
  const fb::RosTime *stamp() const {
    return GetStruct<const fb::RosTime *>(VT_STAMP);
  }
  const flatbuffers::String *frame_id() const {
    return GetPointer<const flatbuffers::String *>(VT_FRAME_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint32_t>(verifier, VT_SEQ) &&
           VerifyFieldRequired<fb::RosTime>(verifier, VT_STAMP) &&
           VerifyOffsetRequired(verifier, VT_FRAME_ID) &&
           verifier.VerifyString(frame_id()) &&
           verifier.EndTable();
  }
  HeaderT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HeaderT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Header> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HeaderT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HeaderBuilder {
  typedef Header Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Header::VT___METADATA, __metadata);
  }
  void add_seq(uint32_t seq) {
    fbb_.AddElement<uint32_t>(Header::VT_SEQ, seq, 0);
  }
  void add_stamp(const fb::RosTime *stamp) {
    fbb_.AddStruct(Header::VT_STAMP, stamp);
  }
  void add_frame_id(flatbuffers::Offset<flatbuffers::String> frame_id) {
    fbb_.AddOffset(Header::VT_FRAME_ID, frame_id);
  }
  explicit HeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Header> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Header>(end);
    fbb_.Required(o, Header::VT_STAMP);
    fbb_.Required(o, Header::VT_FRAME_ID);
    return o;
  }
};

inline flatbuffers::Offset<Header> CreateHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint32_t seq = 0,
    const fb::RosTime *stamp = 0,
    flatbuffers::Offset<flatbuffers::String> frame_id = 0) {
  HeaderBuilder builder_(_fbb);
  builder_.add_frame_id(frame_id);
  builder_.add_stamp(stamp);
  builder_.add_seq(seq);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<Header> CreateHeaderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint32_t seq = 0,
    const fb::RosTime *stamp = 0,
    const char *frame_id = nullptr) {
  auto frame_id__ = frame_id ? _fbb.CreateString(frame_id) : 0;
  return fb::std_msgs::CreateHeader(
      _fbb,
      __metadata,
      seq,
      stamp,
      frame_id__);
}

flatbuffers::Offset<Header> CreateHeader(flatbuffers::FlatBufferBuilder &_fbb, const HeaderT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace std_msgs

namespace sensor_msgs {

struct NavSatStatusT : public flatbuffers::NativeTable {
  typedef NavSatStatus TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  int8_t status;
  uint16_t service;
  NavSatStatusT()
      : status(0),
        service(0) {
  }
};

struct NavSatStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NavSatStatusT NativeTableType;
  typedef NavSatStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_STATUS = 6,
    VT_SERVICE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  int8_t status() const {
    return GetField<int8_t>(VT_STATUS, 0);
  }
  uint16_t service() const {
    return GetField<uint16_t>(VT_SERVICE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<int8_t>(verifier, VT_STATUS) &&
           VerifyField<uint16_t>(verifier, VT_SERVICE) &&
           verifier.EndTable();
  }
  NavSatStatusT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NavSatStatusT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NavSatStatus> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NavSatStatusT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NavSatStatusBuilder {
  typedef NavSatStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(NavSatStatus::VT___METADATA, __metadata);
  }
  void add_status(int8_t status) {
    fbb_.AddElement<int8_t>(NavSatStatus::VT_STATUS, status, 0);
  }
  void add_service(uint16_t service) {
    fbb_.AddElement<uint16_t>(NavSatStatus::VT_SERVICE, service, 0);
  }
  explicit NavSatStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NavSatStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NavSatStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<NavSatStatus> CreateNavSatStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    int8_t status = 0,
    uint16_t service = 0) {
  NavSatStatusBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  builder_.add_service(service);
  builder_.add_status(status);
  return builder_.Finish();
}

flatbuffers::Offset<NavSatStatus> CreateNavSatStatus(flatbuffers::FlatBufferBuilder &_fbb, const NavSatStatusT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NavSatFixT : public flatbuffers::NativeTable {
  typedef NavSatFix TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::std_msgs::HeaderT> header;
  std::unique_ptr<fb::sensor_msgs::NavSatStatusT> status;
  double latitude;
  double longitude;
  double altitude;
  std::vector<double> position_covariance;
  uint8_t position_covariance_type;
  NavSatFixT()
      : latitude(0.0),
        longitude(0.0),
        altitude(0.0),
        position_covariance_type(0) {
  }
};

struct NavSatFix FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NavSatFixT NativeTableType;
  typedef NavSatFixBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_STATUS = 8,
    VT_LATITUDE = 10,
    VT_LONGITUDE = 12,
    VT_ALTITUDE = 14,
    VT_POSITION_COVARIANCE = 16,
    VT_POSITION_COVARIANCE_TYPE = 18
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::sensor_msgs::NavSatStatus *status() const {
    return GetPointer<const fb::sensor_msgs::NavSatStatus *>(VT_STATUS);
  }
  double latitude() const {
    return GetField<double>(VT_LATITUDE, 0.0);
  }
  double longitude() const {
    return GetField<double>(VT_LONGITUDE, 0.0);
  }
  double altitude() const {
    return GetField<double>(VT_ALTITUDE, 0.0);
  }
  const flatbuffers::Vector<double> *position_covariance() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_POSITION_COVARIANCE);
  }
  uint8_t position_covariance_type() const {
    return GetField<uint8_t>(VT_POSITION_COVARIANCE_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_STATUS) &&
           verifier.VerifyTable(status()) &&
           VerifyField<double>(verifier, VT_LATITUDE) &&
           VerifyField<double>(verifier, VT_LONGITUDE) &&
           VerifyField<double>(verifier, VT_ALTITUDE) &&
           VerifyOffsetRequired(verifier, VT_POSITION_COVARIANCE) &&
           verifier.VerifyVector(position_covariance()) &&
           VerifyField<uint8_t>(verifier, VT_POSITION_COVARIANCE_TYPE) &&
           verifier.EndTable();
  }
  NavSatFixT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NavSatFixT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NavSatFix> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NavSatFixT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NavSatFixBuilder {
  typedef NavSatFix Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(NavSatFix::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(NavSatFix::VT_HEADER, header);
  }
  void add_status(flatbuffers::Offset<fb::sensor_msgs::NavSatStatus> status) {
    fbb_.AddOffset(NavSatFix::VT_STATUS, status);
  }
  void add_latitude(double latitude) {
    fbb_.AddElement<double>(NavSatFix::VT_LATITUDE, latitude, 0.0);
  }
  void add_longitude(double longitude) {
    fbb_.AddElement<double>(NavSatFix::VT_LONGITUDE, longitude, 0.0);
  }
  void add_altitude(double altitude) {
    fbb_.AddElement<double>(NavSatFix::VT_ALTITUDE, altitude, 0.0);
  }
  void add_position_covariance(flatbuffers::Offset<flatbuffers::Vector<double>> position_covariance) {
    fbb_.AddOffset(NavSatFix::VT_POSITION_COVARIANCE, position_covariance);
  }
  void add_position_covariance_type(uint8_t position_covariance_type) {
    fbb_.AddElement<uint8_t>(NavSatFix::VT_POSITION_COVARIANCE_TYPE, position_covariance_type, 0);
  }
  explicit NavSatFixBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NavSatFix> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NavSatFix>(end);
    fbb_.Required(o, NavSatFix::VT_HEADER);
    fbb_.Required(o, NavSatFix::VT_STATUS);
    fbb_.Required(o, NavSatFix::VT_POSITION_COVARIANCE);
    return o;
  }
};

inline flatbuffers::Offset<NavSatFix> CreateNavSatFix(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<fb::sensor_msgs::NavSatStatus> status = 0,
    double latitude = 0.0,
    double longitude = 0.0,
    double altitude = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<double>> position_covariance = 0,
    uint8_t position_covariance_type = 0) {
  NavSatFixBuilder builder_(_fbb);
  builder_.add_altitude(altitude);
  builder_.add_longitude(longitude);
  builder_.add_latitude(latitude);
  builder_.add_position_covariance(position_covariance);
  builder_.add_status(status);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  builder_.add_position_covariance_type(position_covariance_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<NavSatFix> CreateNavSatFixDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<fb::sensor_msgs::NavSatStatus> status = 0,
    double latitude = 0.0,
    double longitude = 0.0,
    double altitude = 0.0,
    const std::vector<double> *position_covariance = nullptr,
    uint8_t position_covariance_type = 0) {
  auto position_covariance__ = position_covariance ? _fbb.CreateVector<double>(*position_covariance) : 0;
  return fb::sensor_msgs::CreateNavSatFix(
      _fbb,
      __metadata,
      header,
      status,
      latitude,
      longitude,
      altitude,
      position_covariance__,
      position_covariance_type);
}

flatbuffers::Offset<NavSatFix> CreateNavSatFix(flatbuffers::FlatBufferBuilder &_fbb, const NavSatFixT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LaserScanT : public flatbuffers::NativeTable {
  typedef LaserScan TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::std_msgs::HeaderT> header;
  float angle_min;
  float angle_max;
  float angle_increment;
  float time_increment;
  float scan_time;
  float range_min;
  float range_max;
  std::vector<float> ranges;
  std::vector<float> intensities;
  LaserScanT()
      : angle_min(0.0f),
        angle_max(0.0f),
        angle_increment(0.0f),
        time_increment(0.0f),
        scan_time(0.0f),
        range_min(0.0f),
        range_max(0.0f) {
  }
};

struct LaserScan FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LaserScanT NativeTableType;
  typedef LaserScanBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_ANGLE_MIN = 8,
    VT_ANGLE_MAX = 10,
    VT_ANGLE_INCREMENT = 12,
    VT_TIME_INCREMENT = 14,
    VT_SCAN_TIME = 16,
    VT_RANGE_MIN = 18,
    VT_RANGE_MAX = 20,
    VT_RANGES = 22,
    VT_INTENSITIES = 24
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  float angle_min() const {
    return GetField<float>(VT_ANGLE_MIN, 0.0f);
  }
  float angle_max() const {
    return GetField<float>(VT_ANGLE_MAX, 0.0f);
  }
  float angle_increment() const {
    return GetField<float>(VT_ANGLE_INCREMENT, 0.0f);
  }
  float time_increment() const {
    return GetField<float>(VT_TIME_INCREMENT, 0.0f);
  }
  float scan_time() const {
    return GetField<float>(VT_SCAN_TIME, 0.0f);
  }
  float range_min() const {
    return GetField<float>(VT_RANGE_MIN, 0.0f);
  }
  float range_max() const {
    return GetField<float>(VT_RANGE_MAX, 0.0f);
  }
  const flatbuffers::Vector<float> *ranges() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_RANGES);
  }
  const flatbuffers::Vector<float> *intensities() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_INTENSITIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<float>(verifier, VT_ANGLE_MIN) &&
           VerifyField<float>(verifier, VT_ANGLE_MAX) &&
           VerifyField<float>(verifier, VT_ANGLE_INCREMENT) &&
           VerifyField<float>(verifier, VT_TIME_INCREMENT) &&
           VerifyField<float>(verifier, VT_SCAN_TIME) &&
           VerifyField<float>(verifier, VT_RANGE_MIN) &&
           VerifyField<float>(verifier, VT_RANGE_MAX) &&
           VerifyOffsetRequired(verifier, VT_RANGES) &&
           verifier.VerifyVector(ranges()) &&
           VerifyOffsetRequired(verifier, VT_INTENSITIES) &&
           verifier.VerifyVector(intensities()) &&
           verifier.EndTable();
  }
  LaserScanT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LaserScanT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LaserScan> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaserScanT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LaserScanBuilder {
  typedef LaserScan Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(LaserScan::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(LaserScan::VT_HEADER, header);
  }
  void add_angle_min(float angle_min) {
    fbb_.AddElement<float>(LaserScan::VT_ANGLE_MIN, angle_min, 0.0f);
  }
  void add_angle_max(float angle_max) {
    fbb_.AddElement<float>(LaserScan::VT_ANGLE_MAX, angle_max, 0.0f);
  }
  void add_angle_increment(float angle_increment) {
    fbb_.AddElement<float>(LaserScan::VT_ANGLE_INCREMENT, angle_increment, 0.0f);
  }
  void add_time_increment(float time_increment) {
    fbb_.AddElement<float>(LaserScan::VT_TIME_INCREMENT, time_increment, 0.0f);
  }
  void add_scan_time(float scan_time) {
    fbb_.AddElement<float>(LaserScan::VT_SCAN_TIME, scan_time, 0.0f);
  }
  void add_range_min(float range_min) {
    fbb_.AddElement<float>(LaserScan::VT_RANGE_MIN, range_min, 0.0f);
  }
  void add_range_max(float range_max) {
    fbb_.AddElement<float>(LaserScan::VT_RANGE_MAX, range_max, 0.0f);
  }
  void add_ranges(flatbuffers::Offset<flatbuffers::Vector<float>> ranges) {
    fbb_.AddOffset(LaserScan::VT_RANGES, ranges);
  }
  void add_intensities(flatbuffers::Offset<flatbuffers::Vector<float>> intensities) {
    fbb_.AddOffset(LaserScan::VT_INTENSITIES, intensities);
  }
  explicit LaserScanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LaserScan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LaserScan>(end);
    fbb_.Required(o, LaserScan::VT_HEADER);
    fbb_.Required(o, LaserScan::VT_RANGES);
    fbb_.Required(o, LaserScan::VT_INTENSITIES);
    return o;
  }
};

inline flatbuffers::Offset<LaserScan> CreateLaserScan(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    float angle_min = 0.0f,
    float angle_max = 0.0f,
    float angle_increment = 0.0f,
    float time_increment = 0.0f,
    float scan_time = 0.0f,
    float range_min = 0.0f,
    float range_max = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<float>> ranges = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> intensities = 0) {
  LaserScanBuilder builder_(_fbb);
  builder_.add_intensities(intensities);
  builder_.add_ranges(ranges);
  builder_.add_range_max(range_max);
  builder_.add_range_min(range_min);
  builder_.add_scan_time(scan_time);
  builder_.add_time_increment(time_increment);
  builder_.add_angle_increment(angle_increment);
  builder_.add_angle_max(angle_max);
  builder_.add_angle_min(angle_min);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<LaserScan> CreateLaserScanDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    float angle_min = 0.0f,
    float angle_max = 0.0f,
    float angle_increment = 0.0f,
    float time_increment = 0.0f,
    float scan_time = 0.0f,
    float range_min = 0.0f,
    float range_max = 0.0f,
    const std::vector<float> *ranges = nullptr,
    const std::vector<float> *intensities = nullptr) {
  auto ranges__ = ranges ? _fbb.CreateVector<float>(*ranges) : 0;
  auto intensities__ = intensities ? _fbb.CreateVector<float>(*intensities) : 0;
  return fb::sensor_msgs::CreateLaserScan(
      _fbb,
      __metadata,
      header,
      angle_min,
      angle_max,
      angle_increment,
      time_increment,
      scan_time,
      range_min,
      range_max,
      ranges__,
      intensities__);
}

flatbuffers::Offset<LaserScan> CreateLaserScan(flatbuffers::FlatBufferBuilder &_fbb, const LaserScanT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PointFieldT : public flatbuffers::NativeTable {
  typedef PointField TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::string name;
  uint32_t offset;
  uint8_t datatype;
  uint32_t count;
  PointFieldT()
      : offset(0),
        datatype(0),
        count(0) {
  }
};

struct PointField FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PointFieldT NativeTableType;
  typedef PointFieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_NAME = 6,
    VT_OFFSET = 8,
    VT_DATATYPE = 10,
    VT_COUNT = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t offset() const {
    return GetField<uint32_t>(VT_OFFSET, 0);
  }
  uint8_t datatype() const {
    return GetField<uint8_t>(VT_DATATYPE, 0);
  }
  uint32_t count() const {
    return GetField<uint32_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_OFFSET) &&
           VerifyField<uint8_t>(verifier, VT_DATATYPE) &&
           VerifyField<uint32_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
  PointFieldT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PointFieldT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PointField> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PointFieldT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PointFieldBuilder {
  typedef PointField Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PointField::VT___METADATA, __metadata);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PointField::VT_NAME, name);
  }
  void add_offset(uint32_t offset) {
    fbb_.AddElement<uint32_t>(PointField::VT_OFFSET, offset, 0);
  }
  void add_datatype(uint8_t datatype) {
    fbb_.AddElement<uint8_t>(PointField::VT_DATATYPE, datatype, 0);
  }
  void add_count(uint32_t count) {
    fbb_.AddElement<uint32_t>(PointField::VT_COUNT, count, 0);
  }
  explicit PointFieldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PointField> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PointField>(end);
    fbb_.Required(o, PointField::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<PointField> CreatePointField(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t offset = 0,
    uint8_t datatype = 0,
    uint32_t count = 0) {
  PointFieldBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_offset(offset);
  builder_.add_name(name);
  builder_.add___metadata(__metadata);
  builder_.add_datatype(datatype);
  return builder_.Finish();
}

inline flatbuffers::Offset<PointField> CreatePointFieldDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *name = nullptr,
    uint32_t offset = 0,
    uint8_t datatype = 0,
    uint32_t count = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return fb::sensor_msgs::CreatePointField(
      _fbb,
      __metadata,
      name__,
      offset,
      datatype,
      count);
}

flatbuffers::Offset<PointField> CreatePointField(flatbuffers::FlatBufferBuilder &_fbb, const PointFieldT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PointCloud2T : public flatbuffers::NativeTable {
  typedef PointCloud2 TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::std_msgs::HeaderT> header;
  uint32_t height;
  uint32_t width;
  std::vector<std::unique_ptr<fb::sensor_msgs::PointFieldT>> fields;
  bool is_bigendian;
  uint32_t point_step;
  uint32_t row_step;
  std::vector<uint8_t> data;
  bool is_dense;
  PointCloud2T()
      : height(0),
        width(0),
        is_bigendian(false),
        point_step(0),
        row_step(0),
        is_dense(false) {
  }
};

struct PointCloud2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PointCloud2T NativeTableType;
  typedef PointCloud2Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_HEIGHT = 8,
    VT_WIDTH = 10,
    VT_FIELDS = 12,
    VT_IS_BIGENDIAN = 14,
    VT_POINT_STEP = 16,
    VT_ROW_STEP = 18,
    VT_DATA = 20,
    VT_IS_DENSE = 22
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  uint32_t width() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::sensor_msgs::PointField>> *fields() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::sensor_msgs::PointField>> *>(VT_FIELDS);
  }
  bool is_bigendian() const {
    return GetField<uint8_t>(VT_IS_BIGENDIAN, 0) != 0;
  }
  uint32_t point_step() const {
    return GetField<uint32_t>(VT_POINT_STEP, 0);
  }
  uint32_t row_step() const {
    return GetField<uint32_t>(VT_ROW_STEP, 0);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool is_dense() const {
    return GetField<uint8_t>(VT_IS_DENSE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH) &&
           VerifyOffsetRequired(verifier, VT_FIELDS) &&
           verifier.VerifyVector(fields()) &&
           verifier.VerifyVectorOfTables(fields()) &&
           VerifyField<uint8_t>(verifier, VT_IS_BIGENDIAN) &&
           VerifyField<uint32_t>(verifier, VT_POINT_STEP) &&
           VerifyField<uint32_t>(verifier, VT_ROW_STEP) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyField<uint8_t>(verifier, VT_IS_DENSE) &&
           verifier.EndTable();
  }
  PointCloud2T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PointCloud2T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PointCloud2> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PointCloud2T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PointCloud2Builder {
  typedef PointCloud2 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PointCloud2::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(PointCloud2::VT_HEADER, header);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(PointCloud2::VT_HEIGHT, height, 0);
  }
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(PointCloud2::VT_WIDTH, width, 0);
  }
  void add_fields(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::sensor_msgs::PointField>>> fields) {
    fbb_.AddOffset(PointCloud2::VT_FIELDS, fields);
  }
  void add_is_bigendian(bool is_bigendian) {
    fbb_.AddElement<uint8_t>(PointCloud2::VT_IS_BIGENDIAN, static_cast<uint8_t>(is_bigendian), 0);
  }
  void add_point_step(uint32_t point_step) {
    fbb_.AddElement<uint32_t>(PointCloud2::VT_POINT_STEP, point_step, 0);
  }
  void add_row_step(uint32_t row_step) {
    fbb_.AddElement<uint32_t>(PointCloud2::VT_ROW_STEP, row_step, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(PointCloud2::VT_DATA, data);
  }
  void add_is_dense(bool is_dense) {
    fbb_.AddElement<uint8_t>(PointCloud2::VT_IS_DENSE, static_cast<uint8_t>(is_dense), 0);
  }
  explicit PointCloud2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PointCloud2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PointCloud2>(end);
    fbb_.Required(o, PointCloud2::VT_HEADER);
    fbb_.Required(o, PointCloud2::VT_FIELDS);
    fbb_.Required(o, PointCloud2::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<PointCloud2> CreatePointCloud2(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    uint32_t height = 0,
    uint32_t width = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::sensor_msgs::PointField>>> fields = 0,
    bool is_bigendian = false,
    uint32_t point_step = 0,
    uint32_t row_step = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0,
    bool is_dense = false) {
  PointCloud2Builder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_row_step(row_step);
  builder_.add_point_step(point_step);
  builder_.add_fields(fields);
  builder_.add_width(width);
  builder_.add_height(height);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  builder_.add_is_dense(is_dense);
  builder_.add_is_bigendian(is_bigendian);
  return builder_.Finish();
}

inline flatbuffers::Offset<PointCloud2> CreatePointCloud2Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    uint32_t height = 0,
    uint32_t width = 0,
    const std::vector<flatbuffers::Offset<fb::sensor_msgs::PointField>> *fields = nullptr,
    bool is_bigendian = false,
    uint32_t point_step = 0,
    uint32_t row_step = 0,
    const std::vector<uint8_t> *data = nullptr,
    bool is_dense = false) {
  auto fields__ = fields ? _fbb.CreateVector<flatbuffers::Offset<fb::sensor_msgs::PointField>>(*fields) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return fb::sensor_msgs::CreatePointCloud2(
      _fbb,
      __metadata,
      header,
      height,
      width,
      fields__,
      is_bigendian,
      point_step,
      row_step,
      data__,
      is_dense);
}

flatbuffers::Offset<PointCloud2> CreatePointCloud2(flatbuffers::FlatBufferBuilder &_fbb, const PointCloud2T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CompressedImageT : public flatbuffers::NativeTable {
  typedef CompressedImage TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::std_msgs::HeaderT> header;
  std::string format;
  std::vector<uint8_t> data;
  CompressedImageT() {
  }
};

struct CompressedImage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CompressedImageT NativeTableType;
  typedef CompressedImageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_FORMAT = 8,
    VT_DATA = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const flatbuffers::String *format() const {
    return GetPointer<const flatbuffers::String *>(VT_FORMAT);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_FORMAT) &&
           verifier.VerifyString(format()) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  CompressedImageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CompressedImageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CompressedImage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CompressedImageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CompressedImageBuilder {
  typedef CompressedImage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(CompressedImage::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(CompressedImage::VT_HEADER, header);
  }
  void add_format(flatbuffers::Offset<flatbuffers::String> format) {
    fbb_.AddOffset(CompressedImage::VT_FORMAT, format);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(CompressedImage::VT_DATA, data);
  }
  explicit CompressedImageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CompressedImage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CompressedImage>(end);
    fbb_.Required(o, CompressedImage::VT_HEADER);
    fbb_.Required(o, CompressedImage::VT_FORMAT);
    fbb_.Required(o, CompressedImage::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<CompressedImage> CreateCompressedImage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<flatbuffers::String> format = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  CompressedImageBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_format(format);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<CompressedImage> CreateCompressedImageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const char *format = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  auto format__ = format ? _fbb.CreateString(format) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return fb::sensor_msgs::CreateCompressedImage(
      _fbb,
      __metadata,
      header,
      format__,
      data__);
}

flatbuffers::Offset<CompressedImage> CreateCompressedImage(flatbuffers::FlatBufferBuilder &_fbb, const CompressedImageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace sensor_msgs

namespace std_msgs {

struct StringT : public flatbuffers::NativeTable {
  typedef String TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::string data;
  StringT() {
  }
};

struct String FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StringT NativeTableType;
  typedef StringBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_DATA = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const flatbuffers::String *data() const {
    return GetPointer<const flatbuffers::String *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyString(data()) &&
           verifier.EndTable();
  }
  StringT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StringT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<String> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StringT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StringBuilder {
  typedef String Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(String::VT___METADATA, __metadata);
  }
  void add_data(flatbuffers::Offset<flatbuffers::String> data) {
    fbb_.AddOffset(String::VT_DATA, data);
  }
  explicit StringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<String> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<String>(end);
    fbb_.Required(o, String::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<String> CreateString(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<flatbuffers::String> data = 0) {
  StringBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<String> CreateStringDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *data = nullptr) {
  auto data__ = data ? _fbb.CreateString(data) : 0;
  return fb::std_msgs::CreateString(
      _fbb,
      __metadata,
      data__);
}

flatbuffers::Offset<String> CreateString(flatbuffers::FlatBufferBuilder &_fbb, const StringT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace std_msgs

namespace geometry_msgs {

struct Vector3T : public flatbuffers::NativeTable {
  typedef Vector3 TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  double x;
  double y;
  double z;
  Vector3T()
      : x(0.0),
        y(0.0),
        z(0.0) {
  }
};

struct Vector3 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Vector3T NativeTableType;
  typedef Vector3Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<double>(verifier, VT_X) &&
           VerifyField<double>(verifier, VT_Y) &&
           VerifyField<double>(verifier, VT_Z) &&
           verifier.EndTable();
  }
  Vector3T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Vector3T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Vector3> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Vector3T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Vector3Builder {
  typedef Vector3 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Vector3::VT___METADATA, __metadata);
  }
  void add_x(double x) {
    fbb_.AddElement<double>(Vector3::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Vector3::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(Vector3::VT_Z, z, 0.0);
  }
  explicit Vector3Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Vector3> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Vector3>(end);
    return o;
  }
};

inline flatbuffers::Offset<Vector3> CreateVector3(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0) {
  Vector3Builder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<Vector3> CreateVector3(flatbuffers::FlatBufferBuilder &_fbb, const Vector3T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QuaternionT : public flatbuffers::NativeTable {
  typedef Quaternion TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  double x;
  double y;
  double z;
  double w;
  QuaternionT()
      : x(0.0),
        y(0.0),
        z(0.0),
        w(0.0) {
  }
};

struct Quaternion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuaternionT NativeTableType;
  typedef QuaternionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10,
    VT_W = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  double w() const {
    return GetField<double>(VT_W, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<double>(verifier, VT_X) &&
           VerifyField<double>(verifier, VT_Y) &&
           VerifyField<double>(verifier, VT_Z) &&
           VerifyField<double>(verifier, VT_W) &&
           verifier.EndTable();
  }
  QuaternionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QuaternionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Quaternion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuaternionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QuaternionBuilder {
  typedef Quaternion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Quaternion::VT___METADATA, __metadata);
  }
  void add_x(double x) {
    fbb_.AddElement<double>(Quaternion::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Quaternion::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(Quaternion::VT_Z, z, 0.0);
  }
  void add_w(double w) {
    fbb_.AddElement<double>(Quaternion::VT_W, w, 0.0);
  }
  explicit QuaternionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Quaternion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Quaternion>(end);
    return o;
  }
};

inline flatbuffers::Offset<Quaternion> CreateQuaternion(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0,
    double w = 0.0) {
  QuaternionBuilder builder_(_fbb);
  builder_.add_w(w);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<Quaternion> CreateQuaternion(flatbuffers::FlatBufferBuilder &_fbb, const QuaternionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransformT : public flatbuffers::NativeTable {
  typedef Transform TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::geometry_msgs::Vector3T> translation;
  std::unique_ptr<fb::geometry_msgs::QuaternionT> rotation;
  TransformT() {
  }
};

struct Transform FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TransformT NativeTableType;
  typedef TransformBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_TRANSLATION = 6,
    VT_ROTATION = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Vector3 *translation() const {
    return GetPointer<const fb::geometry_msgs::Vector3 *>(VT_TRANSLATION);
  }
  const fb::geometry_msgs::Quaternion *rotation() const {
    return GetPointer<const fb::geometry_msgs::Quaternion *>(VT_ROTATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_TRANSLATION) &&
           verifier.VerifyTable(translation()) &&
           VerifyOffsetRequired(verifier, VT_ROTATION) &&
           verifier.VerifyTable(rotation()) &&
           verifier.EndTable();
  }
  TransformT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransformT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Transform> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransformT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransformBuilder {
  typedef Transform Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Transform::VT___METADATA, __metadata);
  }
  void add_translation(flatbuffers::Offset<fb::geometry_msgs::Vector3> translation) {
    fbb_.AddOffset(Transform::VT_TRANSLATION, translation);
  }
  void add_rotation(flatbuffers::Offset<fb::geometry_msgs::Quaternion> rotation) {
    fbb_.AddOffset(Transform::VT_ROTATION, rotation);
  }
  explicit TransformBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Transform> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Transform>(end);
    fbb_.Required(o, Transform::VT_TRANSLATION);
    fbb_.Required(o, Transform::VT_ROTATION);
    return o;
  }
};

inline flatbuffers::Offset<Transform> CreateTransform(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::geometry_msgs::Vector3> translation = 0,
    flatbuffers::Offset<fb::geometry_msgs::Quaternion> rotation = 0) {
  TransformBuilder builder_(_fbb);
  builder_.add_rotation(rotation);
  builder_.add_translation(translation);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<Transform> CreateTransform(flatbuffers::FlatBufferBuilder &_fbb, const TransformT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransformStampedT : public flatbuffers::NativeTable {
  typedef TransformStamped TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::std_msgs::HeaderT> header;
  std::string child_frame_id;
  std::unique_ptr<fb::geometry_msgs::TransformT> transform;
  TransformStampedT() {
  }
};

struct TransformStamped FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TransformStampedT NativeTableType;
  typedef TransformStampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_CHILD_FRAME_ID = 8,
    VT_TRANSFORM = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const flatbuffers::String *child_frame_id() const {
    return GetPointer<const flatbuffers::String *>(VT_CHILD_FRAME_ID);
  }
  const fb::geometry_msgs::Transform *transform() const {
    return GetPointer<const fb::geometry_msgs::Transform *>(VT_TRANSFORM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_CHILD_FRAME_ID) &&
           verifier.VerifyString(child_frame_id()) &&
           VerifyOffsetRequired(verifier, VT_TRANSFORM) &&
           verifier.VerifyTable(transform()) &&
           verifier.EndTable();
  }
  TransformStampedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransformStampedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TransformStamped> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransformStampedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransformStampedBuilder {
  typedef TransformStamped Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(TransformStamped::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(TransformStamped::VT_HEADER, header);
  }
  void add_child_frame_id(flatbuffers::Offset<flatbuffers::String> child_frame_id) {
    fbb_.AddOffset(TransformStamped::VT_CHILD_FRAME_ID, child_frame_id);
  }
  void add_transform(flatbuffers::Offset<fb::geometry_msgs::Transform> transform) {
    fbb_.AddOffset(TransformStamped::VT_TRANSFORM, transform);
  }
  explicit TransformStampedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TransformStamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TransformStamped>(end);
    fbb_.Required(o, TransformStamped::VT_HEADER);
    fbb_.Required(o, TransformStamped::VT_CHILD_FRAME_ID);
    fbb_.Required(o, TransformStamped::VT_TRANSFORM);
    return o;
  }
};

inline flatbuffers::Offset<TransformStamped> CreateTransformStamped(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<flatbuffers::String> child_frame_id = 0,
    flatbuffers::Offset<fb::geometry_msgs::Transform> transform = 0) {
  TransformStampedBuilder builder_(_fbb);
  builder_.add_transform(transform);
  builder_.add_child_frame_id(child_frame_id);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<TransformStamped> CreateTransformStampedDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const char *child_frame_id = nullptr,
    flatbuffers::Offset<fb::geometry_msgs::Transform> transform = 0) {
  auto child_frame_id__ = child_frame_id ? _fbb.CreateString(child_frame_id) : 0;
  return fb::geometry_msgs::CreateTransformStamped(
      _fbb,
      __metadata,
      header,
      child_frame_id__,
      transform);
}

flatbuffers::Offset<TransformStamped> CreateTransformStamped(flatbuffers::FlatBufferBuilder &_fbb, const TransformStampedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PointT : public flatbuffers::NativeTable {
  typedef Point TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  double x;
  double y;
  double z;
  PointT()
      : x(0.0),
        y(0.0),
        z(0.0) {
  }
};

struct Point FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PointT NativeTableType;
  typedef PointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<double>(verifier, VT_X) &&
           VerifyField<double>(verifier, VT_Y) &&
           VerifyField<double>(verifier, VT_Z) &&
           verifier.EndTable();
  }
  PointT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PointT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Point> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PointT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PointBuilder {
  typedef Point Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Point::VT___METADATA, __metadata);
  }
  void add_x(double x) {
    fbb_.AddElement<double>(Point::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Point::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(Point::VT_Z, z, 0.0);
  }
  explicit PointBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Point> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Point>(end);
    return o;
  }
};

inline flatbuffers::Offset<Point> CreatePoint(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0) {
  PointBuilder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<Point> CreatePoint(flatbuffers::FlatBufferBuilder &_fbb, const PointT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PoseT : public flatbuffers::NativeTable {
  typedef Pose TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::geometry_msgs::PointT> position;
  std::unique_ptr<fb::geometry_msgs::QuaternionT> orientation;
  PoseT() {
  }
};

struct Pose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PoseT NativeTableType;
  typedef PoseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_POSITION = 6,
    VT_ORIENTATION = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Point *position() const {
    return GetPointer<const fb::geometry_msgs::Point *>(VT_POSITION);
  }
  const fb::geometry_msgs::Quaternion *orientation() const {
    return GetPointer<const fb::geometry_msgs::Quaternion *>(VT_ORIENTATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_POSITION) &&
           verifier.VerifyTable(position()) &&
           VerifyOffsetRequired(verifier, VT_ORIENTATION) &&
           verifier.VerifyTable(orientation()) &&
           verifier.EndTable();
  }
  PoseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PoseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pose> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PoseBuilder {
  typedef Pose Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Pose::VT___METADATA, __metadata);
  }
  void add_position(flatbuffers::Offset<fb::geometry_msgs::Point> position) {
    fbb_.AddOffset(Pose::VT_POSITION, position);
  }
  void add_orientation(flatbuffers::Offset<fb::geometry_msgs::Quaternion> orientation) {
    fbb_.AddOffset(Pose::VT_ORIENTATION, orientation);
  }
  explicit PoseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Pose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pose>(end);
    fbb_.Required(o, Pose::VT_POSITION);
    fbb_.Required(o, Pose::VT_ORIENTATION);
    return o;
  }
};

inline flatbuffers::Offset<Pose> CreatePose(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::geometry_msgs::Point> position = 0,
    flatbuffers::Offset<fb::geometry_msgs::Quaternion> orientation = 0) {
  PoseBuilder builder_(_fbb);
  builder_.add_orientation(orientation);
  builder_.add_position(position);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<Pose> CreatePose(flatbuffers::FlatBufferBuilder &_fbb, const PoseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PoseStampedT : public flatbuffers::NativeTable {
  typedef PoseStamped TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::std_msgs::HeaderT> header;
  std::unique_ptr<fb::geometry_msgs::PoseT> pose;
  PoseStampedT() {
  }
};

struct PoseStamped FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PoseStampedT NativeTableType;
  typedef PoseStampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_POSE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geometry_msgs::Pose *pose() const {
    return GetPointer<const fb::geometry_msgs::Pose *>(VT_POSE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           verifier.EndTable();
  }
  PoseStampedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PoseStampedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PoseStamped> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoseStampedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PoseStampedBuilder {
  typedef PoseStamped Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PoseStamped::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(PoseStamped::VT_HEADER, header);
  }
  void add_pose(flatbuffers::Offset<fb::geometry_msgs::Pose> pose) {
    fbb_.AddOffset(PoseStamped::VT_POSE, pose);
  }
  explicit PoseStampedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PoseStamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PoseStamped>(end);
    fbb_.Required(o, PoseStamped::VT_HEADER);
    fbb_.Required(o, PoseStamped::VT_POSE);
    return o;
  }
};

inline flatbuffers::Offset<PoseStamped> CreatePoseStamped(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<fb::geometry_msgs::Pose> pose = 0) {
  PoseStampedBuilder builder_(_fbb);
  builder_.add_pose(pose);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<PoseStamped> CreatePoseStamped(flatbuffers::FlatBufferBuilder &_fbb, const PoseStampedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PoseWithCovarianceT : public flatbuffers::NativeTable {
  typedef PoseWithCovariance TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::geometry_msgs::PoseT> pose;
  std::vector<double> covariance;
  PoseWithCovarianceT() {
  }
};

struct PoseWithCovariance FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PoseWithCovarianceT NativeTableType;
  typedef PoseWithCovarianceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_POSE = 6,
    VT_COVARIANCE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Pose *pose() const {
    return GetPointer<const fb::geometry_msgs::Pose *>(VT_POSE);
  }
  const flatbuffers::Vector<double> *covariance() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_COVARIANCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           VerifyOffsetRequired(verifier, VT_COVARIANCE) &&
           verifier.VerifyVector(covariance()) &&
           verifier.EndTable();
  }
  PoseWithCovarianceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PoseWithCovarianceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PoseWithCovariance> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoseWithCovarianceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PoseWithCovarianceBuilder {
  typedef PoseWithCovariance Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PoseWithCovariance::VT___METADATA, __metadata);
  }
  void add_pose(flatbuffers::Offset<fb::geometry_msgs::Pose> pose) {
    fbb_.AddOffset(PoseWithCovariance::VT_POSE, pose);
  }
  void add_covariance(flatbuffers::Offset<flatbuffers::Vector<double>> covariance) {
    fbb_.AddOffset(PoseWithCovariance::VT_COVARIANCE, covariance);
  }
  explicit PoseWithCovarianceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PoseWithCovariance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PoseWithCovariance>(end);
    fbb_.Required(o, PoseWithCovariance::VT_POSE);
    fbb_.Required(o, PoseWithCovariance::VT_COVARIANCE);
    return o;
  }
};

inline flatbuffers::Offset<PoseWithCovariance> CreatePoseWithCovariance(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::geometry_msgs::Pose> pose = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> covariance = 0) {
  PoseWithCovarianceBuilder builder_(_fbb);
  builder_.add_covariance(covariance);
  builder_.add_pose(pose);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<PoseWithCovariance> CreatePoseWithCovarianceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::geometry_msgs::Pose> pose = 0,
    const std::vector<double> *covariance = nullptr) {
  auto covariance__ = covariance ? _fbb.CreateVector<double>(*covariance) : 0;
  return fb::geometry_msgs::CreatePoseWithCovariance(
      _fbb,
      __metadata,
      pose,
      covariance__);
}

flatbuffers::Offset<PoseWithCovariance> CreatePoseWithCovariance(flatbuffers::FlatBufferBuilder &_fbb, const PoseWithCovarianceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PoseWithCovarianceStampedT : public flatbuffers::NativeTable {
  typedef PoseWithCovarianceStamped TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::std_msgs::HeaderT> header;
  std::unique_ptr<fb::geometry_msgs::PoseWithCovarianceT> pose;
  PoseWithCovarianceStampedT() {
  }
};

struct PoseWithCovarianceStamped FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PoseWithCovarianceStampedT NativeTableType;
  typedef PoseWithCovarianceStampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_POSE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geometry_msgs::PoseWithCovariance *pose() const {
    return GetPointer<const fb::geometry_msgs::PoseWithCovariance *>(VT_POSE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           verifier.EndTable();
  }
  PoseWithCovarianceStampedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PoseWithCovarianceStampedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PoseWithCovarianceStamped> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoseWithCovarianceStampedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PoseWithCovarianceStampedBuilder {
  typedef PoseWithCovarianceStamped Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PoseWithCovarianceStamped::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(PoseWithCovarianceStamped::VT_HEADER, header);
  }
  void add_pose(flatbuffers::Offset<fb::geometry_msgs::PoseWithCovariance> pose) {
    fbb_.AddOffset(PoseWithCovarianceStamped::VT_POSE, pose);
  }
  explicit PoseWithCovarianceStampedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PoseWithCovarianceStamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PoseWithCovarianceStamped>(end);
    fbb_.Required(o, PoseWithCovarianceStamped::VT_HEADER);
    fbb_.Required(o, PoseWithCovarianceStamped::VT_POSE);
    return o;
  }
};

inline flatbuffers::Offset<PoseWithCovarianceStamped> CreatePoseWithCovarianceStamped(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<fb::geometry_msgs::PoseWithCovariance> pose = 0) {
  PoseWithCovarianceStampedBuilder builder_(_fbb);
  builder_.add_pose(pose);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<PoseWithCovarianceStamped> CreatePoseWithCovarianceStamped(flatbuffers::FlatBufferBuilder &_fbb, const PoseWithCovarianceStampedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TwistT : public flatbuffers::NativeTable {
  typedef Twist TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::geometry_msgs::Vector3T> linear;
  std::unique_ptr<fb::geometry_msgs::Vector3T> angular;
  TwistT() {
  }
};

struct Twist FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TwistT NativeTableType;
  typedef TwistBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_LINEAR = 6,
    VT_ANGULAR = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Vector3 *linear() const {
    return GetPointer<const fb::geometry_msgs::Vector3 *>(VT_LINEAR);
  }
  const fb::geometry_msgs::Vector3 *angular() const {
    return GetPointer<const fb::geometry_msgs::Vector3 *>(VT_ANGULAR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_LINEAR) &&
           verifier.VerifyTable(linear()) &&
           VerifyOffsetRequired(verifier, VT_ANGULAR) &&
           verifier.VerifyTable(angular()) &&
           verifier.EndTable();
  }
  TwistT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TwistT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Twist> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TwistT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TwistBuilder {
  typedef Twist Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Twist::VT___METADATA, __metadata);
  }
  void add_linear(flatbuffers::Offset<fb::geometry_msgs::Vector3> linear) {
    fbb_.AddOffset(Twist::VT_LINEAR, linear);
  }
  void add_angular(flatbuffers::Offset<fb::geometry_msgs::Vector3> angular) {
    fbb_.AddOffset(Twist::VT_ANGULAR, angular);
  }
  explicit TwistBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Twist> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Twist>(end);
    fbb_.Required(o, Twist::VT_LINEAR);
    fbb_.Required(o, Twist::VT_ANGULAR);
    return o;
  }
};

inline flatbuffers::Offset<Twist> CreateTwist(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::geometry_msgs::Vector3> linear = 0,
    flatbuffers::Offset<fb::geometry_msgs::Vector3> angular = 0) {
  TwistBuilder builder_(_fbb);
  builder_.add_angular(angular);
  builder_.add_linear(linear);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<Twist> CreateTwist(flatbuffers::FlatBufferBuilder &_fbb, const TwistT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TwistStampedT : public flatbuffers::NativeTable {
  typedef TwistStamped TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::std_msgs::HeaderT> header;
  std::unique_ptr<fb::geometry_msgs::TwistT> twist;
  TwistStampedT() {
  }
};

struct TwistStamped FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TwistStampedT NativeTableType;
  typedef TwistStampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_TWIST = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geometry_msgs::Twist *twist() const {
    return GetPointer<const fb::geometry_msgs::Twist *>(VT_TWIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_TWIST) &&
           verifier.VerifyTable(twist()) &&
           verifier.EndTable();
  }
  TwistStampedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TwistStampedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TwistStamped> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TwistStampedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TwistStampedBuilder {
  typedef TwistStamped Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(TwistStamped::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(TwistStamped::VT_HEADER, header);
  }
  void add_twist(flatbuffers::Offset<fb::geometry_msgs::Twist> twist) {
    fbb_.AddOffset(TwistStamped::VT_TWIST, twist);
  }
  explicit TwistStampedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TwistStamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TwistStamped>(end);
    fbb_.Required(o, TwistStamped::VT_HEADER);
    fbb_.Required(o, TwistStamped::VT_TWIST);
    return o;
  }
};

inline flatbuffers::Offset<TwistStamped> CreateTwistStamped(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<fb::geometry_msgs::Twist> twist = 0) {
  TwistStampedBuilder builder_(_fbb);
  builder_.add_twist(twist);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<TwistStamped> CreateTwistStamped(flatbuffers::FlatBufferBuilder &_fbb, const TwistStampedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace geometry_msgs

namespace geographic_msgs {

struct GeoPointT : public flatbuffers::NativeTable {
  typedef GeoPoint TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  double latitude;
  double longitude;
  double altitude;
  GeoPointT()
      : latitude(0.0),
        longitude(0.0),
        altitude(0.0) {
  }
};

struct GeoPoint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeoPointT NativeTableType;
  typedef GeoPointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_LATITUDE = 6,
    VT_LONGITUDE = 8,
    VT_ALTITUDE = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  double latitude() const {
    return GetField<double>(VT_LATITUDE, 0.0);
  }
  double longitude() const {
    return GetField<double>(VT_LONGITUDE, 0.0);
  }
  double altitude() const {
    return GetField<double>(VT_ALTITUDE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<double>(verifier, VT_LATITUDE) &&
           VerifyField<double>(verifier, VT_LONGITUDE) &&
           VerifyField<double>(verifier, VT_ALTITUDE) &&
           verifier.EndTable();
  }
  GeoPointT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GeoPointT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GeoPoint> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GeoPointT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GeoPointBuilder {
  typedef GeoPoint Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GeoPoint::VT___METADATA, __metadata);
  }
  void add_latitude(double latitude) {
    fbb_.AddElement<double>(GeoPoint::VT_LATITUDE, latitude, 0.0);
  }
  void add_longitude(double longitude) {
    fbb_.AddElement<double>(GeoPoint::VT_LONGITUDE, longitude, 0.0);
  }
  void add_altitude(double altitude) {
    fbb_.AddElement<double>(GeoPoint::VT_ALTITUDE, altitude, 0.0);
  }
  explicit GeoPointBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GeoPoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeoPoint>(end);
    return o;
  }
};

inline flatbuffers::Offset<GeoPoint> CreateGeoPoint(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    double latitude = 0.0,
    double longitude = 0.0,
    double altitude = 0.0) {
  GeoPointBuilder builder_(_fbb);
  builder_.add_altitude(altitude);
  builder_.add_longitude(longitude);
  builder_.add_latitude(latitude);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<GeoPoint> CreateGeoPoint(flatbuffers::FlatBufferBuilder &_fbb, const GeoPointT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GeoPoseT : public flatbuffers::NativeTable {
  typedef GeoPose TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::geographic_msgs::GeoPointT> position;
  std::unique_ptr<fb::geometry_msgs::QuaternionT> orientation;
  GeoPoseT() {
  }
};

struct GeoPose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeoPoseT NativeTableType;
  typedef GeoPoseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_POSITION = 6,
    VT_ORIENTATION = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geographic_msgs::GeoPoint *position() const {
    return GetPointer<const fb::geographic_msgs::GeoPoint *>(VT_POSITION);
  }
  const fb::geometry_msgs::Quaternion *orientation() const {
    return GetPointer<const fb::geometry_msgs::Quaternion *>(VT_ORIENTATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_POSITION) &&
           verifier.VerifyTable(position()) &&
           VerifyOffsetRequired(verifier, VT_ORIENTATION) &&
           verifier.VerifyTable(orientation()) &&
           verifier.EndTable();
  }
  GeoPoseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GeoPoseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GeoPose> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GeoPoseBuilder {
  typedef GeoPose Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GeoPose::VT___METADATA, __metadata);
  }
  void add_position(flatbuffers::Offset<fb::geographic_msgs::GeoPoint> position) {
    fbb_.AddOffset(GeoPose::VT_POSITION, position);
  }
  void add_orientation(flatbuffers::Offset<fb::geometry_msgs::Quaternion> orientation) {
    fbb_.AddOffset(GeoPose::VT_ORIENTATION, orientation);
  }
  explicit GeoPoseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GeoPose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeoPose>(end);
    fbb_.Required(o, GeoPose::VT_POSITION);
    fbb_.Required(o, GeoPose::VT_ORIENTATION);
    return o;
  }
};

inline flatbuffers::Offset<GeoPose> CreateGeoPose(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::geographic_msgs::GeoPoint> position = 0,
    flatbuffers::Offset<fb::geometry_msgs::Quaternion> orientation = 0) {
  GeoPoseBuilder builder_(_fbb);
  builder_.add_orientation(orientation);
  builder_.add_position(position);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<GeoPose> CreateGeoPose(flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GeoPoseStampedT : public flatbuffers::NativeTable {
  typedef GeoPoseStamped TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::std_msgs::HeaderT> header;
  std::unique_ptr<fb::geographic_msgs::GeoPoseT> pose;
  GeoPoseStampedT() {
  }
};

struct GeoPoseStamped FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeoPoseStampedT NativeTableType;
  typedef GeoPoseStampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_POSE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geographic_msgs::GeoPose *pose() const {
    return GetPointer<const fb::geographic_msgs::GeoPose *>(VT_POSE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           verifier.EndTable();
  }
  GeoPoseStampedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GeoPoseStampedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GeoPoseStamped> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseStampedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GeoPoseStampedBuilder {
  typedef GeoPoseStamped Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GeoPoseStamped::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(GeoPoseStamped::VT_HEADER, header);
  }
  void add_pose(flatbuffers::Offset<fb::geographic_msgs::GeoPose> pose) {
    fbb_.AddOffset(GeoPoseStamped::VT_POSE, pose);
  }
  explicit GeoPoseStampedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GeoPoseStamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeoPoseStamped>(end);
    fbb_.Required(o, GeoPoseStamped::VT_HEADER);
    fbb_.Required(o, GeoPoseStamped::VT_POSE);
    return o;
  }
};

inline flatbuffers::Offset<GeoPoseStamped> CreateGeoPoseStamped(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<fb::geographic_msgs::GeoPose> pose = 0) {
  GeoPoseStampedBuilder builder_(_fbb);
  builder_.add_pose(pose);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<GeoPoseStamped> CreateGeoPoseStamped(flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseStampedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GeoPoseWithCovarianceT : public flatbuffers::NativeTable {
  typedef GeoPoseWithCovariance TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::geographic_msgs::GeoPoseT> pose;
  std::vector<double> covariance;
  GeoPoseWithCovarianceT() {
  }
};

struct GeoPoseWithCovariance FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeoPoseWithCovarianceT NativeTableType;
  typedef GeoPoseWithCovarianceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_POSE = 6,
    VT_COVARIANCE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geographic_msgs::GeoPose *pose() const {
    return GetPointer<const fb::geographic_msgs::GeoPose *>(VT_POSE);
  }
  const flatbuffers::Vector<double> *covariance() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_COVARIANCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           VerifyOffsetRequired(verifier, VT_COVARIANCE) &&
           verifier.VerifyVector(covariance()) &&
           verifier.EndTable();
  }
  GeoPoseWithCovarianceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GeoPoseWithCovarianceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GeoPoseWithCovariance> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseWithCovarianceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GeoPoseWithCovarianceBuilder {
  typedef GeoPoseWithCovariance Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GeoPoseWithCovariance::VT___METADATA, __metadata);
  }
  void add_pose(flatbuffers::Offset<fb::geographic_msgs::GeoPose> pose) {
    fbb_.AddOffset(GeoPoseWithCovariance::VT_POSE, pose);
  }
  void add_covariance(flatbuffers::Offset<flatbuffers::Vector<double>> covariance) {
    fbb_.AddOffset(GeoPoseWithCovariance::VT_COVARIANCE, covariance);
  }
  explicit GeoPoseWithCovarianceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GeoPoseWithCovariance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeoPoseWithCovariance>(end);
    fbb_.Required(o, GeoPoseWithCovariance::VT_POSE);
    fbb_.Required(o, GeoPoseWithCovariance::VT_COVARIANCE);
    return o;
  }
};

inline flatbuffers::Offset<GeoPoseWithCovariance> CreateGeoPoseWithCovariance(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::geographic_msgs::GeoPose> pose = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> covariance = 0) {
  GeoPoseWithCovarianceBuilder builder_(_fbb);
  builder_.add_covariance(covariance);
  builder_.add_pose(pose);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<GeoPoseWithCovariance> CreateGeoPoseWithCovarianceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::geographic_msgs::GeoPose> pose = 0,
    const std::vector<double> *covariance = nullptr) {
  auto covariance__ = covariance ? _fbb.CreateVector<double>(*covariance) : 0;
  return fb::geographic_msgs::CreateGeoPoseWithCovariance(
      _fbb,
      __metadata,
      pose,
      covariance__);
}

flatbuffers::Offset<GeoPoseWithCovariance> CreateGeoPoseWithCovariance(flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseWithCovarianceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GeoPoseWithCovarianceStampedT : public flatbuffers::NativeTable {
  typedef GeoPoseWithCovarianceStamped TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::std_msgs::HeaderT> header;
  std::unique_ptr<fb::geographic_msgs::GeoPoseWithCovarianceT> pose;
  GeoPoseWithCovarianceStampedT() {
  }
};

struct GeoPoseWithCovarianceStamped FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeoPoseWithCovarianceStampedT NativeTableType;
  typedef GeoPoseWithCovarianceStampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_POSE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::geographic_msgs::GeoPoseWithCovariance *pose() const {
    return GetPointer<const fb::geographic_msgs::GeoPoseWithCovariance *>(VT_POSE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           verifier.EndTable();
  }
  GeoPoseWithCovarianceStampedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GeoPoseWithCovarianceStampedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GeoPoseWithCovarianceStamped> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseWithCovarianceStampedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GeoPoseWithCovarianceStampedBuilder {
  typedef GeoPoseWithCovarianceStamped Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(GeoPoseWithCovarianceStamped::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(GeoPoseWithCovarianceStamped::VT_HEADER, header);
  }
  void add_pose(flatbuffers::Offset<fb::geographic_msgs::GeoPoseWithCovariance> pose) {
    fbb_.AddOffset(GeoPoseWithCovarianceStamped::VT_POSE, pose);
  }
  explicit GeoPoseWithCovarianceStampedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GeoPoseWithCovarianceStamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeoPoseWithCovarianceStamped>(end);
    fbb_.Required(o, GeoPoseWithCovarianceStamped::VT_HEADER);
    fbb_.Required(o, GeoPoseWithCovarianceStamped::VT_POSE);
    return o;
  }
};

inline flatbuffers::Offset<GeoPoseWithCovarianceStamped> CreateGeoPoseWithCovarianceStamped(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<fb::geographic_msgs::GeoPoseWithCovariance> pose = 0) {
  GeoPoseWithCovarianceStampedBuilder builder_(_fbb);
  builder_.add_pose(pose);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<GeoPoseWithCovarianceStamped> CreateGeoPoseWithCovarianceStamped(flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseWithCovarianceStampedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace geographic_msgs

namespace geometry_msgs {

struct TwistWithCovarianceT : public flatbuffers::NativeTable {
  typedef TwistWithCovariance TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::geometry_msgs::TwistT> twist;
  std::vector<double> covariance;
  TwistWithCovarianceT() {
  }
};

struct TwistWithCovariance FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TwistWithCovarianceT NativeTableType;
  typedef TwistWithCovarianceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_TWIST = 6,
    VT_COVARIANCE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Twist *twist() const {
    return GetPointer<const fb::geometry_msgs::Twist *>(VT_TWIST);
  }
  const flatbuffers::Vector<double> *covariance() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_COVARIANCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_TWIST) &&
           verifier.VerifyTable(twist()) &&
           VerifyOffsetRequired(verifier, VT_COVARIANCE) &&
           verifier.VerifyVector(covariance()) &&
           verifier.EndTable();
  }
  TwistWithCovarianceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TwistWithCovarianceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TwistWithCovariance> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TwistWithCovarianceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TwistWithCovarianceBuilder {
  typedef TwistWithCovariance Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(TwistWithCovariance::VT___METADATA, __metadata);
  }
  void add_twist(flatbuffers::Offset<fb::geometry_msgs::Twist> twist) {
    fbb_.AddOffset(TwistWithCovariance::VT_TWIST, twist);
  }
  void add_covariance(flatbuffers::Offset<flatbuffers::Vector<double>> covariance) {
    fbb_.AddOffset(TwistWithCovariance::VT_COVARIANCE, covariance);
  }
  explicit TwistWithCovarianceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TwistWithCovariance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TwistWithCovariance>(end);
    fbb_.Required(o, TwistWithCovariance::VT_TWIST);
    fbb_.Required(o, TwistWithCovariance::VT_COVARIANCE);
    return o;
  }
};

inline flatbuffers::Offset<TwistWithCovariance> CreateTwistWithCovariance(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::geometry_msgs::Twist> twist = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> covariance = 0) {
  TwistWithCovarianceBuilder builder_(_fbb);
  builder_.add_covariance(covariance);
  builder_.add_twist(twist);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<TwistWithCovariance> CreateTwistWithCovarianceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::geometry_msgs::Twist> twist = 0,
    const std::vector<double> *covariance = nullptr) {
  auto covariance__ = covariance ? _fbb.CreateVector<double>(*covariance) : 0;
  return fb::geometry_msgs::CreateTwistWithCovariance(
      _fbb,
      __metadata,
      twist,
      covariance__);
}

flatbuffers::Offset<TwistWithCovariance> CreateTwistWithCovariance(flatbuffers::FlatBufferBuilder &_fbb, const TwistWithCovarianceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace geometry_msgs

namespace nav_msgs {

struct OdometryT : public flatbuffers::NativeTable {
  typedef Odometry TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::std_msgs::HeaderT> header;
  std::string child_frame_id;
  std::unique_ptr<fb::geometry_msgs::PoseWithCovarianceT> pose;
  std::unique_ptr<fb::geometry_msgs::TwistWithCovarianceT> twist;
  OdometryT() {
  }
};

struct Odometry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OdometryT NativeTableType;
  typedef OdometryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_CHILD_FRAME_ID = 8,
    VT_POSE = 10,
    VT_TWIST = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const flatbuffers::String *child_frame_id() const {
    return GetPointer<const flatbuffers::String *>(VT_CHILD_FRAME_ID);
  }
  const fb::geometry_msgs::PoseWithCovariance *pose() const {
    return GetPointer<const fb::geometry_msgs::PoseWithCovariance *>(VT_POSE);
  }
  const fb::geometry_msgs::TwistWithCovariance *twist() const {
    return GetPointer<const fb::geometry_msgs::TwistWithCovariance *>(VT_TWIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_CHILD_FRAME_ID) &&
           verifier.VerifyString(child_frame_id()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           VerifyOffsetRequired(verifier, VT_TWIST) &&
           verifier.VerifyTable(twist()) &&
           verifier.EndTable();
  }
  OdometryT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OdometryT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Odometry> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OdometryT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OdometryBuilder {
  typedef Odometry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Odometry::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(Odometry::VT_HEADER, header);
  }
  void add_child_frame_id(flatbuffers::Offset<flatbuffers::String> child_frame_id) {
    fbb_.AddOffset(Odometry::VT_CHILD_FRAME_ID, child_frame_id);
  }
  void add_pose(flatbuffers::Offset<fb::geometry_msgs::PoseWithCovariance> pose) {
    fbb_.AddOffset(Odometry::VT_POSE, pose);
  }
  void add_twist(flatbuffers::Offset<fb::geometry_msgs::TwistWithCovariance> twist) {
    fbb_.AddOffset(Odometry::VT_TWIST, twist);
  }
  explicit OdometryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Odometry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Odometry>(end);
    fbb_.Required(o, Odometry::VT_HEADER);
    fbb_.Required(o, Odometry::VT_CHILD_FRAME_ID);
    fbb_.Required(o, Odometry::VT_POSE);
    fbb_.Required(o, Odometry::VT_TWIST);
    return o;
  }
};

inline flatbuffers::Offset<Odometry> CreateOdometry(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<flatbuffers::String> child_frame_id = 0,
    flatbuffers::Offset<fb::geometry_msgs::PoseWithCovariance> pose = 0,
    flatbuffers::Offset<fb::geometry_msgs::TwistWithCovariance> twist = 0) {
  OdometryBuilder builder_(_fbb);
  builder_.add_twist(twist);
  builder_.add_pose(pose);
  builder_.add_child_frame_id(child_frame_id);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<Odometry> CreateOdometryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const char *child_frame_id = nullptr,
    flatbuffers::Offset<fb::geometry_msgs::PoseWithCovariance> pose = 0,
    flatbuffers::Offset<fb::geometry_msgs::TwistWithCovariance> twist = 0) {
  auto child_frame_id__ = child_frame_id ? _fbb.CreateString(child_frame_id) : 0;
  return fb::nav_msgs::CreateOdometry(
      _fbb,
      __metadata,
      header,
      child_frame_id__,
      pose,
      twist);
}

flatbuffers::Offset<Odometry> CreateOdometry(flatbuffers::FlatBufferBuilder &_fbb, const OdometryT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PathT : public flatbuffers::NativeTable {
  typedef Path TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::std_msgs::HeaderT> header;
  std::vector<std::unique_ptr<fb::geometry_msgs::PoseStampedT>> poses;
  PathT() {
  }
};

struct Path FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PathT NativeTableType;
  typedef PathBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_POSES = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::geometry_msgs::PoseStamped>> *poses() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::geometry_msgs::PoseStamped>> *>(VT_POSES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_POSES) &&
           verifier.VerifyVector(poses()) &&
           verifier.VerifyVectorOfTables(poses()) &&
           verifier.EndTable();
  }
  PathT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PathT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Path> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PathT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PathBuilder {
  typedef Path Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Path::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(Path::VT_HEADER, header);
  }
  void add_poses(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::geometry_msgs::PoseStamped>>> poses) {
    fbb_.AddOffset(Path::VT_POSES, poses);
  }
  explicit PathBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Path> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Path>(end);
    fbb_.Required(o, Path::VT_HEADER);
    fbb_.Required(o, Path::VT_POSES);
    return o;
  }
};

inline flatbuffers::Offset<Path> CreatePath(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::geometry_msgs::PoseStamped>>> poses = 0) {
  PathBuilder builder_(_fbb);
  builder_.add_poses(poses);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<Path> CreatePathDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const std::vector<flatbuffers::Offset<fb::geometry_msgs::PoseStamped>> *poses = nullptr) {
  auto poses__ = poses ? _fbb.CreateVector<flatbuffers::Offset<fb::geometry_msgs::PoseStamped>>(*poses) : 0;
  return fb::nav_msgs::CreatePath(
      _fbb,
      __metadata,
      header,
      poses__);
}

flatbuffers::Offset<Path> CreatePath(flatbuffers::FlatBufferBuilder &_fbb, const PathT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace nav_msgs

namespace temoto_action_engine {

struct UmrfGraphDiffT : public flatbuffers::NativeTable {
  typedef UmrfGraphDiff TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::string ADD;
  std::string SUBTRACT;
  std::string operation;
  std::string umrf_json;
  UmrfGraphDiffT() {
  }
};

struct UmrfGraphDiff FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UmrfGraphDiffT NativeTableType;
  typedef UmrfGraphDiffBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_ADD = 6,
    VT_SUBTRACT = 8,
    VT_OPERATION = 10,
    VT_UMRF_JSON = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const flatbuffers::String *ADD() const {
    return GetPointer<const flatbuffers::String *>(VT_ADD);
  }
  const flatbuffers::String *SUBTRACT() const {
    return GetPointer<const flatbuffers::String *>(VT_SUBTRACT);
  }
  const flatbuffers::String *operation() const {
    return GetPointer<const flatbuffers::String *>(VT_OPERATION);
  }
  const flatbuffers::String *umrf_json() const {
    return GetPointer<const flatbuffers::String *>(VT_UMRF_JSON);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_ADD) &&
           verifier.VerifyString(ADD()) &&
           VerifyOffsetRequired(verifier, VT_SUBTRACT) &&
           verifier.VerifyString(SUBTRACT()) &&
           VerifyOffsetRequired(verifier, VT_OPERATION) &&
           verifier.VerifyString(operation()) &&
           VerifyOffsetRequired(verifier, VT_UMRF_JSON) &&
           verifier.VerifyString(umrf_json()) &&
           verifier.EndTable();
  }
  UmrfGraphDiffT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UmrfGraphDiffT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UmrfGraphDiff> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UmrfGraphDiffT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UmrfGraphDiffBuilder {
  typedef UmrfGraphDiff Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(UmrfGraphDiff::VT___METADATA, __metadata);
  }
  void add_ADD(flatbuffers::Offset<flatbuffers::String> ADD) {
    fbb_.AddOffset(UmrfGraphDiff::VT_ADD, ADD);
  }
  void add_SUBTRACT(flatbuffers::Offset<flatbuffers::String> SUBTRACT) {
    fbb_.AddOffset(UmrfGraphDiff::VT_SUBTRACT, SUBTRACT);
  }
  void add_operation(flatbuffers::Offset<flatbuffers::String> operation) {
    fbb_.AddOffset(UmrfGraphDiff::VT_OPERATION, operation);
  }
  void add_umrf_json(flatbuffers::Offset<flatbuffers::String> umrf_json) {
    fbb_.AddOffset(UmrfGraphDiff::VT_UMRF_JSON, umrf_json);
  }
  explicit UmrfGraphDiffBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UmrfGraphDiff> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UmrfGraphDiff>(end);
    fbb_.Required(o, UmrfGraphDiff::VT_ADD);
    fbb_.Required(o, UmrfGraphDiff::VT_SUBTRACT);
    fbb_.Required(o, UmrfGraphDiff::VT_OPERATION);
    fbb_.Required(o, UmrfGraphDiff::VT_UMRF_JSON);
    return o;
  }
};

inline flatbuffers::Offset<UmrfGraphDiff> CreateUmrfGraphDiff(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<flatbuffers::String> ADD = 0,
    flatbuffers::Offset<flatbuffers::String> SUBTRACT = 0,
    flatbuffers::Offset<flatbuffers::String> operation = 0,
    flatbuffers::Offset<flatbuffers::String> umrf_json = 0) {
  UmrfGraphDiffBuilder builder_(_fbb);
  builder_.add_umrf_json(umrf_json);
  builder_.add_operation(operation);
  builder_.add_SUBTRACT(SUBTRACT);
  builder_.add_ADD(ADD);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<UmrfGraphDiff> CreateUmrfGraphDiffDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *ADD = nullptr,
    const char *SUBTRACT = nullptr,
    const char *operation = nullptr,
    const char *umrf_json = nullptr) {
  auto ADD__ = ADD ? _fbb.CreateString(ADD) : 0;
  auto SUBTRACT__ = SUBTRACT ? _fbb.CreateString(SUBTRACT) : 0;
  auto operation__ = operation ? _fbb.CreateString(operation) : 0;
  auto umrf_json__ = umrf_json ? _fbb.CreateString(umrf_json) : 0;
  return fb::temoto_action_engine::CreateUmrfGraphDiff(
      _fbb,
      __metadata,
      ADD__,
      SUBTRACT__,
      operation__,
      umrf_json__);
}

flatbuffers::Offset<UmrfGraphDiff> CreateUmrfGraphDiff(flatbuffers::FlatBufferBuilder &_fbb, const UmrfGraphDiffT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BroadcastStartUmrfGraphT : public flatbuffers::NativeTable {
  typedef BroadcastStartUmrfGraph TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::string umrf_graph_name;
  bool name_match_required;
  std::vector<std::string> targets;
  std::string umrf_graph_json;
  std::vector<std::unique_ptr<fb::temoto_action_engine::UmrfGraphDiffT>> umrf_graph_diffs;
  BroadcastStartUmrfGraphT()
      : name_match_required(false) {
  }
};

struct BroadcastStartUmrfGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BroadcastStartUmrfGraphT NativeTableType;
  typedef BroadcastStartUmrfGraphBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_UMRF_GRAPH_NAME = 6,
    VT_NAME_MATCH_REQUIRED = 8,
    VT_TARGETS = 10,
    VT_UMRF_GRAPH_JSON = 12,
    VT_UMRF_GRAPH_DIFFS = 14
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const flatbuffers::String *umrf_graph_name() const {
    return GetPointer<const flatbuffers::String *>(VT_UMRF_GRAPH_NAME);
  }
  bool name_match_required() const {
    return GetField<uint8_t>(VT_NAME_MATCH_REQUIRED, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *targets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TARGETS);
  }
  const flatbuffers::String *umrf_graph_json() const {
    return GetPointer<const flatbuffers::String *>(VT_UMRF_GRAPH_JSON);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::temoto_action_engine::UmrfGraphDiff>> *umrf_graph_diffs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::temoto_action_engine::UmrfGraphDiff>> *>(VT_UMRF_GRAPH_DIFFS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_UMRF_GRAPH_NAME) &&
           verifier.VerifyString(umrf_graph_name()) &&
           VerifyField<uint8_t>(verifier, VT_NAME_MATCH_REQUIRED) &&
           VerifyOffsetRequired(verifier, VT_TARGETS) &&
           verifier.VerifyVector(targets()) &&
           verifier.VerifyVectorOfStrings(targets()) &&
           VerifyOffsetRequired(verifier, VT_UMRF_GRAPH_JSON) &&
           verifier.VerifyString(umrf_graph_json()) &&
           VerifyOffsetRequired(verifier, VT_UMRF_GRAPH_DIFFS) &&
           verifier.VerifyVector(umrf_graph_diffs()) &&
           verifier.VerifyVectorOfTables(umrf_graph_diffs()) &&
           verifier.EndTable();
  }
  BroadcastStartUmrfGraphT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BroadcastStartUmrfGraphT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BroadcastStartUmrfGraph> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastStartUmrfGraphT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BroadcastStartUmrfGraphBuilder {
  typedef BroadcastStartUmrfGraph Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(BroadcastStartUmrfGraph::VT___METADATA, __metadata);
  }
  void add_umrf_graph_name(flatbuffers::Offset<flatbuffers::String> umrf_graph_name) {
    fbb_.AddOffset(BroadcastStartUmrfGraph::VT_UMRF_GRAPH_NAME, umrf_graph_name);
  }
  void add_name_match_required(bool name_match_required) {
    fbb_.AddElement<uint8_t>(BroadcastStartUmrfGraph::VT_NAME_MATCH_REQUIRED, static_cast<uint8_t>(name_match_required), 0);
  }
  void add_targets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> targets) {
    fbb_.AddOffset(BroadcastStartUmrfGraph::VT_TARGETS, targets);
  }
  void add_umrf_graph_json(flatbuffers::Offset<flatbuffers::String> umrf_graph_json) {
    fbb_.AddOffset(BroadcastStartUmrfGraph::VT_UMRF_GRAPH_JSON, umrf_graph_json);
  }
  void add_umrf_graph_diffs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::temoto_action_engine::UmrfGraphDiff>>> umrf_graph_diffs) {
    fbb_.AddOffset(BroadcastStartUmrfGraph::VT_UMRF_GRAPH_DIFFS, umrf_graph_diffs);
  }
  explicit BroadcastStartUmrfGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BroadcastStartUmrfGraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BroadcastStartUmrfGraph>(end);
    fbb_.Required(o, BroadcastStartUmrfGraph::VT_UMRF_GRAPH_NAME);
    fbb_.Required(o, BroadcastStartUmrfGraph::VT_TARGETS);
    fbb_.Required(o, BroadcastStartUmrfGraph::VT_UMRF_GRAPH_JSON);
    fbb_.Required(o, BroadcastStartUmrfGraph::VT_UMRF_GRAPH_DIFFS);
    return o;
  }
};

inline flatbuffers::Offset<BroadcastStartUmrfGraph> CreateBroadcastStartUmrfGraph(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<flatbuffers::String> umrf_graph_name = 0,
    bool name_match_required = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> targets = 0,
    flatbuffers::Offset<flatbuffers::String> umrf_graph_json = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::temoto_action_engine::UmrfGraphDiff>>> umrf_graph_diffs = 0) {
  BroadcastStartUmrfGraphBuilder builder_(_fbb);
  builder_.add_umrf_graph_diffs(umrf_graph_diffs);
  builder_.add_umrf_graph_json(umrf_graph_json);
  builder_.add_targets(targets);
  builder_.add_umrf_graph_name(umrf_graph_name);
  builder_.add___metadata(__metadata);
  builder_.add_name_match_required(name_match_required);
  return builder_.Finish();
}

inline flatbuffers::Offset<BroadcastStartUmrfGraph> CreateBroadcastStartUmrfGraphDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *umrf_graph_name = nullptr,
    bool name_match_required = false,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *targets = nullptr,
    const char *umrf_graph_json = nullptr,
    const std::vector<flatbuffers::Offset<fb::temoto_action_engine::UmrfGraphDiff>> *umrf_graph_diffs = nullptr) {
  auto umrf_graph_name__ = umrf_graph_name ? _fbb.CreateString(umrf_graph_name) : 0;
  auto targets__ = targets ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*targets) : 0;
  auto umrf_graph_json__ = umrf_graph_json ? _fbb.CreateString(umrf_graph_json) : 0;
  auto umrf_graph_diffs__ = umrf_graph_diffs ? _fbb.CreateVector<flatbuffers::Offset<fb::temoto_action_engine::UmrfGraphDiff>>(*umrf_graph_diffs) : 0;
  return fb::temoto_action_engine::CreateBroadcastStartUmrfGraph(
      _fbb,
      __metadata,
      umrf_graph_name__,
      name_match_required,
      targets__,
      umrf_graph_json__,
      umrf_graph_diffs__);
}

flatbuffers::Offset<BroadcastStartUmrfGraph> CreateBroadcastStartUmrfGraph(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastStartUmrfGraphT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BroadcastStopUmrfGraphT : public flatbuffers::NativeTable {
  typedef BroadcastStopUmrfGraph TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::string umrf_graph_name;
  std::vector<std::string> targets;
  BroadcastStopUmrfGraphT() {
  }
};

struct BroadcastStopUmrfGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BroadcastStopUmrfGraphT NativeTableType;
  typedef BroadcastStopUmrfGraphBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_UMRF_GRAPH_NAME = 6,
    VT_TARGETS = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const flatbuffers::String *umrf_graph_name() const {
    return GetPointer<const flatbuffers::String *>(VT_UMRF_GRAPH_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *targets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TARGETS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_UMRF_GRAPH_NAME) &&
           verifier.VerifyString(umrf_graph_name()) &&
           VerifyOffsetRequired(verifier, VT_TARGETS) &&
           verifier.VerifyVector(targets()) &&
           verifier.VerifyVectorOfStrings(targets()) &&
           verifier.EndTable();
  }
  BroadcastStopUmrfGraphT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BroadcastStopUmrfGraphT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BroadcastStopUmrfGraph> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastStopUmrfGraphT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BroadcastStopUmrfGraphBuilder {
  typedef BroadcastStopUmrfGraph Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(BroadcastStopUmrfGraph::VT___METADATA, __metadata);
  }
  void add_umrf_graph_name(flatbuffers::Offset<flatbuffers::String> umrf_graph_name) {
    fbb_.AddOffset(BroadcastStopUmrfGraph::VT_UMRF_GRAPH_NAME, umrf_graph_name);
  }
  void add_targets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> targets) {
    fbb_.AddOffset(BroadcastStopUmrfGraph::VT_TARGETS, targets);
  }
  explicit BroadcastStopUmrfGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BroadcastStopUmrfGraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BroadcastStopUmrfGraph>(end);
    fbb_.Required(o, BroadcastStopUmrfGraph::VT_UMRF_GRAPH_NAME);
    fbb_.Required(o, BroadcastStopUmrfGraph::VT_TARGETS);
    return o;
  }
};

inline flatbuffers::Offset<BroadcastStopUmrfGraph> CreateBroadcastStopUmrfGraph(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<flatbuffers::String> umrf_graph_name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> targets = 0) {
  BroadcastStopUmrfGraphBuilder builder_(_fbb);
  builder_.add_targets(targets);
  builder_.add_umrf_graph_name(umrf_graph_name);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<BroadcastStopUmrfGraph> CreateBroadcastStopUmrfGraphDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *umrf_graph_name = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *targets = nullptr) {
  auto umrf_graph_name__ = umrf_graph_name ? _fbb.CreateString(umrf_graph_name) : 0;
  auto targets__ = targets ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*targets) : 0;
  return fb::temoto_action_engine::CreateBroadcastStopUmrfGraph(
      _fbb,
      __metadata,
      umrf_graph_name__,
      targets__);
}

flatbuffers::Offset<BroadcastStopUmrfGraph> CreateBroadcastStopUmrfGraph(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastStopUmrfGraphT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace temoto_action_engine

namespace augre_msgs {

struct AgentStatusT : public flatbuffers::NativeTable {
  typedef AgentStatus TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::string uid;
  std::string callsign;
  std::string agent_type;
  float battery;
  std::string commander;
  std::string control_status;
  AgentStatusT()
      : battery(0.0f) {
  }
};

struct AgentStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AgentStatusT NativeTableType;
  typedef AgentStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_UID = 6,
    VT_CALLSIGN = 8,
    VT_AGENT_TYPE = 10,
    VT_BATTERY = 12,
    VT_COMMANDER = 14,
    VT_CONTROL_STATUS = 16
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const flatbuffers::String *uid() const {
    return GetPointer<const flatbuffers::String *>(VT_UID);
  }
  const flatbuffers::String *callsign() const {
    return GetPointer<const flatbuffers::String *>(VT_CALLSIGN);
  }
  const flatbuffers::String *agent_type() const {
    return GetPointer<const flatbuffers::String *>(VT_AGENT_TYPE);
  }
  float battery() const {
    return GetField<float>(VT_BATTERY, 0.0f);
  }
  const flatbuffers::String *commander() const {
    return GetPointer<const flatbuffers::String *>(VT_COMMANDER);
  }
  const flatbuffers::String *control_status() const {
    return GetPointer<const flatbuffers::String *>(VT_CONTROL_STATUS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_UID) &&
           verifier.VerifyString(uid()) &&
           VerifyOffsetRequired(verifier, VT_CALLSIGN) &&
           verifier.VerifyString(callsign()) &&
           VerifyOffsetRequired(verifier, VT_AGENT_TYPE) &&
           verifier.VerifyString(agent_type()) &&
           VerifyField<float>(verifier, VT_BATTERY) &&
           VerifyOffsetRequired(verifier, VT_COMMANDER) &&
           verifier.VerifyString(commander()) &&
           VerifyOffsetRequired(verifier, VT_CONTROL_STATUS) &&
           verifier.VerifyString(control_status()) &&
           verifier.EndTable();
  }
  AgentStatusT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AgentStatusT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AgentStatus> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AgentStatusT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AgentStatusBuilder {
  typedef AgentStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(AgentStatus::VT___METADATA, __metadata);
  }
  void add_uid(flatbuffers::Offset<flatbuffers::String> uid) {
    fbb_.AddOffset(AgentStatus::VT_UID, uid);
  }
  void add_callsign(flatbuffers::Offset<flatbuffers::String> callsign) {
    fbb_.AddOffset(AgentStatus::VT_CALLSIGN, callsign);
  }
  void add_agent_type(flatbuffers::Offset<flatbuffers::String> agent_type) {
    fbb_.AddOffset(AgentStatus::VT_AGENT_TYPE, agent_type);
  }
  void add_battery(float battery) {
    fbb_.AddElement<float>(AgentStatus::VT_BATTERY, battery, 0.0f);
  }
  void add_commander(flatbuffers::Offset<flatbuffers::String> commander) {
    fbb_.AddOffset(AgentStatus::VT_COMMANDER, commander);
  }
  void add_control_status(flatbuffers::Offset<flatbuffers::String> control_status) {
    fbb_.AddOffset(AgentStatus::VT_CONTROL_STATUS, control_status);
  }
  explicit AgentStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AgentStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AgentStatus>(end);
    fbb_.Required(o, AgentStatus::VT_UID);
    fbb_.Required(o, AgentStatus::VT_CALLSIGN);
    fbb_.Required(o, AgentStatus::VT_AGENT_TYPE);
    fbb_.Required(o, AgentStatus::VT_COMMANDER);
    fbb_.Required(o, AgentStatus::VT_CONTROL_STATUS);
    return o;
  }
};

inline flatbuffers::Offset<AgentStatus> CreateAgentStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<flatbuffers::String> uid = 0,
    flatbuffers::Offset<flatbuffers::String> callsign = 0,
    flatbuffers::Offset<flatbuffers::String> agent_type = 0,
    float battery = 0.0f,
    flatbuffers::Offset<flatbuffers::String> commander = 0,
    flatbuffers::Offset<flatbuffers::String> control_status = 0) {
  AgentStatusBuilder builder_(_fbb);
  builder_.add_control_status(control_status);
  builder_.add_commander(commander);
  builder_.add_battery(battery);
  builder_.add_agent_type(agent_type);
  builder_.add_callsign(callsign);
  builder_.add_uid(uid);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<AgentStatus> CreateAgentStatusDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *uid = nullptr,
    const char *callsign = nullptr,
    const char *agent_type = nullptr,
    float battery = 0.0f,
    const char *commander = nullptr,
    const char *control_status = nullptr) {
  auto uid__ = uid ? _fbb.CreateString(uid) : 0;
  auto callsign__ = callsign ? _fbb.CreateString(callsign) : 0;
  auto agent_type__ = agent_type ? _fbb.CreateString(agent_type) : 0;
  auto commander__ = commander ? _fbb.CreateString(commander) : 0;
  auto control_status__ = control_status ? _fbb.CreateString(control_status) : 0;
  return fb::augre_msgs::CreateAgentStatus(
      _fbb,
      __metadata,
      uid__,
      callsign__,
      agent_type__,
      battery,
      commander__,
      control_status__);
}

flatbuffers::Offset<AgentStatus> CreateAgentStatus(flatbuffers::FlatBufferBuilder &_fbb, const AgentStatusT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DetectedItemT : public flatbuffers::NativeTable {
  typedef DetectedItem TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::string uid;
  std::string callsign;
  std::string type;
  std::string type_label;
  std::string how;
  std::string how_label;
  std::unique_ptr<fb::geometry_msgs::PoseStampedT> pose;
  std::unique_ptr<fb::sensor_msgs::CompressedImageT> cmpr_image;
  std::string url;
  DetectedItemT() {
  }
};

struct DetectedItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DetectedItemT NativeTableType;
  typedef DetectedItemBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_UID = 6,
    VT_CALLSIGN = 8,
    VT_TYPE = 10,
    VT_TYPE_LABEL = 12,
    VT_HOW = 14,
    VT_HOW_LABEL = 16,
    VT_POSE = 18,
    VT_CMPR_IMAGE = 20,
    VT_URL = 22
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const flatbuffers::String *uid() const {
    return GetPointer<const flatbuffers::String *>(VT_UID);
  }
  const flatbuffers::String *callsign() const {
    return GetPointer<const flatbuffers::String *>(VT_CALLSIGN);
  }
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::String *type_label() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE_LABEL);
  }
  const flatbuffers::String *how() const {
    return GetPointer<const flatbuffers::String *>(VT_HOW);
  }
  const flatbuffers::String *how_label() const {
    return GetPointer<const flatbuffers::String *>(VT_HOW_LABEL);
  }
  const fb::geometry_msgs::PoseStamped *pose() const {
    return GetPointer<const fb::geometry_msgs::PoseStamped *>(VT_POSE);
  }
  const fb::sensor_msgs::CompressedImage *cmpr_image() const {
    return GetPointer<const fb::sensor_msgs::CompressedImage *>(VT_CMPR_IMAGE);
  }
  const flatbuffers::String *url() const {
    return GetPointer<const flatbuffers::String *>(VT_URL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_UID) &&
           verifier.VerifyString(uid()) &&
           VerifyOffsetRequired(verifier, VT_CALLSIGN) &&
           verifier.VerifyString(callsign()) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffsetRequired(verifier, VT_TYPE_LABEL) &&
           verifier.VerifyString(type_label()) &&
           VerifyOffsetRequired(verifier, VT_HOW) &&
           verifier.VerifyString(how()) &&
           VerifyOffsetRequired(verifier, VT_HOW_LABEL) &&
           verifier.VerifyString(how_label()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           VerifyOffsetRequired(verifier, VT_CMPR_IMAGE) &&
           verifier.VerifyTable(cmpr_image()) &&
           VerifyOffsetRequired(verifier, VT_URL) &&
           verifier.VerifyString(url()) &&
           verifier.EndTable();
  }
  DetectedItemT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DetectedItemT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DetectedItem> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DetectedItemT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DetectedItemBuilder {
  typedef DetectedItem Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(DetectedItem::VT___METADATA, __metadata);
  }
  void add_uid(flatbuffers::Offset<flatbuffers::String> uid) {
    fbb_.AddOffset(DetectedItem::VT_UID, uid);
  }
  void add_callsign(flatbuffers::Offset<flatbuffers::String> callsign) {
    fbb_.AddOffset(DetectedItem::VT_CALLSIGN, callsign);
  }
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(DetectedItem::VT_TYPE, type);
  }
  void add_type_label(flatbuffers::Offset<flatbuffers::String> type_label) {
    fbb_.AddOffset(DetectedItem::VT_TYPE_LABEL, type_label);
  }
  void add_how(flatbuffers::Offset<flatbuffers::String> how) {
    fbb_.AddOffset(DetectedItem::VT_HOW, how);
  }
  void add_how_label(flatbuffers::Offset<flatbuffers::String> how_label) {
    fbb_.AddOffset(DetectedItem::VT_HOW_LABEL, how_label);
  }
  void add_pose(flatbuffers::Offset<fb::geometry_msgs::PoseStamped> pose) {
    fbb_.AddOffset(DetectedItem::VT_POSE, pose);
  }
  void add_cmpr_image(flatbuffers::Offset<fb::sensor_msgs::CompressedImage> cmpr_image) {
    fbb_.AddOffset(DetectedItem::VT_CMPR_IMAGE, cmpr_image);
  }
  void add_url(flatbuffers::Offset<flatbuffers::String> url) {
    fbb_.AddOffset(DetectedItem::VT_URL, url);
  }
  explicit DetectedItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DetectedItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DetectedItem>(end);
    fbb_.Required(o, DetectedItem::VT_UID);
    fbb_.Required(o, DetectedItem::VT_CALLSIGN);
    fbb_.Required(o, DetectedItem::VT_TYPE);
    fbb_.Required(o, DetectedItem::VT_TYPE_LABEL);
    fbb_.Required(o, DetectedItem::VT_HOW);
    fbb_.Required(o, DetectedItem::VT_HOW_LABEL);
    fbb_.Required(o, DetectedItem::VT_POSE);
    fbb_.Required(o, DetectedItem::VT_CMPR_IMAGE);
    fbb_.Required(o, DetectedItem::VT_URL);
    return o;
  }
};

inline flatbuffers::Offset<DetectedItem> CreateDetectedItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<flatbuffers::String> uid = 0,
    flatbuffers::Offset<flatbuffers::String> callsign = 0,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::String> type_label = 0,
    flatbuffers::Offset<flatbuffers::String> how = 0,
    flatbuffers::Offset<flatbuffers::String> how_label = 0,
    flatbuffers::Offset<fb::geometry_msgs::PoseStamped> pose = 0,
    flatbuffers::Offset<fb::sensor_msgs::CompressedImage> cmpr_image = 0,
    flatbuffers::Offset<flatbuffers::String> url = 0) {
  DetectedItemBuilder builder_(_fbb);
  builder_.add_url(url);
  builder_.add_cmpr_image(cmpr_image);
  builder_.add_pose(pose);
  builder_.add_how_label(how_label);
  builder_.add_how(how);
  builder_.add_type_label(type_label);
  builder_.add_type(type);
  builder_.add_callsign(callsign);
  builder_.add_uid(uid);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<DetectedItem> CreateDetectedItemDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *uid = nullptr,
    const char *callsign = nullptr,
    const char *type = nullptr,
    const char *type_label = nullptr,
    const char *how = nullptr,
    const char *how_label = nullptr,
    flatbuffers::Offset<fb::geometry_msgs::PoseStamped> pose = 0,
    flatbuffers::Offset<fb::sensor_msgs::CompressedImage> cmpr_image = 0,
    const char *url = nullptr) {
  auto uid__ = uid ? _fbb.CreateString(uid) : 0;
  auto callsign__ = callsign ? _fbb.CreateString(callsign) : 0;
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto type_label__ = type_label ? _fbb.CreateString(type_label) : 0;
  auto how__ = how ? _fbb.CreateString(how) : 0;
  auto how_label__ = how_label ? _fbb.CreateString(how_label) : 0;
  auto url__ = url ? _fbb.CreateString(url) : 0;
  return fb::augre_msgs::CreateDetectedItem(
      _fbb,
      __metadata,
      uid__,
      callsign__,
      type__,
      type_label__,
      how__,
      how_label__,
      pose,
      cmpr_image,
      url__);
}

flatbuffers::Offset<DetectedItem> CreateDetectedItem(flatbuffers::FlatBufferBuilder &_fbb, const DetectedItemT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransformWithCovarianceStampedT : public flatbuffers::NativeTable {
  typedef TransformWithCovarianceStamped TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::geometry_msgs::TransformStampedT> transform;
  std::vector<float> covariance;
  TransformWithCovarianceStampedT() {
  }
};

struct TransformWithCovarianceStamped FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TransformWithCovarianceStampedT NativeTableType;
  typedef TransformWithCovarianceStampedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_TRANSFORM = 6,
    VT_COVARIANCE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::TransformStamped *transform() const {
    return GetPointer<const fb::geometry_msgs::TransformStamped *>(VT_TRANSFORM);
  }
  const flatbuffers::Vector<float> *covariance() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_COVARIANCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_TRANSFORM) &&
           verifier.VerifyTable(transform()) &&
           VerifyOffsetRequired(verifier, VT_COVARIANCE) &&
           verifier.VerifyVector(covariance()) &&
           verifier.EndTable();
  }
  TransformWithCovarianceStampedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransformWithCovarianceStampedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TransformWithCovarianceStamped> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransformWithCovarianceStampedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransformWithCovarianceStampedBuilder {
  typedef TransformWithCovarianceStamped Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(TransformWithCovarianceStamped::VT___METADATA, __metadata);
  }
  void add_transform(flatbuffers::Offset<fb::geometry_msgs::TransformStamped> transform) {
    fbb_.AddOffset(TransformWithCovarianceStamped::VT_TRANSFORM, transform);
  }
  void add_covariance(flatbuffers::Offset<flatbuffers::Vector<float>> covariance) {
    fbb_.AddOffset(TransformWithCovarianceStamped::VT_COVARIANCE, covariance);
  }
  explicit TransformWithCovarianceStampedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TransformWithCovarianceStamped> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TransformWithCovarianceStamped>(end);
    fbb_.Required(o, TransformWithCovarianceStamped::VT_TRANSFORM);
    fbb_.Required(o, TransformWithCovarianceStamped::VT_COVARIANCE);
    return o;
  }
};

inline flatbuffers::Offset<TransformWithCovarianceStamped> CreateTransformWithCovarianceStamped(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::geometry_msgs::TransformStamped> transform = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> covariance = 0) {
  TransformWithCovarianceStampedBuilder builder_(_fbb);
  builder_.add_covariance(covariance);
  builder_.add_transform(transform);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<TransformWithCovarianceStamped> CreateTransformWithCovarianceStampedDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::geometry_msgs::TransformStamped> transform = 0,
    const std::vector<float> *covariance = nullptr) {
  auto covariance__ = covariance ? _fbb.CreateVector<float>(*covariance) : 0;
  return fb::augre_msgs::CreateTransformWithCovarianceStamped(
      _fbb,
      __metadata,
      transform,
      covariance__);
}

flatbuffers::Offset<TransformWithCovarianceStamped> CreateTransformWithCovarianceStamped(flatbuffers::FlatBufferBuilder &_fbb, const TransformWithCovarianceStampedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace augre_msgs

namespace asa_db_portal {

struct AzureSpatialAnchorT : public flatbuffers::NativeTable {
  typedef AzureSpatialAnchor TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::string asa_id;
  std::string rep_id;
  std::string ns;
  std::unique_ptr<fb::RosTime> timestamp;
  std::unique_ptr<fb::geometry_msgs::PoseWithCovarianceStampedT> pose;
  std::unique_ptr<fb::geographic_msgs::GeoPoseWithCovarianceStampedT> geopose;
  std::vector<std::string> neighbors;
  AzureSpatialAnchorT() {
  }
};

struct AzureSpatialAnchor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AzureSpatialAnchorT NativeTableType;
  typedef AzureSpatialAnchorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_ASA_ID = 6,
    VT_REP_ID = 8,
    VT_NS = 10,
    VT_TIMESTAMP = 12,
    VT_POSE = 14,
    VT_GEOPOSE = 16,
    VT_NEIGHBORS = 18
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const flatbuffers::String *asa_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ASA_ID);
  }
  const flatbuffers::String *rep_id() const {
    return GetPointer<const flatbuffers::String *>(VT_REP_ID);
  }
  const flatbuffers::String *ns() const {
    return GetPointer<const flatbuffers::String *>(VT_NS);
  }
  const fb::RosTime *timestamp() const {
    return GetStruct<const fb::RosTime *>(VT_TIMESTAMP);
  }
  const fb::geometry_msgs::PoseWithCovarianceStamped *pose() const {
    return GetPointer<const fb::geometry_msgs::PoseWithCovarianceStamped *>(VT_POSE);
  }
  const fb::geographic_msgs::GeoPoseWithCovarianceStamped *geopose() const {
    return GetPointer<const fb::geographic_msgs::GeoPoseWithCovarianceStamped *>(VT_GEOPOSE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *neighbors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_NEIGHBORS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_ASA_ID) &&
           verifier.VerifyString(asa_id()) &&
           VerifyOffsetRequired(verifier, VT_REP_ID) &&
           verifier.VerifyString(rep_id()) &&
           VerifyOffsetRequired(verifier, VT_NS) &&
           verifier.VerifyString(ns()) &&
           VerifyFieldRequired<fb::RosTime>(verifier, VT_TIMESTAMP) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           VerifyOffsetRequired(verifier, VT_GEOPOSE) &&
           verifier.VerifyTable(geopose()) &&
           VerifyOffsetRequired(verifier, VT_NEIGHBORS) &&
           verifier.VerifyVector(neighbors()) &&
           verifier.VerifyVectorOfStrings(neighbors()) &&
           verifier.EndTable();
  }
  AzureSpatialAnchorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AzureSpatialAnchorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AzureSpatialAnchor> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AzureSpatialAnchorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AzureSpatialAnchorBuilder {
  typedef AzureSpatialAnchor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(AzureSpatialAnchor::VT___METADATA, __metadata);
  }
  void add_asa_id(flatbuffers::Offset<flatbuffers::String> asa_id) {
    fbb_.AddOffset(AzureSpatialAnchor::VT_ASA_ID, asa_id);
  }
  void add_rep_id(flatbuffers::Offset<flatbuffers::String> rep_id) {
    fbb_.AddOffset(AzureSpatialAnchor::VT_REP_ID, rep_id);
  }
  void add_ns(flatbuffers::Offset<flatbuffers::String> ns) {
    fbb_.AddOffset(AzureSpatialAnchor::VT_NS, ns);
  }
  void add_timestamp(const fb::RosTime *timestamp) {
    fbb_.AddStruct(AzureSpatialAnchor::VT_TIMESTAMP, timestamp);
  }
  void add_pose(flatbuffers::Offset<fb::geometry_msgs::PoseWithCovarianceStamped> pose) {
    fbb_.AddOffset(AzureSpatialAnchor::VT_POSE, pose);
  }
  void add_geopose(flatbuffers::Offset<fb::geographic_msgs::GeoPoseWithCovarianceStamped> geopose) {
    fbb_.AddOffset(AzureSpatialAnchor::VT_GEOPOSE, geopose);
  }
  void add_neighbors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> neighbors) {
    fbb_.AddOffset(AzureSpatialAnchor::VT_NEIGHBORS, neighbors);
  }
  explicit AzureSpatialAnchorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AzureSpatialAnchor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AzureSpatialAnchor>(end);
    fbb_.Required(o, AzureSpatialAnchor::VT_ASA_ID);
    fbb_.Required(o, AzureSpatialAnchor::VT_REP_ID);
    fbb_.Required(o, AzureSpatialAnchor::VT_NS);
    fbb_.Required(o, AzureSpatialAnchor::VT_TIMESTAMP);
    fbb_.Required(o, AzureSpatialAnchor::VT_POSE);
    fbb_.Required(o, AzureSpatialAnchor::VT_GEOPOSE);
    fbb_.Required(o, AzureSpatialAnchor::VT_NEIGHBORS);
    return o;
  }
};

inline flatbuffers::Offset<AzureSpatialAnchor> CreateAzureSpatialAnchor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<flatbuffers::String> asa_id = 0,
    flatbuffers::Offset<flatbuffers::String> rep_id = 0,
    flatbuffers::Offset<flatbuffers::String> ns = 0,
    const fb::RosTime *timestamp = 0,
    flatbuffers::Offset<fb::geometry_msgs::PoseWithCovarianceStamped> pose = 0,
    flatbuffers::Offset<fb::geographic_msgs::GeoPoseWithCovarianceStamped> geopose = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> neighbors = 0) {
  AzureSpatialAnchorBuilder builder_(_fbb);
  builder_.add_neighbors(neighbors);
  builder_.add_geopose(geopose);
  builder_.add_pose(pose);
  builder_.add_timestamp(timestamp);
  builder_.add_ns(ns);
  builder_.add_rep_id(rep_id);
  builder_.add_asa_id(asa_id);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<AzureSpatialAnchor> CreateAzureSpatialAnchorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *asa_id = nullptr,
    const char *rep_id = nullptr,
    const char *ns = nullptr,
    const fb::RosTime *timestamp = 0,
    flatbuffers::Offset<fb::geometry_msgs::PoseWithCovarianceStamped> pose = 0,
    flatbuffers::Offset<fb::geographic_msgs::GeoPoseWithCovarianceStamped> geopose = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *neighbors = nullptr) {
  auto asa_id__ = asa_id ? _fbb.CreateString(asa_id) : 0;
  auto rep_id__ = rep_id ? _fbb.CreateString(rep_id) : 0;
  auto ns__ = ns ? _fbb.CreateString(ns) : 0;
  auto neighbors__ = neighbors ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*neighbors) : 0;
  return fb::asa_db_portal::CreateAzureSpatialAnchor(
      _fbb,
      __metadata,
      asa_id__,
      rep_id__,
      ns__,
      timestamp,
      pose,
      geopose,
      neighbors__);
}

flatbuffers::Offset<AzureSpatialAnchor> CreateAzureSpatialAnchor(flatbuffers::FlatBufferBuilder &_fbb, const AzureSpatialAnchorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace asa_db_portal

namespace amrl_msgs {

struct RobofleetStatusT : public flatbuffers::NativeTable {
  typedef RobofleetStatus TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::string status;
  bool is_ok;
  float battery_level;
  std::string location;
  RobofleetStatusT()
      : is_ok(false),
        battery_level(0.0f) {
  }
};

struct RobofleetStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RobofleetStatusT NativeTableType;
  typedef RobofleetStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_STATUS = 6,
    VT_IS_OK = 8,
    VT_BATTERY_LEVEL = 10,
    VT_LOCATION = 12
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const flatbuffers::String *status() const {
    return GetPointer<const flatbuffers::String *>(VT_STATUS);
  }
  bool is_ok() const {
    return GetField<uint8_t>(VT_IS_OK, 0) != 0;
  }
  float battery_level() const {
    return GetField<float>(VT_BATTERY_LEVEL, 0.0f);
  }
  const flatbuffers::String *location() const {
    return GetPointer<const flatbuffers::String *>(VT_LOCATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_STATUS) &&
           verifier.VerifyString(status()) &&
           VerifyField<uint8_t>(verifier, VT_IS_OK) &&
           VerifyField<float>(verifier, VT_BATTERY_LEVEL) &&
           VerifyOffsetRequired(verifier, VT_LOCATION) &&
           verifier.VerifyString(location()) &&
           verifier.EndTable();
  }
  RobofleetStatusT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RobofleetStatusT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RobofleetStatus> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RobofleetStatusT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RobofleetStatusBuilder {
  typedef RobofleetStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(RobofleetStatus::VT___METADATA, __metadata);
  }
  void add_status(flatbuffers::Offset<flatbuffers::String> status) {
    fbb_.AddOffset(RobofleetStatus::VT_STATUS, status);
  }
  void add_is_ok(bool is_ok) {
    fbb_.AddElement<uint8_t>(RobofleetStatus::VT_IS_OK, static_cast<uint8_t>(is_ok), 0);
  }
  void add_battery_level(float battery_level) {
    fbb_.AddElement<float>(RobofleetStatus::VT_BATTERY_LEVEL, battery_level, 0.0f);
  }
  void add_location(flatbuffers::Offset<flatbuffers::String> location) {
    fbb_.AddOffset(RobofleetStatus::VT_LOCATION, location);
  }
  explicit RobofleetStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RobofleetStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RobofleetStatus>(end);
    fbb_.Required(o, RobofleetStatus::VT_STATUS);
    fbb_.Required(o, RobofleetStatus::VT_LOCATION);
    return o;
  }
};

inline flatbuffers::Offset<RobofleetStatus> CreateRobofleetStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<flatbuffers::String> status = 0,
    bool is_ok = false,
    float battery_level = 0.0f,
    flatbuffers::Offset<flatbuffers::String> location = 0) {
  RobofleetStatusBuilder builder_(_fbb);
  builder_.add_location(location);
  builder_.add_battery_level(battery_level);
  builder_.add_status(status);
  builder_.add___metadata(__metadata);
  builder_.add_is_ok(is_ok);
  return builder_.Finish();
}

inline flatbuffers::Offset<RobofleetStatus> CreateRobofleetStatusDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *status = nullptr,
    bool is_ok = false,
    float battery_level = 0.0f,
    const char *location = nullptr) {
  auto status__ = status ? _fbb.CreateString(status) : 0;
  auto location__ = location ? _fbb.CreateString(location) : 0;
  return fb::amrl_msgs::CreateRobofleetStatus(
      _fbb,
      __metadata,
      status__,
      is_ok,
      battery_level,
      location__);
}

flatbuffers::Offset<RobofleetStatus> CreateRobofleetStatus(flatbuffers::FlatBufferBuilder &_fbb, const RobofleetStatusT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RobofleetSubscriptionT : public flatbuffers::NativeTable {
  typedef RobofleetSubscription TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::string topic_regex;
  uint8_t action;
  RobofleetSubscriptionT()
      : action(0) {
  }
};

struct RobofleetSubscription FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RobofleetSubscriptionT NativeTableType;
  typedef RobofleetSubscriptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_TOPIC_REGEX = 6,
    VT_ACTION = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const flatbuffers::String *topic_regex() const {
    return GetPointer<const flatbuffers::String *>(VT_TOPIC_REGEX);
  }
  uint8_t action() const {
    return GetField<uint8_t>(VT_ACTION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_TOPIC_REGEX) &&
           verifier.VerifyString(topic_regex()) &&
           VerifyField<uint8_t>(verifier, VT_ACTION) &&
           verifier.EndTable();
  }
  RobofleetSubscriptionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RobofleetSubscriptionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RobofleetSubscription> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RobofleetSubscriptionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RobofleetSubscriptionBuilder {
  typedef RobofleetSubscription Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(RobofleetSubscription::VT___METADATA, __metadata);
  }
  void add_topic_regex(flatbuffers::Offset<flatbuffers::String> topic_regex) {
    fbb_.AddOffset(RobofleetSubscription::VT_TOPIC_REGEX, topic_regex);
  }
  void add_action(uint8_t action) {
    fbb_.AddElement<uint8_t>(RobofleetSubscription::VT_ACTION, action, 0);
  }
  explicit RobofleetSubscriptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RobofleetSubscription> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RobofleetSubscription>(end);
    fbb_.Required(o, RobofleetSubscription::VT_TOPIC_REGEX);
    return o;
  }
};

inline flatbuffers::Offset<RobofleetSubscription> CreateRobofleetSubscription(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<flatbuffers::String> topic_regex = 0,
    uint8_t action = 0) {
  RobofleetSubscriptionBuilder builder_(_fbb);
  builder_.add_topic_regex(topic_regex);
  builder_.add___metadata(__metadata);
  builder_.add_action(action);
  return builder_.Finish();
}

inline flatbuffers::Offset<RobofleetSubscription> CreateRobofleetSubscriptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *topic_regex = nullptr,
    uint8_t action = 0) {
  auto topic_regex__ = topic_regex ? _fbb.CreateString(topic_regex) : 0;
  return fb::amrl_msgs::CreateRobofleetSubscription(
      _fbb,
      __metadata,
      topic_regex__,
      action);
}

flatbuffers::Offset<RobofleetSubscription> CreateRobofleetSubscription(flatbuffers::FlatBufferBuilder &_fbb, const RobofleetSubscriptionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ElevatorStatusT : public flatbuffers::NativeTable {
  typedef ElevatorStatus TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  uint8_t floor;
  uint8_t door;
  ElevatorStatusT()
      : floor(0),
        door(0) {
  }
};

struct ElevatorStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ElevatorStatusT NativeTableType;
  typedef ElevatorStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_FLOOR = 6,
    VT_DOOR = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  uint8_t floor() const {
    return GetField<uint8_t>(VT_FLOOR, 0);
  }
  uint8_t door() const {
    return GetField<uint8_t>(VT_DOOR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint8_t>(verifier, VT_FLOOR) &&
           VerifyField<uint8_t>(verifier, VT_DOOR) &&
           verifier.EndTable();
  }
  ElevatorStatusT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ElevatorStatusT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ElevatorStatus> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ElevatorStatusT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ElevatorStatusBuilder {
  typedef ElevatorStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ElevatorStatus::VT___METADATA, __metadata);
  }
  void add_floor(uint8_t floor) {
    fbb_.AddElement<uint8_t>(ElevatorStatus::VT_FLOOR, floor, 0);
  }
  void add_door(uint8_t door) {
    fbb_.AddElement<uint8_t>(ElevatorStatus::VT_DOOR, door, 0);
  }
  explicit ElevatorStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ElevatorStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ElevatorStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<ElevatorStatus> CreateElevatorStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint8_t floor = 0,
    uint8_t door = 0) {
  ElevatorStatusBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  builder_.add_door(door);
  builder_.add_floor(floor);
  return builder_.Finish();
}

flatbuffers::Offset<ElevatorStatus> CreateElevatorStatus(flatbuffers::FlatBufferBuilder &_fbb, const ElevatorStatusT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ElevatorCommandT : public flatbuffers::NativeTable {
  typedef ElevatorCommand TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  uint8_t floor_cmd;
  bool hold_door;
  ElevatorCommandT()
      : floor_cmd(0),
        hold_door(false) {
  }
};

struct ElevatorCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ElevatorCommandT NativeTableType;
  typedef ElevatorCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_FLOOR_CMD = 6,
    VT_HOLD_DOOR = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  uint8_t floor_cmd() const {
    return GetField<uint8_t>(VT_FLOOR_CMD, 0);
  }
  bool hold_door() const {
    return GetField<uint8_t>(VT_HOLD_DOOR, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<uint8_t>(verifier, VT_FLOOR_CMD) &&
           VerifyField<uint8_t>(verifier, VT_HOLD_DOOR) &&
           verifier.EndTable();
  }
  ElevatorCommandT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ElevatorCommandT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ElevatorCommand> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ElevatorCommandT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ElevatorCommandBuilder {
  typedef ElevatorCommand Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ElevatorCommand::VT___METADATA, __metadata);
  }
  void add_floor_cmd(uint8_t floor_cmd) {
    fbb_.AddElement<uint8_t>(ElevatorCommand::VT_FLOOR_CMD, floor_cmd, 0);
  }
  void add_hold_door(bool hold_door) {
    fbb_.AddElement<uint8_t>(ElevatorCommand::VT_HOLD_DOOR, static_cast<uint8_t>(hold_door), 0);
  }
  explicit ElevatorCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ElevatorCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ElevatorCommand>(end);
    return o;
  }
};

inline flatbuffers::Offset<ElevatorCommand> CreateElevatorCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    uint8_t floor_cmd = 0,
    bool hold_door = false) {
  ElevatorCommandBuilder builder_(_fbb);
  builder_.add___metadata(__metadata);
  builder_.add_hold_door(hold_door);
  builder_.add_floor_cmd(floor_cmd);
  return builder_.Finish();
}

flatbuffers::Offset<ElevatorCommand> CreateElevatorCommand(flatbuffers::FlatBufferBuilder &_fbb, const ElevatorCommandT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Pose2DfT : public flatbuffers::NativeTable {
  typedef Pose2Df TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  float x;
  float y;
  float theta;
  Pose2DfT()
      : x(0.0f),
        y(0.0f),
        theta(0.0f) {
  }
};

struct Pose2Df FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Pose2DfT NativeTableType;
  typedef Pose2DfBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_THETA = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float theta() const {
    return GetField<float>(VT_THETA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<float>(verifier, VT_X) &&
           VerifyField<float>(verifier, VT_Y) &&
           VerifyField<float>(verifier, VT_THETA) &&
           verifier.EndTable();
  }
  Pose2DfT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Pose2DfT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pose2Df> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pose2DfT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Pose2DfBuilder {
  typedef Pose2Df Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Pose2Df::VT___METADATA, __metadata);
  }
  void add_x(float x) {
    fbb_.AddElement<float>(Pose2Df::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Pose2Df::VT_Y, y, 0.0f);
  }
  void add_theta(float theta) {
    fbb_.AddElement<float>(Pose2Df::VT_THETA, theta, 0.0f);
  }
  explicit Pose2DfBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Pose2Df> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pose2Df>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pose2Df> CreatePose2Df(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    float x = 0.0f,
    float y = 0.0f,
    float theta = 0.0f) {
  Pose2DfBuilder builder_(_fbb);
  builder_.add_theta(theta);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<Pose2Df> CreatePose2Df(flatbuffers::FlatBufferBuilder &_fbb, const Pose2DfT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Localization2DMsgT : public flatbuffers::NativeTable {
  typedef Localization2DMsg TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::std_msgs::HeaderT> header;
  std::unique_ptr<fb::amrl_msgs::Pose2DfT> pose;
  std::string map;
  Localization2DMsgT() {
  }
};

struct Localization2DMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Localization2DMsgT NativeTableType;
  typedef Localization2DMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_POSE = 8,
    VT_MAP = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const fb::amrl_msgs::Pose2Df *pose() const {
    return GetPointer<const fb::amrl_msgs::Pose2Df *>(VT_POSE);
  }
  const flatbuffers::String *map() const {
    return GetPointer<const flatbuffers::String *>(VT_MAP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           VerifyOffsetRequired(verifier, VT_MAP) &&
           verifier.VerifyString(map()) &&
           verifier.EndTable();
  }
  Localization2DMsgT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Localization2DMsgT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Localization2DMsg> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Localization2DMsgT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Localization2DMsgBuilder {
  typedef Localization2DMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Localization2DMsg::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(Localization2DMsg::VT_HEADER, header);
  }
  void add_pose(flatbuffers::Offset<fb::amrl_msgs::Pose2Df> pose) {
    fbb_.AddOffset(Localization2DMsg::VT_POSE, pose);
  }
  void add_map(flatbuffers::Offset<flatbuffers::String> map) {
    fbb_.AddOffset(Localization2DMsg::VT_MAP, map);
  }
  explicit Localization2DMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Localization2DMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Localization2DMsg>(end);
    fbb_.Required(o, Localization2DMsg::VT_HEADER);
    fbb_.Required(o, Localization2DMsg::VT_POSE);
    fbb_.Required(o, Localization2DMsg::VT_MAP);
    return o;
  }
};

inline flatbuffers::Offset<Localization2DMsg> CreateLocalization2DMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<fb::amrl_msgs::Pose2Df> pose = 0,
    flatbuffers::Offset<flatbuffers::String> map = 0) {
  Localization2DMsgBuilder builder_(_fbb);
  builder_.add_map(map);
  builder_.add_pose(pose);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<Localization2DMsg> CreateLocalization2DMsgDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<fb::amrl_msgs::Pose2Df> pose = 0,
    const char *map = nullptr) {
  auto map__ = map ? _fbb.CreateString(map) : 0;
  return fb::amrl_msgs::CreateLocalization2DMsg(
      _fbb,
      __metadata,
      header,
      pose,
      map__);
}

flatbuffers::Offset<Localization2DMsg> CreateLocalization2DMsg(flatbuffers::FlatBufferBuilder &_fbb, const Localization2DMsgT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PathVisualizationT : public flatbuffers::NativeTable {
  typedef PathVisualization TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  float curvature;
  float distance;
  float clearance;
  PathVisualizationT()
      : curvature(0.0f),
        distance(0.0f),
        clearance(0.0f) {
  }
};

struct PathVisualization FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PathVisualizationT NativeTableType;
  typedef PathVisualizationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_CURVATURE = 6,
    VT_DISTANCE = 8,
    VT_CLEARANCE = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  float curvature() const {
    return GetField<float>(VT_CURVATURE, 0.0f);
  }
  float distance() const {
    return GetField<float>(VT_DISTANCE, 0.0f);
  }
  float clearance() const {
    return GetField<float>(VT_CLEARANCE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<float>(verifier, VT_CURVATURE) &&
           VerifyField<float>(verifier, VT_DISTANCE) &&
           VerifyField<float>(verifier, VT_CLEARANCE) &&
           verifier.EndTable();
  }
  PathVisualizationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PathVisualizationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PathVisualization> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PathVisualizationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PathVisualizationBuilder {
  typedef PathVisualization Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PathVisualization::VT___METADATA, __metadata);
  }
  void add_curvature(float curvature) {
    fbb_.AddElement<float>(PathVisualization::VT_CURVATURE, curvature, 0.0f);
  }
  void add_distance(float distance) {
    fbb_.AddElement<float>(PathVisualization::VT_DISTANCE, distance, 0.0f);
  }
  void add_clearance(float clearance) {
    fbb_.AddElement<float>(PathVisualization::VT_CLEARANCE, clearance, 0.0f);
  }
  explicit PathVisualizationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PathVisualization> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PathVisualization>(end);
    return o;
  }
};

inline flatbuffers::Offset<PathVisualization> CreatePathVisualization(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    float curvature = 0.0f,
    float distance = 0.0f,
    float clearance = 0.0f) {
  PathVisualizationBuilder builder_(_fbb);
  builder_.add_clearance(clearance);
  builder_.add_distance(distance);
  builder_.add_curvature(curvature);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<PathVisualization> CreatePathVisualization(flatbuffers::FlatBufferBuilder &_fbb, const PathVisualizationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Point2DT : public flatbuffers::NativeTable {
  typedef Point2D TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  float x;
  float y;
  Point2DT()
      : x(0.0f),
        y(0.0f) {
  }
};

struct Point2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Point2DT NativeTableType;
  typedef Point2DBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_X = 6,
    VT_Y = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyField<float>(verifier, VT_X) &&
           VerifyField<float>(verifier, VT_Y) &&
           verifier.EndTable();
  }
  Point2DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Point2DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Point2D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Point2DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Point2DBuilder {
  typedef Point2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Point2D::VT___METADATA, __metadata);
  }
  void add_x(float x) {
    fbb_.AddElement<float>(Point2D::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Point2D::VT_Y, y, 0.0f);
  }
  explicit Point2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Point2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Point2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<Point2D> CreatePoint2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    float x = 0.0f,
    float y = 0.0f) {
  Point2DBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<Point2D> CreatePoint2D(flatbuffers::FlatBufferBuilder &_fbb, const Point2DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ColoredPoint2DT : public flatbuffers::NativeTable {
  typedef ColoredPoint2D TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::amrl_msgs::Point2DT> point;
  uint32_t color;
  ColoredPoint2DT()
      : color(0) {
  }
};

struct ColoredPoint2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ColoredPoint2DT NativeTableType;
  typedef ColoredPoint2DBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_POINT = 6,
    VT_COLOR = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::amrl_msgs::Point2D *point() const {
    return GetPointer<const fb::amrl_msgs::Point2D *>(VT_POINT);
  }
  uint32_t color() const {
    return GetField<uint32_t>(VT_COLOR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_POINT) &&
           verifier.VerifyTable(point()) &&
           VerifyField<uint32_t>(verifier, VT_COLOR) &&
           verifier.EndTable();
  }
  ColoredPoint2DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ColoredPoint2DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ColoredPoint2D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ColoredPoint2DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ColoredPoint2DBuilder {
  typedef ColoredPoint2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ColoredPoint2D::VT___METADATA, __metadata);
  }
  void add_point(flatbuffers::Offset<fb::amrl_msgs::Point2D> point) {
    fbb_.AddOffset(ColoredPoint2D::VT_POINT, point);
  }
  void add_color(uint32_t color) {
    fbb_.AddElement<uint32_t>(ColoredPoint2D::VT_COLOR, color, 0);
  }
  explicit ColoredPoint2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ColoredPoint2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ColoredPoint2D>(end);
    fbb_.Required(o, ColoredPoint2D::VT_POINT);
    return o;
  }
};

inline flatbuffers::Offset<ColoredPoint2D> CreateColoredPoint2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::amrl_msgs::Point2D> point = 0,
    uint32_t color = 0) {
  ColoredPoint2DBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_point(point);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<ColoredPoint2D> CreateColoredPoint2D(flatbuffers::FlatBufferBuilder &_fbb, const ColoredPoint2DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ColoredLine2DT : public flatbuffers::NativeTable {
  typedef ColoredLine2D TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::amrl_msgs::Point2DT> p0;
  std::unique_ptr<fb::amrl_msgs::Point2DT> p1;
  uint32_t color;
  ColoredLine2DT()
      : color(0) {
  }
};

struct ColoredLine2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ColoredLine2DT NativeTableType;
  typedef ColoredLine2DBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_P0 = 6,
    VT_P1 = 8,
    VT_COLOR = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::amrl_msgs::Point2D *p0() const {
    return GetPointer<const fb::amrl_msgs::Point2D *>(VT_P0);
  }
  const fb::amrl_msgs::Point2D *p1() const {
    return GetPointer<const fb::amrl_msgs::Point2D *>(VT_P1);
  }
  uint32_t color() const {
    return GetField<uint32_t>(VT_COLOR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_P0) &&
           verifier.VerifyTable(p0()) &&
           VerifyOffsetRequired(verifier, VT_P1) &&
           verifier.VerifyTable(p1()) &&
           VerifyField<uint32_t>(verifier, VT_COLOR) &&
           verifier.EndTable();
  }
  ColoredLine2DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ColoredLine2DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ColoredLine2D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ColoredLine2DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ColoredLine2DBuilder {
  typedef ColoredLine2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ColoredLine2D::VT___METADATA, __metadata);
  }
  void add_p0(flatbuffers::Offset<fb::amrl_msgs::Point2D> p0) {
    fbb_.AddOffset(ColoredLine2D::VT_P0, p0);
  }
  void add_p1(flatbuffers::Offset<fb::amrl_msgs::Point2D> p1) {
    fbb_.AddOffset(ColoredLine2D::VT_P1, p1);
  }
  void add_color(uint32_t color) {
    fbb_.AddElement<uint32_t>(ColoredLine2D::VT_COLOR, color, 0);
  }
  explicit ColoredLine2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ColoredLine2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ColoredLine2D>(end);
    fbb_.Required(o, ColoredLine2D::VT_P0);
    fbb_.Required(o, ColoredLine2D::VT_P1);
    return o;
  }
};

inline flatbuffers::Offset<ColoredLine2D> CreateColoredLine2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::amrl_msgs::Point2D> p0 = 0,
    flatbuffers::Offset<fb::amrl_msgs::Point2D> p1 = 0,
    uint32_t color = 0) {
  ColoredLine2DBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_p1(p1);
  builder_.add_p0(p0);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<ColoredLine2D> CreateColoredLine2D(flatbuffers::FlatBufferBuilder &_fbb, const ColoredLine2DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ColoredArc2DT : public flatbuffers::NativeTable {
  typedef ColoredArc2D TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::amrl_msgs::Point2DT> center;
  float radius;
  float start_angle;
  float end_angle;
  uint32_t color;
  ColoredArc2DT()
      : radius(0.0f),
        start_angle(0.0f),
        end_angle(0.0f),
        color(0) {
  }
};

struct ColoredArc2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ColoredArc2DT NativeTableType;
  typedef ColoredArc2DBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_CENTER = 6,
    VT_RADIUS = 8,
    VT_START_ANGLE = 10,
    VT_END_ANGLE = 12,
    VT_COLOR = 14
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::amrl_msgs::Point2D *center() const {
    return GetPointer<const fb::amrl_msgs::Point2D *>(VT_CENTER);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  float start_angle() const {
    return GetField<float>(VT_START_ANGLE, 0.0f);
  }
  float end_angle() const {
    return GetField<float>(VT_END_ANGLE, 0.0f);
  }
  uint32_t color() const {
    return GetField<uint32_t>(VT_COLOR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_CENTER) &&
           verifier.VerifyTable(center()) &&
           VerifyField<float>(verifier, VT_RADIUS) &&
           VerifyField<float>(verifier, VT_START_ANGLE) &&
           VerifyField<float>(verifier, VT_END_ANGLE) &&
           VerifyField<uint32_t>(verifier, VT_COLOR) &&
           verifier.EndTable();
  }
  ColoredArc2DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ColoredArc2DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ColoredArc2D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ColoredArc2DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ColoredArc2DBuilder {
  typedef ColoredArc2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(ColoredArc2D::VT___METADATA, __metadata);
  }
  void add_center(flatbuffers::Offset<fb::amrl_msgs::Point2D> center) {
    fbb_.AddOffset(ColoredArc2D::VT_CENTER, center);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(ColoredArc2D::VT_RADIUS, radius, 0.0f);
  }
  void add_start_angle(float start_angle) {
    fbb_.AddElement<float>(ColoredArc2D::VT_START_ANGLE, start_angle, 0.0f);
  }
  void add_end_angle(float end_angle) {
    fbb_.AddElement<float>(ColoredArc2D::VT_END_ANGLE, end_angle, 0.0f);
  }
  void add_color(uint32_t color) {
    fbb_.AddElement<uint32_t>(ColoredArc2D::VT_COLOR, color, 0);
  }
  explicit ColoredArc2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ColoredArc2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ColoredArc2D>(end);
    fbb_.Required(o, ColoredArc2D::VT_CENTER);
    return o;
  }
};

inline flatbuffers::Offset<ColoredArc2D> CreateColoredArc2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::amrl_msgs::Point2D> center = 0,
    float radius = 0.0f,
    float start_angle = 0.0f,
    float end_angle = 0.0f,
    uint32_t color = 0) {
  ColoredArc2DBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_end_angle(end_angle);
  builder_.add_start_angle(start_angle);
  builder_.add_radius(radius);
  builder_.add_center(center);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<ColoredArc2D> CreateColoredArc2D(flatbuffers::FlatBufferBuilder &_fbb, const ColoredArc2DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct VisualizationMsgT : public flatbuffers::NativeTable {
  typedef VisualizationMsg TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::std_msgs::HeaderT> header;
  std::string ns;
  std::vector<std::unique_ptr<fb::amrl_msgs::Pose2DfT>> particles;
  std::vector<std::unique_ptr<fb::amrl_msgs::PathVisualizationT>> path_options;
  std::vector<std::unique_ptr<fb::amrl_msgs::ColoredPoint2DT>> points;
  std::vector<std::unique_ptr<fb::amrl_msgs::ColoredLine2DT>> lines;
  std::vector<std::unique_ptr<fb::amrl_msgs::ColoredArc2DT>> arcs;
  VisualizationMsgT() {
  }
};

struct VisualizationMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VisualizationMsgT NativeTableType;
  typedef VisualizationMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_NS = 8,
    VT_PARTICLES = 10,
    VT_PATH_OPTIONS = 12,
    VT_POINTS = 14,
    VT_LINES = 16,
    VT_ARCS = 18
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const flatbuffers::String *ns() const {
    return GetPointer<const flatbuffers::String *>(VT_NS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> *particles() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> *>(VT_PARTICLES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::PathVisualization>> *path_options() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::PathVisualization>> *>(VT_PATH_OPTIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::ColoredPoint2D>> *points() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::ColoredPoint2D>> *>(VT_POINTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::ColoredLine2D>> *lines() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::ColoredLine2D>> *>(VT_LINES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::ColoredArc2D>> *arcs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::ColoredArc2D>> *>(VT_ARCS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_NS) &&
           verifier.VerifyString(ns()) &&
           VerifyOffsetRequired(verifier, VT_PARTICLES) &&
           verifier.VerifyVector(particles()) &&
           verifier.VerifyVectorOfTables(particles()) &&
           VerifyOffsetRequired(verifier, VT_PATH_OPTIONS) &&
           verifier.VerifyVector(path_options()) &&
           verifier.VerifyVectorOfTables(path_options()) &&
           VerifyOffsetRequired(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.VerifyVectorOfTables(points()) &&
           VerifyOffsetRequired(verifier, VT_LINES) &&
           verifier.VerifyVector(lines()) &&
           verifier.VerifyVectorOfTables(lines()) &&
           VerifyOffsetRequired(verifier, VT_ARCS) &&
           verifier.VerifyVector(arcs()) &&
           verifier.VerifyVectorOfTables(arcs()) &&
           verifier.EndTable();
  }
  VisualizationMsgT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VisualizationMsgT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<VisualizationMsg> Pack(flatbuffers::FlatBufferBuilder &_fbb, const VisualizationMsgT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VisualizationMsgBuilder {
  typedef VisualizationMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(VisualizationMsg::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(VisualizationMsg::VT_HEADER, header);
  }
  void add_ns(flatbuffers::Offset<flatbuffers::String> ns) {
    fbb_.AddOffset(VisualizationMsg::VT_NS, ns);
  }
  void add_particles(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::Pose2Df>>> particles) {
    fbb_.AddOffset(VisualizationMsg::VT_PARTICLES, particles);
  }
  void add_path_options(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::PathVisualization>>> path_options) {
    fbb_.AddOffset(VisualizationMsg::VT_PATH_OPTIONS, path_options);
  }
  void add_points(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::ColoredPoint2D>>> points) {
    fbb_.AddOffset(VisualizationMsg::VT_POINTS, points);
  }
  void add_lines(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::ColoredLine2D>>> lines) {
    fbb_.AddOffset(VisualizationMsg::VT_LINES, lines);
  }
  void add_arcs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::ColoredArc2D>>> arcs) {
    fbb_.AddOffset(VisualizationMsg::VT_ARCS, arcs);
  }
  explicit VisualizationMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VisualizationMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VisualizationMsg>(end);
    fbb_.Required(o, VisualizationMsg::VT_HEADER);
    fbb_.Required(o, VisualizationMsg::VT_NS);
    fbb_.Required(o, VisualizationMsg::VT_PARTICLES);
    fbb_.Required(o, VisualizationMsg::VT_PATH_OPTIONS);
    fbb_.Required(o, VisualizationMsg::VT_POINTS);
    fbb_.Required(o, VisualizationMsg::VT_LINES);
    fbb_.Required(o, VisualizationMsg::VT_ARCS);
    return o;
  }
};

inline flatbuffers::Offset<VisualizationMsg> CreateVisualizationMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<flatbuffers::String> ns = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::Pose2Df>>> particles = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::PathVisualization>>> path_options = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::ColoredPoint2D>>> points = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::ColoredLine2D>>> lines = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::amrl_msgs::ColoredArc2D>>> arcs = 0) {
  VisualizationMsgBuilder builder_(_fbb);
  builder_.add_arcs(arcs);
  builder_.add_lines(lines);
  builder_.add_points(points);
  builder_.add_path_options(path_options);
  builder_.add_particles(particles);
  builder_.add_ns(ns);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<VisualizationMsg> CreateVisualizationMsgDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const char *ns = nullptr,
    const std::vector<flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> *particles = nullptr,
    const std::vector<flatbuffers::Offset<fb::amrl_msgs::PathVisualization>> *path_options = nullptr,
    const std::vector<flatbuffers::Offset<fb::amrl_msgs::ColoredPoint2D>> *points = nullptr,
    const std::vector<flatbuffers::Offset<fb::amrl_msgs::ColoredLine2D>> *lines = nullptr,
    const std::vector<flatbuffers::Offset<fb::amrl_msgs::ColoredArc2D>> *arcs = nullptr) {
  auto ns__ = ns ? _fbb.CreateString(ns) : 0;
  auto particles__ = particles ? _fbb.CreateVector<flatbuffers::Offset<fb::amrl_msgs::Pose2Df>>(*particles) : 0;
  auto path_options__ = path_options ? _fbb.CreateVector<flatbuffers::Offset<fb::amrl_msgs::PathVisualization>>(*path_options) : 0;
  auto points__ = points ? _fbb.CreateVector<flatbuffers::Offset<fb::amrl_msgs::ColoredPoint2D>>(*points) : 0;
  auto lines__ = lines ? _fbb.CreateVector<flatbuffers::Offset<fb::amrl_msgs::ColoredLine2D>>(*lines) : 0;
  auto arcs__ = arcs ? _fbb.CreateVector<flatbuffers::Offset<fb::amrl_msgs::ColoredArc2D>>(*arcs) : 0;
  return fb::amrl_msgs::CreateVisualizationMsg(
      _fbb,
      __metadata,
      header,
      ns__,
      particles__,
      path_options__,
      points__,
      lines__,
      arcs__);
}

flatbuffers::Offset<VisualizationMsg> CreateVisualizationMsg(flatbuffers::FlatBufferBuilder &_fbb, const VisualizationMsgT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DetectedItemT : public flatbuffers::NativeTable {
  typedef DetectedItem TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::string name;
  std::string repID;
  std::string anchorID;
  double x;
  double y;
  double z;
  double lat;
  double lon;
  double elv;
  std::unique_ptr<fb::sensor_msgs::CompressedImageT> cmpr_image;
  DetectedItemT()
      : x(0.0),
        y(0.0),
        z(0.0),
        lat(0.0),
        lon(0.0),
        elv(0.0) {
  }
};

struct DetectedItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DetectedItemT NativeTableType;
  typedef DetectedItemBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_NAME = 6,
    VT_REPID = 8,
    VT_ANCHORID = 10,
    VT_X = 12,
    VT_Y = 14,
    VT_Z = 16,
    VT_LAT = 18,
    VT_LON = 20,
    VT_ELV = 22,
    VT_CMPR_IMAGE = 24
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *repID() const {
    return GetPointer<const flatbuffers::String *>(VT_REPID);
  }
  const flatbuffers::String *anchorID() const {
    return GetPointer<const flatbuffers::String *>(VT_ANCHORID);
  }
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  double lat() const {
    return GetField<double>(VT_LAT, 0.0);
  }
  double lon() const {
    return GetField<double>(VT_LON, 0.0);
  }
  double elv() const {
    return GetField<double>(VT_ELV, 0.0);
  }
  const fb::sensor_msgs::CompressedImage *cmpr_image() const {
    return GetPointer<const fb::sensor_msgs::CompressedImage *>(VT_CMPR_IMAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_REPID) &&
           verifier.VerifyString(repID()) &&
           VerifyOffsetRequired(verifier, VT_ANCHORID) &&
           verifier.VerifyString(anchorID()) &&
           VerifyField<double>(verifier, VT_X) &&
           VerifyField<double>(verifier, VT_Y) &&
           VerifyField<double>(verifier, VT_Z) &&
           VerifyField<double>(verifier, VT_LAT) &&
           VerifyField<double>(verifier, VT_LON) &&
           VerifyField<double>(verifier, VT_ELV) &&
           VerifyOffsetRequired(verifier, VT_CMPR_IMAGE) &&
           verifier.VerifyTable(cmpr_image()) &&
           verifier.EndTable();
  }
  DetectedItemT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DetectedItemT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DetectedItem> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DetectedItemT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DetectedItemBuilder {
  typedef DetectedItem Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(DetectedItem::VT___METADATA, __metadata);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(DetectedItem::VT_NAME, name);
  }
  void add_repID(flatbuffers::Offset<flatbuffers::String> repID) {
    fbb_.AddOffset(DetectedItem::VT_REPID, repID);
  }
  void add_anchorID(flatbuffers::Offset<flatbuffers::String> anchorID) {
    fbb_.AddOffset(DetectedItem::VT_ANCHORID, anchorID);
  }
  void add_x(double x) {
    fbb_.AddElement<double>(DetectedItem::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(DetectedItem::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(DetectedItem::VT_Z, z, 0.0);
  }
  void add_lat(double lat) {
    fbb_.AddElement<double>(DetectedItem::VT_LAT, lat, 0.0);
  }
  void add_lon(double lon) {
    fbb_.AddElement<double>(DetectedItem::VT_LON, lon, 0.0);
  }
  void add_elv(double elv) {
    fbb_.AddElement<double>(DetectedItem::VT_ELV, elv, 0.0);
  }
  void add_cmpr_image(flatbuffers::Offset<fb::sensor_msgs::CompressedImage> cmpr_image) {
    fbb_.AddOffset(DetectedItem::VT_CMPR_IMAGE, cmpr_image);
  }
  explicit DetectedItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DetectedItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DetectedItem>(end);
    fbb_.Required(o, DetectedItem::VT_NAME);
    fbb_.Required(o, DetectedItem::VT_REPID);
    fbb_.Required(o, DetectedItem::VT_ANCHORID);
    fbb_.Required(o, DetectedItem::VT_CMPR_IMAGE);
    return o;
  }
};

inline flatbuffers::Offset<DetectedItem> CreateDetectedItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> repID = 0,
    flatbuffers::Offset<flatbuffers::String> anchorID = 0,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0,
    double lat = 0.0,
    double lon = 0.0,
    double elv = 0.0,
    flatbuffers::Offset<fb::sensor_msgs::CompressedImage> cmpr_image = 0) {
  DetectedItemBuilder builder_(_fbb);
  builder_.add_elv(elv);
  builder_.add_lon(lon);
  builder_.add_lat(lat);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_cmpr_image(cmpr_image);
  builder_.add_anchorID(anchorID);
  builder_.add_repID(repID);
  builder_.add_name(name);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<DetectedItem> CreateDetectedItemDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const char *name = nullptr,
    const char *repID = nullptr,
    const char *anchorID = nullptr,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0,
    double lat = 0.0,
    double lon = 0.0,
    double elv = 0.0,
    flatbuffers::Offset<fb::sensor_msgs::CompressedImage> cmpr_image = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto repID__ = repID ? _fbb.CreateString(repID) : 0;
  auto anchorID__ = anchorID ? _fbb.CreateString(anchorID) : 0;
  return fb::amrl_msgs::CreateDetectedItem(
      _fbb,
      __metadata,
      name__,
      repID__,
      anchorID__,
      x,
      y,
      z,
      lat,
      lon,
      elv,
      cmpr_image);
}

flatbuffers::Offset<DetectedItem> CreateDetectedItem(flatbuffers::FlatBufferBuilder &_fbb, const DetectedItemT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace amrl_msgs

namespace tf2_msgs {

struct TFMessageT : public flatbuffers::NativeTable {
  typedef TFMessage TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::vector<std::unique_ptr<fb::geometry_msgs::TransformStampedT>> transforms;
  TFMessageT() {
  }
};

struct TFMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TFMessageT NativeTableType;
  typedef TFMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_TRANSFORMS = 6
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::geometry_msgs::TransformStamped>> *transforms() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::geometry_msgs::TransformStamped>> *>(VT_TRANSFORMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_TRANSFORMS) &&
           verifier.VerifyVector(transforms()) &&
           verifier.VerifyVectorOfTables(transforms()) &&
           verifier.EndTable();
  }
  TFMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TFMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TFMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TFMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TFMessageBuilder {
  typedef TFMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(TFMessage::VT___METADATA, __metadata);
  }
  void add_transforms(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::geometry_msgs::TransformStamped>>> transforms) {
    fbb_.AddOffset(TFMessage::VT_TRANSFORMS, transforms);
  }
  explicit TFMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TFMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TFMessage>(end);
    fbb_.Required(o, TFMessage::VT_TRANSFORMS);
    return o;
  }
};

inline flatbuffers::Offset<TFMessage> CreateTFMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::geometry_msgs::TransformStamped>>> transforms = 0) {
  TFMessageBuilder builder_(_fbb);
  builder_.add_transforms(transforms);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<TFMessage> CreateTFMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    const std::vector<flatbuffers::Offset<fb::geometry_msgs::TransformStamped>> *transforms = nullptr) {
  auto transforms__ = transforms ? _fbb.CreateVector<flatbuffers::Offset<fb::geometry_msgs::TransformStamped>>(*transforms) : 0;
  return fb::tf2_msgs::CreateTFMessage(
      _fbb,
      __metadata,
      transforms__);
}

flatbuffers::Offset<TFMessage> CreateTFMessage(flatbuffers::FlatBufferBuilder &_fbb, const TFMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace tf2_msgs

namespace leg_tracker {

struct DetectionT : public flatbuffers::NativeTable {
  typedef Detection TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::geometry_msgs::PointT> position;
  float confidence;
  int32_t label;
  DetectionT()
      : confidence(0.0f),
        label(0) {
  }
};

struct Detection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DetectionT NativeTableType;
  typedef DetectionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_POSITION = 6,
    VT_CONFIDENCE = 8,
    VT_LABEL = 10
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Point *position() const {
    return GetPointer<const fb::geometry_msgs::Point *>(VT_POSITION);
  }
  float confidence() const {
    return GetField<float>(VT_CONFIDENCE, 0.0f);
  }
  int32_t label() const {
    return GetField<int32_t>(VT_LABEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_POSITION) &&
           verifier.VerifyTable(position()) &&
           VerifyField<float>(verifier, VT_CONFIDENCE) &&
           VerifyField<int32_t>(verifier, VT_LABEL) &&
           verifier.EndTable();
  }
  DetectionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DetectionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Detection> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DetectionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DetectionBuilder {
  typedef Detection Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Detection::VT___METADATA, __metadata);
  }
  void add_position(flatbuffers::Offset<fb::geometry_msgs::Point> position) {
    fbb_.AddOffset(Detection::VT_POSITION, position);
  }
  void add_confidence(float confidence) {
    fbb_.AddElement<float>(Detection::VT_CONFIDENCE, confidence, 0.0f);
  }
  void add_label(int32_t label) {
    fbb_.AddElement<int32_t>(Detection::VT_LABEL, label, 0);
  }
  explicit DetectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Detection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Detection>(end);
    fbb_.Required(o, Detection::VT_POSITION);
    return o;
  }
};

inline flatbuffers::Offset<Detection> CreateDetection(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::geometry_msgs::Point> position = 0,
    float confidence = 0.0f,
    int32_t label = 0) {
  DetectionBuilder builder_(_fbb);
  builder_.add_label(label);
  builder_.add_confidence(confidence);
  builder_.add_position(position);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<Detection> CreateDetection(flatbuffers::FlatBufferBuilder &_fbb, const DetectionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DetectionArrayT : public flatbuffers::NativeTable {
  typedef DetectionArray TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::std_msgs::HeaderT> header;
  std::vector<std::unique_ptr<fb::leg_tracker::DetectionT>> detections;
  DetectionArrayT() {
  }
};

struct DetectionArray FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DetectionArrayT NativeTableType;
  typedef DetectionArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_DETECTIONS = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::leg_tracker::Detection>> *detections() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::leg_tracker::Detection>> *>(VT_DETECTIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_DETECTIONS) &&
           verifier.VerifyVector(detections()) &&
           verifier.VerifyVectorOfTables(detections()) &&
           verifier.EndTable();
  }
  DetectionArrayT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DetectionArrayT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DetectionArray> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DetectionArrayT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DetectionArrayBuilder {
  typedef DetectionArray Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(DetectionArray::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(DetectionArray::VT_HEADER, header);
  }
  void add_detections(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::leg_tracker::Detection>>> detections) {
    fbb_.AddOffset(DetectionArray::VT_DETECTIONS, detections);
  }
  explicit DetectionArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DetectionArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DetectionArray>(end);
    fbb_.Required(o, DetectionArray::VT_HEADER);
    fbb_.Required(o, DetectionArray::VT_DETECTIONS);
    return o;
  }
};

inline flatbuffers::Offset<DetectionArray> CreateDetectionArray(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::leg_tracker::Detection>>> detections = 0) {
  DetectionArrayBuilder builder_(_fbb);
  builder_.add_detections(detections);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<DetectionArray> CreateDetectionArrayDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const std::vector<flatbuffers::Offset<fb::leg_tracker::Detection>> *detections = nullptr) {
  auto detections__ = detections ? _fbb.CreateVector<flatbuffers::Offset<fb::leg_tracker::Detection>>(*detections) : 0;
  return fb::leg_tracker::CreateDetectionArray(
      _fbb,
      __metadata,
      header,
      detections__);
}

flatbuffers::Offset<DetectionArray> CreateDetectionArray(flatbuffers::FlatBufferBuilder &_fbb, const DetectionArrayT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LegT : public flatbuffers::NativeTable {
  typedef Leg TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::geometry_msgs::PointT> position;
  float confidence;
  LegT()
      : confidence(0.0f) {
  }
};

struct Leg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LegT NativeTableType;
  typedef LegBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_POSITION = 6,
    VT_CONFIDENCE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Point *position() const {
    return GetPointer<const fb::geometry_msgs::Point *>(VT_POSITION);
  }
  float confidence() const {
    return GetField<float>(VT_CONFIDENCE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_POSITION) &&
           verifier.VerifyTable(position()) &&
           VerifyField<float>(verifier, VT_CONFIDENCE) &&
           verifier.EndTable();
  }
  LegT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LegT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Leg> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LegT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LegBuilder {
  typedef Leg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Leg::VT___METADATA, __metadata);
  }
  void add_position(flatbuffers::Offset<fb::geometry_msgs::Point> position) {
    fbb_.AddOffset(Leg::VT_POSITION, position);
  }
  void add_confidence(float confidence) {
    fbb_.AddElement<float>(Leg::VT_CONFIDENCE, confidence, 0.0f);
  }
  explicit LegBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Leg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Leg>(end);
    fbb_.Required(o, Leg::VT_POSITION);
    return o;
  }
};

inline flatbuffers::Offset<Leg> CreateLeg(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::geometry_msgs::Point> position = 0,
    float confidence = 0.0f) {
  LegBuilder builder_(_fbb);
  builder_.add_confidence(confidence);
  builder_.add_position(position);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<Leg> CreateLeg(flatbuffers::FlatBufferBuilder &_fbb, const LegT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LegArrayT : public flatbuffers::NativeTable {
  typedef LegArray TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::std_msgs::HeaderT> header;
  std::vector<std::unique_ptr<fb::leg_tracker::LegT>> legs;
  LegArrayT() {
  }
};

struct LegArray FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LegArrayT NativeTableType;
  typedef LegArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_LEGS = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::leg_tracker::Leg>> *legs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::leg_tracker::Leg>> *>(VT_LEGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_LEGS) &&
           verifier.VerifyVector(legs()) &&
           verifier.VerifyVectorOfTables(legs()) &&
           verifier.EndTable();
  }
  LegArrayT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LegArrayT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LegArray> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LegArrayT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LegArrayBuilder {
  typedef LegArray Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(LegArray::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(LegArray::VT_HEADER, header);
  }
  void add_legs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::leg_tracker::Leg>>> legs) {
    fbb_.AddOffset(LegArray::VT_LEGS, legs);
  }
  explicit LegArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LegArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LegArray>(end);
    fbb_.Required(o, LegArray::VT_HEADER);
    fbb_.Required(o, LegArray::VT_LEGS);
    return o;
  }
};

inline flatbuffers::Offset<LegArray> CreateLegArray(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::leg_tracker::Leg>>> legs = 0) {
  LegArrayBuilder builder_(_fbb);
  builder_.add_legs(legs);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<LegArray> CreateLegArrayDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const std::vector<flatbuffers::Offset<fb::leg_tracker::Leg>> *legs = nullptr) {
  auto legs__ = legs ? _fbb.CreateVector<flatbuffers::Offset<fb::leg_tracker::Leg>>(*legs) : 0;
  return fb::leg_tracker::CreateLegArray(
      _fbb,
      __metadata,
      header,
      legs__);
}

flatbuffers::Offset<LegArray> CreateLegArray(flatbuffers::FlatBufferBuilder &_fbb, const LegArrayT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PersonT : public flatbuffers::NativeTable {
  typedef Person TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::geometry_msgs::PoseT> pose;
  uint32_t id;
  PersonT()
      : id(0) {
  }
};

struct Person FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PersonT NativeTableType;
  typedef PersonBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_POSE = 6,
    VT_ID = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::geometry_msgs::Pose *pose() const {
    return GetPointer<const fb::geometry_msgs::Pose *>(VT_POSE);
  }
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
  PersonT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PersonT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Person> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PersonT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PersonBuilder {
  typedef Person Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(Person::VT___METADATA, __metadata);
  }
  void add_pose(flatbuffers::Offset<fb::geometry_msgs::Pose> pose) {
    fbb_.AddOffset(Person::VT_POSE, pose);
  }
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(Person::VT_ID, id, 0);
  }
  explicit PersonBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Person> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Person>(end);
    fbb_.Required(o, Person::VT_POSE);
    return o;
  }
};

inline flatbuffers::Offset<Person> CreatePerson(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::geometry_msgs::Pose> pose = 0,
    uint32_t id = 0) {
  PersonBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_pose(pose);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

flatbuffers::Offset<Person> CreatePerson(flatbuffers::FlatBufferBuilder &_fbb, const PersonT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PersonArrayT : public flatbuffers::NativeTable {
  typedef PersonArray TableType;
  std::unique_ptr<fb::MsgMetadataT> __metadata;
  std::unique_ptr<fb::std_msgs::HeaderT> header;
  std::vector<std::unique_ptr<fb::leg_tracker::PersonT>> people;
  PersonArrayT() {
  }
};

struct PersonArray FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PersonArrayT NativeTableType;
  typedef PersonArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT___METADATA = 4,
    VT_HEADER = 6,
    VT_PEOPLE = 8
  };
  const fb::MsgMetadata *__metadata() const {
    return GetPointer<const fb::MsgMetadata *>(VT___METADATA);
  }
  const fb::std_msgs::Header *header() const {
    return GetPointer<const fb::std_msgs::Header *>(VT_HEADER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fb::leg_tracker::Person>> *people() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fb::leg_tracker::Person>> *>(VT_PEOPLE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT___METADATA) &&
           verifier.VerifyTable(__metadata()) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_PEOPLE) &&
           verifier.VerifyVector(people()) &&
           verifier.VerifyVectorOfTables(people()) &&
           verifier.EndTable();
  }
  PersonArrayT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PersonArrayT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PersonArray> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PersonArrayT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PersonArrayBuilder {
  typedef PersonArray Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add___metadata(flatbuffers::Offset<fb::MsgMetadata> __metadata) {
    fbb_.AddOffset(PersonArray::VT___METADATA, __metadata);
  }
  void add_header(flatbuffers::Offset<fb::std_msgs::Header> header) {
    fbb_.AddOffset(PersonArray::VT_HEADER, header);
  }
  void add_people(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::leg_tracker::Person>>> people) {
    fbb_.AddOffset(PersonArray::VT_PEOPLE, people);
  }
  explicit PersonArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PersonArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PersonArray>(end);
    fbb_.Required(o, PersonArray::VT_HEADER);
    fbb_.Required(o, PersonArray::VT_PEOPLE);
    return o;
  }
};

inline flatbuffers::Offset<PersonArray> CreatePersonArray(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fb::leg_tracker::Person>>> people = 0) {
  PersonArrayBuilder builder_(_fbb);
  builder_.add_people(people);
  builder_.add_header(header);
  builder_.add___metadata(__metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<PersonArray> CreatePersonArrayDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fb::MsgMetadata> __metadata = 0,
    flatbuffers::Offset<fb::std_msgs::Header> header = 0,
    const std::vector<flatbuffers::Offset<fb::leg_tracker::Person>> *people = nullptr) {
  auto people__ = people ? _fbb.CreateVector<flatbuffers::Offset<fb::leg_tracker::Person>>(*people) : 0;
  return fb::leg_tracker::CreatePersonArray(
      _fbb,
      __metadata,
      header,
      people__);
}

flatbuffers::Offset<PersonArray> CreatePersonArray(flatbuffers::FlatBufferBuilder &_fbb, const PersonArrayT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace leg_tracker

inline MsgMetadataT *MsgMetadata::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::MsgMetadataT> _o = std::unique_ptr<fb::MsgMetadataT>(new MsgMetadataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MsgMetadata::UnPackTo(MsgMetadataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); if (_e) _o->type = _e->str(); }
  { auto _e = topic(); if (_e) _o->topic = _e->str(); }
}

inline flatbuffers::Offset<MsgMetadata> MsgMetadata::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgMetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsgMetadata(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MsgMetadata> CreateMsgMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MsgMetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MsgMetadataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type.empty() ? 0 : _fbb.CreateString(_o->type);
  auto _topic = _o->topic.empty() ? 0 : _fbb.CreateString(_o->topic);
  return fb::CreateMsgMetadata(
      _fbb,
      _type,
      _topic);
}

inline MsgWithMetadataT *MsgWithMetadata::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::MsgWithMetadataT> _o = std::unique_ptr<fb::MsgWithMetadataT>(new MsgWithMetadataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MsgWithMetadata::UnPackTo(MsgWithMetadataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<MsgWithMetadata> MsgWithMetadata::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MsgWithMetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMsgWithMetadata(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MsgWithMetadata> CreateMsgWithMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MsgWithMetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MsgWithMetadataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  return fb::CreateMsgWithMetadata(
      _fbb,
      ___metadata);
}

namespace std_msgs {

inline HeaderT *Header::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::std_msgs::HeaderT> _o = std::unique_ptr<fb::std_msgs::HeaderT>(new HeaderT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Header::UnPackTo(HeaderT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = seq(); _o->seq = _e; }
  { auto _e = stamp(); if (_e) _o->stamp = std::unique_ptr<fb::RosTime>(new fb::RosTime(*_e)); }
  { auto _e = frame_id(); if (_e) _o->frame_id = _e->str(); }
}

inline flatbuffers::Offset<Header> Header::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HeaderT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHeader(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Header> CreateHeader(flatbuffers::FlatBufferBuilder &_fbb, const HeaderT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HeaderT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _seq = _o->seq;
  auto _stamp = _o->stamp ? _o->stamp.get() : 0;
  auto _frame_id = _fbb.CreateString(_o->frame_id);
  return fb::std_msgs::CreateHeader(
      _fbb,
      ___metadata,
      _seq,
      _stamp,
      _frame_id);
}

}  // namespace std_msgs

namespace sensor_msgs {

inline NavSatStatusT *NavSatStatus::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::sensor_msgs::NavSatStatusT> _o = std::unique_ptr<fb::sensor_msgs::NavSatStatusT>(new NavSatStatusT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NavSatStatus::UnPackTo(NavSatStatusT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = status(); _o->status = _e; }
  { auto _e = service(); _o->service = _e; }
}

inline flatbuffers::Offset<NavSatStatus> NavSatStatus::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NavSatStatusT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNavSatStatus(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NavSatStatus> CreateNavSatStatus(flatbuffers::FlatBufferBuilder &_fbb, const NavSatStatusT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NavSatStatusT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _status = _o->status;
  auto _service = _o->service;
  return fb::sensor_msgs::CreateNavSatStatus(
      _fbb,
      ___metadata,
      _status,
      _service);
}

inline NavSatFixT *NavSatFix::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::sensor_msgs::NavSatFixT> _o = std::unique_ptr<fb::sensor_msgs::NavSatFixT>(new NavSatFixT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NavSatFix::UnPackTo(NavSatFixT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); }
  { auto _e = status(); if (_e) _o->status = std::unique_ptr<fb::sensor_msgs::NavSatStatusT>(_e->UnPack(_resolver)); }
  { auto _e = latitude(); _o->latitude = _e; }
  { auto _e = longitude(); _o->longitude = _e; }
  { auto _e = altitude(); _o->altitude = _e; }
  { auto _e = position_covariance(); if (_e) { _o->position_covariance.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->position_covariance[_i] = _e->Get(_i); } } }
  { auto _e = position_covariance_type(); _o->position_covariance_type = _e; }
}

inline flatbuffers::Offset<NavSatFix> NavSatFix::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NavSatFixT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNavSatFix(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NavSatFix> CreateNavSatFix(flatbuffers::FlatBufferBuilder &_fbb, const NavSatFixT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NavSatFixT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _status = _o->status ? CreateNavSatStatus(_fbb, _o->status.get(), _rehasher) : 0;
  auto _latitude = _o->latitude;
  auto _longitude = _o->longitude;
  auto _altitude = _o->altitude;
  auto _position_covariance = _fbb.CreateVector(_o->position_covariance);
  auto _position_covariance_type = _o->position_covariance_type;
  return fb::sensor_msgs::CreateNavSatFix(
      _fbb,
      ___metadata,
      _header,
      _status,
      _latitude,
      _longitude,
      _altitude,
      _position_covariance,
      _position_covariance_type);
}

inline LaserScanT *LaserScan::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::sensor_msgs::LaserScanT> _o = std::unique_ptr<fb::sensor_msgs::LaserScanT>(new LaserScanT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LaserScan::UnPackTo(LaserScanT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); }
  { auto _e = angle_min(); _o->angle_min = _e; }
  { auto _e = angle_max(); _o->angle_max = _e; }
  { auto _e = angle_increment(); _o->angle_increment = _e; }
  { auto _e = time_increment(); _o->time_increment = _e; }
  { auto _e = scan_time(); _o->scan_time = _e; }
  { auto _e = range_min(); _o->range_min = _e; }
  { auto _e = range_max(); _o->range_max = _e; }
  { auto _e = ranges(); if (_e) { _o->ranges.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ranges[_i] = _e->Get(_i); } } }
  { auto _e = intensities(); if (_e) { _o->intensities.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->intensities[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<LaserScan> LaserScan::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LaserScanT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLaserScan(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LaserScan> CreateLaserScan(flatbuffers::FlatBufferBuilder &_fbb, const LaserScanT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LaserScanT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _angle_min = _o->angle_min;
  auto _angle_max = _o->angle_max;
  auto _angle_increment = _o->angle_increment;
  auto _time_increment = _o->time_increment;
  auto _scan_time = _o->scan_time;
  auto _range_min = _o->range_min;
  auto _range_max = _o->range_max;
  auto _ranges = _fbb.CreateVector(_o->ranges);
  auto _intensities = _fbb.CreateVector(_o->intensities);
  return fb::sensor_msgs::CreateLaserScan(
      _fbb,
      ___metadata,
      _header,
      _angle_min,
      _angle_max,
      _angle_increment,
      _time_increment,
      _scan_time,
      _range_min,
      _range_max,
      _ranges,
      _intensities);
}

inline PointFieldT *PointField::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::sensor_msgs::PointFieldT> _o = std::unique_ptr<fb::sensor_msgs::PointFieldT>(new PointFieldT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PointField::UnPackTo(PointFieldT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = offset(); _o->offset = _e; }
  { auto _e = datatype(); _o->datatype = _e; }
  { auto _e = count(); _o->count = _e; }
}

inline flatbuffers::Offset<PointField> PointField::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PointFieldT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePointField(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PointField> CreatePointField(flatbuffers::FlatBufferBuilder &_fbb, const PointFieldT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PointFieldT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _name = _fbb.CreateString(_o->name);
  auto _offset = _o->offset;
  auto _datatype = _o->datatype;
  auto _count = _o->count;
  return fb::sensor_msgs::CreatePointField(
      _fbb,
      ___metadata,
      _name,
      _offset,
      _datatype,
      _count);
}

inline PointCloud2T *PointCloud2::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::sensor_msgs::PointCloud2T> _o = std::unique_ptr<fb::sensor_msgs::PointCloud2T>(new PointCloud2T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PointCloud2::UnPackTo(PointCloud2T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); }
  { auto _e = height(); _o->height = _e; }
  { auto _e = width(); _o->width = _e; }
  { auto _e = fields(); if (_e) { _o->fields.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->fields[_i] = std::unique_ptr<fb::sensor_msgs::PointFieldT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = is_bigendian(); _o->is_bigendian = _e; }
  { auto _e = point_step(); _o->point_step = _e; }
  { auto _e = row_step(); _o->row_step = _e; }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } }
  { auto _e = is_dense(); _o->is_dense = _e; }
}

inline flatbuffers::Offset<PointCloud2> PointCloud2::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PointCloud2T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePointCloud2(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PointCloud2> CreatePointCloud2(flatbuffers::FlatBufferBuilder &_fbb, const PointCloud2T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PointCloud2T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _height = _o->height;
  auto _width = _o->width;
  auto _fields = _fbb.CreateVector<flatbuffers::Offset<fb::sensor_msgs::PointField>> (_o->fields.size(), [](size_t i, _VectorArgs *__va) { return CreatePointField(*__va->__fbb, __va->__o->fields[i].get(), __va->__rehasher); }, &_va );
  auto _is_bigendian = _o->is_bigendian;
  auto _point_step = _o->point_step;
  auto _row_step = _o->row_step;
  auto _data = _fbb.CreateVector(_o->data);
  auto _is_dense = _o->is_dense;
  return fb::sensor_msgs::CreatePointCloud2(
      _fbb,
      ___metadata,
      _header,
      _height,
      _width,
      _fields,
      _is_bigendian,
      _point_step,
      _row_step,
      _data,
      _is_dense);
}

inline CompressedImageT *CompressedImage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::sensor_msgs::CompressedImageT> _o = std::unique_ptr<fb::sensor_msgs::CompressedImageT>(new CompressedImageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CompressedImage::UnPackTo(CompressedImageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); }
  { auto _e = format(); if (_e) _o->format = _e->str(); }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<CompressedImage> CompressedImage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CompressedImageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCompressedImage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CompressedImage> CreateCompressedImage(flatbuffers::FlatBufferBuilder &_fbb, const CompressedImageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CompressedImageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _format = _fbb.CreateString(_o->format);
  auto _data = _fbb.CreateVector(_o->data);
  return fb::sensor_msgs::CreateCompressedImage(
      _fbb,
      ___metadata,
      _header,
      _format,
      _data);
}

}  // namespace sensor_msgs

namespace std_msgs {

inline StringT *String::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::std_msgs::StringT> _o = std::unique_ptr<fb::std_msgs::StringT>(new StringT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void String::UnPackTo(StringT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = data(); if (_e) _o->data = _e->str(); }
}

inline flatbuffers::Offset<String> String::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StringT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateString(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<String> CreateString(flatbuffers::FlatBufferBuilder &_fbb, const StringT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StringT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _data = _fbb.CreateString(_o->data);
  return fb::std_msgs::CreateString(
      _fbb,
      ___metadata,
      _data);
}

}  // namespace std_msgs

namespace geometry_msgs {

inline Vector3T *Vector3::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geometry_msgs::Vector3T> _o = std::unique_ptr<fb::geometry_msgs::Vector3T>(new Vector3T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Vector3::UnPackTo(Vector3T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
}

inline flatbuffers::Offset<Vector3> Vector3::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Vector3T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVector3(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Vector3> CreateVector3(flatbuffers::FlatBufferBuilder &_fbb, const Vector3T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Vector3T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  return fb::geometry_msgs::CreateVector3(
      _fbb,
      ___metadata,
      _x,
      _y,
      _z);
}

inline QuaternionT *Quaternion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geometry_msgs::QuaternionT> _o = std::unique_ptr<fb::geometry_msgs::QuaternionT>(new QuaternionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Quaternion::UnPackTo(QuaternionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
  { auto _e = w(); _o->w = _e; }
}

inline flatbuffers::Offset<Quaternion> Quaternion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuaternionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQuaternion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Quaternion> CreateQuaternion(flatbuffers::FlatBufferBuilder &_fbb, const QuaternionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QuaternionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  auto _w = _o->w;
  return fb::geometry_msgs::CreateQuaternion(
      _fbb,
      ___metadata,
      _x,
      _y,
      _z,
      _w);
}

inline TransformT *Transform::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geometry_msgs::TransformT> _o = std::unique_ptr<fb::geometry_msgs::TransformT>(new TransformT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Transform::UnPackTo(TransformT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = translation(); if (_e) _o->translation = std::unique_ptr<fb::geometry_msgs::Vector3T>(_e->UnPack(_resolver)); }
  { auto _e = rotation(); if (_e) _o->rotation = std::unique_ptr<fb::geometry_msgs::QuaternionT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<Transform> Transform::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransformT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTransform(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Transform> CreateTransform(flatbuffers::FlatBufferBuilder &_fbb, const TransformT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TransformT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _translation = _o->translation ? CreateVector3(_fbb, _o->translation.get(), _rehasher) : 0;
  auto _rotation = _o->rotation ? CreateQuaternion(_fbb, _o->rotation.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreateTransform(
      _fbb,
      ___metadata,
      _translation,
      _rotation);
}

inline TransformStampedT *TransformStamped::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geometry_msgs::TransformStampedT> _o = std::unique_ptr<fb::geometry_msgs::TransformStampedT>(new TransformStampedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TransformStamped::UnPackTo(TransformStampedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); }
  { auto _e = child_frame_id(); if (_e) _o->child_frame_id = _e->str(); }
  { auto _e = transform(); if (_e) _o->transform = std::unique_ptr<fb::geometry_msgs::TransformT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<TransformStamped> TransformStamped::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransformStampedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTransformStamped(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TransformStamped> CreateTransformStamped(flatbuffers::FlatBufferBuilder &_fbb, const TransformStampedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TransformStampedT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _child_frame_id = _fbb.CreateString(_o->child_frame_id);
  auto _transform = _o->transform ? CreateTransform(_fbb, _o->transform.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreateTransformStamped(
      _fbb,
      ___metadata,
      _header,
      _child_frame_id,
      _transform);
}

inline PointT *Point::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geometry_msgs::PointT> _o = std::unique_ptr<fb::geometry_msgs::PointT>(new PointT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Point::UnPackTo(PointT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
}

inline flatbuffers::Offset<Point> Point::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PointT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePoint(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Point> CreatePoint(flatbuffers::FlatBufferBuilder &_fbb, const PointT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PointT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  return fb::geometry_msgs::CreatePoint(
      _fbb,
      ___metadata,
      _x,
      _y,
      _z);
}

inline PoseT *Pose::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geometry_msgs::PoseT> _o = std::unique_ptr<fb::geometry_msgs::PoseT>(new PoseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pose::UnPackTo(PoseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<fb::geometry_msgs::PointT>(_e->UnPack(_resolver)); }
  { auto _e = orientation(); if (_e) _o->orientation = std::unique_ptr<fb::geometry_msgs::QuaternionT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<Pose> Pose::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePose(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pose> CreatePose(flatbuffers::FlatBufferBuilder &_fbb, const PoseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PoseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _position = _o->position ? CreatePoint(_fbb, _o->position.get(), _rehasher) : 0;
  auto _orientation = _o->orientation ? CreateQuaternion(_fbb, _o->orientation.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreatePose(
      _fbb,
      ___metadata,
      _position,
      _orientation);
}

inline PoseStampedT *PoseStamped::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geometry_msgs::PoseStampedT> _o = std::unique_ptr<fb::geometry_msgs::PoseStampedT>(new PoseStampedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PoseStamped::UnPackTo(PoseStampedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); }
  { auto _e = pose(); if (_e) _o->pose = std::unique_ptr<fb::geometry_msgs::PoseT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<PoseStamped> PoseStamped::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoseStampedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePoseStamped(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PoseStamped> CreatePoseStamped(flatbuffers::FlatBufferBuilder &_fbb, const PoseStampedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PoseStampedT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _pose = _o->pose ? CreatePose(_fbb, _o->pose.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreatePoseStamped(
      _fbb,
      ___metadata,
      _header,
      _pose);
}

inline PoseWithCovarianceT *PoseWithCovariance::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geometry_msgs::PoseWithCovarianceT> _o = std::unique_ptr<fb::geometry_msgs::PoseWithCovarianceT>(new PoseWithCovarianceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PoseWithCovariance::UnPackTo(PoseWithCovarianceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = pose(); if (_e) _o->pose = std::unique_ptr<fb::geometry_msgs::PoseT>(_e->UnPack(_resolver)); }
  { auto _e = covariance(); if (_e) { _o->covariance.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->covariance[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<PoseWithCovariance> PoseWithCovariance::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoseWithCovarianceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePoseWithCovariance(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PoseWithCovariance> CreatePoseWithCovariance(flatbuffers::FlatBufferBuilder &_fbb, const PoseWithCovarianceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PoseWithCovarianceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _pose = _o->pose ? CreatePose(_fbb, _o->pose.get(), _rehasher) : 0;
  auto _covariance = _fbb.CreateVector(_o->covariance);
  return fb::geometry_msgs::CreatePoseWithCovariance(
      _fbb,
      ___metadata,
      _pose,
      _covariance);
}

inline PoseWithCovarianceStampedT *PoseWithCovarianceStamped::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geometry_msgs::PoseWithCovarianceStampedT> _o = std::unique_ptr<fb::geometry_msgs::PoseWithCovarianceStampedT>(new PoseWithCovarianceStampedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PoseWithCovarianceStamped::UnPackTo(PoseWithCovarianceStampedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); }
  { auto _e = pose(); if (_e) _o->pose = std::unique_ptr<fb::geometry_msgs::PoseWithCovarianceT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<PoseWithCovarianceStamped> PoseWithCovarianceStamped::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoseWithCovarianceStampedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePoseWithCovarianceStamped(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PoseWithCovarianceStamped> CreatePoseWithCovarianceStamped(flatbuffers::FlatBufferBuilder &_fbb, const PoseWithCovarianceStampedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PoseWithCovarianceStampedT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _pose = _o->pose ? CreatePoseWithCovariance(_fbb, _o->pose.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreatePoseWithCovarianceStamped(
      _fbb,
      ___metadata,
      _header,
      _pose);
}

inline TwistT *Twist::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geometry_msgs::TwistT> _o = std::unique_ptr<fb::geometry_msgs::TwistT>(new TwistT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Twist::UnPackTo(TwistT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = linear(); if (_e) _o->linear = std::unique_ptr<fb::geometry_msgs::Vector3T>(_e->UnPack(_resolver)); }
  { auto _e = angular(); if (_e) _o->angular = std::unique_ptr<fb::geometry_msgs::Vector3T>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<Twist> Twist::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TwistT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTwist(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Twist> CreateTwist(flatbuffers::FlatBufferBuilder &_fbb, const TwistT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TwistT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _linear = _o->linear ? CreateVector3(_fbb, _o->linear.get(), _rehasher) : 0;
  auto _angular = _o->angular ? CreateVector3(_fbb, _o->angular.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreateTwist(
      _fbb,
      ___metadata,
      _linear,
      _angular);
}

inline TwistStampedT *TwistStamped::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geometry_msgs::TwistStampedT> _o = std::unique_ptr<fb::geometry_msgs::TwistStampedT>(new TwistStampedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TwistStamped::UnPackTo(TwistStampedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); }
  { auto _e = twist(); if (_e) _o->twist = std::unique_ptr<fb::geometry_msgs::TwistT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<TwistStamped> TwistStamped::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TwistStampedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTwistStamped(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TwistStamped> CreateTwistStamped(flatbuffers::FlatBufferBuilder &_fbb, const TwistStampedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TwistStampedT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _twist = _o->twist ? CreateTwist(_fbb, _o->twist.get(), _rehasher) : 0;
  return fb::geometry_msgs::CreateTwistStamped(
      _fbb,
      ___metadata,
      _header,
      _twist);
}

}  // namespace geometry_msgs

namespace geographic_msgs {

inline GeoPointT *GeoPoint::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geographic_msgs::GeoPointT> _o = std::unique_ptr<fb::geographic_msgs::GeoPointT>(new GeoPointT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GeoPoint::UnPackTo(GeoPointT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = latitude(); _o->latitude = _e; }
  { auto _e = longitude(); _o->longitude = _e; }
  { auto _e = altitude(); _o->altitude = _e; }
}

inline flatbuffers::Offset<GeoPoint> GeoPoint::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GeoPointT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGeoPoint(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GeoPoint> CreateGeoPoint(flatbuffers::FlatBufferBuilder &_fbb, const GeoPointT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GeoPointT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _latitude = _o->latitude;
  auto _longitude = _o->longitude;
  auto _altitude = _o->altitude;
  return fb::geographic_msgs::CreateGeoPoint(
      _fbb,
      ___metadata,
      _latitude,
      _longitude,
      _altitude);
}

inline GeoPoseT *GeoPose::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geographic_msgs::GeoPoseT> _o = std::unique_ptr<fb::geographic_msgs::GeoPoseT>(new GeoPoseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GeoPose::UnPackTo(GeoPoseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<fb::geographic_msgs::GeoPointT>(_e->UnPack(_resolver)); }
  { auto _e = orientation(); if (_e) _o->orientation = std::unique_ptr<fb::geometry_msgs::QuaternionT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<GeoPose> GeoPose::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGeoPose(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GeoPose> CreateGeoPose(flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GeoPoseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _position = _o->position ? CreateGeoPoint(_fbb, _o->position.get(), _rehasher) : 0;
  auto _orientation = _o->orientation ? CreateQuaternion(_fbb, _o->orientation.get(), _rehasher) : 0;
  return fb::geographic_msgs::CreateGeoPose(
      _fbb,
      ___metadata,
      _position,
      _orientation);
}

inline GeoPoseStampedT *GeoPoseStamped::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geographic_msgs::GeoPoseStampedT> _o = std::unique_ptr<fb::geographic_msgs::GeoPoseStampedT>(new GeoPoseStampedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GeoPoseStamped::UnPackTo(GeoPoseStampedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); }
  { auto _e = pose(); if (_e) _o->pose = std::unique_ptr<fb::geographic_msgs::GeoPoseT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<GeoPoseStamped> GeoPoseStamped::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseStampedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGeoPoseStamped(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GeoPoseStamped> CreateGeoPoseStamped(flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseStampedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GeoPoseStampedT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _pose = _o->pose ? CreateGeoPose(_fbb, _o->pose.get(), _rehasher) : 0;
  return fb::geographic_msgs::CreateGeoPoseStamped(
      _fbb,
      ___metadata,
      _header,
      _pose);
}

inline GeoPoseWithCovarianceT *GeoPoseWithCovariance::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geographic_msgs::GeoPoseWithCovarianceT> _o = std::unique_ptr<fb::geographic_msgs::GeoPoseWithCovarianceT>(new GeoPoseWithCovarianceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GeoPoseWithCovariance::UnPackTo(GeoPoseWithCovarianceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = pose(); if (_e) _o->pose = std::unique_ptr<fb::geographic_msgs::GeoPoseT>(_e->UnPack(_resolver)); }
  { auto _e = covariance(); if (_e) { _o->covariance.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->covariance[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<GeoPoseWithCovariance> GeoPoseWithCovariance::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseWithCovarianceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGeoPoseWithCovariance(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GeoPoseWithCovariance> CreateGeoPoseWithCovariance(flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseWithCovarianceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GeoPoseWithCovarianceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _pose = _o->pose ? CreateGeoPose(_fbb, _o->pose.get(), _rehasher) : 0;
  auto _covariance = _fbb.CreateVector(_o->covariance);
  return fb::geographic_msgs::CreateGeoPoseWithCovariance(
      _fbb,
      ___metadata,
      _pose,
      _covariance);
}

inline GeoPoseWithCovarianceStampedT *GeoPoseWithCovarianceStamped::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geographic_msgs::GeoPoseWithCovarianceStampedT> _o = std::unique_ptr<fb::geographic_msgs::GeoPoseWithCovarianceStampedT>(new GeoPoseWithCovarianceStampedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GeoPoseWithCovarianceStamped::UnPackTo(GeoPoseWithCovarianceStampedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); }
  { auto _e = pose(); if (_e) _o->pose = std::unique_ptr<fb::geographic_msgs::GeoPoseWithCovarianceT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<GeoPoseWithCovarianceStamped> GeoPoseWithCovarianceStamped::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseWithCovarianceStampedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGeoPoseWithCovarianceStamped(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GeoPoseWithCovarianceStamped> CreateGeoPoseWithCovarianceStamped(flatbuffers::FlatBufferBuilder &_fbb, const GeoPoseWithCovarianceStampedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GeoPoseWithCovarianceStampedT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _pose = _o->pose ? CreateGeoPoseWithCovariance(_fbb, _o->pose.get(), _rehasher) : 0;
  return fb::geographic_msgs::CreateGeoPoseWithCovarianceStamped(
      _fbb,
      ___metadata,
      _header,
      _pose);
}

}  // namespace geographic_msgs

namespace geometry_msgs {

inline TwistWithCovarianceT *TwistWithCovariance::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::geometry_msgs::TwistWithCovarianceT> _o = std::unique_ptr<fb::geometry_msgs::TwistWithCovarianceT>(new TwistWithCovarianceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TwistWithCovariance::UnPackTo(TwistWithCovarianceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = twist(); if (_e) _o->twist = std::unique_ptr<fb::geometry_msgs::TwistT>(_e->UnPack(_resolver)); }
  { auto _e = covariance(); if (_e) { _o->covariance.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->covariance[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<TwistWithCovariance> TwistWithCovariance::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TwistWithCovarianceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTwistWithCovariance(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TwistWithCovariance> CreateTwistWithCovariance(flatbuffers::FlatBufferBuilder &_fbb, const TwistWithCovarianceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TwistWithCovarianceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _twist = _o->twist ? CreateTwist(_fbb, _o->twist.get(), _rehasher) : 0;
  auto _covariance = _fbb.CreateVector(_o->covariance);
  return fb::geometry_msgs::CreateTwistWithCovariance(
      _fbb,
      ___metadata,
      _twist,
      _covariance);
}

}  // namespace geometry_msgs

namespace nav_msgs {

inline OdometryT *Odometry::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::nav_msgs::OdometryT> _o = std::unique_ptr<fb::nav_msgs::OdometryT>(new OdometryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Odometry::UnPackTo(OdometryT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); }
  { auto _e = child_frame_id(); if (_e) _o->child_frame_id = _e->str(); }
  { auto _e = pose(); if (_e) _o->pose = std::unique_ptr<fb::geometry_msgs::PoseWithCovarianceT>(_e->UnPack(_resolver)); }
  { auto _e = twist(); if (_e) _o->twist = std::unique_ptr<fb::geometry_msgs::TwistWithCovarianceT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<Odometry> Odometry::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OdometryT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOdometry(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Odometry> CreateOdometry(flatbuffers::FlatBufferBuilder &_fbb, const OdometryT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OdometryT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _child_frame_id = _fbb.CreateString(_o->child_frame_id);
  auto _pose = _o->pose ? CreatePoseWithCovariance(_fbb, _o->pose.get(), _rehasher) : 0;
  auto _twist = _o->twist ? CreateTwistWithCovariance(_fbb, _o->twist.get(), _rehasher) : 0;
  return fb::nav_msgs::CreateOdometry(
      _fbb,
      ___metadata,
      _header,
      _child_frame_id,
      _pose,
      _twist);
}

inline PathT *Path::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::nav_msgs::PathT> _o = std::unique_ptr<fb::nav_msgs::PathT>(new PathT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Path::UnPackTo(PathT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); }
  { auto _e = poses(); if (_e) { _o->poses.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->poses[_i] = std::unique_ptr<fb::geometry_msgs::PoseStampedT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<Path> Path::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PathT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePath(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Path> CreatePath(flatbuffers::FlatBufferBuilder &_fbb, const PathT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PathT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _poses = _fbb.CreateVector<flatbuffers::Offset<fb::geometry_msgs::PoseStamped>> (_o->poses.size(), [](size_t i, _VectorArgs *__va) { return CreatePoseStamped(*__va->__fbb, __va->__o->poses[i].get(), __va->__rehasher); }, &_va );
  return fb::nav_msgs::CreatePath(
      _fbb,
      ___metadata,
      _header,
      _poses);
}

}  // namespace nav_msgs

namespace temoto_action_engine {

inline UmrfGraphDiffT *UmrfGraphDiff::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::temoto_action_engine::UmrfGraphDiffT> _o = std::unique_ptr<fb::temoto_action_engine::UmrfGraphDiffT>(new UmrfGraphDiffT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UmrfGraphDiff::UnPackTo(UmrfGraphDiffT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = ADD(); if (_e) _o->ADD = _e->str(); }
  { auto _e = SUBTRACT(); if (_e) _o->SUBTRACT = _e->str(); }
  { auto _e = operation(); if (_e) _o->operation = _e->str(); }
  { auto _e = umrf_json(); if (_e) _o->umrf_json = _e->str(); }
}

inline flatbuffers::Offset<UmrfGraphDiff> UmrfGraphDiff::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UmrfGraphDiffT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUmrfGraphDiff(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UmrfGraphDiff> CreateUmrfGraphDiff(flatbuffers::FlatBufferBuilder &_fbb, const UmrfGraphDiffT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UmrfGraphDiffT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _ADD = _fbb.CreateString(_o->ADD);
  auto _SUBTRACT = _fbb.CreateString(_o->SUBTRACT);
  auto _operation = _fbb.CreateString(_o->operation);
  auto _umrf_json = _fbb.CreateString(_o->umrf_json);
  return fb::temoto_action_engine::CreateUmrfGraphDiff(
      _fbb,
      ___metadata,
      _ADD,
      _SUBTRACT,
      _operation,
      _umrf_json);
}

inline BroadcastStartUmrfGraphT *BroadcastStartUmrfGraph::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::temoto_action_engine::BroadcastStartUmrfGraphT> _o = std::unique_ptr<fb::temoto_action_engine::BroadcastStartUmrfGraphT>(new BroadcastStartUmrfGraphT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BroadcastStartUmrfGraph::UnPackTo(BroadcastStartUmrfGraphT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = umrf_graph_name(); if (_e) _o->umrf_graph_name = _e->str(); }
  { auto _e = name_match_required(); _o->name_match_required = _e; }
  { auto _e = targets(); if (_e) { _o->targets.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->targets[_i] = _e->Get(_i)->str(); } } }
  { auto _e = umrf_graph_json(); if (_e) _o->umrf_graph_json = _e->str(); }
  { auto _e = umrf_graph_diffs(); if (_e) { _o->umrf_graph_diffs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->umrf_graph_diffs[_i] = std::unique_ptr<fb::temoto_action_engine::UmrfGraphDiffT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<BroadcastStartUmrfGraph> BroadcastStartUmrfGraph::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastStartUmrfGraphT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBroadcastStartUmrfGraph(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BroadcastStartUmrfGraph> CreateBroadcastStartUmrfGraph(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastStartUmrfGraphT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BroadcastStartUmrfGraphT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _umrf_graph_name = _fbb.CreateString(_o->umrf_graph_name);
  auto _name_match_required = _o->name_match_required;
  auto _targets = _fbb.CreateVectorOfStrings(_o->targets);
  auto _umrf_graph_json = _fbb.CreateString(_o->umrf_graph_json);
  auto _umrf_graph_diffs = _fbb.CreateVector<flatbuffers::Offset<fb::temoto_action_engine::UmrfGraphDiff>> (_o->umrf_graph_diffs.size(), [](size_t i, _VectorArgs *__va) { return CreateUmrfGraphDiff(*__va->__fbb, __va->__o->umrf_graph_diffs[i].get(), __va->__rehasher); }, &_va );
  return fb::temoto_action_engine::CreateBroadcastStartUmrfGraph(
      _fbb,
      ___metadata,
      _umrf_graph_name,
      _name_match_required,
      _targets,
      _umrf_graph_json,
      _umrf_graph_diffs);
}

inline BroadcastStopUmrfGraphT *BroadcastStopUmrfGraph::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::temoto_action_engine::BroadcastStopUmrfGraphT> _o = std::unique_ptr<fb::temoto_action_engine::BroadcastStopUmrfGraphT>(new BroadcastStopUmrfGraphT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BroadcastStopUmrfGraph::UnPackTo(BroadcastStopUmrfGraphT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = umrf_graph_name(); if (_e) _o->umrf_graph_name = _e->str(); }
  { auto _e = targets(); if (_e) { _o->targets.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->targets[_i] = _e->Get(_i)->str(); } } }
}

inline flatbuffers::Offset<BroadcastStopUmrfGraph> BroadcastStopUmrfGraph::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastStopUmrfGraphT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBroadcastStopUmrfGraph(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BroadcastStopUmrfGraph> CreateBroadcastStopUmrfGraph(flatbuffers::FlatBufferBuilder &_fbb, const BroadcastStopUmrfGraphT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BroadcastStopUmrfGraphT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _umrf_graph_name = _fbb.CreateString(_o->umrf_graph_name);
  auto _targets = _fbb.CreateVectorOfStrings(_o->targets);
  return fb::temoto_action_engine::CreateBroadcastStopUmrfGraph(
      _fbb,
      ___metadata,
      _umrf_graph_name,
      _targets);
}

}  // namespace temoto_action_engine

namespace augre_msgs {

inline AgentStatusT *AgentStatus::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::augre_msgs::AgentStatusT> _o = std::unique_ptr<fb::augre_msgs::AgentStatusT>(new AgentStatusT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AgentStatus::UnPackTo(AgentStatusT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = uid(); if (_e) _o->uid = _e->str(); }
  { auto _e = callsign(); if (_e) _o->callsign = _e->str(); }
  { auto _e = agent_type(); if (_e) _o->agent_type = _e->str(); }
  { auto _e = battery(); _o->battery = _e; }
  { auto _e = commander(); if (_e) _o->commander = _e->str(); }
  { auto _e = control_status(); if (_e) _o->control_status = _e->str(); }
}

inline flatbuffers::Offset<AgentStatus> AgentStatus::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AgentStatusT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAgentStatus(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AgentStatus> CreateAgentStatus(flatbuffers::FlatBufferBuilder &_fbb, const AgentStatusT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AgentStatusT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _uid = _fbb.CreateString(_o->uid);
  auto _callsign = _fbb.CreateString(_o->callsign);
  auto _agent_type = _fbb.CreateString(_o->agent_type);
  auto _battery = _o->battery;
  auto _commander = _fbb.CreateString(_o->commander);
  auto _control_status = _fbb.CreateString(_o->control_status);
  return fb::augre_msgs::CreateAgentStatus(
      _fbb,
      ___metadata,
      _uid,
      _callsign,
      _agent_type,
      _battery,
      _commander,
      _control_status);
}

inline DetectedItemT *DetectedItem::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::augre_msgs::DetectedItemT> _o = std::unique_ptr<fb::augre_msgs::DetectedItemT>(new DetectedItemT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DetectedItem::UnPackTo(DetectedItemT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = uid(); if (_e) _o->uid = _e->str(); }
  { auto _e = callsign(); if (_e) _o->callsign = _e->str(); }
  { auto _e = type(); if (_e) _o->type = _e->str(); }
  { auto _e = type_label(); if (_e) _o->type_label = _e->str(); }
  { auto _e = how(); if (_e) _o->how = _e->str(); }
  { auto _e = how_label(); if (_e) _o->how_label = _e->str(); }
  { auto _e = pose(); if (_e) _o->pose = std::unique_ptr<fb::geometry_msgs::PoseStampedT>(_e->UnPack(_resolver)); }
  { auto _e = cmpr_image(); if (_e) _o->cmpr_image = std::unique_ptr<fb::sensor_msgs::CompressedImageT>(_e->UnPack(_resolver)); }
  { auto _e = url(); if (_e) _o->url = _e->str(); }
}

inline flatbuffers::Offset<DetectedItem> DetectedItem::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DetectedItemT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDetectedItem(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DetectedItem> CreateDetectedItem(flatbuffers::FlatBufferBuilder &_fbb, const DetectedItemT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DetectedItemT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _uid = _fbb.CreateString(_o->uid);
  auto _callsign = _fbb.CreateString(_o->callsign);
  auto _type = _fbb.CreateString(_o->type);
  auto _type_label = _fbb.CreateString(_o->type_label);
  auto _how = _fbb.CreateString(_o->how);
  auto _how_label = _fbb.CreateString(_o->how_label);
  auto _pose = _o->pose ? CreatePoseStamped(_fbb, _o->pose.get(), _rehasher) : 0;
  auto _cmpr_image = _o->cmpr_image ? CreateCompressedImage(_fbb, _o->cmpr_image.get(), _rehasher) : 0;
  auto _url = _fbb.CreateString(_o->url);
  return fb::augre_msgs::CreateDetectedItem(
      _fbb,
      ___metadata,
      _uid,
      _callsign,
      _type,
      _type_label,
      _how,
      _how_label,
      _pose,
      _cmpr_image,
      _url);
}

inline TransformWithCovarianceStampedT *TransformWithCovarianceStamped::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::augre_msgs::TransformWithCovarianceStampedT> _o = std::unique_ptr<fb::augre_msgs::TransformWithCovarianceStampedT>(new TransformWithCovarianceStampedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TransformWithCovarianceStamped::UnPackTo(TransformWithCovarianceStampedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = transform(); if (_e) _o->transform = std::unique_ptr<fb::geometry_msgs::TransformStampedT>(_e->UnPack(_resolver)); }
  { auto _e = covariance(); if (_e) { _o->covariance.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->covariance[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<TransformWithCovarianceStamped> TransformWithCovarianceStamped::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransformWithCovarianceStampedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTransformWithCovarianceStamped(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TransformWithCovarianceStamped> CreateTransformWithCovarianceStamped(flatbuffers::FlatBufferBuilder &_fbb, const TransformWithCovarianceStampedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TransformWithCovarianceStampedT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _transform = _o->transform ? CreateTransformStamped(_fbb, _o->transform.get(), _rehasher) : 0;
  auto _covariance = _fbb.CreateVector(_o->covariance);
  return fb::augre_msgs::CreateTransformWithCovarianceStamped(
      _fbb,
      ___metadata,
      _transform,
      _covariance);
}

}  // namespace augre_msgs

namespace asa_db_portal {

inline AzureSpatialAnchorT *AzureSpatialAnchor::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::asa_db_portal::AzureSpatialAnchorT> _o = std::unique_ptr<fb::asa_db_portal::AzureSpatialAnchorT>(new AzureSpatialAnchorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AzureSpatialAnchor::UnPackTo(AzureSpatialAnchorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = asa_id(); if (_e) _o->asa_id = _e->str(); }
  { auto _e = rep_id(); if (_e) _o->rep_id = _e->str(); }
  { auto _e = ns(); if (_e) _o->ns = _e->str(); }
  { auto _e = timestamp(); if (_e) _o->timestamp = std::unique_ptr<fb::RosTime>(new fb::RosTime(*_e)); }
  { auto _e = pose(); if (_e) _o->pose = std::unique_ptr<fb::geometry_msgs::PoseWithCovarianceStampedT>(_e->UnPack(_resolver)); }
  { auto _e = geopose(); if (_e) _o->geopose = std::unique_ptr<fb::geographic_msgs::GeoPoseWithCovarianceStampedT>(_e->UnPack(_resolver)); }
  { auto _e = neighbors(); if (_e) { _o->neighbors.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->neighbors[_i] = _e->Get(_i)->str(); } } }
}

inline flatbuffers::Offset<AzureSpatialAnchor> AzureSpatialAnchor::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AzureSpatialAnchorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAzureSpatialAnchor(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AzureSpatialAnchor> CreateAzureSpatialAnchor(flatbuffers::FlatBufferBuilder &_fbb, const AzureSpatialAnchorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AzureSpatialAnchorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _asa_id = _fbb.CreateString(_o->asa_id);
  auto _rep_id = _fbb.CreateString(_o->rep_id);
  auto _ns = _fbb.CreateString(_o->ns);
  auto _timestamp = _o->timestamp ? _o->timestamp.get() : 0;
  auto _pose = _o->pose ? CreatePoseWithCovarianceStamped(_fbb, _o->pose.get(), _rehasher) : 0;
  auto _geopose = _o->geopose ? CreateGeoPoseWithCovarianceStamped(_fbb, _o->geopose.get(), _rehasher) : 0;
  auto _neighbors = _fbb.CreateVectorOfStrings(_o->neighbors);
  return fb::asa_db_portal::CreateAzureSpatialAnchor(
      _fbb,
      ___metadata,
      _asa_id,
      _rep_id,
      _ns,
      _timestamp,
      _pose,
      _geopose,
      _neighbors);
}

}  // namespace asa_db_portal

namespace amrl_msgs {

inline RobofleetStatusT *RobofleetStatus::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::amrl_msgs::RobofleetStatusT> _o = std::unique_ptr<fb::amrl_msgs::RobofleetStatusT>(new RobofleetStatusT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RobofleetStatus::UnPackTo(RobofleetStatusT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = status(); if (_e) _o->status = _e->str(); }
  { auto _e = is_ok(); _o->is_ok = _e; }
  { auto _e = battery_level(); _o->battery_level = _e; }
  { auto _e = location(); if (_e) _o->location = _e->str(); }
}

inline flatbuffers::Offset<RobofleetStatus> RobofleetStatus::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RobofleetStatusT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRobofleetStatus(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RobofleetStatus> CreateRobofleetStatus(flatbuffers::FlatBufferBuilder &_fbb, const RobofleetStatusT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RobofleetStatusT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _status = _fbb.CreateString(_o->status);
  auto _is_ok = _o->is_ok;
  auto _battery_level = _o->battery_level;
  auto _location = _fbb.CreateString(_o->location);
  return fb::amrl_msgs::CreateRobofleetStatus(
      _fbb,
      ___metadata,
      _status,
      _is_ok,
      _battery_level,
      _location);
}

inline RobofleetSubscriptionT *RobofleetSubscription::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::amrl_msgs::RobofleetSubscriptionT> _o = std::unique_ptr<fb::amrl_msgs::RobofleetSubscriptionT>(new RobofleetSubscriptionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RobofleetSubscription::UnPackTo(RobofleetSubscriptionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = topic_regex(); if (_e) _o->topic_regex = _e->str(); }
  { auto _e = action(); _o->action = _e; }
}

inline flatbuffers::Offset<RobofleetSubscription> RobofleetSubscription::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RobofleetSubscriptionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRobofleetSubscription(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RobofleetSubscription> CreateRobofleetSubscription(flatbuffers::FlatBufferBuilder &_fbb, const RobofleetSubscriptionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RobofleetSubscriptionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _topic_regex = _fbb.CreateString(_o->topic_regex);
  auto _action = _o->action;
  return fb::amrl_msgs::CreateRobofleetSubscription(
      _fbb,
      ___metadata,
      _topic_regex,
      _action);
}

inline ElevatorStatusT *ElevatorStatus::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::amrl_msgs::ElevatorStatusT> _o = std::unique_ptr<fb::amrl_msgs::ElevatorStatusT>(new ElevatorStatusT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ElevatorStatus::UnPackTo(ElevatorStatusT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = floor(); _o->floor = _e; }
  { auto _e = door(); _o->door = _e; }
}

inline flatbuffers::Offset<ElevatorStatus> ElevatorStatus::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ElevatorStatusT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateElevatorStatus(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ElevatorStatus> CreateElevatorStatus(flatbuffers::FlatBufferBuilder &_fbb, const ElevatorStatusT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ElevatorStatusT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _floor = _o->floor;
  auto _door = _o->door;
  return fb::amrl_msgs::CreateElevatorStatus(
      _fbb,
      ___metadata,
      _floor,
      _door);
}

inline ElevatorCommandT *ElevatorCommand::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::amrl_msgs::ElevatorCommandT> _o = std::unique_ptr<fb::amrl_msgs::ElevatorCommandT>(new ElevatorCommandT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ElevatorCommand::UnPackTo(ElevatorCommandT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = floor_cmd(); _o->floor_cmd = _e; }
  { auto _e = hold_door(); _o->hold_door = _e; }
}

inline flatbuffers::Offset<ElevatorCommand> ElevatorCommand::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ElevatorCommandT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateElevatorCommand(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ElevatorCommand> CreateElevatorCommand(flatbuffers::FlatBufferBuilder &_fbb, const ElevatorCommandT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ElevatorCommandT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _floor_cmd = _o->floor_cmd;
  auto _hold_door = _o->hold_door;
  return fb::amrl_msgs::CreateElevatorCommand(
      _fbb,
      ___metadata,
      _floor_cmd,
      _hold_door);
}

inline Pose2DfT *Pose2Df::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::amrl_msgs::Pose2DfT> _o = std::unique_ptr<fb::amrl_msgs::Pose2DfT>(new Pose2DfT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pose2Df::UnPackTo(Pose2DfT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = theta(); _o->theta = _e; }
}

inline flatbuffers::Offset<Pose2Df> Pose2Df::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pose2DfT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePose2Df(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pose2Df> CreatePose2Df(flatbuffers::FlatBufferBuilder &_fbb, const Pose2DfT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Pose2DfT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _theta = _o->theta;
  return fb::amrl_msgs::CreatePose2Df(
      _fbb,
      ___metadata,
      _x,
      _y,
      _theta);
}

inline Localization2DMsgT *Localization2DMsg::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::amrl_msgs::Localization2DMsgT> _o = std::unique_ptr<fb::amrl_msgs::Localization2DMsgT>(new Localization2DMsgT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Localization2DMsg::UnPackTo(Localization2DMsgT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); }
  { auto _e = pose(); if (_e) _o->pose = std::unique_ptr<fb::amrl_msgs::Pose2DfT>(_e->UnPack(_resolver)); }
  { auto _e = map(); if (_e) _o->map = _e->str(); }
}

inline flatbuffers::Offset<Localization2DMsg> Localization2DMsg::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Localization2DMsgT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLocalization2DMsg(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Localization2DMsg> CreateLocalization2DMsg(flatbuffers::FlatBufferBuilder &_fbb, const Localization2DMsgT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Localization2DMsgT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _pose = _o->pose ? CreatePose2Df(_fbb, _o->pose.get(), _rehasher) : 0;
  auto _map = _fbb.CreateString(_o->map);
  return fb::amrl_msgs::CreateLocalization2DMsg(
      _fbb,
      ___metadata,
      _header,
      _pose,
      _map);
}

inline PathVisualizationT *PathVisualization::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::amrl_msgs::PathVisualizationT> _o = std::unique_ptr<fb::amrl_msgs::PathVisualizationT>(new PathVisualizationT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PathVisualization::UnPackTo(PathVisualizationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = curvature(); _o->curvature = _e; }
  { auto _e = distance(); _o->distance = _e; }
  { auto _e = clearance(); _o->clearance = _e; }
}

inline flatbuffers::Offset<PathVisualization> PathVisualization::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PathVisualizationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePathVisualization(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PathVisualization> CreatePathVisualization(flatbuffers::FlatBufferBuilder &_fbb, const PathVisualizationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PathVisualizationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _curvature = _o->curvature;
  auto _distance = _o->distance;
  auto _clearance = _o->clearance;
  return fb::amrl_msgs::CreatePathVisualization(
      _fbb,
      ___metadata,
      _curvature,
      _distance,
      _clearance);
}

inline Point2DT *Point2D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::amrl_msgs::Point2DT> _o = std::unique_ptr<fb::amrl_msgs::Point2DT>(new Point2DT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Point2D::UnPackTo(Point2DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
}

inline flatbuffers::Offset<Point2D> Point2D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Point2DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePoint2D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Point2D> CreatePoint2D(flatbuffers::FlatBufferBuilder &_fbb, const Point2DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Point2DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _x = _o->x;
  auto _y = _o->y;
  return fb::amrl_msgs::CreatePoint2D(
      _fbb,
      ___metadata,
      _x,
      _y);
}

inline ColoredPoint2DT *ColoredPoint2D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::amrl_msgs::ColoredPoint2DT> _o = std::unique_ptr<fb::amrl_msgs::ColoredPoint2DT>(new ColoredPoint2DT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ColoredPoint2D::UnPackTo(ColoredPoint2DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = point(); if (_e) _o->point = std::unique_ptr<fb::amrl_msgs::Point2DT>(_e->UnPack(_resolver)); }
  { auto _e = color(); _o->color = _e; }
}

inline flatbuffers::Offset<ColoredPoint2D> ColoredPoint2D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ColoredPoint2DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateColoredPoint2D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ColoredPoint2D> CreateColoredPoint2D(flatbuffers::FlatBufferBuilder &_fbb, const ColoredPoint2DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ColoredPoint2DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _point = _o->point ? CreatePoint2D(_fbb, _o->point.get(), _rehasher) : 0;
  auto _color = _o->color;
  return fb::amrl_msgs::CreateColoredPoint2D(
      _fbb,
      ___metadata,
      _point,
      _color);
}

inline ColoredLine2DT *ColoredLine2D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::amrl_msgs::ColoredLine2DT> _o = std::unique_ptr<fb::amrl_msgs::ColoredLine2DT>(new ColoredLine2DT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ColoredLine2D::UnPackTo(ColoredLine2DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = p0(); if (_e) _o->p0 = std::unique_ptr<fb::amrl_msgs::Point2DT>(_e->UnPack(_resolver)); }
  { auto _e = p1(); if (_e) _o->p1 = std::unique_ptr<fb::amrl_msgs::Point2DT>(_e->UnPack(_resolver)); }
  { auto _e = color(); _o->color = _e; }
}

inline flatbuffers::Offset<ColoredLine2D> ColoredLine2D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ColoredLine2DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateColoredLine2D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ColoredLine2D> CreateColoredLine2D(flatbuffers::FlatBufferBuilder &_fbb, const ColoredLine2DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ColoredLine2DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _p0 = _o->p0 ? CreatePoint2D(_fbb, _o->p0.get(), _rehasher) : 0;
  auto _p1 = _o->p1 ? CreatePoint2D(_fbb, _o->p1.get(), _rehasher) : 0;
  auto _color = _o->color;
  return fb::amrl_msgs::CreateColoredLine2D(
      _fbb,
      ___metadata,
      _p0,
      _p1,
      _color);
}

inline ColoredArc2DT *ColoredArc2D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::amrl_msgs::ColoredArc2DT> _o = std::unique_ptr<fb::amrl_msgs::ColoredArc2DT>(new ColoredArc2DT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ColoredArc2D::UnPackTo(ColoredArc2DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = center(); if (_e) _o->center = std::unique_ptr<fb::amrl_msgs::Point2DT>(_e->UnPack(_resolver)); }
  { auto _e = radius(); _o->radius = _e; }
  { auto _e = start_angle(); _o->start_angle = _e; }
  { auto _e = end_angle(); _o->end_angle = _e; }
  { auto _e = color(); _o->color = _e; }
}

inline flatbuffers::Offset<ColoredArc2D> ColoredArc2D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ColoredArc2DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateColoredArc2D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ColoredArc2D> CreateColoredArc2D(flatbuffers::FlatBufferBuilder &_fbb, const ColoredArc2DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ColoredArc2DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _center = _o->center ? CreatePoint2D(_fbb, _o->center.get(), _rehasher) : 0;
  auto _radius = _o->radius;
  auto _start_angle = _o->start_angle;
  auto _end_angle = _o->end_angle;
  auto _color = _o->color;
  return fb::amrl_msgs::CreateColoredArc2D(
      _fbb,
      ___metadata,
      _center,
      _radius,
      _start_angle,
      _end_angle,
      _color);
}

inline VisualizationMsgT *VisualizationMsg::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::amrl_msgs::VisualizationMsgT> _o = std::unique_ptr<fb::amrl_msgs::VisualizationMsgT>(new VisualizationMsgT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void VisualizationMsg::UnPackTo(VisualizationMsgT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); }
  { auto _e = ns(); if (_e) _o->ns = _e->str(); }
  { auto _e = particles(); if (_e) { _o->particles.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->particles[_i] = std::unique_ptr<fb::amrl_msgs::Pose2DfT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = path_options(); if (_e) { _o->path_options.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->path_options[_i] = std::unique_ptr<fb::amrl_msgs::PathVisualizationT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = points(); if (_e) { _o->points.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->points[_i] = std::unique_ptr<fb::amrl_msgs::ColoredPoint2DT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = lines(); if (_e) { _o->lines.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->lines[_i] = std::unique_ptr<fb::amrl_msgs::ColoredLine2DT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = arcs(); if (_e) { _o->arcs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->arcs[_i] = std::unique_ptr<fb::amrl_msgs::ColoredArc2DT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<VisualizationMsg> VisualizationMsg::Pack(flatbuffers::FlatBufferBuilder &_fbb, const VisualizationMsgT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVisualizationMsg(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<VisualizationMsg> CreateVisualizationMsg(flatbuffers::FlatBufferBuilder &_fbb, const VisualizationMsgT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const VisualizationMsgT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _ns = _fbb.CreateString(_o->ns);
  auto _particles = _fbb.CreateVector<flatbuffers::Offset<fb::amrl_msgs::Pose2Df>> (_o->particles.size(), [](size_t i, _VectorArgs *__va) { return CreatePose2Df(*__va->__fbb, __va->__o->particles[i].get(), __va->__rehasher); }, &_va );
  auto _path_options = _fbb.CreateVector<flatbuffers::Offset<fb::amrl_msgs::PathVisualization>> (_o->path_options.size(), [](size_t i, _VectorArgs *__va) { return CreatePathVisualization(*__va->__fbb, __va->__o->path_options[i].get(), __va->__rehasher); }, &_va );
  auto _points = _fbb.CreateVector<flatbuffers::Offset<fb::amrl_msgs::ColoredPoint2D>> (_o->points.size(), [](size_t i, _VectorArgs *__va) { return CreateColoredPoint2D(*__va->__fbb, __va->__o->points[i].get(), __va->__rehasher); }, &_va );
  auto _lines = _fbb.CreateVector<flatbuffers::Offset<fb::amrl_msgs::ColoredLine2D>> (_o->lines.size(), [](size_t i, _VectorArgs *__va) { return CreateColoredLine2D(*__va->__fbb, __va->__o->lines[i].get(), __va->__rehasher); }, &_va );
  auto _arcs = _fbb.CreateVector<flatbuffers::Offset<fb::amrl_msgs::ColoredArc2D>> (_o->arcs.size(), [](size_t i, _VectorArgs *__va) { return CreateColoredArc2D(*__va->__fbb, __va->__o->arcs[i].get(), __va->__rehasher); }, &_va );
  return fb::amrl_msgs::CreateVisualizationMsg(
      _fbb,
      ___metadata,
      _header,
      _ns,
      _particles,
      _path_options,
      _points,
      _lines,
      _arcs);
}

inline DetectedItemT *DetectedItem::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::amrl_msgs::DetectedItemT> _o = std::unique_ptr<fb::amrl_msgs::DetectedItemT>(new DetectedItemT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DetectedItem::UnPackTo(DetectedItemT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = repID(); if (_e) _o->repID = _e->str(); }
  { auto _e = anchorID(); if (_e) _o->anchorID = _e->str(); }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
  { auto _e = lat(); _o->lat = _e; }
  { auto _e = lon(); _o->lon = _e; }
  { auto _e = elv(); _o->elv = _e; }
  { auto _e = cmpr_image(); if (_e) _o->cmpr_image = std::unique_ptr<fb::sensor_msgs::CompressedImageT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<DetectedItem> DetectedItem::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DetectedItemT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDetectedItem(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DetectedItem> CreateDetectedItem(flatbuffers::FlatBufferBuilder &_fbb, const DetectedItemT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DetectedItemT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _name = _fbb.CreateString(_o->name);
  auto _repID = _fbb.CreateString(_o->repID);
  auto _anchorID = _fbb.CreateString(_o->anchorID);
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  auto _lat = _o->lat;
  auto _lon = _o->lon;
  auto _elv = _o->elv;
  auto _cmpr_image = _o->cmpr_image ? CreateCompressedImage(_fbb, _o->cmpr_image.get(), _rehasher) : 0;
  return fb::amrl_msgs::CreateDetectedItem(
      _fbb,
      ___metadata,
      _name,
      _repID,
      _anchorID,
      _x,
      _y,
      _z,
      _lat,
      _lon,
      _elv,
      _cmpr_image);
}

}  // namespace amrl_msgs

namespace tf2_msgs {

inline TFMessageT *TFMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::tf2_msgs::TFMessageT> _o = std::unique_ptr<fb::tf2_msgs::TFMessageT>(new TFMessageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TFMessage::UnPackTo(TFMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = transforms(); if (_e) { _o->transforms.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->transforms[_i] = std::unique_ptr<fb::geometry_msgs::TransformStampedT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<TFMessage> TFMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TFMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTFMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TFMessage> CreateTFMessage(flatbuffers::FlatBufferBuilder &_fbb, const TFMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TFMessageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _transforms = _fbb.CreateVector<flatbuffers::Offset<fb::geometry_msgs::TransformStamped>> (_o->transforms.size(), [](size_t i, _VectorArgs *__va) { return CreateTransformStamped(*__va->__fbb, __va->__o->transforms[i].get(), __va->__rehasher); }, &_va );
  return fb::tf2_msgs::CreateTFMessage(
      _fbb,
      ___metadata,
      _transforms);
}

}  // namespace tf2_msgs

namespace leg_tracker {

inline DetectionT *Detection::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::leg_tracker::DetectionT> _o = std::unique_ptr<fb::leg_tracker::DetectionT>(new DetectionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Detection::UnPackTo(DetectionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<fb::geometry_msgs::PointT>(_e->UnPack(_resolver)); }
  { auto _e = confidence(); _o->confidence = _e; }
  { auto _e = label(); _o->label = _e; }
}

inline flatbuffers::Offset<Detection> Detection::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DetectionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDetection(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Detection> CreateDetection(flatbuffers::FlatBufferBuilder &_fbb, const DetectionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DetectionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _position = _o->position ? CreatePoint(_fbb, _o->position.get(), _rehasher) : 0;
  auto _confidence = _o->confidence;
  auto _label = _o->label;
  return fb::leg_tracker::CreateDetection(
      _fbb,
      ___metadata,
      _position,
      _confidence,
      _label);
}

inline DetectionArrayT *DetectionArray::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::leg_tracker::DetectionArrayT> _o = std::unique_ptr<fb::leg_tracker::DetectionArrayT>(new DetectionArrayT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DetectionArray::UnPackTo(DetectionArrayT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); }
  { auto _e = detections(); if (_e) { _o->detections.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->detections[_i] = std::unique_ptr<fb::leg_tracker::DetectionT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<DetectionArray> DetectionArray::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DetectionArrayT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDetectionArray(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DetectionArray> CreateDetectionArray(flatbuffers::FlatBufferBuilder &_fbb, const DetectionArrayT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DetectionArrayT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _detections = _fbb.CreateVector<flatbuffers::Offset<fb::leg_tracker::Detection>> (_o->detections.size(), [](size_t i, _VectorArgs *__va) { return CreateDetection(*__va->__fbb, __va->__o->detections[i].get(), __va->__rehasher); }, &_va );
  return fb::leg_tracker::CreateDetectionArray(
      _fbb,
      ___metadata,
      _header,
      _detections);
}

inline LegT *Leg::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::leg_tracker::LegT> _o = std::unique_ptr<fb::leg_tracker::LegT>(new LegT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Leg::UnPackTo(LegT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<fb::geometry_msgs::PointT>(_e->UnPack(_resolver)); }
  { auto _e = confidence(); _o->confidence = _e; }
}

inline flatbuffers::Offset<Leg> Leg::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LegT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLeg(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Leg> CreateLeg(flatbuffers::FlatBufferBuilder &_fbb, const LegT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LegT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _position = _o->position ? CreatePoint(_fbb, _o->position.get(), _rehasher) : 0;
  auto _confidence = _o->confidence;
  return fb::leg_tracker::CreateLeg(
      _fbb,
      ___metadata,
      _position,
      _confidence);
}

inline LegArrayT *LegArray::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::leg_tracker::LegArrayT> _o = std::unique_ptr<fb::leg_tracker::LegArrayT>(new LegArrayT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LegArray::UnPackTo(LegArrayT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); }
  { auto _e = legs(); if (_e) { _o->legs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->legs[_i] = std::unique_ptr<fb::leg_tracker::LegT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<LegArray> LegArray::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LegArrayT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLegArray(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LegArray> CreateLegArray(flatbuffers::FlatBufferBuilder &_fbb, const LegArrayT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LegArrayT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _legs = _fbb.CreateVector<flatbuffers::Offset<fb::leg_tracker::Leg>> (_o->legs.size(), [](size_t i, _VectorArgs *__va) { return CreateLeg(*__va->__fbb, __va->__o->legs[i].get(), __va->__rehasher); }, &_va );
  return fb::leg_tracker::CreateLegArray(
      _fbb,
      ___metadata,
      _header,
      _legs);
}

inline PersonT *Person::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::leg_tracker::PersonT> _o = std::unique_ptr<fb::leg_tracker::PersonT>(new PersonT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Person::UnPackTo(PersonT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = pose(); if (_e) _o->pose = std::unique_ptr<fb::geometry_msgs::PoseT>(_e->UnPack(_resolver)); }
  { auto _e = id(); _o->id = _e; }
}

inline flatbuffers::Offset<Person> Person::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PersonT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePerson(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Person> CreatePerson(flatbuffers::FlatBufferBuilder &_fbb, const PersonT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PersonT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _pose = _o->pose ? CreatePose(_fbb, _o->pose.get(), _rehasher) : 0;
  auto _id = _o->id;
  return fb::leg_tracker::CreatePerson(
      _fbb,
      ___metadata,
      _pose,
      _id);
}

inline PersonArrayT *PersonArray::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<fb::leg_tracker::PersonArrayT> _o = std::unique_ptr<fb::leg_tracker::PersonArrayT>(new PersonArrayT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PersonArray::UnPackTo(PersonArrayT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = __metadata(); if (_e) _o->__metadata = std::unique_ptr<fb::MsgMetadataT>(_e->UnPack(_resolver)); }
  { auto _e = header(); if (_e) _o->header = std::unique_ptr<fb::std_msgs::HeaderT>(_e->UnPack(_resolver)); }
  { auto _e = people(); if (_e) { _o->people.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->people[_i] = std::unique_ptr<fb::leg_tracker::PersonT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<PersonArray> PersonArray::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PersonArrayT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePersonArray(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PersonArray> CreatePersonArray(flatbuffers::FlatBufferBuilder &_fbb, const PersonArrayT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PersonArrayT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto ___metadata = _o->__metadata ? CreateMsgMetadata(_fbb, _o->__metadata.get(), _rehasher) : 0;
  auto _header = _o->header ? CreateHeader(_fbb, _o->header.get(), _rehasher) : 0;
  auto _people = _fbb.CreateVector<flatbuffers::Offset<fb::leg_tracker::Person>> (_o->people.size(), [](size_t i, _VectorArgs *__va) { return CreatePerson(*__va->__fbb, __va->__o->people[i].get(), __va->__rehasher); }, &_va );
  return fb::leg_tracker::CreatePersonArray(
      _fbb,
      ___metadata,
      _header,
      _people);
}

}  // namespace leg_tracker
}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_SCHEMA_FB_LEG_TRACKER_H_
